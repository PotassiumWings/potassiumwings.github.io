<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vjudge297843-BUAA Summer Practice 2017 1 字符串专场 题解]]></title>
    <url>%2F2019%2F04%2F26%2Fbuaa2017string%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M 4/13 O . O . . . . . . . O O . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 密码：buaa A 题目描述问长度为$n$，给定的$m$个字符串都为$a$的连续子串的字符串$a$有多少种。 $1\leq n\leq 25,0\leq m\leq 10$ 解题思路看到$n,m$很小（$1&lt;&lt;10=1024$），很容易想到建立$AC$自动机进行爆搜记忆化搜索。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define N 105typedef long long ll;using namespace std;char a[25];int n,m,trie[N][26],fail[N],sign[N],tot;void add(int x)&#123; int now=0,i; for(i=0;a[i];i++)&#123; int p=a[i]-'a'; if(!trie[now][p])trie[now][p]=++tot; now=trie[now][p]; &#125; sign[now]|=1&lt;&lt;x;&#125;queue&lt;int&gt;Q;void build()&#123; int i,pos; for(i=0;i&lt;26;i++)if(trie[0][i])Q.push(trie[0][i]); while(!Q.empty())&#123; pos=Q.front();Q.pop(); for(i=0;i&lt;26;i++)&#123; if(trie[pos][i])&#123; fail[trie[pos][i]]=trie[fail[pos]][i]; Q.push(trie[pos][i]); sign[trie[pos][i]]|=sign[fail[trie[pos][i]]]; &#125;else trie[pos][i]=trie[fail[pos]][i]; &#125; &#125;&#125;ll f[27][N][1030];//f[len][pos][state]ll dp(int len,int state,int pos)&#123; ll &amp;ans=f[len][pos][state]; if(~ans)return ans; if(len==n)return ans=state==(1&lt;&lt;m)-1; int i; ans=0; for(i=0;i&lt;26;i++) ans+=dp(len+1,state|sign[trie[pos][i]],trie[pos][i]); return ans;&#125;char out[30];void print(int len,int state,int pos)&#123; if(len==n)&#123; fwrite(out,sizeof(out[0]),n,stdout); puts(""); return; &#125; int i; for(i=0;i&lt;26;i++)&#123; out[len]=i+'a'; if(f[len+1][trie[pos][i]][state|sign[trie[pos][i]]]&gt;0) print(len+1,state|sign[trie[pos][i]],trie[pos][i]); &#125;&#125;int main()&#123; int i,t=0; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;(n|m))&#123; t++; memset(trie,0,sizeof(trie)); memset(fail,0,sizeof(fail)); memset(f,-1,sizeof(f)); memset(sign,0,sizeof(sign)); tot=0; for(i=0;i&lt;m;i++)scanf("%s",a),add(i); build(); ll ans=dp(0,0,0); printf("Case %d: %lld suspects\n",t,ans); if(ans&lt;=42)print(0,0,0); &#125; return 0;&#125; B 题目描述解题思路AC代码点击 12 C 题目描述如果一个长度为$n$的字符串$a$满足：对于任意$0&lt; i\leq |n|$，$a_i$属于集合$S_i$，则其是一个合法的串。 给定字符串$a$，集合$S_i(1\leq i\leq n)$，按读入顺序输出$a$中所有合法的连续子串。 $1\leq n \leq 1000,|a|\leq 5\times 10^6$。 解题思路看起来$|a|$比较大，似乎应当用一种比较快速、尽量能递推解决的算法解决。 构造一个$bitset$数组$b$，存放每一个元素$x$允许出现的位置$pos$，即对于每一个合法的位置，有$b[x][pos]=1$。 再构造一个$bitset$存储当前匹配状态$now$，每一次$now$左移$1$（代表开始匹配下一位），最低位设置成$1$（还未判断匹配情况），位运算进行匹配（与对应$b[x]$进行与运算），则如果$now$的第$n$位为$1$，就说明已经匹配成功，输出即可。 AC代码点击 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;bitset&gt;using namespace std;char c[5000001],t;bitset&lt;1001&gt;b[11],now;int main()&#123; int i,n,k,a; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;k); while(k--)scanf("%d",&amp;a),b[a][i]=1; &#125; scanf("%s",c); for(i=0;c[i];i++)&#123; ((now&lt;&lt;=1).set(0))&amp;=b[c[i]-'0']; if(now[n-1])fwrite(c+i-n+1,sizeof(c[0]),n,stdout),putchar('\n'); &#125; return 0;&#125; D 题目描述解题思路AC代码点击 12 E 题目描述解题思路AC代码点击 12 F 题目描述解题思路AC代码点击 12 G 题目描述解题思路AC代码点击 12 H 题目描述解题思路AC代码点击 12 I 题目描述解题思路AC代码点击 12 J 题目描述解题思路AC代码点击 12 K 题目描述定义一个串是好串，当且仅当它可以表示成$A+B+…+A+B+A$的形式，其中$A,B$可以为空，分别出现了$k+1$次和$k$次。 给定一个字符串$a(1\leq |a|\leq 10^6)$和$k(1\leq k\leq 10^6)$，求每一个前缀是否是好串。 解题思路假设字符串$s$的前$i$位为$ABAB…ABA$，则显然，$AB…ABA$和$ABAB…A$可以匹配。 于是用$kmp$字符串匹配的思想自己匹配自己，有$|BA|=i-nxt[i]$。 如果$B$可以为空，也即$s$的前$i$位为$SS…S(共出现num=\frac i{|BA|}次)$，也即$i\%|BA|==0$，则只需要满足分成恰好$k$段后的剩余段长度小于等于前面段长度（设新生成的前面段$|A|$为$SS…S(共出现\frac{num}k次)$，剩余段为$SS…S(共出现num\%k次)$，则需要满足$\frac{num}k\geq num\%k$）。 否则，同理可分析出要求为$\frac{num}k&gt;num\%k$。 AC代码点击 1234567891011121314151617181920#include&lt;stdio.h&gt;#define N 1000005int n,k;char a[N];int nxt[N],ans[N];int main()&#123; int i,j=0; scanf("%d%d",&amp;n,&amp;k); scanf("%s",a); for(i=1;i&lt;=n;i++)&#123; while(j&amp;&amp;a[i]!=a[j])j=nxt[j]; if(a[i]==a[j])j++; nxt[i+1]=j; int r=i-nxt[i],num=i/r; if(i%r)ans[i]=num/k&gt;num%k; else ans[i]=num/k&gt;=num%k; &#125; for(i=1;i&lt;=n;i++)printf("%d",ans[i]); return 0;&#125; L 题目描述给两个字符串$A,B(1\leq |A|,|B|\leq 2\times 10^5)$，求不同的公共回文子串$P,Q$个数，重复出现也要算入。 解题思路使用两棵回文树，分别在偶数根和奇数根上同时深搜，把结果加起来即可。 刚学习回文树，感觉十分巧妙。大致说一下它的思路。 不同于$AC$自动机，回文树的建立基于对每一个回文串的中心向两端扩张，树上的每一个节点代表的是一种回文串，所以$fail$指针指向的是与当前节点具有最长公共回文后缀的串的树上的节点位置（不是字符位置！不是字符位置！）。最初状态只有两个树根，分别为奇数长度回文串的树根和偶数长度回文串的树根。每次添加一个节点$p$的时候，找到上一个节点$last$的最长回文后缀$S$，使得新形成的$pSp$为回文串。当然，如果找不到，那只能让$p$单独成为一个回文串。 用$len[i]$表示节点$i$代表的回文串长度，$cnt[i]$表示这个回文串出现的次数，剩下的就是在$fail$上面跳就好了。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#define N 200005typedef long long ll;struct PT&#123; int tr[N][26],fail[N],cnt[N]/*,num[N]*/,len[N]; int tot,s[N],n,last,i; int newnode(int l)&#123; for(i=0;i&lt;26;i++)tr[tot][i]=0; cnt[tot]=0; len[tot]=l; //num[tot]=l; return tot++; &#125; void init()&#123; n=last=tot=0; newnode(0);newnode(-1);//建立两个树根 s[0]=-1;//奇数回文树树根len=-1 fail[0]=1;//奇数的fail指向偶数树根 &#125; int getfail(int p)&#123; while(s[n-len[p]-1]!=s[n])p=fail[p];//找到最长的能构成回文串的节点 return p; &#125; void add(int p)&#123; s[++n]=p; int cur=getfail(last); if(!tr[cur][p])&#123; int now=newnode(len[cur]+2);//向两端扩张，长度+2 fail[now]=tr[getfail(fail[cur])][p]; tr[cur][p]=now; //num[now]=num[fail[now]]+1; &#125; last=tr[cur][p]; cnt[last]++; &#125; void count()&#123; for(i=tot-1;i&gt;=0;i--)cnt[fail[i]]+=cnt[i]; &#125;&#125;p1,p2;char a[N],b[N];ll dfs(int a,int b)&#123; ll ans=0;int i; for(i=0;i&lt;26;i++) if(p1.tr[a][i]&amp;&amp;p2.tr[b][i]) ans+=1LL*p1.cnt[p1.tr[a][i]]*p2.cnt[p2.tr[b][i]]+dfs(p1.tr[a][i],p2.tr[b][i]); return ans;&#125;int main()&#123; int i,j,t; scanf("%d",&amp;t); for(i=1;i&lt;=t;i++)&#123; p1.init();p2.init(); scanf("%s%s",a,b); for(j=0;a[j];j++)p1.add(a[j]-'a'); for(j=0;b[j];j++)p2.add(b[j]-'a'); p1.count();p2.count(); printf("Case #%d: %lld\n",i,dfs(0,0)+dfs(1,1)); &#125; return 0;&#125; M 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vjudge296318-ICPC2018亚洲区域赛组题 题解]]></title>
    <url>%2F2019%2F04%2F25%2Fvjudge296318regional2018%2F</url>
    <content type="text"><![CDATA[Solved A B C D E 5/5 O O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给定一个$n$个节点的树和$m$个简单路，求有多少个选择$k$个给定简单路并使得这$k$个简单路交于同一点的方案。答案对$1e9+7$取模。 解题思路先用树上差分求出每个点经过的简单路个数$path[i]$，再用$C(path[i],k)$求出该点的贡献，但显然会有重复。显然，所有路径的交点至少为一个$LCA$，故只需记录每一个点作为$LCA$做出的贡献即可。记录每一个点作为$LCA$的个数$num[i]$，则答案为$\sum_{i=1}^{n}C(path[i],k)-C(path[i]-num[i],k)$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 300005#define mid ((l+r)&gt;&gt;1)struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int d[N],fa[N][22],lg[N],hd[N],cnt,n,m,k;void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;void dfs(int now,int f)&#123; d[now]=d[f]+1; fa[now][0]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++)fa[now][i]=fa[fa[now][i-1]][i-1]; for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=f)dfs(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y])x=fa[x][lg[d[x]-d[y]]]; if(x==y)return x; for(i=lg[d[x]];~i;i--)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int path[N],num[N];void init(int now,int f)&#123; int i,q; for(i=hd[now];i;i=e[i].n)&#123; q=e[i].e; if(q!=f)&#123; init(q,now); path[now]+=path[q]; &#125; &#125;&#125;ll jc[N]=&#123;1&#125;,inv[N]=&#123;1&#125;,w=1000000007;ll c(int n,int m)&#123; if(n&lt;m)return 0; return jc[n]*inv[m]%w*inv[n-m]%w;&#125;ll qpow(ll a,ll b)&#123; int i; ll ans=1; for(i=b;i;i&gt;&gt;=1,a=a*a%w)if(i&amp;1)ans=ans*a%w; return ans;&#125;int main()&#123; int i,t,u,v; for(i=2;i&lt;N;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); for(i=1;i&lt;N;i++)jc[i]=jc[i-1]*i%w,inv[i]=qpow(jc[i],w-2); scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(i=1;i&lt;n;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v),add(v,u); dfs(1,0); for(i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); int w=lca(u,v); path[w]--;path[fa[w][0]]--; path[u]++;path[v]++; num[w]++; &#125; init(1,0); ll ans=0; for(i=1;i&lt;=n;i++) ans=((ans+c(path[i],k)-c(path[i]-num[i],k))%w+w)%w; printf("%lld\n",ans); memset(hd,0,sizeof(int)*(n+1));cnt=0; memset(d,0,sizeof(int)*(n+1)); memset(path,0,sizeof(int)*(n+1)); memset(num,0,sizeof(int)*(n+1)); memset(fa,0,sizeof(int)*(n+1)*22); &#125; return 0;&#125; B 题目描述有$n$个战斗回合，$boss$无限血量，初始状态战斗力$A=0$，预备增量$D=0$。 每一个回合有三个参数$a[i],b[i],c[i]$可以任选下面三种策略之一： 攻击，伤害为$A+a[i]$ 不攻击，$A+=b[i]$ 不攻击，$D+=c[i]$ 每回合结束之后，$A+=D$。 求$n$回合后的最大伤害。所有数在$[1,1e9]$范围内。 解题思路开始想了半天如何$DP$，死活无法推出式子。后来经nikkukun同学的提点，发现可以从后到前递推。 原因是： 操作具有后效性但不具有前效性。 故考虑用$f[i][j]$表示到第$i$个人，已经干了$j$架的最大伤害。 推一下状态转移方程：$f[i][j]=max(f[i+1][j]+max(x\times b[i],j\times c[i]),f[i+1][j-1]+a[i])$前半部分表示选择不攻击的两种方法对答案的贡献，后半部分表示选择攻击的贡献。 但是这里出现了一个莫名其妙的$x$，代表的是操作②对答案的贡献，它的值为所有后续打架的位置和当前位置的距离之和，而这里是一个不能确定的变量。于是增加第三维：所有攻击操作的下标之和。于是就可以愉快地递推了，$x=k-i\times j$。 然后快乐地提交，获得了$MLE$。所以需要滚动一下。 AC代码点击 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll f[2][102][5052],a[110],b[110],c[110],ans;int main()&#123; int i,t,j,n,k; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lld%lld%lld",&amp;a[i],&amp;b[i],&amp;c[i]); for(i=0;i&lt;2;i++)for(j=0;j&lt;=n;j++)for(k=0;k&lt;=n*(n+1)/2;k++)f[i][j][k]=-1; f[0][1][n]=a[n]; int p=0; for(i=n-1;i;i--)&#123; p^=1; for(j=n-i+1;j;j--)&#123; for(k=n*(n+1)/2;k&gt;=n;k--)&#123; if(k-i&gt;=n&amp;&amp;j&gt;=2&amp;&amp;~f[p^1][j-1][k-i])f[p][j][k]=f[p^1][j-1][k-i]+a[i]; if(~f[p^1][j][k])f[p][j][k]=max(f[p][j][k],f[p^1][j][k]+max(c[i]*j,(k-i*j)*b[i])); &#125; &#125; for(j=0;j&lt;=n;j++)for(k=0;k&lt;=n*(n+1)/2;k++)f[p^1][j][k]=-1; &#125; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n*(n+1)/2-i*(i-1)/2;j++) ans=max(ans,f[p][i][j]); printf("%lld\n",ans); &#125; return 0;&#125; C 题目描述给定两个长度$2\leq |s|\leq 10^6,1\leq |t|&lt;|s|$的字符串，求满足以下要求的三元组$(i,j,k)$的个数： $1\leq i\leq j\leq |s|$ $1\leq k\leq |t|$ $j-i+1&gt;k$ 把$[s[i],s[j]]$和$[t[1],t[k]]$拼接起来的新串为回文串。 解题思路题目可以转化为：在$s$中找到连续的串$a,b$，在$t$中找到串$c$，且$a,b,c$不空，$b$为回文串且$a$和$c$倒序相等。 可以先$manacher$处理出$s$中每一个$i$开头的回文串个数（用差分思想），再在旋转过的$b$串后缀中字符串哈希二分查找最长公共子串长度，乘起来再求和即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;typedef long long ll;#define N 2000010#define base 998244353#define mod 2078526727ll hs[N],ht[N],pw[N];char s[N],t[N];char a[N]=&#123;'.'&#125;;int len[N];int p[N];using namespace std;int ls,lt;ll hashf(ll*a,int l,int r)&#123; return ((a[r]-a[l]*pw[r-l])%mod+mod)%mod;&#125;int check(int x,int i)&#123; return hashf(ht,lt-x,lt)==hashf(hs,i-x,i);&#125;int main()&#123; int i; pw[0]=1; for(i=1;i&lt;N;i++)pw[i]=pw[i-1]*base%mod; scanf("%s%s",s,t); ls=strlen(s),lt=strlen(t); reverse(t,t+lt); for(i=0;i&lt;ls;i++)&#123; a[2*i+1]='#'; a[2*i+2]=s[i]; &#125; a[2*ls+1]='#'; int mr=0,mid=0; for(i=1;i&lt;=2*ls+2;i++)&#123; if(mr&gt;i)len[i]=min(mr-i,len[2*mid-i]); else len[i]=1; while(a[i+len[i]]==a[i-len[i]])len[i]++; if(i+len[i]&gt;mr)&#123; mr=i+len[i]; mid=i; &#125; &#125; for(i=1;i&lt;2*ls+2;i++)&#123; p[(i-len[i])/2]++; p[(i)/2]--; &#125; for(i=1;i&lt;=ls;i++)p[i]+=p[i-1]; hs[0]=ht[0]=1; for(i=1;i&lt;=ls;i++)hs[i]=(hs[i-1]*base+s[i-1]-'a')%mod; for(i=1;i&lt;=lt;i++)ht[i]=(ht[i-1]*base+t[i-1]-'a')%mod; ll ans=0; for(i=1;i&lt;ls;i++)&#123; if(s[i-1]!=t[lt-1])continue; int l=1,r=min(lt,i); while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid,i))l=mid+1; else r=mid; &#125; if(!check(l,i))l--; ans+=p[i]*1LL*l; &#125; printf("%I64d",ans); return 0;&#125; D 题目描述有$n$个人，每个人能打$t[i]$个怪兽，分别为$m[i][j]$。每个人最多只能打一只怪兽。这时候提供了$k$个膜法药水，一个人最多可以喝一瓶，喝了一瓶之后最多就能打两只怪兽了。 问最好的分配情况下，一共能打多少只怪兽。 解题思路非常裸的网络流，从源点到每个人、每个怪兽到汇点建长度为$1$的边，每个人与他能打的怪兽之间建长度为$1$的边。再考虑膜法药水，从源点到新增节点$magic$建长度为$k$的边，从$magic$到每个人建长度为$1$的边，跑一遍最大流即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1010int s,t,magic;struct Edge&#123; int end,near,len;&#125;e[N*N];int head[N],cnt=1,cur[N];int n,m,k;void add(int a,int b,int l)&#123; e[++cnt].end=b; e[cnt].near=head[a]; e[cnt].len=l; head[a]=cnt;&#125;queue&lt;int&gt;Q;int dep[N];int bfs()&#123; int i,p,q; memset(dep,0,sizeof(dep)); for(i=0;i&lt;=magic;i++)cur[i]=head[i]; Q.push(s);dep[s]=1; while(!Q.empty())&#123; p=Q.front();Q.pop(); for(i=head[p];i;i=e[i].near)&#123; q=e[i].end; if(e[i].len&amp;&amp;!dep[q])&#123; dep[q]=dep[p]+1; Q.push(q); &#125; &#125; &#125; return dep[t];&#125;int dfs(int p,int flow)&#123; if(p==t)return flow; int i,q; for(i=cur[p];i;i=e[i].near)&#123; cur[p]=i; q=e[i].end; if(dep[q]==dep[p]+1&amp;&amp;e[i].len)&#123; int ans=dfs(q,min(flow,e[i].len)); if(ans)&#123; e[i].len-=ans; e[i^1].len+=ans; return ans; &#125; &#125; &#125; return 0;&#125;int dinic()&#123; int d,ans=0; while(bfs())&#123; while((d=dfs(s,1e6))) ans+=d; &#125; return ans;&#125;int main()&#123; int i,j,M,T; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); s=0; t=n+m+1; magic=t+1; for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;T); for(j=0;j&lt;T;j++)scanf("%d",&amp;M),add(i,M+n,1),add(M+n,i,0); &#125; add(s,magic,k),add(magic,s,0); for(i=1;i&lt;=n;i++)&#123; add(s,i,1),add(i,s,0); add(magic,i,1),add(i,magic,0); &#125; for(i=1;i&lt;=m;i++)add(i+n,t,1),add(t,i+n,0); printf("%d",dinic()); return 0;&#125; E 题目描述给定一个有$n$个数（$1\leq n\leq 10^6$）的正整数序列$a[i]$，$1\leq a[i]\leq 10^6$。。定义$mul(l,r)=\prod_{i=l}^{r}a[i]$，$fac(l,r)$为$mul(l,r)$中的所有质因数种数之和。 求$\sum_{i=1}^{n}\sum_{j=i}^{n}fac(i,j)$。 解题思路考虑每一个质因数的贡献，设它出现的位置为$p[1],p[2],…,p[m]$。不妨设$p[0]=0,p[m+1]=n+1$，则其贡献为$\frac{n\times (n+1)}2-\sum_{i=0}^{m}\frac{(p[i+1]-p[i])(p[i+1]-p[i]-1)}2$。枚举每一个$a[i]$，计算出其对应的所有质因数，最后统计即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1000010int n,prime[N],a[N]=&#123;1,1&#125;,cnt;ll ans;vector&lt;int&gt;num[N];ll f(ll a,ll b)&#123;return (b-a+1)*(b-a+2)/2;&#125;int main()&#123; int i,j,p; for(i=2;i&lt;N;i++)&#123; if(!a[i])prime[cnt++]=i,a[i]=cnt-1; for(j=0;i*prime[j]&lt;N&amp;&amp;j&lt;cnt;j++)&#123; a[i*prime[j]]=1; if(i%prime[j]==0)break; &#125; &#125; scanf("%d",&amp;n); for(i=0;i&lt;cnt;i++)num[i].push_back(0); for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;p); for(j=0;j&lt;cnt&amp;&amp;prime[j]*prime[j]&lt;=p;j++)&#123; if(p%prime[j]==0)&#123; num[j].push_back(i); while(p%prime[j]==0)p/=prime[j]; &#125; &#125; if(p&gt;1)num[a[p]].push_back(i); &#125; for(i=0;i&lt;cnt;i++)num[i].push_back(n+1); for(i=0;i&lt;cnt;i++)&#123; ans+=1LL*(n+1)*n/2; for(j=1;j&lt;num[i].size();j++) ans-=f(num[i][j-1]+1,num[i][j]-1); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南昌邀请赛网络赛2019.04.20 题解]]></title>
    <url>%2F2019%2F04%2F21%2Fnanchanginternet2019%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M 7/13 O . . . . . . O O Ø O Ø O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 官方题解 A 题目描述输出前五个完全数。 解题思路打表。 AC代码点击 12345#include&lt;bits/stdc++.h&gt;int main()&#123; printf("6\n28\n496\n8128\n33550336"); return 0;&#125; B 题目描述解题思路AC代码点击 12 C 题目描述解题思路AC代码点击 12 D 题目描述解题思路AC代码点击 12 E 题目描述解题思路AC代码点击 12 F 题目描述解题思路AC代码点击 12 G 题目描述解题思路AC代码点击 12 H 题目描述给定一个$2\times N$的格点图，从左上角走到右下角，可以向上、下、左、右、左上、左下、右上、右下走，走过的点的集合为$S$，求$S$的种数对$1000000007$取模的值。$0&lt;n\leq 10^9$。 解题思路最左一列只能有两种选择：只经过上面、两块都经过 最右一列只能有两种选择：只经过下面、两块都经过 其他列每一列至少需要有一个经过的点，故有三种选择：只经过上面、只经过下面、两块都经过。 于是，答案为$4\times 3^{N-2}$。注意特判$N=1$。 AC代码点击 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int w=1000000007,n;ll qpow(ll a,ll b)&#123; ll ans=1; int i; for(i=b;i;i&gt;&gt;=1,a=a*a%w)if(i&amp;1)ans=ans*a%w; return ans;&#125;int main()&#123; scanf("%d",&amp;n); if(n==1)printf("1"); else printf("%d",1LL*4*qpow(3,n-2)%w); return 0;&#125; I 题目描述给定一个序列，求其中一个子序列，其中元素$a[i]∈[-10^5,10^5]$，使得其区间最小值乘区间和最大，求出最大值。 解题思路代码&amp;思路 by​ Nikkukun 对于每一个值作为区间最小值，求出最大的左端与右端，求出其和的最大值，复杂度$O(n^2)$。 考虑最小值的正负，当最小值为正时，向左右分别延伸到最大值且不含比该值小的数的区间；否则延伸到最小值且不含比该值小的数的区间。 用线段树维护区间最大值，乘以$-1$后也可维护区间最小值（用$ST$表会$MLE$）。 再用含偏移的树状数组（处理负数）维护距离$a[i]$最近的、比$a[i]$小的下标$j$。从左端往右、从右端往左分别维护一个树状数组，树状数组的下标表示$a[i]$，其值表示下标$j$。 AC代码-BIT+线段树 By Nikkukun-223ms点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (o&lt;&lt;1)#define rson ((o&lt;&lt;1)|1)typedef long long ll;const int N=500000+5,BIAS=100000+5,T=BIAS*2,LEN=18+2;const ll INF=0x3f3f3f3f3f3f3f3f;struct BITree&#123; int t[T]; BITree()&#123; memset(t,0,sizeof(t)); &#125; int Lowbit(int x)&#123; return x&amp;(-x); &#125; void Add(int x,int v)&#123; for(;x&lt;T;x+=Lowbit(x)) t[x]=v; &#125; int Query(int x)&#123; int ret=0; for(;x;x-=Lowbit(x)) ret=max(ret,t[x]); return ret; &#125;&#125;;struct ST&#123; ll t[N*4]; void Build(int o,int L,int R,ll a[],int f)&#123; if(L==R)&#123; t[o]=f*a[L]; return; &#125; int M=(L+R)/2; Build(lson,L,M,a,f); Build(rson,M+1,R,a,f); t[o]=max(t[lson],t[rson]); &#125; ll Query(int o,int L,int R,int qL,int qR)&#123; if(qL&lt;=L&amp;&amp;R&lt;=qR)return t[o]; ll ret=-INF; int M=(L+R)/2; if(qL&lt;=M)ret=max(ret,Query(lson,L,M,qL,qR)); if(M+1&lt;=qR)ret=max(ret,Query(rson,M+1,R,qL,qR)); return ret; &#125;&#125;;int a[N];int l[N],r[N];ll suml[N],sumr[N];BITree bitl,bitr;ST stl[2],str[2];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; l[i]=bitl.Query(a[i]+BIAS); bitl.Add(a[i]+BIAS+1,i); suml[i]=suml[i-1]+a[i]; &#125; for(int i=n;i&gt;0;i--)&#123; r[i]=bitr.Query(a[i]+BIAS); bitr.Add(a[i]+BIAS+1,n-i+1); sumr[i]=sumr[i+1]+a[i]; &#125; stl[0].Build(1,1,n,suml,1); stl[1].Build(1,1,n,suml,-1); str[0].Build(1,1,n,sumr,1); str[1].Build(1,1,n,sumr,-1); ll ans=0; for(int i=1;i&lt;=n;i++)&#123; int j=(a[i]&gt;0)?0:1; int f=(a[i]&gt;0)?1:-1; ll L=f*str[j].Query(1,1,n,l[i]+1,i)-sumr[i]; ll R=f*stl[j].Query(1,1,n,i,n-r[i]+1-1)-suml[i]; ans=max(ans,(L+R+a[i])*a[i]); &#125; printf("%lld",ans); return 0;&#125; 赛后突然发现维护一个单调增的单调栈亦可以找出左右端的最大伸展区间。 AC代码-单调栈+线段树 By Potassium-514ms点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 500002#define mid ((l+r)&gt;&gt;1)#define inf 9e18int sta[N],n,top,l[N],r[N];ll a[N],s[N];struct SegTree&#123; ll mn,mx; int l,r;&#125;t[N&lt;&lt;2];void build(int l,int r,int p)&#123; t[p].l=l;t[p].r=r; if(l==r)&#123; t[p].mn=t[p].mx=s[l]; return; &#125; build(l,mid,p&lt;&lt;1); build(mid+1,r,p&lt;&lt;1|1); t[p].mn=min(t[p&lt;&lt;1].mn,t[p&lt;&lt;1|1].mn); t[p].mx=max(t[p&lt;&lt;1].mx,t[p&lt;&lt;1|1].mx);&#125;ll querymin(int l,int r,int p)&#123; int L=t[p].l,R=t[p].r; if(L&gt;=l&amp;&amp;R&lt;=r)return t[p].mn; if(L&gt;r||R&lt;l)return inf; return min(querymin(l,r,p&lt;&lt;1),querymin(l,r,p&lt;&lt;1|1));&#125;ll querymax(int l,int r,int p)&#123; int L=t[p].l,R=t[p].r; if(L&gt;=l&amp;&amp;R&lt;=r)return t[p].mx; if(L&gt;r||R&lt;l)return -inf; return max(querymax(l,r,p&lt;&lt;1),querymax(l,r,p&lt;&lt;1|1));&#125;int main()&#123; int i; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]),s[i]=s[i-1]+a[i]; for(i=1;i&lt;=n;i++)&#123; while(top&amp;&amp;a[sta[top]]&gt;=a[i])top--; l[i]=top?sta[top]+1:1; sta[++top]=i; &#125; top=0; for(i=n;i;i--)&#123; while(top&amp;&amp;a[sta[top]]&gt;=a[i])top--; r[i]=top?sta[top]-1:n; sta[++top]=i; &#125; ll ans=0; build(0,n,1); for(i=1;i&lt;=n;i++)&#123; ll lmn=querymin(l[i]-1,i,1),rmn=querymin(i,r[i],1); ll lmx=querymax(l[i]-1,i,1),rmx=querymax(i,r[i],1); ans=max(ans,a[i]*(rmn-lmx)); ans=max(ans,a[i]*(rmx-lmn)); &#125; printf("%lld",ans); return 0;&#125; J 题目描述给定一棵含$n$个节点的树，有$m$个询问，每个询问$(u,v,k)$求给定两点$(u,v)$之间路径长度不大于$k$的路径数。 $2\leq n \leq 10^5,1\leq m\leq 10^5,1\leq u,v\leq n,0\leq k \leq 10^9$。 解题思路如果求区间小于$k$的个数，可以用主席树；而在树上路径，则可以用在树上建主席树。设$f(b)$表示从根$(1)$到$b$的路径中小于等于$k$的路径个数，则$ans(u,v,k)=f(u)+f(v)-2f(lca(u,v))$。 注意离散化。 主席树早忘光了，赛场上没写出来…… AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100005#define mid ((l+r)&gt;&gt;1)struct Edge&#123; int e,n,l;&#125;e[N&lt;&lt;1];int d[N],fa[22][N],lg[N],hd[N],cnt;void add(int a,int b,int l)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;e[cnt].l=l;&#125;void dfs2(int now,int f)&#123; d[now]=d[f]+1; fa[0][now]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++) fa[i][now]=fa[i-1][fa[i-1][now]]; for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=f)dfs2(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y]) x=fa[lg[d[x]-d[y]]][x]; if(x==y)return x; for(i=lg[d[x]];~i;i--) if(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y]; return fa[0][x];&#125;int A[N],B[N];int root[N],L[N&lt;&lt;5],R[N&lt;&lt;5],sum[N&lt;&lt;5];int build(int l,int r)&#123; int now=++cnt; sum[now]=0; if(l&lt;r)&#123; L[now]=build(l,mid); R[now]=build(mid+1,r); &#125; return now;&#125;int update(int root,int l,int r,int x)&#123; int now=++cnt; L[now]=L[root]; R[now]=R[root]; sum[now]=sum[root]+1; if(l&lt;r)&#123; if(x&lt;=mid)L[now]=update(L[root],l,mid,x); else R[now]=update(R[root],mid+1,r,x); &#125; return now;&#125;int query(int lt,int rt,int l,int r,int x)&#123; if(l&gt;=r)&#123; if(B[l]&lt;=x)return sum[rt]-sum[lt]; else return 0; &#125; if(B[mid]&lt;=x)return sum[L[rt]]-sum[L[lt]]+query(R[lt],R[rt],mid+1,r,x); return query(L[lt],L[rt],l,mid,x);&#125;int mx;int quer(int x,int z)&#123; return query(root[1],root[x],1,mx,z);&#125;void dfs(int r,int f,int len)&#123; int i; root[r]=update(root[f],1,mx,lower_bound(B+1,B+mx+1,len)-B); for(i=hd[r];i;i=e[i].n)&#123; int q=e[i].e; if(q!=f)dfs(q,r,e[i].l); &#125;&#125;int main()&#123; int i,n,m,a,b,l; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;n;i++)scanf("%d%d%d",&amp;a,&amp;b,&amp;l),add(a,b,l),add(b,a,l),A[i]=B[i]=l; cnt=0; sort(B+1,B+n); mx=unique(B+1,B+n)-B-1; root[0]=build(1,mx); dfs(1,0,0); dfs2(1,0); for(i=2;i&lt;=n;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;l); printf("%d\n",quer(a,l)+quer(b,l)-2*quer(lca(a,b),l)); &#125; return 0;&#125; K 题目描述给定一个序列${a_n}$，定义三个函数$f,g,w$，$f(l,r)=\oplus a[x] (l\leq x\leq r)$，$g(l,r)=\oplus f(x) (l\leq x\leq r)$，$w(l,r)=\oplus g(x) (l\leq x\leq r)$。 有$q$个询问，每次询问一个区间$[l,r]$，输出$w(l,r)$。 解题思路比赛的时候模拟一下$fgw$打了个表找出来规律，然后就过了。 最后的结果是一个有规律的平行四边形，用线段树很容易维护。（用前缀和也可，但打线段树打上瘾了） 打表代码点击 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;int ans[1000];void f(int x,int y)&#123; int i; for(i=x;i&lt;=y;i++)ans[i]^=1;&#125;void g(int x,int y)&#123; int i,j; for(i=x;i&lt;=y;i++)for(j=i;j&lt;=y;j++)f(i,j);&#125;void w(int x,int y)&#123; int i,j; for(i=x;i&lt;=y;i++)for(j=i;j&lt;=y;j++)g(i,j);&#125;int main()&#123; int i,j; for(i=1;i&lt;=20;i++)&#123; memset(ans,0,sizeof(ans)); w(1,i); for(j=1;j&lt;=i;j++)printf("%d ",ans[j]); puts(""); &#125; return 0;&#125; 输出结果： $1$$1 1$$0 1 0$$0 0 0 0$$1 0 0 0 1$$1 1 0 0 1 1$$0 1 0 0 0 1 0$$0 0 0 0 0 0 0 0$$1 0 0 0 1 0 0 0 1$$1 1 0 0 1 1 0 0 1 1$$0 1 0 0 0 1 0 0 0 1 0$$0 0 0 0 0 0 0 0 0 0 0 0$$1 0 0 0 1 0 0 0 1 0 0 0 1$$1 1 0 0 1 1 0 0 1 1 0 0 1 1$$0 1 0 0 0 1 0 0 0 1 0 0 0 1 0$$0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0$$1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1$$1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1$$0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0$$0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0$ AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int read()&#123; char c=getchar();int now=0,f=1; while(c&gt;'9'||c&lt;'0')&#123; if(c=='-')f=-1; c=getchar(); &#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123; now=(now&lt;&lt;3)+(now&lt;&lt;1)+c-'0'; c=getchar(); &#125; return now*f;&#125;#define N 100010struct Tree&#123; int l,r,dat;&#125;t[4][N&lt;&lt;2];int a[N],n;void build(int R,int p,int l,int r)&#123; t[R][p].l=l;t[R][p].r=r; if(l==r)&#123; t[R][p].dat=(l%4==R)?a[l]:0; return; &#125; build(R,p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(R,p&lt;&lt;1|1,(l+r&gt;&gt;1)+1,r); t[R][p].dat=t[R][p&lt;&lt;1].dat^t[R][p&lt;&lt;1|1].dat;&#125;int query(int R,int p,int l,int r)&#123; int L=t[R][p].l,Rr=t[R][p].r; if(l&lt;=L&amp;&amp;Rr&lt;=r)return t[R][p].dat; if(L&gt;r||Rr&lt;l)return 0; return query(R,p&lt;&lt;1,l,r)^query(R,p&lt;&lt;1|1,l,r);&#125;int main()&#123; int T,i,q; T=read(); while(T--)&#123; n=read(); for(i=1;i&lt;=n;i++)a[i]=read(); for(i=0;i&lt;4;i++)build(i,1,1,n); q=read(); while(q--)&#123; int l=read(),r=read(); int R=l%4; if((r-l+1)%4==0)printf("0\n"); else if((r-l+1)%4==1)printf("%d\n",query(R,1,l,r)); else if((r-l+1)%4==3)printf("%d\n",query((R+1)%4,1,l+1,r)); else printf("%d\n",query(R,1,l,r)^query((R+1)%4,1,l+1,r)); &#125; &#125; return 0;&#125; L 题目描述有一棵树，第一年是一个杆，每年每个叶子节点伸出三个长度为当前树枝长度四分之一的树枝，分别与当前树枝方向呈$0°,60°,-60°$。给一个方程为$y=k(x-x_0)+y_0$的直线去砍这棵树，问最后根节点连带的一段没被砍掉的有多么长。 解题思路？？这么水一题当时怎么没做 根据深度找搜索方向，深搜一遍，$3^{14}$甚至不需要剪枝（什么，最后只跑了14ms）。 AC代码点击 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define delta (k*(a-x)+y-b)using namespace std;int n,l;double x,y,k;int OnLine(double a,double b)&#123; if(fabs(delta)&lt;1e-8)return 0; if(delta&lt;0)return -1; return 1;&#125;double dir[6][2]=&#123;&#123;0,1&#125;,&#123;-sqrt(3)/2,0.5&#125;,&#123;-sqrt(3)/2,-0.5&#125;,&#123;0,-1&#125;,&#123;sqrt(3)/2,-0.5&#125;,&#123;sqrt(3)/2,0.5&#125;&#125;;double dfs(int dep,int di,double a,double b,double len)&#123; if(dep==n||!OnLine(a,b))return 0; double dis=delta/(dir[di][1]-k*dir[di][0]); if(dis&gt;=0&amp;&amp;dis&lt;=len)return dis; return len+ dfs(dep+1,(di+1)%6,a+len*dir[di][0],b+len*dir[di][1],len/4)+ dfs(dep+1,di,a+len*dir[di][0],b+len*dir[di][1],len/4)+ dfs(dep+1,(di+5)%6,a+len*dir[di][0],b+len*dir[di][1],len/4);&#125;int main()&#123; int i,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%lf%lf%lf",&amp;l,&amp;n,&amp;x,&amp;y,&amp;k); printf("%.6f\n",dfs(0,0,0,0,l)); &#125; return 0;&#125; M 题目描述给一个只含小写字母的字符串$S$，$n$个字符串$T$，判断每一个$T$是否是$S$的子串。$0&lt; |S|,|T|\leq 1e5$。 解题思路代码&amp;思路 by Nikkukun 预处理出$nxt[i][j]$表示第$i$位字符之后最接近的字符$j+’a’$的下一个位置，$O(\sum_{i=1}^n len(T_i))$处理。 AC代码-By Nikkukun-1783ms点击 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;const int N=100000+5,C=26+2;char s[N],t[N];int nxt[N][C];int main()&#123; scanf("%s",s); int i,j,n=strlen(s),q; memset(nxt,-1,sizeof(nxt)); for(i=0;i&lt;n;i++)nxt[i][s[i]-'a']=i; for(j=0;j&lt;C;j++)nxt[n][j]=n; for(i=n-1;i&gt;=0;i--) for(j=0;j&lt;C;j++) if(~nxt[i][j])nxt[i][j]=nxt[i+1][j]; scanf("%d",&amp;q); while(q--)&#123; scanf("%s",t); int m=strlen(t); int p=0,cnt=0; while(cnt&lt;m&amp;&amp;nxt[p][t[cnt]-'a']&lt;n)&#123; p=nxt[p][t[cnt]-'a']+1; cnt++; &#125; printf((cnt==m)?"YES\n":"NO\n"); &#125; return 0;&#125; 赛后发现，原来暴力也能过，而且竟然只是$1700ms$和$2000ms$的差别。。。 AC代码-By Potassium-2093ms点击 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;char a[100002],b[100002];int main()&#123; int n,x,y,la,lb,flag; scanf("%s%d",a,&amp;n); while(n--)&#123; scanf("%s",b); if((lb=strlen(b))&gt;(la=strlen(a)))printf("NO\n"); else&#123; x=y=flag=0; while(x&lt;la&amp;&amp;y&lt;lb)&#123; if(a[x]==b[y])x++,y++; else&#123; x++; if(!a[x])&#123; flag=1; break; &#125; &#125; &#125; if(!b[y]&amp;&amp;!flag)printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北理校赛2019.04.14 题解]]></title>
    <url>%2F2019%2F04%2F16%2Fbitcontest2019%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L 12/12 O O O Ø O O Ø O Ø O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给一个表，求打表结果。 解题思路签到打比赛，一个愿打一个愿挨。 AC代码点击 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;int x[10][10]; char ch[4]=&#123;'I','E'&#125;;int main()&#123; int i,n; x[0][5]=x[1][1]=x[1][3]=x[1][5]=x[2][1]=x[2][3]=x[2][5]=1; x[3][1]=x[3][3]=x[3][5]=x[4][1]=x[5][3]=1; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; char a[10]=&#123;0&#125;; scanf("%s",a); int p=a[0]-'0',q=2; if(!p)&#123; printf("X"); continue; &#125; if(a[1])&#123; if(a[2])&#123; if(a[2]=='-')q=0; else q=4; &#125;else&#123; if(a[1]=='-')q=1; else q=3; &#125; &#125; printf("%c",ch[x[q][p]]); &#125; return 0;&#125; B 题目描述给定$m$个字符串$a[i] (1 \leq i \leq m)$，求一个长度为$n$的字符串$A$，使得$a[i] (i\leq i \leq m)$均不为$A$的连续子串。 解题思路$AC$自动机套$DP$。用$dep[i]$表示$i$这个节点最多能延伸到多么深。沿着$trie$图走，记忆化搜索，只要遇到字符串标记则记$dep[i]=0$。如果成环则必定可行（这一个环上都没有子串），所以用$vis[i]$表示当前走过的路径，以缩减搜索时间。最后输出的时候再沿着可行边走即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define N 800010#define P 26int t[N][P],END[N],fail[N],tot,n,m;char a[N];void insert()&#123; int i,now=0; for(i=0;a[i];i++)&#123; int c=a[i]-'a'; if(!t[now][c])t[now][c]=++tot; now=t[now][c]; &#125; END[now]++;&#125;queue&lt;int&gt;Q;void build()&#123; int i; for(i=0;i&lt;P;i++)if(t[0][i])Q.push(t[0][i]); while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=0;i&lt;P;i++)&#123; if(!t[p][i])t[p][i]=t[fail[p]][i]; else&#123; fail[t[p][i]]=t[fail[p]][i]; if(END[fail[t[p][i]]])END[t[p][i]]=1; Q.push(t[p][i]); &#125; &#125; &#125;&#125;int vis[N],dep[N];int dfs(int d,int now)&#123; if(vis[now])return dep[now]=1e6; if(~dep[now])return dep[now]; if(END[now])return dep[now]=0; if(!d)return dep[now]=1; vis[now]=1; dep[now]=0; int i; for(i=0;i&lt;P;i++)dep[now]=max(dep[now],dfs(d-1,t[now][i])+1); vis[now]=0; return dep[now];&#125;void print(int d)&#123; int i,now=0; while(d)&#123; for(i=0;i&lt;P;i++)&#123; if(d&lt;=dep[t[now][i]])&#123; printf("%c",i+'a');d--; now=t[now][i]; break; &#125; &#125; &#125;&#125;int main()&#123; int i; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;m;i++)scanf("%s",a),insert(); build(); memset(dep,-1,sizeof(dep)); dfs(n,0); print(n); return 0;&#125; C 题目描述路上有$n$个怪兽，每个怪兽有攻击力$x[i]$血量$d[i]$，你的攻击力是$k$。每遇到一个怪兽，你先手攻击，之后轮流攻击，当怪兽的血量$\leq 0$的时候该怪兽死亡。 有$c$个道具，该道具可以在瞬间吃下而且使本回合临时增加$k$点攻击力，该道具可以在任意时候吃，且可以连续吃。问你最少消耗多少血量。 解题思路一个道具相当于多打该怪兽一个回合，贪心地攻击攻击力最高的怪兽即可，记得开$long$ $long$。 AC代码点击 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct Monster&#123; int d,x; bool operator&lt;(const Monster&amp;a)const&#123;return x&gt;a.x;&#125;&#125;a[100010];int tot;int main()&#123; int i,n,k,c,d,x; scanf("%d%d%d",&amp;n,&amp;k,&amp;c); for(i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;d,&amp;x); if(d&gt;k)a[tot++]=(Monster)&#123;d/k+(d%k!=0)-1,x&#125;; &#125; sort(a,a+tot); int left=0; for(i=0;i&lt;c;i++)&#123; a[left].d--; if(a[left].d&lt;=0)left++; if(left&gt;=tot)break; &#125; long long ans=0; for(i=0;i&lt;tot;i++)ans+=a[i].d*1LL*a[i].x; printf("%lld",ans); return 0;&#125; D 题目描述在宽为$w$的走廊中有$n$个圆形障碍物，求能通过该走廊的最大圆的半径。 解题思路显然，最大的圆能够使得整个走廊两端连接。故以两点之间距离减两圆半径作为边权，用$krustal$跑一遍最小生成树，答案即为最大边权。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define N 1002using namespace std;struct Circle&#123; int x,y,r; double dis; bool operator&lt;(const Circle&amp;a)const&#123;return dis&lt;a.dis;&#125;&#125;a[N];int x[N],n,w;double dist(int X1,int Y1,int X2,int Y2)&#123; return sqrt((X1-X2)*(X1-X2)+(Y1-Y2)*(Y1-Y2));&#125;void upd(int now,int last)&#123; double d; if(a[last].y+a[last].r&gt;=w&amp;&amp;a[now].y+a[now].r&gt;=w)a[now].dis=0; else if(a[now].dis&gt;(d=dist(a[now].x,a[now].y,a[last].x,a[last].y)-a[now].r-a[last].r))a[now].dis=d;&#125;int main()&#123; int i,j,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;w,&amp;n); for(i=0;i&lt;n;i++)scanf("%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].r),a[i].dis=a[i].y-a[i].r,x[i]=a[i].x; sort(x,x+n); int mx=unique(x,x+n)-x; for(i=0;i&lt;mx;i++)a[n++]=(Circle)&#123;x[i],w,0,w*1.0&#125;; sort(a,a+n); double ans=max(a[0].dis,0.0); for(j=1;j&lt;n;j++)upd(j,0); sort(a,a+n); for(i=1;i&lt;n;i++)&#123; //for(j=0;j&lt;n;j++)printf("%d %d %d %.4f\n",a[j].x,a[j].y,a[j].r,a[j].dis); sort(a+i,a+n); ans=max(ans,a[i].dis); for(j=i+1;j&lt;n;j++)upd(j,i); &#125; printf("%.10f\n",ans/2); &#125; return 0;&#125; E 题目描述给一个全排列，求多少个栈才能把全排列变成有序的升序序列。 解题思路两个栈必定能完成全部操作：想取出任意一个元素均有可行方案。故只需要判断能否用一个栈解决。 AC代码点击 123456789101112131415161718#include&lt;stdio.h&gt;int st[100010],top,t,n,now,a[100010];int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; top=0;now=1; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)&#123; st[top++]=a[i]; while(top&amp;&amp;st[top-1]==now)top--,now++; &#125; if(now!=n+1)printf("2\n"); else printf("1\n"); &#125; return 0;&#125; F 题目描述给一个$n\times m$的网格图，求本质不同的四个顶点都在格点上构成的正方形个数。 解题思路先考虑边长为$i\times i$的正方形，以它的四个边上的点为顶点的正方形个数为$i$。 故答案即为$\sum_{i=1}^{m}(n-i+1)\times (m-i+1)\times i$。 AC代码点击 12345678910111213#include&lt;stdio.h&gt;int t,n,m;int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; long long ans=0; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=m;i++)ans+=1LL*(n-i+1)*(m-i+1)*i; printf("%lld\n",ans); &#125; return 0;&#125; G 题目描述有两个区域，$A$区域的人全都要去$B$区域。$A$区域的人分别位于$c[i]$上，$B$区域只能到达$d[i]$。现在给定$n$条特殊道路，$A$区域$[a,b]$范围和$B$区域$[c,d]$范围连通，需要的耗时为$w$，问$A$区的人同时出发，最后到达的人所需时间是多少。 解题思路新建$s,t$，连$t-&gt;B,B-&gt;A,A-&gt;s$的边，跑最短路，找到$t$到$c[i]$路径最长的即为答案。 三种边分别如何连呢？ $t-&gt;B:$$t$到所有$d[i]$$A-&gt;s:$所有$c[i]$到$s$（其实完全可以不连）$B-&gt;A:$线段树维护，添加特殊点保证连边数量线性。 其中令左线段树($B$)上的点为其编号本身，令右线段树($A$)上的点为其编号本身$+2n$，叶节点序号用$lnum,rnum$表示。 线段树维护过程：将线段树上每一个节点视为点，则该点代表所有以它为根的子树，故初始化的时候左线段树连接从儿子到爸爸权值为$0$的边，右线段树连接从爸爸到儿子权值为$0$的边。添加特殊道路时，添加一个中间特殊点，分别同向连接两棵线段树。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;#define N (100000&lt;&lt;3)struct Edge&#123; int e,n,l;&#125;e[(N)&lt;&lt;2];int hd[N],cnt;void add(int a,int b,int l)&#123; e[++cnt].e=b;e[cnt].n=hd[a];e[cnt].l=l;hd[a]=cnt; //printf("%d %d %d %d\n",a,b,l,cnt);&#125;struct Tree&#123; int l,r;&#125;t1[N],t2[N];int t,s,n,m,p,q;int c[N],d[N];int ltnum(int x)&#123;return x;&#125;//lefttreenumint rtnum(int x)&#123;return x+2*n;&#125;//righttreenumint lnum[N],rnum[N];int tot;void build(struct Tree *a,int l,int r,int p,int dir)&#123;//dir:从根到叶-1；从叶到根-0 a[p].l=l; a[p].r=r; if(l==r)&#123; if(!dir)lnum[l]=p; else rnum[l]=p+2*n; return; &#125; build(a,l,(l+r)&gt;&gt;1,p&lt;&lt;1,dir); build(a,((l+r)&gt;&gt;1)+1,r,p&lt;&lt;1|1,dir); if(a[p&lt;&lt;1].l)&#123; if(!dir)add(ltnum(p&lt;&lt;1),ltnum(p),0); else add(rtnum(p),rtnum(p&lt;&lt;1),0); &#125; if(a[p&lt;&lt;1|1].l)&#123; if(!dir)add(ltnum(p&lt;&lt;1|1),ltnum(p),0); else add(rtnum(p),rtnum(p&lt;&lt;1|1),0); &#125;&#125;void adde(struct Tree *a,int l,int r,int midpoint,int p,int dir,int w,int offset)&#123; //offset:点的id int L=a[p].l,R=a[p].r; if(l&lt;=L&amp;&amp;R&lt;=r)&#123; if(!dir)add(p+offset,midpoint,w); else add(midpoint,p+offset,w); return; &#125; if(a[p&lt;&lt;1].r&gt;=l)adde(a,l,r,midpoint,p&lt;&lt;1,dir,w,offset); if(a[p&lt;&lt;1|1].l&lt;=r)adde(a,l,r,midpoint,p&lt;&lt;1|1,dir,w,offset);&#125;struct Node&#123; int x; long long w; bool operator&lt;(const Node&amp;a)const&#123;return w&gt;a.w;&#125;&#125;;priority_queue&lt;Node&gt;Q;int vis[N];long long dis[N];void dijkstra()&#123; int i; Q.push((Node)&#123;t,0&#125;); while(!Q.empty())&#123; int top=Q.top().x; Q.pop(); if(vis[top])continue; vis[top]=1; for(i=hd[top];i;i=e[i].n)&#123; int q=e[i].e; if(dis[q]&gt;dis[top]+0LL+e[i].l)&#123; dis[q]=dis[top]+0LL+e[i].l; Q.push((Node)&#123;q,dis[q]&#125;); &#125; &#125; &#125;&#125;int main()&#123; int i,a,b,C,D,w; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;p,&amp;q); while(n&amp;(n-1))n++; t=4*n+1; tot=s=4*n+2; build(t1,1,n,1,0); build(t2,1,n,1,1); for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;C,&amp;D,&amp;w); adde(t2,a,b,++tot,1,0,w,2*n); adde(t1,C,D,tot,1,1,0,0); adde(t2,C,D,++tot,1,0,w,0); adde(t1,a,b,tot,1,1,0,2*n); &#125; for(i=0;i&lt;p;i++)scanf("%d",&amp;c[i]); for(i=0;i&lt;q;i++)scanf("%d",&amp;d[i]); sort(d,d+q);q=unique(d,d+q)-d;for(i=0;i&lt;q;i++)add(t,lnum[d[i]],0); sort(c,c+p);p=unique(c,c+p)-c;for(i=0;i&lt;p;i++)add(rnum[c[i]],s,0); memset(dis,0x3f,sizeof(dis)); dis[t]=0; dijkstra(); long long ans=0; for(i=0;i&lt;p;i++)ans=max(ans,dis[rnum[c[i]]]); if(ans&lt;1e16)printf("%I64d",ans); else printf("boring game"); return 0;&#125; H 题目描述找出$\sqrt {ax}+b=x$的解，保证解存在且为整数。 解题思路初中数学题。 AC代码点击 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;math.h&gt;int t,a,b;int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;a,&amp;b); int A[6]=&#123;0&#125;,ans=0; int x1=round(1.0*(2*b+a+sqrt(a*a+4*a*b))/2),x2=round(1.0*(2*b+a-sqrt(a*a+4*a*b))/2); if(fabs(sqrt(a*x1)+b-x1)&lt;1e-5)A[ans++]=x1; if(fabs(sqrt(a*x2)+b-x2)&lt;1e-5&amp;&amp;x2!=x1)A[ans++]=x2; printf("%d\n",ans); for(i=0;i&lt;ans;i++)printf("%d ",A[i]); puts(""); &#125; return 0;&#125; I 题目描述给一个$n\times n$的棋盘，每个格子可以填$[1,k]$的正整数，定义棋盘中某个点为$bi$点当且仅当其为该行该列严格最大值，设$B[i]$为棋盘中恰好存在$i$个$bi$点的方案数，求$\sum_{i=0}^{n^2}i^2B[i]$。 解题思路由于任意交换两行两列不影响$bi$点状况，故可以先讨论$bi$点在对角线且$bi$点非严格单调递增的情况。 设$dp[i][j]$表示已经确定了前$i$个$bi$点，且其中最大的$bi$点对应数值不超过$j$的方案总数。 那么有：$dp[i][j]=\sum_{k=0}^{j-1}dp[k][j-1]\times \frac{(j-1)^{(i-k)(2n-i-k-1)}}{(i-k)!}$。 递推的过程即为填$bi$点值为$j$的状态。其中$dp[k][j-1]$表示前$k$行列不超过$j-1$，$j-1$的次方表示非前$k$行控制的、$k+1$到$i$行列的，由新增加进来的值为$bi$点控制的节点。最后除以$(i-k)!$为了除重。 设至少有$i$个$bi$点的方案数位$b[i]$，则有$b[i]={A_{n}^{i}}^2dp[i][k]\times k^{(n-i)^2}$，即从$n$行$n$列分别选出$i$行$i$列，且最大不超过$k$，剩下未支配的部分从$[1,k]$任取的方案个数，这段可能有重复，不过无关紧要，请看下一步。 再设$f[i]$为恰好有$i$个$bi$点的方案总数，则可以进行容斥：$f[i]=b[i]+\sum_{i&lt;j}(-1)^{(j-i)}b[j]\times C_{j}^{i}$。 最后即可得出结果。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 205typedef long long ll;int f[N],dp[N][N],b[N];ll w=998244353,jc[N]=&#123;1&#125;;ll qpow(ll x,ll p)&#123; int i; ll ans=1; for(i=p;i;i&gt;&gt;=1,x=x*x%w)if(i&amp;1)ans=ans*x%w; return ans;&#125;ll inv(ll x)&#123;return qpow(x,w-2);&#125;int main()&#123; int i,j,k,t,n,K; scanf("%d",&amp;t); for(i=1;i&lt;N;i++)jc[i]=jc[i-1]*i%w; while(t--)&#123; scanf("%d%d",&amp;n,&amp;K); memset(dp,0,sizeof(dp)); memset(b,0,sizeof(b)); memset(f,0,sizeof(f)); for(i=0;i&lt;=n;i++)dp[0][i]=1; for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;=K;j++)&#123; for(k=0;k&lt;=i;k++) dp[i][j]+=dp[k][j-1]*qpow(j-1,(i-k)*(2*n-i-k-1))%w*inv(jc[i-k])%w; &#125; &#125; for(i=1;i&lt;=n;i++) b[i]=jc[n]*inv(jc[n-i])%w*jc[n]*inv(jc[n-i])%w*dp[i][K]%w*qpow(K,(n-i)*(n-i))%w; for(i=1;i&lt;=n;i++)&#123; f[i]=b[i]; int nowsign=-1; for(j=i+1;j&lt;=n;j++)&#123; f[i]+=(nowsign)*b[j]*jc[j]%w*inv(jc[i])%w*inv(jc[j-i])%w; f[i]%=w; nowsign*=-1; &#125; f[i]+=w; f[i]%=w; &#125; ll ans=0; for(i=1;i&lt;=n;i++) (ans+=i*i*f[i])%=w; printf("%lld\n",(ans%w+w)%w); &#125; return 0;&#125; J 题目描述定义一个合法的算式是一个恰好长为$n$的字符串，其中只包含$0-9,+,-$，不允许运算符相邻或出现在首尾，允许前导零。合法的算式的计算结果即为对该字符串模拟十进制加减法运算的结果。 求所有合法算式计算结果的和，答案对$998244353$取模。 解题思路由于$+$和$-$都可以出现，所以能出现加号的地方必能出现减号，只需要考虑算式最左端的数对应的结果即可。 可设： $p[j]=10^i$$f[i]=\frac{10^i}{2}(10^i+1)$，此即只含有$i$位数字的算式计算结果。$g[i]$为长度为$i$、第一个字符为$+$或$-$的不同串总种数。$ans$为长度为$n$的合法算式计算结果的和。 则有$g[2]=20,g[i]=2p[i-1]+\sum_{j=2}^{i-2}2p[i-j-1]g[j]$ 处理成前缀和： $g[i]=2f[i-1]+10^{i-1}\sum_{j=2}^{i-2}2*10^{-j}g[j]$ $=2f[i-1]+p[i-1]h[i-2]$ 其中$h[i]=\sum_{j=2}^{i}2\times 10^{-j}g[j]$，同时处理即可。 $ans=f[n]+\sum_{j=2}^{n-1}f[n-j]g[j]$ AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define N 500002typedef long long ll;int t,a,b;ll inv=299473306;ll w=998244353;ll p[N]=&#123;1&#125;;ll f[N]=&#123;1&#125;,g[N],h[N];ll invf[N]=&#123;1&#125;;int main()&#123; int i,n; scanf("%d",&amp;t); for(i=1;i&lt;N;i++)p[i]=p[i-1]*10%w; for(i=1;i&lt;N;i++) f[i]=(p[i]-1)*p[i-1]*5%w,invf[i]=invf[i-1]*inv%w; g[2]=20; while(t--)&#123; ll ans=0; scanf("%d",&amp;n); for(i=2;i&lt;=n;i++)&#123; g[i]=(2*p[i-1]+p[i-1]*h[i-2])%w; h[i]=(h[i-1]+2*invf[i]*g[i])%w; &#125; for(i=2;i&lt;=n-1;i++)ans=(ans+f[n-i]*g[i])%w; ans=(ans+f[n])%w; //for(i=1;i&lt;n;i++)printf("h:%I64d g:%I64d f:%I64d\n",h[i],g[i],f[i]); printf("%I64d\n",ans); &#125; return 0;&#125; K 题目描述给一个多项式，求其导数各指数的系数。 解题思路签到。 AC代码点击 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int i,j,n,k,a[110]=&#123;0&#125;; scanf("%d%d",&amp;n,&amp;k); for(i=n;i&gt;=0;i--)scanf("%d",&amp;a[i]); for(i=0;i&lt;k;i++)&#123; for(j=0;j&lt;=n;j++) a[j]=(a[j]*((j&gt;i)?j-i:0))%2019; &#125; for(i=0;i&lt;k;i++)printf("0 "); for(i=n;i&gt;=k;i--)printf("%d ",a[i]%2019); return 0;&#125; L 题目描述给定$n$个点，$m$条边权均为$1$的边，从节点$1$开始，等概率选择其后继或停留，最多停留时间 为$1$，问总时间期望。 解题思路推出式子树形$DP$即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#define N 100010typedef long long ll;struct Edge&#123; int e,n;&#125;e[N];int ind[N],oud[N],cnt,hd[N],n,m;void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt; ind[b]++;oud[a]++;&#125;int w=998244353;ll qpow(ll x,ll p)&#123; int i; ll ans=1; for(i=p;i;i&gt;&gt;=1,x=x*x%w)if(i&amp;1)ans=ans*x%w; return ans;&#125;ll inv(ll x)&#123;return qpow(x,w-2);&#125;ll dfs(int x)&#123; if(!oud[x])return 2; int i,q; ll p=0; for(i=hd[x];i;i=e[i].n)&#123; q=e[i].e; (p+=dfs(q))%=w; &#125; return (1+(p+oud[x])*inv(oud[x]+1)%w+inv(oud[x]+1)*inv(oud[x])%w*(p+2*oud[x]))%w;&#125;int main()&#123; int i,t,u,v; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;m;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v); printf("%lld\n",dfs(1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2050 Programming Competition 部分题解]]></title>
    <url>%2F2019%2F04%2F15%2F2050contest%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I 7/9 O O O O O O Ø . . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述问一个字符串是不是$2050$拼成的。 解题思路签到题，暴力求解。 AC代码点击 1234567891011121314151617181920#include&lt;stdio.h&gt;char a[10000010];int main()&#123; int i,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",a); int flag=0; for(i=0;a[i];i+=4)&#123; if(a[i]=='2'&amp;&amp;a[i+1]=='0'&amp;&amp;a[i+2]=='5'&amp;&amp;a[i+3]=='0'); else &#123; flag=1; break; &#125; &#125; if(flag)printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125; B 题目描述给一个年月日时分秒，求这个时间点和$2050$年$1$月$1$日$0$时$0$分$0$秒差多少秒，答案对$100$取模。 解题思路刚开始一边写判断闰年一边暗骂出题者毒瘤，写到一半突然发现答案竟然是对$100$取模？？ （脏话） 直接计算这是该天的第几秒，判断一下这个时间在给定日期之前还是之后即可。 AC代码点击 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int t,y,m,d,h,min,s; scanf("%d",&amp;t); while(t--)&#123; int ans=0; scanf("%d-%d-%d",&amp;y,&amp;m,&amp;d); scanf("%d:%d:%d",&amp;h,&amp;min,&amp;s); ans=h*3600+min*60+s; if(y&lt;2050)ans=86400-ans; printf("%d\n",ans%100); &#125; return 0;&#125; C 题目描述有一堆人，$n+k$个男生，$m+k$个女生，其中$k$对情侣。有双人间$a$、三人间$b$、情侣间$c$，其中情侣间只能住情侣，双人三人间只能住同性且可以不住满。三种房间分别有不同价格，求把他们安排下住宿的最小花费。 解题思路刚开始想的是取情侣全住$c$和全不住$c$的最小值，然后兴高采烈交了个$WA$。 后来才发现，情侣可以部分住$c$，枚举即可。 $f$表示的是$x$个人分配到$a$或$b$间的最小花费，分三种情况（除三的余数）讨论即可。 然后递推就可以了。 AC代码点击 123456789101112131415161718192021222324#include&lt;stdio.h&gt;typedef long long ll; int t,n,m,k;ll a,b,c;ll min(ll a,ll b)&#123;return a&gt;b?b:a;&#125;ll f(int x)&#123; ll ans=0; if(x&lt;3)return min(a,b); if(x%3==1)ans=min((x/3+1)*b,(x/3-1)*b+2*a); else if(x%3==2)ans=min((x/3+1)*b,x/3*b+a); else ans=x/3*b; return min((x/2+(x%2!=0))*a,ans);&#125;int main()&#123; scanf("%d",&amp;t); int i; while(t--)&#123; scanf("%d%d%d%lld%lld%lld",&amp;n,&amp;m,&amp;k,&amp;a,&amp;b,&amp;c); ll ans=f(n+k)+f(m+k); for(i=0;i&lt;k;i++)ans=min(ans,f(n+i)+f(m+i)+(k-i)*c); printf("%lld\n",ans); &#125; return 0;&#125; D 题目描述给一个计分规则，求最终奖品个数。 给定一个$01$串，求每一个前缀包含的所有本质不同的字母串个数。 解题思路纯模拟，没啥好说的。 显然需要离线处理枚举前缀的结尾。 第一思路是，从前缀的结尾$i$往前递推，$num$记录最多能向后延伸几位，$dp[j]$表示$j$之后的字母串种类个数。 AC代码点击 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;int a[10010],num[10010];int peo[10010];int main()&#123; int i; int t,n,m,k; scanf("%d",&amp;t); while(t--)&#123; memset(num,0,sizeof(num)); memset(peo,0,sizeof(peo)); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); num[a[i]]++; &#125; for(i=0;i&lt;=m;i++)peo[i]=num[i]-num[i]/k; int ans=0; for(i=0;i&lt;n/2;i++)if(num[a[i]]&gt;peo[a[i]])num[a[i]]--,ans++; printf("%d\n",ans); &#125; return 0;&#125; E 题目描述两个人打乒乓球。给一个球赛的计分榜，其中有$A$得分、$B$得分、未知得分三种情况，问最多进行了多少场比赛。 解题思路这题的$DP$挺麻烦的。 可以设一个$f[i][j][k]$表示在第$k$个计分之后，$A$和$B$比分为$i:j$的时候，最多可能的比赛轮数，其中$-1$表示不可能到达这种局面。其中，$10:10$之后某方得分可以化为$10:9$，特判即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int f[12][12][10010];char a[10010];int main()&#123; int i,j,k,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",a+1); int l=strlen(a+1); memset(f,-1,sizeof(f)); f[0][0][0]=0; for(i=1;a[i];i++)&#123; if(a[i]=='A')&#123; for(j=1;j&lt;=10;j++) for(k=0;k&lt;=10;k++) if(~f[j-1][k][i-1])f[j][k][i]=f[j-1][k][i-1]; for(j=0;j&lt;10;j++) if(~f[10][j][i-1])f[0][0][i]=max(f[0][0][i],f[10][j][i-1]+1); f[10][9][i]=max(f[10][10][i-1],f[10][9][i]); &#125;else if(a[i]=='B')&#123; for(j=0;j&lt;=10;j++) for(k=1;k&lt;=10;k++) if(~f[j][k-1][i-1])f[j][k][i]=f[j][k-1][i-1]; for(j=0;j&lt;10;j++) if(~f[j][10][i-1])f[0][0][i]=max(f[0][0][i],f[j][10][i-1]+1); f[9][10][i]=max(f[10][10][i-1],f[9][10][i]); &#125;else&#123; for(j=0;j&lt;=10;j++) for(k=0;k&lt;=10;k++)&#123; if(j&amp;&amp;~f[j-1][k][i-1])f[j][k][i]=f[j-1][k][i-1]; if(k&amp;&amp;~f[j][k-1][i-1])f[j][k][i]=f[j][k-1][i-1]; &#125; for(j=0;j&lt;10;j++)&#123; if(~f[j][10][i-1]) f[0][0][i]=max(f[0][0][i],f[j][10][i-1]+1); if(~f[10][j][i-1]) f[0][0][i]=max(f[0][0][i],f[10][j][i-1]+1); &#125; f[9][10][i]=max(f[10][10][i-1],f[9][10][i]); f[10][9][i]=max(f[10][10][i-1],f[10][9][i]); &#125; /*printf("%d %c\n",i,a[i]); for(j=0;j&lt;12;j++)&#123; for(k=0;k&lt;12;k++)printf("%d ",f[j][k][i]); puts(""); &#125; puts("");*/ &#125; int ans=0; for(i=0;i&lt;=10;i++)for(j=0;j&lt;=10;j++) ans=max(ans,f[i][j][l]); printf("%d\n",ans); &#125; return 0;&#125; F 题目描述现在，我们要依次面对$n$个冰水挑战，每个挑战你都可以选择接受或不接受。接受第$i$个挑战会让你丧失$a_i$点体力，因为每个挑战所处的环境不同，如果你要挑战它，在挑战它之前你的体力$x$会变成 $min(x,b_i)$，当你完成这个挑战的时候，你的体力会变成$x−a_i$，体力任何时候不允许小于等于$0$，无论你是否接受第$i$个挑战，在这个挑战结束以后你的体力都会增加$c_i$。 解题思路$f[i][j]$表示进行到第$i$个挑战，已经完成了$j$ 个挑战之后，最大的体力值。然后$dp$即可。 AC代码点击 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;int t,n;long long p,a[1010],b[1010],c[1010];long long f[1010][1010];int main()&#123; int i,j; scanf("%d",&amp;t); while(t--)&#123; memset(f,0,sizeof(f)); scanf("%d%lld",&amp;n,&amp;p); for(i=1;i&lt;=n;i++)scanf("%lld%lld%lld",&amp;a[i],&amp;b[i],&amp;c[i]); f[0][0]=p; for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;=i;j++)&#123; if(f[i-1][j])f[i][j]=f[i-1][j]+c[i]; if(j&amp;&amp;min(f[i-1][j-1],b[i])-a[i]&gt;0) f[i][j]=max(f[i][j],min(f[i-1][j-1],b[i])-a[i]+c[i]); &#125; &#125; int ans=0; for(i=1;i&lt;=n;i++)if(f[n][i])ans=i; printf("%d\n",ans); &#125; return 0;&#125; G 题目描述我们看到了一栋高楼大厦，大厦的墙面可以看做一个$W×H$的矩形，我们把它的左下角当成$(0,0)$，右上角当成$(W,H)$。上面分布着一些$LED$灯，这些$LED$灯与地面呈$45$度倾斜，并且从矩形的边界延伸到另一边界，把大厦分成了若干个区域。我们想数一下这个图里面存在多少个与地面成$45$度角的矩形，其中四条边都是$LED$灯的一部分。 解题思路比赛并没有过这个题，但是想到了一种扫描线算法，出奇的麻烦，结果听学长说用$bitset$简单可过…… AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;bitset&gt;using namespace std;#define N 1002int w,h,n,m,a[N],b[N];long long W=1000000007;bitset&lt;N&gt; B[N];void solve()&#123; long long ans=0; scanf("%d%d%d%d",&amp;w,&amp;h,&amp;n,&amp;m); int i,j; for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); for(j=0;j&lt;N;j++)B[i][j]=0; &#125; for(i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;b[i]); for(j=1;j&lt;=n;j++)if(a[j]+b[i]&gt;=0&amp;&amp;a[j]+b[i]&lt;=2*w&amp;&amp;a[j]&gt;=b[i]&amp;&amp;a[j]-b[i]&lt;=2*h)B[j][i]=1; &#125; for(i=1;i&lt;=n;i++) for(j=i+1;j&lt;=n;j++)&#123; long long sum=(B[i]&amp;B[j]).count(); (ans+=sum*(sum-1)/2)%=W; &#125; printf("%lld\n",ans);&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)solve(); return 0;&#125; 后面的题还没看……]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组&后缀自动机学习笔记]]></title>
    <url>%2F2019%2F04%2F10%2Fsuffixarray%2F</url>
    <content type="text"><![CDATA[今天干了两件事情，学会了后缀数组，搞定了洛谷$AC$数量的问题，以后可以不用洛谷咯！ 继续学习、复习算法，下一步是后缀自动机。 后缀数组这儿有道纯模板题 思路只学了倍增法，但也折腾了半天。贴一下自己的想法。 既然要对后缀排序，那首先当然要找出所有后缀从第一位开始比较了。 于是一上来就有了下面这段代码： 1234for(i=0;i&lt;m;i++)c[i]=0;for(i=0;i&lt;n;i++)c[x[i]=s[i]]++;for(i=1;i&lt;m;i++)c[i]+=c[i-1];for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; 妈耶，这一堆数组都是啥 $c[i]: $一个辅助数组，用处见下面注释$x[i]: $呃，这一步的作用仅仅是记录一下$s[i]$的$ASCII$码值。$s[i]: $就是给定的字符串啦。$sa[i]: $当前排名为$i$的后缀，起始位置的下标。 一句话一句话解释。 1234567891011for(i=0;i&lt;m;i++)c[i]=0;//数组清零for(i=0;i&lt;n;i++)c[x[i]=s[i]]++;//表示这个地方有个东西（比如字符串"abbcc"），最终结果是c['a']=1,c['b']=2,c['c']=3。//那其实这里的c数组就是一个桶。//这里先把第一位排好序。for(i=1;i&lt;m;i++)c[i]+=c[i-1];//统计前缀和，方便后续统计排名。for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i;//统计排名的时候要求排名互不相同，于是强制在字符相同的情况下，第一个字母靠前的排名靠前。//这里倒着循环以满足上述条件。 好了，这步结束之后，第一位比较完了。 先看一个例子：$ababbaba$ 第一次排序后：（$97$为$‘a’$的$ASCII$码值) $i$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $x [i]$ $97$ $98$ $97$ $98$ $98$ $97$ $98$ $97$ $sa [i]$ $0$ $2$ $5$ $7$ $1$ $3$ $4$ $6$ $sa[i+1]$ $2$ $5$ $7$ $1$ $3$ $4$ $6$ $0$ 根据字典序的思想，在第一位字符相同的情况下应该接着比较下一个位置。也就是基数排序，在第一个字符相等的基础上，更细的分离出第二个字符上的区别。 那么我假设前两个字符都比完了，那么接下来该比较的是前三个字符，前四个字符……但实际上，在比完前两个字符的情况下，可以直接添加两个字符（第二关键词）到前四个字符，在下一轮添加四个字符（第二关键词）到前八个字符……这里就可以应用倍增的思想进行比较了。 接下来的代码比较长，分几部分，逐步理解。 123456for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; ...&#125; $y[i]:$ 第二关键词（即第2个，第3,4个，第5,6,7,8个……）的排序，$y[i]=j$表示排名$i$的第二关键词，第一关键词的起始位置为$j$。 $[0,i]$中，后$k$个位置的第二关键词是$0$，所以这是最小的，先加入$y$数组。 然后其他的相应排名为$sa[i]$，前面已经排了$k$个，故排名为$sa[i]-k$。 执行完这段代码后： $i$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $y [i]$ $7$ $1$ $4$ $6$ $0$ $2$ $3$ $5$ 接着和第一次几乎一样的排序： 12345for(i=0;i&lt;m;i++)c[i]=0;//清空桶for(i=0;i&lt;n;i++)c[x[i]]++;//扔进桶for(i=1;i&lt;m;i++)c[i]+=c[i-1];//前缀和for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i];//这里是唯一不一样的地方，起到的作用就是在第一次的基础上对第二关键词排序 执行完这段代码后： $i$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $sa[i]$ $7$ $0$ $2$ $5$ $1$ $4$ $6$ $3$ 对应字符串 $a0$ $ab$ $ab$ $ab$ $ba$ $ba$ $ba$ $bb$ 然后$y$数组已经光荣完成使命，下一轮的$x$数组由这一轮的$x$数组决定。怎么决定呢？显然，如果两个后缀的第一、二关键字在上一轮排名相同，那么本轮排名也相同；否则不同。于是就有： 123456std::swap(x,y);//其实是扔掉了y数组num=1;x[sa[0]]=0;//排名为0for(i=1;i&lt;n;i++)x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++;if(num&gt;=n)break;//排序完成的字符数到了n，也就是没有不同排名的后缀了，那么退出m=num;//优化一下循环 多次类似倍增后，即可得到结果。 代码123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#define N 1000010char s[N];int x[N],y[N],sa[N],c[10*N];int main()&#123; int i,k,n,m=10000; scanf("%s",s); n=strlen(s); for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]=s[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[y[i]]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i]; std::swap(x,y); num=1; x[sa[0]]=0; for(i=1;i&lt;n;i++) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++; if(num&gt;=n)break; m=num; &#125; for(i=0;i&lt;n;i++)printf("%d ",sa[i]+1); return 0;&#125; 后缀自动机此坑待填。]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vjudge294125-动态规划训练 题解]]></title>
    <url>%2F2019%2F04%2F09%2Fvjudge294125dp4-9%2F</url>
    <content type="text"><![CDATA[Solved A B C D 4/4 O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 突然看到有套在线$DP$比赛，就顺便打了一下，还挺有趣的。 比赛链接 A 题目描述给一个$1/2$序列，可以取某一段区间进行翻转操作（该区间所有元素$1$-$2$，$2$-$1$）求一种操作使得最终非严格递增序列最长并求出最大值。 解题思路枚举待操作区间中的一点$i$。枚举区间左端点$j$，统计从$[1,j]$中$1$的总个数与$[j+1,i]$中$2$的总个数和的最大值$l$。枚举区间右端点$j$，统计从$[i,j]$中$1$的总个数与$[j+1,n]$中$2$的总个数和的最大值$r$。则$l+r$即为最大值。用前缀和计算上述问题。 AC代码点击 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 2010int n,a[N],p[N],q[N],ans;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++)p[i]=p[i-1]+(a[i]==1); for(i=n;i;i--)q[i]=q[i+1]+(a[i]==2); for(i=1;i&lt;=n;i++)&#123; int r=0,l=0; for(j=1;j&lt;=i+1;j++)l=max(l,p[j-1]+q[j]-q[i+1]); for(j=i;j&lt;=n;j++)r=max(r,q[j+1]+p[j]-p[i]); ans=max(ans,l+r); &#125; printf("%d",ans); return 0;&#125; B 题目描述题干极长，英语阅读能力差，看了好吓人。题目中给的图$AB$之间还有空缺，理解了半天，原来是图错了。 简单概括为一句话：给定先序遍历的路径，求树的形态种数。 解题思路我们假设$dp[i][j]$是第$i$个字符和第$j$个字符之间的串可能构成的子树形态种数，则答案即为$dp[0][l-1]$。 对于$a[i]==a[j]$，我们先假设这两个点代表同一个节点$a$： $dp[i][j]+=dp[i+1][j-1]$，这时$a$只有一个孩子； $dp[i][j]+=\sum_{k=i+2}^{j-2}dp[i][k]*dp[k+1][j-1] (a[i]==a[k])$，这时$a$有一个右孩子$[k+1,j-1]$，至少一个左孩子$[i,k]$，这个可以继续当做树根。 其实，在递推的时候保证了这是一个子树节点也就是这两个点代表同一个节点。 AC代码点击 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define w 1000000000#define N 310char a[N];long long dp[N][N];long long dfs(int l,int r)&#123; if(~dp[l][r])return dp[l][r]; if(l&gt;=r)return 1; int i; long long ans=0; if(a[l]==a[r]&amp;&amp;r&gt;l+1)&#123; ans=dfs(l+1,r-1); for(i=l+2;i&lt;r-1;i++)if(a[i]==a[l])(ans+=dfs(l,i)*dfs(i+1,r-1))%=w; &#125; return dp[l][r]=ans%w;&#125;int main()&#123; int i; while(~scanf("%s",a))&#123; memset(dp,-1,sizeof(dp)); printf("%lld\n",dfs(0,strlen(a)-1)); &#125; return 0;&#125; C 题目描述给定一段序列，让选一个点$x$，每次选定包含$x$这个元素的包含两种相邻颜色的区域，把他们染成任意一种颜色。求最少多少步能够把所有的点染成一个颜色。 解题思路设$dp[0][l][r]$表示把$[l,r]$区间内的元素染成$color[l]$所需最少步数，设$dp[1][l][r]$表示把$[l,r]$区间内的元素染成$color[r]$所需最少步数。 然后递推就可以了。 AC代码点击 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 5002int n,cnt,a[N],dp[2][N][N];int main()&#123; int i,j,x; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x); if(!i||x!=a[cnt-1])a[cnt++]=x; &#125; n=cnt; memset(dp,0x3f,sizeof(dp)); for(i=0;i&lt;n;i++)dp[0][i][i]=dp[1][i][i]=0; for(i=0;i&lt;n;i++)&#123; for(j=i;j&gt;=0;j--)&#123; if(j)dp[0][j-1][i]=min(dp[0][j-1][i],min(dp[0][j][i]+(a[j-1]!=a[j]),dp[1][j][i]+(a[j-1]!=a[i]))); if(i&lt;n-1)dp[1][j][i+1]=min(dp[1][j][i+1],min(dp[0][j][i]+(a[i+1]!=a[j]),dp[1][j][i]+(a[i+1]!=a[i]))); &#125; &#125; printf("%d",min(dp[0][0][n-1],dp[1][0][n-1])); return 0;&#125; D 题目描述用$1$到$4$位二进制数表示$26$个英文字母，其中$0011,0101,1110,1111$没有对应的英文字母。 给定一个$01$串，求每一个前缀包含的所有本质不同的字母串个数。 解题思路这个题是最有意思的一道题，刚开始没想过来差点没有AK 显然需要离线处理枚举前缀的结尾。 第一思路是，从前缀的结尾$i$往前递推，$num$记录最多能向后延伸几位，$dp[j]$表示$j$之后的字母串种类个数。 那么有$dp[j]=\sum_{k=1}^{num}{dp[j+k]}$，也就是$[j,j+k-1]$表示的一个字母和$[j+k,i]$表示的一段字母串连成一个更大的字母串。 但是要处理本质不同这个问题，有点麻烦。 本来是想用后缀自动机解决，发现没有必要，可以用倒序的字典树直接判重解决。稍微有点细节，直接上代码。 AC代码点击 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define N 3010#define w 1000000007#define rep ((a[j]&lt;&lt;3)+(a[j+1]&lt;&lt;2)+(a[j+2]&lt;&lt;1)+a[j+3])int trie[2][N*N/2],tot;int n,a[N],f[N];int main()&#123; int i,j,k,num,now,ans=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)&#123; f[i+1]=1; now=0; for(j=i;j&gt;=0;j--)&#123; num=std::min(4,i-j+1); f[j]=0; if(num==4&amp;&amp;(rep==3||rep==5||rep==14||rep==15))num--; for(k=1;k&lt;=num;k++)(f[j]+=f[j+k])%=w; if(!trie[a[j]][now])(ans+=f[j])%=w,trie[a[j]][now]=++tot; now=trie[a[j]][now]; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vjudge293222-动态规划基础题集合 题解]]></title>
    <url>%2F2019%2F04%2F07%2Fvjudge293222basicdp%2F</url>
    <content type="text"><![CDATA[最近在学动态规划，看到$vjudge$上这套题感觉挺有意思的。 Solved A B C D E F G H I J K L M N O P Q R S 19/19 O O O O O O O O O O O O O O O O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述求一个序列的最大$m$段非空子段和。 解题思路设$g[i][j]$表示前$i$个元素中选取$j$个段，且必包含第$i$个元素的最大值。设$f[i][j]$表示前$i$个元素中选取$j$个段，且不必包含第$i$个元素的最大值。 则有：$g[i][j]=max(g[i-1][j],f[i-1][j-1])+a[i]$$f[i][j]=max(g[i-1][j],f[i-1][j])$ 答案即为$f[n][m]$。 滚动数组优化掉第一维即可。 AC代码点击 123456789101112131415161718192021#include&lt;stdio.h&gt;#define N 1000010typedef long long ll;int n,m,a[N];ll g[N],f[N];int min(int a,int b)&#123;return a&gt;b?b:a;&#125;ll max(ll a,ll b)&#123;return a&gt;b?a:b;&#125;int main()&#123; int i,j; while(~scanf("%d%d",&amp;m,&amp;n))&#123; for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++)g[i]=f[i]=-1e18; for(i=1;i&lt;=n;i++) for(j=min(i,m);j;j--)&#123; g[j]=max(g[j],f[j-1])+a[i]; f[j]=max(f[j],g[j]); &#125; printf("%lld\n",f[m]); &#125; return 0;&#125; B 题目描述给定一段个数$n$为奇数的序列，其中有一个数字出现了至少$\frac {n+1}2$次，问这个数是多少。 $1\leq n\leq999999$，$a[i]∈[-2^{31},2^{31}-1]$。 解题思路用$map$可以水过，但可以用一种更巧妙的思路做出来。 显然，如果两个数不相等，那么删掉这两个数之后剩下的数仍然满足题目要求。所以可以用一个$cnt$表示当前数出现的净次数（删掉和它不等的相同个数的数），当$cnt=0$时更新答案，也就是说答案在结束的时候必须满足它对应的$cnt\neq0$。所以最后的答案必然是所求。 AC代码-map点击 12345678910111213141516#include&lt;cstdio&gt;#include&lt;map&gt;std::map&lt;int,int&gt;m;int main()&#123; int i,n,a,ans; while(~scanf("%d",&amp;n))&#123; m.clear(); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a); m[a]++; if(m[a]&gt;=(n+1)/2)ans=a; &#125; printf("%d\n",ans); &#125; return 0;&#125; AC代码-递推点击 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int i,n,cnt,a,ans; while(~scanf("%d",&amp;n))&#123; cnt=0; for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a); if(!cnt)cnt=1,ans=a; else cnt+=a==ans?1:-1; &#125; printf("%d\n",ans); &#125; return 0;&#125; C 题目描述给定一些种类的长方体的长宽高，它们有任意多个、可任意摆放（指任意方式竖立），问当保证下一层的长宽严格大于上一层的长宽的时候，可以摞起来的最大高度。 解题思路数据超级水，直接添加所有的长宽高组合，以长为关键词排序，从上到下递推即可。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define N 520using namespace std;struct Box&#123; int x,y,z; bool operator&lt;(const Box&amp;a)const&#123;return x&gt;a.x;&#125;&#125;a[N];int n,tot,dp[N],b[4];void add(int x,int y,int z)&#123;a[tot++]=&#123;x,y,z&#125;;&#125;int main()&#123; int i,j,k,l,ans,cas=0; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; tot=ans=0; memset(dp,0,sizeof(dp)); for(l=0;l&lt;n;l++)&#123; scanf("%d%d%d",&amp;b[0],&amp;b[1],&amp;b[2]); for(i=0;i&lt;3;i++)for(j=0;j&lt;3;j++)for(k=0;k&lt;3;k++) if(i!=j&amp;&amp;i!=k&amp;&amp;j!=k)add(b[i],b[j],b[k]); &#125; sort(a,a+tot); for(i=0;i&lt;tot;i++)&#123; for(j=0;j&lt;i;j++)if(a[i].x&lt;a[j].x&amp;&amp;a[i].y&lt;a[j].y)dp[i]=max(dp[i],dp[j]); dp[i]+=a[i].z; ans=max(ans,dp[i]); &#125; printf("Case %d: maximum height = %d\n",++cas,ans); &#125; return 0;&#125; D 题目描述现在摆在面前一堆作业和$DDL$，并知道每个作业需要的时间，求使得超出$DDL$的时间的总和最小的方案。如果有多种，输出作业名字典序最小的那一种。数据保证给定的顺序符合作业名字典序。 解题思路一上来想了个贪心，哗哗哗写出来了兴高采烈地交上了。 然后获得了$WA$。 WA代码点击 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;struct ddl&#123; char a[110]; int d,c; bool operator&lt;(const ddl&amp;p)const&#123;return d&lt;p.d||(d==p.d&amp;&amp;strcmp(a,p.a)&lt;0);&#125;&#125;a[16];int main()&#123; int i,n;scanf("%*d"); while(~scanf("%d",&amp;n))&#123; for(i=0;i&lt;n;i++)scanf("%s%d%d",a[i].a,&amp;a[i].d,&amp;a[i].c); sort(a,a+n); int ans=0,time=0; for(i=0;i&lt;n;i++)&#123; time+=a[i].c; if(time&gt;a[i].d)ans+=time-a[i].d; &#125; printf("%d\n",ans); for(i=0;i&lt;n;i++)printf("%s\n",a[i].a); &#125; return 0;&#125; 然后找到了下面这组数据： $1$$5$$A$ $10$ $2$$B$ $2$ $8$$C$ $10$ $1$$D$ $9$ $3$$E$ $2$ $1$ $emmmm$，贪心确实行不通。 那咋办呢？一看数据范围，这不赤裸裸地提示状压嘛！从下到上递推，记录一下每一个状态是由哪里转移过来的，然后输出试试？ 诶，$A$了！ AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct ddl&#123; char a[110]; int d,c;&#125;a[16];struct state&#123; int t,pre,v;//走到这一步的时间，总消耗 &#125;dp[1&lt;&lt;15];int seq[16];int f(int x)&#123; int cnt=0; while(x)x&gt;&gt;=1,cnt++; return cnt-1;&#125;int main()&#123; int i,j,n;scanf("%*d"); while(~scanf("%d",&amp;n))&#123; for(i=0;i&lt;n;i++)scanf("%s%d%d",a[i].a,&amp;a[i].d,&amp;a[i].c); for(i=1;i&lt;(1&lt;&lt;n);i++)dp[i].v=1e9; for(i=0;i&lt;(1&lt;&lt;n);i++)&#123; for(j=0;j&lt;n;j++)&#123; if((i&amp;(1&lt;&lt;j))==0)&#123; int tar=i+(1&lt;&lt;j),t=max(0,dp[i].t+a[j].c-a[j].d); if(dp[tar].v&gt;dp[i].v+t)&#123; dp[tar].v=dp[i].v+t; dp[tar].t=dp[i].t+a[j].c; dp[tar].pre=i; &#125; &#125; &#125; &#125; printf("%d\n",dp[(1&lt;&lt;n)-1].v); int p=n; i=(1&lt;&lt;n)-1; while(n)&#123; seq[--n]=f(i^dp[i].pre); i=dp[i].pre; &#125; for(i=0;i&lt;p;i++)printf("%s\n",a[seq[i]].a); &#125; return 0;&#125; 但似乎事情不太对。这个$pre$定下来定的毫无道理啊，不能一定满足字典序最小。 有了！从上向下递推，再$dfs$一遍找出最优解！ 也许只是数据比较水，所以$AC$了也不一定就是对的呢。 AC代码-REAL点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;struct ddl&#123; char a[110]; int d,c;&#125;a[16];struct state&#123; int t,v;//走到这一步的时间，总消耗 &#125;dp[1&lt;&lt;15];int seq[16],tmp[16],n,FLAG;void dfs(int p,int dep)&#123; int i; if(!p)&#123; int flag=0; if(!FLAG)&#123; FLAG=flag=1; &#125;else for(i=n-1;i&gt;=0;i--)&#123; int cmp=strcmp(a[tmp[i]].a,a[seq[i]].a); if(cmp&lt;0)&#123; flag=1; break; &#125;else if(cmp)break; &#125; if(flag)for(i=0;i&lt;n;i++)seq[i]=tmp[i]; return; &#125; for(i=0;i&lt;n;i++)&#123; if(p&amp;(1&lt;&lt;i))&#123; int tar=p-(1&lt;&lt;i),t=max(0,dp[tar].t+a[i].c-a[i].d); if(dp[p].v==dp[tar].v+t)&#123; tmp[dep]=i; dfs(tar,dep+1); &#125; &#125; &#125;&#125;int main()&#123; int i,j;scanf("%*d"); while(~scanf("%d",&amp;n))&#123; FLAG=0; for(i=0;i&lt;n;i++)scanf("%s%d%d",a[i].a,&amp;a[i].d,&amp;a[i].c); for(i=1;i&lt;(1&lt;&lt;n);i++)dp[i].v=1e9; for(i=0;i&lt;(1&lt;&lt;n);i++)&#123; for(j=0;j&lt;n;j++)&#123; if(i&amp;(1&lt;&lt;j))&#123; int tar=i-(1&lt;&lt;j),t=max(0,dp[tar].t+a[j].c-a[j].d); if(dp[i].v&gt;dp[tar].v+t)&#123; dp[i].v=dp[tar].v+t; dp[i].t=dp[tar].t+a[j].c; &#125; &#125; &#125; &#125; printf("%d\n",dp[(1&lt;&lt;n)-1].v); dfs((1&lt;&lt;n)-1,0); for(i=n-1;i&gt;=0;i--)printf("%s\n",a[seq[i]].a); &#125; return 0;&#125; E 题目描述给定一个整数序列，求其严格单调递增子序列（可为空）的最大和。 解题思路从前往后递推即可。 AC代码点击 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 1005int n,a[N];long long ans,dp[N];int main()&#123; int i,j; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; ans=0; for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)&#123; dp[i]=a[i]; for(j=0;j&lt;i;j++)if(a[j]&lt;a[i])dp[i]=max(dp[i],dp[j]+a[i]); ans=max(ans,dp[i]); &#125; printf("%lld\n",ans); &#125; return 0;&#125; F 题目描述给定一堆物品的总重，以及构成这堆物品的所有可能元素的价值和重量，判断存不存在一种方案使得给定元素构成这堆物品。如果存在，输出总价值的下确界。 解题思路完全背包，压缩到一维即可。 AC代码点击 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define N 520int t,n,e,f,v[N],w[N],dp[10010];int main()&#123; int i,j; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;e,&amp;f); f-=e; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d%d",&amp;v[i],&amp;w[i]); memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(i=0;i&lt;n;i++) for(j=w[i];j&lt;=f;j++) dp[j]=std::min(dp[j],dp[j-w[i]]+v[i]); if(dp[f]&lt;1e9)printf("The minimum amount of money in the piggy-bank is %d.\n",dp[f]); else printf("This is impossible.\n"); &#125; return 0;&#125; G 题目描述天上正在掉馅饼，给定掉馅饼的坐标（一维）和时间，初始位置给定，求能够接到的最大馅饼数。 解题思路两种递推思路，从前往后，从后往前。从后往前的比较好写，不用判特殊情况。滚动掉一维即可。 AC代码点击 1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 100010using namespace std;int n,x,t,a[12][N],dp[2][14];int main()&#123; int i,j; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; int mx=0; memset(dp,0,sizeof(dp)); memset(a,0,sizeof(a)); for(i=0;i&lt;n;i++)scanf("%d%d",&amp;x,&amp;t),a[x+1][t]++,mx=max(mx,t); for(i=mx;i&gt;=0;i--) for(j=1;j&lt;12;j++) dp[i&amp;1][j]=max(max(dp[(i+1)&amp;1][j-1],dp[(i+1)&amp;1][j]),dp[(i+1)&amp;1][j+1])+a[j][i]; printf("%d\n",dp[0][6]); &#125; return 0;&#125; H 题目描述有一列人，花费$a[i]$时间可以消除第$i$个人，花费$b[i]$时间可以消除第$i$和第$i+1$个人。求最短用时，求最终时刻的$HH:MM:SS$ $am|pm$表示。 解题思路直接暴力递推即可。 AC代码点击 1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 2010using namespace std;int n,k,a[N],b[N],dp[N];int main()&#123; int i; scanf("%*d"); while(~scanf("%d",&amp;k))&#123; for(i=1;i&lt;=k;i++)scanf("%d",&amp;a[i]); for(i=2;i&lt;=k;i++)scanf("%d",&amp;b[i]); dp[0]=0;dp[1]=a[1]; for(i=2;i&lt;=k;i++)dp[i]=min(dp[i-2]+b[i],dp[i-1]+a[i]); int h=8,m=0,s=dp[k]; if(s&gt;=60)m+=s/60,s%=60; if(m&gt;=60)h+=m/60,m%=60; printf("%02d:%02d:%02d %s\n",(h-1)%12+1,m,s,h&gt;12?"pm":"am"); &#125; return 0;&#125; I 题目描述求一个序列的非严格下降子列的最小个数。 解题思路也就是求严格上升子列长度。$O(log n)$解决。 AC代码点击 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define N 30010int a,dp[N],len;int main()&#123; int i,n; while(~scanf("%d",&amp;n))&#123; scanf("%d",&amp;dp[0]); len=1; for(i=1;i&lt;n;i++)&#123; scanf("%d",&amp;a); if(a&gt;dp[len-1])dp[len++]=a; else&#123; int p=upper_bound(dp,dp+len,a)-dp; if(dp[p]&gt;a)dp[p]=a; &#125; &#125; printf("%d\n",len); memset(dp,0,sizeof(int)*n); &#125; return 0;&#125; J 题目描述给一些老鼠的速度和质量，求最长的子序列保证老鼠的质量严格递增而速度严格递减，输出方案。 解题思路对质量排序后递推并记录从哪里递推得到的，最后递归输出。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 1010using namespace std;struct mouse&#123; int a,b,i; bool operator&lt;(const mouse&amp;p)const&#123;return a&lt;p.a;&#125;&#125;a[N];int len[N],last[N],mx,temp;void print(int x)&#123; if(!x)return; print(last[x]); printf("%d\n",x);&#125;int main()&#123; int j,i=0,k; while(~scanf("%d%d",&amp;a[i].a,&amp;a[i].b))&#123; a[i].i=i+1; i++; &#125; sort(a,a+i); for(j=0;j&lt;i;j++)&#123; len[j]=1; for(k=0;k&lt;j;k++)&#123; if(a[k].a&lt;a[j].a&amp;&amp;a[k].b&gt;a[j].b&amp;&amp;len[k]+1&gt;len[j])&#123; len[j]=len[k]+1; last[a[j].i]=a[k].i; &#125; &#125; if(len[j]&gt;mx)&#123; mx=len[j]; temp=a[j].i; &#125; &#125; printf("%d\n",mx); print(temp); return 0;&#125; K 题目描述给一些人的两种特性$d$和$p$，选择给定数量个人，使得这些人$d$总和$D$与$p$总和$P$之差的绝对值$|D-P|$最小的情况下，$D+P$最大，输出$|D-P|$，$D+P$，并按上升序输出选择人的序号。 解题思路一个个人选择，$dp[i][j]$表示选了$i$个人，其$D-P=j$（没有绝对值）的情况下，$D+P$的最大值。记录下选了$i$个人、每个$j$对应的最优解对应的人的编号$path[i][j]$，每次枚举每一个人，如果在这个条件下没有加入则可以加入这个人。 由于不能加绝对值，需要加一个$offset$调整。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define N 210#define M 22using namespace std;int n,m,d[N],p[N],v[N],s[N];int f[M][M*M*2],path[M][M*M*2];int sel(int num,int val,int now)&#123; while(num&amp;&amp;path[num][val]!=now)val-=v[path[num][val]],num--; return num;&#125;int seq[M];int main()&#123; int i,j,k,cas=0; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;n|m)&#123; cas++; memset(f,-1,sizeof(f)); int offset=m*M; f[0][offset]=0; for(i=1;i&lt;=n;i++) scanf("%d%d",&amp;d[i],&amp;p[i]),v[i]=d[i]-p[i],s[i]=d[i]+p[i]; for(i=1;i&lt;=m;i++)&#123; for(j=0;j&lt;=offset*2;j++)&#123; if(f[i-1][j]&lt;0)continue; for(k=1;k&lt;=n;k++)&#123; if(f[i-1][j]+s[k]&gt;f[i][j+v[k]]&amp;&amp;!sel(i-1,j,k))&#123; path[i][j+v[k]]=k; f[i][j+v[k]]=f[i-1][j]+s[k]; &#125; &#125; &#125; &#125; for(i=0;i&lt;=offset;i++)if(f[m][offset+i]&gt;=0||f[m][offset-i]&gt;=0)break; int ans=f[m][offset+i]&gt;f[m][offset-i]?offset+i:offset-i; printf("Jury #%d\nBest jury has value %d for prosecution and value %d for defence:\n",cas,(ans-offset+f[m][ans])/2,(-ans+offset+f[m][ans])/2); for(i=m;i;i--)seq[i]=path[i][ans],ans-=v[path[i][ans]]; sort(seq+1,seq+m+1); for(i=1;i&lt;=m;i++)printf(" %d",seq[i]); printf("\n\n"); &#125; return 0;&#125; L 题目描述求最长公共子序列。 解题思路裸题，非常裸。 AC代码点击 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define N 1010char a[N],b[N];int dp[N][N];int main()&#123; int i,j; while(~scanf("%s%s",a+1,b+1))&#123; int l=strlen(a+1),L=strlen(b+1); for(i=1;i&lt;=l;i++)&#123; for(j=1;i&lt;=L;j++)&#123; if(a[i]==b[j])dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); &#125; &#125; printf("%d\n",dp[l][L]); memset(dp,0,sizeof(dp)); &#125; return 0;&#125; M 题目描述有一堆高度不同、起终不同的板子，一个人，这个人要到地上，求最短时间。 这人很神奇，下落、平移的速度相同。但下落高度不能超过给定值，否则会摔死。数据保证一定有解。 解题思路纯搜索$T$掉了，记忆化搜索就可以了。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1010using namespace std;struct ck&#123; int x[2],h; bool operator &lt;(const ck&amp;a)const&#123;return h&gt;a.h;&#125;&#125;a[N];int t,n,x,y,mx;int dp[2][1010];int dfs(int now,int dir)&#123; if(dp[dir][now])return dp[dir][now]; int i,x=a[now].x[dir]; for(i=now+1;i&lt;=n+1&amp;&amp;a[now].h-a[i].h&lt;=mx;i++)&#123; if(i==n+1)return dp[dir][now]=a[now].h; if(x&gt;=a[i].x[0]&amp;&amp;x&lt;=a[i].x[1])return dp[dir][now]+=min(x-a[i].x[0]+dfs(i,0),a[i].x[1]-x+dfs(i,1))+a[now].h-a[i].h; &#125; return dp[dir][now]=1e8;&#125;int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d%d",&amp;n,&amp;x,&amp;y,&amp;mx); memset(dp,0,sizeof(dp)); for(i=1;i&lt;=n;i++)scanf("%d%d%d",&amp;a[i].x[0],&amp;a[i].x[1],&amp;a[i].h); a[0].x[0]=a[0].x[1]=x;a[0].h=y; sort(a+1,a+n+1); printf("%d\n",dfs(0,1)); &#125; return 0;&#125; N 题目描述求最长严格上升子序列。 解题思路又是一道裸题。 AC代码点击 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int n,a,len,dp[1010];int main()&#123; int i; scanf("%d",&amp;n); scanf("%d",&amp;a);dp[len++]=a; for(i=1;i&lt;n;i++)&#123; scanf("%d",&amp;a); if(a&gt;dp[len-1])dp[len++]=a; else&#123; int p=upper_bound(dp,dp+len,a)-dp; dp[p]=min(dp[p],a); &#125; &#125; printf("%d",len); return 0;&#125; O 题目描述给定一些食物，其价格与时间成正比，给定系数。每次必须且只能从头或尾取，求最大价格和。 解题思路区间$DP$，从最后一个取出递推到开头，$dp[i][j]$表示$i,j$之间所有元素最后取出的最大价值和。 AC代码点击 1234567891011121314#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define N 2019int a[N],n,dp[N][N];int main()&#123; int i,j; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]),dp[i][i]=a[i]*n; for(i=1;i&lt;n;i++) for(j=0;j+i&lt;n;j++) dp[j][j+i]=std::max(dp[j][j+i-1]+a[j+i]*(n-i),dp[j+1][j+i]+a[j]*(n-i)); printf("%d",dp[0][n-1]); return 0;&#125; P 题目描述一个老鼠在一个由奶酪组成的格子图中走动，每次可以上下走动$1$到$k$个格子，并吃掉这个格子里的奶酪。要求每次吃的奶酪都比上次大，终点任选，求可以吃到的奶酪的最大和。 解题思路记忆化搜索，每次可以向四个方向走一定距离。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 110int a[N][N],n,k,dp[N][N];int dx[4]=&#123;-1,1,0,0&#125;;int dy[4]=&#123;0,0,-1,1&#125;;int dfs(int x,int y)&#123; if(~dp[x][y])return dp[x][y]; dp[x][y]=a[x][y]; int i,j,p,q,mx=0; for(i=0;i&lt;4;i++)&#123; for(j=1;j&lt;=k;j++)&#123; p=x+dx[i]*j; q=y+dy[i]*j; if(p&gt;=0&amp;&amp;q&gt;=0&amp;&amp;p&lt;n&amp;&amp;q&lt;n&amp;&amp;a[p][q]&gt;a[x][y])&#123; dfs(p,q); if(dp[p][q]&gt;mx)mx=dp[p][q]; &#125; &#125; &#125; return dp[x][y]+=mx;&#125;int main()&#123; int i,j; while(~scanf("%d%d",&amp;n,&amp;k)&amp;&amp;~n&amp;&amp;~k)&#123; memset(dp,-1,sizeof(dp)); for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;a[i][j]); printf("%d\n",dfs(0,0)); &#125; return 0;&#125; Q 题目描述求最大关于反对角线对称的子矩阵。 解题思路想法是从右上角枚举到左下角，每次扩展一定范围并判断是否合理（能否对称），但程序很慢，跑了$2000ms$还多。 看到有人跑了不到$200ms$，不知道是什么方法。 AC代码点击 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#define N 1010int n,dp[N][N];char a[N][N];int main()&#123; int i,j,k; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; int ans=0; for(i=0;i&lt;n;i++)scanf("%s",a[i]); for(i=0;i&lt;n;i++)&#123; for(j=n-1;j&gt;=0;j--)&#123; dp[i][j]=1; if(i&amp;&amp;j&lt;n-1)&#123; for(k=1;k&lt;=dp[i-1][j+1];k++)&#123; if(a[i-k][j]==a[i][j+k])dp[i][j]++; else break; &#125; &#125; if(ans&lt;dp[i][j])ans=dp[i][j]; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; R 题目描述给一段挤奶时间的开始和结束点，每次挤奶的产量，求最大总产量。两次挤奶需要间隔一定时间。 解题思路对时间段关于结束时间递减排序，从前向后递推即可。 AC代码点击 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 1010using namespace std;struct interval&#123; int b,e,v; bool operator&lt;(const interval&amp;a)const&#123;return e&lt;a.e;&#125;&#125;a[N];int dp[N];int n,m,r;int main()&#123; int i,j,ans=0; scanf("%d%d%d",&amp;n,&amp;m,&amp;r); for(i=0;i&lt;m;i++)scanf("%d%d%d",&amp;a[i].b,&amp;a[i].e,&amp;a[i].v); sort(a,a+m); for(i=0;i&lt;m;i++)&#123; dp[i]=0; for(j=0;j&lt;i;j++)if(a[j].e+r&lt;=a[i].b)dp[i]=max(dp[i],dp[j]); dp[i]+=a[i].v; ans=max(ans,dp[i]); &#125; printf("%d",ans); return 0;&#125; S 题目描述给定一段序列，增加或减少其中的某些元素的值，使得最终序列非严格单调递增或递减。求最终序列和原序列每一个元素差值绝对值的和的最小值。$1\leq n\leq2000$，序列中的数保证$0\leq a[i]\leq 10^9$。 解题思路数很大，需要离散化，$dp[i][j]$表示枚举到第$i$个数且让它变成第$j$小/大的数$b[j]$时的贡献，因为保证序列单调，有$dp[i][j]=min(dp[i-1][k])(k∈[0,j])+|a[i]-b[j]|$。其中$min(dp[i-1][k])(k∈[0,j])$可以实时更新。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 2010using namespace std;int n;int a[N],b[N],dp[N][N],ans=1e9;int f(int x)&#123;return x&gt;0?x:-x;&#125;int cmp(int x,int y)&#123;return x&gt;y;&#125;void solve()&#123; int i,j; memset(dp,0x3f,sizeof(dp)); for(i=0;i&lt;n;i++)dp[0][i]=f(a[0]-b[i]); for(i=1;i&lt;n;i++)&#123; int mn=1e9; for(j=0;j&lt;n;j++)&#123; mn=min(mn,dp[i-1][j]); dp[i][j]=mn+f(a[i]-b[j]); &#125; &#125; for(i=0;i&lt;n;i++)ans=min(ans,dp[n-1][i]);&#125;int main()&#123; int i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]),b[i]=a[i]; sort(b,b+n);solve(); sort(b,b+n,cmp);solve(); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2019%2F04%2F05%2Frandomtitle%2F</url>
    <content type="text"><![CDATA[随笔一篇，聊以自慰。 最近一段时间，写代码总是没有脑子，很绝望，也很困惑。于是想不出题怎么写的一个人随便来博客发了一条牢骚。 还记得刚上大学的时候，对于程序设计的那一股激情。那时候的自己只有一个动力：一雪高一信息竞赛训练什么题都不会而被劝退的前耻，适应大学生活。那时的自己，对大学充满未知和兴奋，做好了一切努力地准备。 可是现在呢？ 转眼看看现在的自己，什么地方都差别人很远。要说课程学习，因为上学期考的还算可以，下学期就很浮躁起来，学习也只限制于做完作业，没有任何的延伸拓展，也没有任何的总结思考，所有的时间都用在了别的事情上。要说用在了什么事情上，那大概是$ACM$和感情上。要说$ACM$，前些日子的决赛考的一塌糊涂，最近写题也写不进去，读书也倍感时间不够读不完，上学期的算法半数还给了各种$OJ$。要说感情，这可是一件细腻的活，一不小心就有可能会忘记一些很重要的事情，在学习生活中也根本无法静下心来干自己的事。纠结于当下的所有事情，结果只能是一件都做不好。 不可以继续这样颓下去了，这不是我想要的生活。 很烦躁，不知道何从下手这一团乱麻。 有了以前的打击，洛谷这一重要的刷题来源消失，自此本就模糊的目标更加不明确了。 身边的几乎所有人都跟我说，要打进$WF$，为北航争光。我也想啊，可是我真的没有这个能力。我想退出$ACM​$了，因为智商实在不够。但又不甘心，不甘心一个目标的失去，不甘心辜负身边人的期望，不甘心自己为之付出的一切。东野奎吾先生《白夜行》中的一段文字，深以为然： 人生也一样，有白天和黑夜，只是不会像真正的太阳那样，有定时的日出和日落。有些人一辈子都活在太阳的照耀下，也有些人不得不一直活在漆黑的深夜里。人害怕的，就是本来一直存在的太阳落下不再升起，也就是非常害怕原本照在身上的光芒消失。 写到这里，我想自己已经冷静许多了。 因为害怕失去，因为只会隐忍，所以才会造成今日的焦虑与恐惧。 而其实这一些东西，无论是学业还是竞赛，无论是感情还是生活，顺其自然、放平心态才是解决问题的不二法门。害怕失去是人之本性，而解决焦虑的根源便是顺其自然，如果自己不想放弃，那就不要放弃。 我想，自己大概已经拥有许多了。北航是一所很好的学校，而大学生活从不只有学习，更有许多自己想干的、爱干的课余之事。能够遇到让自己又爱又恨的算法竞赛，这或许是一种对自己意志的磨练；而能够遇到和自己志同道合互相欣赏的同学，获得升华的友情，我想这本身就是一种十分幸福的事情了。 至于算法竞赛，有什么可以怕的呢？无论实力在不在，自己学的高兴难道不就是最重要的吗？ 闻道有先后，术业有专攻。 如是而已。 我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳明那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。你明白吗？我从来就没有太阳，所以不怕失去。 我从来就没有太阳，所以不怕失去。]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝书第一章部分经典例题题解]]></title>
    <url>%2F2019%2F04%2F05%2Flrj-blue-1%2F</url>
    <content type="text"><![CDATA[最近在读刘汝佳先生的《算法竞赛入门经典》，收获颇丰，特此记录一些自己以前未曾涉猎算法的经典例题题解。 UVA-10755 Garbage Heap（三维前缀和）题目链接Garbage Heap 解题思路$UVA$上一定要用$\%lld$！！！只有$CF$才需要$I64d$！！！空格换行要求也很严格！ 大致思路是，把三维用前缀和表示，每次枚举两维，第三维再用前缀和的思想用类似求最大子序列的求法$O(n)$解决，总复杂度$O(n^5)$。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define For(i,a,b) for(i=a;i&lt;=b;i++)#define FFF For(i,1,a)For(j,1,b)For(k,1,c)typedef long long ll;ll m[25][25][25];int a,b,c,t;ll sumf(int x1,int x2,int y1,int y2,int z1,int z2)&#123; ll num=m[x2][y2][z2]; num-=m[x1-1][y2][z2]; num-=m[x2][y1-1][z2]; num-=m[x2][y2][z1-1]; num+=m[x1-1][y1-1][z2]; num+=m[x1-1][y2][z1-1]; num+=m[x2][y1-1][z1-1]; num-=m[x1-1][y1-1][z1-1]; return num;&#125;int main()&#123; int i,j,k,l,p; ll ans,minpre,sum; scanf("%d",&amp;t); while(t--)&#123; ans=-1e18; memset(m,0,sizeof(m)); scanf("%d%d%d",&amp;a,&amp;b,&amp;c); FFF scanf("%lld",&amp;m[i][j][k]); FFF m[i][j][k]+=m[i-1][j][k]; FFF m[i][j][k]+=m[i][j-1][k]; FFF m[i][j][k]+=m[i][j][k-1]; For(i,1,a)For(j,i,a)For(k,1,b)For(l,k,b)&#123; minpre=0; For(p,1,c)&#123; sum=sumf(i,j,k,l,1,p); if(sum-minpre&gt;ans)ans=sum-minpre; if(sum&lt;minpre)minpre=sum; &#125; &#125; printf("%lld\n",ans); if(t)putchar('\n'); &#125; return 0;&#125; UVA-1326 Jurassic Remains（中途相遇法）题目链接Jurassic Remains 解题思路由于直接状态压缩的消耗太大，分成两部分状态压缩解决，通过保存第一部分的状态，枚举第二部分的状态时$O(lgn)$寻找（$STL$的$map$），时间复杂度从$O(2^n)$降到$O(2^{\frac n2}logn)​$。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;int n,state[50];char s[100010];map&lt;int,int&gt;m;int count(int x)&#123; int p=0; while(x)p+=(x&amp;1),x&gt;&gt;=1; return p;&#125;int main()&#123; int i,j; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; m.clear(); for(i=0;i&lt;n;i++)&#123; scanf("%s",s); state[i]=0; for(j=0;s[j];j++)state[i]^=(1&lt;&lt;(s[j]-'A')); &#125; int n1=n/2,n2=n-n1,ans=0; for(i=0;i&lt;(1&lt;&lt;n1);i++)&#123; int x=0,cnt=0; for(j=0;j&lt;n1;j++)if(i&amp;(1&lt;&lt;j))x^=state[j],cnt++; if(!m.count(x)||cnt&gt;count(m[x]))m[x]=i; &#125; for(i=0;i&lt;(1&lt;&lt;n2);i++)&#123; int x=0; for(j=0;j&lt;n2;j++)if(i&amp;(1&lt;&lt;j))x^=state[j+n1]; if(m.count(x)&amp;&amp;count(m[x])+count(i)&gt;count(ans)) ans=(i&lt;&lt;n1)^m[x]; &#125; printf("%d\n",count(ans)); int flag=0; for(i=0;i&lt;n;i++)if(ans&amp;(1&lt;&lt;i))&#123; if(!flag)printf("%d",i+1); else printf(" %d",i+1); flag=1; &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>LRJ</category>
        <category>Chapter 1</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 547 (Div.3)]]></title>
    <url>%2F2019%2F04%2F02%2Fcf547div3%2F</url>
    <content type="text"><![CDATA[第一次完整的打下来一场比赛。 Solved A B C D E F G 7/7 O O O O O Ø Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接CF Round #547 div.3 F 题目大意给定一段长度$\leq1500$的序列，求一组互不相交的子序列，使得每个子序列内数字之和相等，问这一组子序列最多包含多少个子序列。 解题思路先储存所有子序列和的可能性，再从左往右枚举右端点，枚举左端点，贪心地添加区间信息。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int n;int a[1600],s[1600];vector&lt;int&gt;G;struct Ans&#123; int num,r;//r:上一组区间的右端点 vector&lt;pair&lt;int,int&gt; &gt;vec;&#125;ans[1125080];int f(int x)&#123;return lower_bound(G.begin(),G.end(),x)-G.begin();&#125;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),s[i]=s[i-1]+a[i]; for(i=1;i&lt;=n;i++)for(j=i;j&lt;=n;j++)G.push_back(s[j]-s[i-1]); sort(G.begin(),G.end()); G.erase(unique(G.begin(),G.end()),G.end()); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=i;j++)&#123; int su=s[i]-s[j-1]; int p=f(su); if(ans[p].r&lt;j)&#123; ans[p].r=i; ans[p].num++; ans[p].vec.push_back(&#123;j,i&#125;); &#125; &#125; &#125; int mx=-1e9,temp=0; for(i=0;i&lt;G.size();i++) if(ans[i].num&gt;mx)mx=ans[i].num,temp=i; printf("%d\n",mx); for(i=0;i&lt;ans[temp].vec.size();i++) printf("%d %d\n",ans[temp].vec[i].first,ans[temp].vec[i].second); return 0;&#125; G 题目大意给一棵树，给边染色，对任意一个节点，如果连着多个同样颜色的边就称之为“坏点”，问“坏点”不超过$k$个需要染色的色数最少是多少，并输出一种染色方案。 解题思路题意理解了半天没搞懂，导致最后没有AK 对于“非坏点”，所有连接它的边都是不同颜色的，所以色数是第$k$大度数的点的度数。然后xjb​染就行了。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define N 200010struct Edge&#123; int end,near;&#125;e[N&lt;&lt;1];int head[N],cnt=1;void add(int a,int b)&#123; e[++cnt].end=b;e[cnt].near=head[a];head[a]=cnt;&#125;int deg[N],mx,col[N&lt;&lt;1];void dfs(int c,int p,int f)&#123; int i,q; for(i=head[p];i;i=e[i].near)&#123; q=e[i].end; if(q==f)continue; col[i&gt;&gt;1]=(++c)%mx; dfs(c,q,p); &#125;&#125;int main()&#123; int i,n,k,x,y; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;n;i++)scanf("%d%d",&amp;x,&amp;y),add(x,y),add(y,x),deg[x]++,deg[y]++; sort(deg+1,deg+n+1); printf("%d\n",mx=deg[n-k]); dfs(1,1,0); for(i=1;i&lt;n;i++)printf("%d ",col[i]+1); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十三届北航程序设计竞赛预赛题解]]></title>
    <url>%2F2019%2F03%2F26%2F13thbcpc-pretest%2F</url>
    <content type="text"><![CDATA[大概咕掉了，以后看摸着再回来做吧。 Solved A B C D E F G H I J K L M 6/13 Ø Ø Ø Ø . . Ø Ø . . . . . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述我们将五角星关于它的中心旋转$alpha$角度得到一个新五角星，再与原五角星重叠，得到一个新的平面图形，请问在新的平面图形中二维平面被分成了多少个区域？ 解题思路观察易得，情况就两种。 AC代码点击 12345678910 #include&lt;stdio.h&gt;int main()&#123; int n,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); printf("%d\n",n%72?32:7); &#125; return 0;&#125; B 题目描述给一个$01$串，求一个最短非空$01$串，使得其不是给定串的子串，求最短长度。 解题思路答案不超过$23$（$2^{23}&gt;4.5e6$），故从上界向下枚举即可。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N (1&lt;&lt;23)+10char a[N];int vis[N];int main()&#123; int i,j,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",a); int ans,l=strlen(a),k=0,now=0; while((1&lt;&lt;k)&lt;=l)k++; ans=k; for(i=0;i&lt;l;i++)&#123; if(i&lt;k)now=(now&lt;&lt;1)+a[i]-'0'; else now=((now&amp;((1&lt;&lt;k-1)-1))&lt;&lt;1)+a[i]-'0'; if(i&gt;=k-1)vis[now]=1; &#125; for(i=k-1;i;i--)&#123; int flag=0; for(j=0;j&lt;(1&lt;&lt;i);j++) if(vis[j&lt;&lt;1]||vis[j&lt;&lt;1|1]||vis[j+(1&lt;&lt;i)]||vis[j])vis[j]=1; else flag=1; if(flag)ans=i; else break; &#125; printf("%d\n",ans); memset(vis,0,sizeof(vis)); &#125; return 0;&#125; C 题目描述给定一个等腰梯形，每一行均匀分布一些点，问从这个等腰梯形中的点里面选三个构成正三角形的个数。 解题思路极其麻烦的一道题，做了整整三个小时。（还不是因为菜） 把三角形分为头朝上、头朝下两部分解决。假设头朝下的、底边在宽度为$i$的一层中的正三角形个数为$a_i$，头朝上的、顶点在宽度为$i$的一层中的正三角形个数为$b_i$，那么答案便是$\sum_{i=n}^{m}{a_i+b_i}$。 先求$a_i$。 底边在宽度为$i$的一层中的正三角形，其边长的取值范围为$l∈[1,i-n]$，记$h_i=i-n$，$H=m-n$，于是相当于考虑在$i+1$个点中选择距离$d\leq h_i$的种数，也就是$a_i=h_i(i+1)-\frac{h_i(h_i+1)}2$。 解释一下上面这个式子。在$i+1$个点中任选一个点$p$，在不考虑超出范围的情况下，距离$d\leq h_i$的点有$p+1,p+2,…,p+h_i$，共有$h_i$个。但显然这样多算了选了并不能选的点的情况。这种右端的点超出范围情况共有$(1+2+3+…+h_i)$种情况，即$\frac{h_i(h_i+1)}2$。 于是 $\sum_{i=n}^{m} a_i$ $=\sum_{i=n}^{m}{(i+1)h_i-\frac{h_i(h_i+1)}2}$ $=\sum_{i=0}^{H}{\frac{(i+2n+1)i}2}$ $=\sum_{i=0}^{H}{\frac{i^2}{2}+\frac{(2n+1)i}2}$ $=\frac{H(H+1)(2H+1)}{12}+\frac{(2n+1)(H+1)H}{4}$ $=\frac{n(H+1)H}2+\frac{H(H+1)(H+2)}6$ 再来计算$b_i$。 对于顶点在宽度为$i$的一层中的三角形，其边长为$l=min(i-n,\left\lfloor\frac i2\right\rfloor)$。枚举底边宽度$j$，则正三角形边长为$i-j$，个数为$2j-i+1$。 故$b_i=\sum_{j=n}^{i-1}2j-i+1,k\leq2n;\sum_{j=\left\lfloor\frac{k+1}2\right\rfloor}^{i-1}2j-i+1,k&gt;2n$。 分段求和，有 $1.m\leq2n$ $\sum_{i=n}^{m}b_i$ $=\sum_{i=n}^{m}\sum_{j=n}^{i-1}2j-i+1$ $=\sum_{i=n}^{m}(1-i)(i-1-n+1)+2\frac{(n+i-1)(i-n)}{2}$ $=\sum_{i=n}^{m}n(i-n)$ $=\frac{n(1+H)H}2$ $2.m&gt;2n$ $\sum_{i=n}^{m}b_i$ $=\sum_{i=n}^{2n}b_i+\sum_{i=2n+1}^{m}b_i$ $=\frac{n(1+2n-n)(2n-n)}2+\sum_{i=2n+1}^{m}b_i$ $=\frac{n^2(1+n)}2+\sum_{i=2n+1}^{m}\sum_{j=\left\lfloor\frac{k+1}2\right\rfloor}^{i-1}2j-i+1$ $=\frac{n^2(1+n)}2+\sum_{i=2n+1}^{m}(1-i)(i-\left\lfloor\frac{i+1}2\right\rfloor)+(\left\lfloor\frac{i+1}2\right\rfloor+i-1)(i-\left\lfloor\frac{i+1}2\right\rfloor)$ $=\frac{n^2(1+n)}2+\sum_{i=2n+1}^{m}\left\lfloor\frac{i+1}2\right\rfloor\left\lceil\frac{i+1}2\right\rceil$ $=\frac{n^2(1+n)}2+\sum_{i=2n+1}^{m}\frac{i^2}4-\frac14(当i为奇数)$ $=\frac{n^2(1+n)}2+\frac14(\frac{m(m+1)(2m+1)}6-\frac{2n(2n+1)(4n+1)}6)-\frac14(\left\lfloor\frac m2\right\rfloor-n)$ 然后加起来就行了。 AC代码点击 1234567891011121314151617#include&lt;stdio.h&gt;long long n,m,w=1e9+7;long long ans; int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; ans=0; scanf("%lld%lld",&amp;m,&amp;n); long long H=m-n; ans=(n*H*(H+1)/2+(H+2)*(H+1)*H/6)%w; if(m&lt;=2*n)ans=(ans+(n*H*(H+1)/2)%w)%w; else ans=(ans+n*n*(n+1)/2+(((m*(m+1)*(2*m+1)-(2*n)*(2*n+1)*(4*n+1))/6+n-m/2)/4)%w)%w; printf("%lld\n",ans%w); &#125; return 0;&#125; D 题目描述从几堆牌中随机等概率取牌，一堆中取一张牌则所有的牌被取走。除了第一堆，每一堆牌的个数都是从一个闭区间中等概率选取的。当第一堆被取走时，游戏结束。问游戏结束时，取走的牌数期望值。 解题思路设$P(i,j)$表示第$i$堆牌有$j$个，这堆牌其中某一张牌在第一堆牌某一张牌之前被取走的概率。于是有$P(i,j)=\frac{j}{a_1+j}$。 $ans=\sum_{i=2}^{n}\frac1{up[i]-low[i]+1}\sum_{j=low[i]}^{up[i]}\frac{j^2}{a_1+j}$。 每组数据预处理出后一个求和号里的东西，逆元记忆化搜索即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233 #include&lt;stdio.h&gt;#define N 100010typedef long long ll;int u[N],l[N],w=998244353;ll a[N*10];ll pw(ll a,ll p)&#123; ll x=1; for(;p;p&gt;&gt;=1,a=a*a%w)if(p&amp;1)x=x*a%w; return x;&#125;int inv[N*20];ll invf(int x)&#123; if(inv[x])return inv[x]; return inv[x]=pw(x,w-2);&#125;int main()&#123; int i,t,n,a1; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;a1); int max=0; ll ans=a1; for(i=1;i&lt;n;i++)&#123; scanf("%d%d",&amp;l[i],&amp;u[i]); if(u[i]&gt;max)max=u[i]; &#125; for(i=1;i&lt;=max;i++)a[i]=1LL*i*i%w*invf(a1+i)%w; for(i=1;i&lt;=max;i++)a[i]=(a[i]+a[i-1])%w; for(i=1;i&lt;n;i++)ans=(ans+(invf(u[i]-l[i]+1)*(a[u[i]]-a[l[i]-1]+w)%w)%w)%w; printf("%lld\n",(ans+w)%w); &#125; return 0;&#125; E 题目描述解题思路AC代码点击 1 F 题目描述解题思路AC代码点击 1 G 题目描述给定一个一元二次方程，如果有无限小数实数解则保留到$1e6$位，如果有有限小数实数解则保留所有小数，如果无解则输出无解。 按照以下规则输出：输出$0-9$在解中出现的频率百分比，保留到整数。 解题思路先判断有解无解、有无有理解，如果解无理，则全部输出$10$。 如果有有理解，再分为有限小数、无限小数讨论。如果无限小数且$1e6+1$位$\geq5$，则需要找到循环节中对应的位置进行进位、增加等处理；否则直接处理循环节输出。 我没有AC，但还是要发题解。 没有AC的代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#define M 1000000int num[11],cir[2010],cnt,infinite;//出现次数，余数是否出现，总数，不循环 int len,fir;//循环节长度及初始出现位置 int cy[2010];//循环节 int tail;//第1e6+1位在循环节中的位置 void init()&#123; memset(num,0,sizeof(num)); memset(cir,0,sizeof(cir)); memset(cy,0,sizeof(cy)); fir=tail=infinite=cnt=len=0;&#125;void solveinteger(int x)&#123; if(!x)num[0]++,cnt++; while(x)num[x%10]++,x/=10,cnt++;&#125;void find(int k,int d)&#123; int temp[11]=&#123;0&#125;,tot=0; int i,j,r=k; cir[r]=1; for(i=1;i&lt;=M;i++)&#123; if(!r)break; if(!infinite&amp;&amp;cir[r]&amp;&amp;i!=1)&#123; infinite=1; cy[++len]=r*10/d; for(j=r*10%d;j!=r;j=j*10%d)cy[++len]=j*10/d; fir=i-len; int number=(M-i)/len;//后面循环节个数 for(j=r*10%d;;j=j*10%d)&#123; temp[j*10/d]+=number; if(j==r)break; &#125; i+=number*len; tot+=number*len; tail=(M-i+2)%len;//M+1 &#125; temp[r*10/d]++; tot++; cir[r]=i; r=r*10%d; &#125; if(!infinite||cy[tail]&lt;5)&#123; for(i=0;i&lt;10;i++)num[i]+=temp[i]; cnt+=tot; &#125;else&#123; if(!tail)tail=len; int mx; for(i=1;i&lt;=len;i++)&#123; mx=(tail-1-i+len)%len+1; if(cy[mx]!=9)break; &#125; r=k; cir[r]=1; int tmp=i,flag=0; memset(cir,0,sizeof(cir)); for(i=1;i&lt;=M-tmp;i++)&#123; if(!r)break; if(!flag&amp;&amp;cir[r]&amp;&amp;i!=1)&#123; flag=1; int number=(M-i-tmp)/len;//后面循环节个数 for(j=r*10%d;;j=j*10%d)&#123; num[j*10/d]+=number; if(j==r)break; &#125; i+=number*len; &#125; num[r*10/d]++; cir[r]=i; r=r*10%d; &#125; num[(r*10/d+1)%10]++; for(i=M-tmp+2;i&lt;=M;i++)num[0]++; cnt+=M; &#125;&#125;void printresult()&#123; int i; for(i=0;i&lt;10;i++)&#123; double tp=num[i]*100.0/cnt; printf("%d ",tp-(int)tp&lt;0.5-1e-10?(int)tp:(int)tp+1); &#125; printf("\n");&#125;void print(int k,int d)&#123; if(k&lt;0)k=-k; if(d&lt;0)d=-d; init(); solveinteger(k/d); find(k%d,d); printresult();&#125; int main()&#123; int a,b,c,T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); int delta=b*b-4*a*c; if(delta&lt;0)printf("NO JIE\n"); else if(round(sqrt(delta))*round(sqrt(delta))==delta)&#123; if(a&lt;0)print((-b+round(sqrt(delta))),2*a),print((-b-round(sqrt(delta))),2*a); else print((-b-round(sqrt(delta))),2*a),print((-b+round(sqrt(delta))),2*a); &#125;else printf("10 10 10 10 10 10 10 10 10 10\n10 10 10 10 10 10 10 10 10 10\n"); &#125; return 0;&#125; H 题目描述给定一个$300*300$以内的数字矩阵，其中$’x’$表示这个点不能被选择，再给出$\leq 1000$组询问，每组询问要求输出在包含给定$(x,y)$的基础上的、不选$’x’$点的元素之和最大的子矩阵中元素之和。 解题思路把子矩阵包含$(x,y)$这个条件转化成：在行数范围在$[up,down]$区间内、必选$k$这一列时，最大的子矩阵大小，并在$up\leq x\leq down$条件下取最大值。 $’x’$可设置成一个比较小的数，但不能太小，$-1e7$比较好，而$-1e8$就不太行了，否则可能会爆掉。 通过问题转化，可以$O(n^2m+q)$解决问题。 剧毒，卡常数（还不是因为我太菜了） TLE代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#define N 305int inf=-1e7;int read()&#123; char c=getchar();int f=1,num=0; while(c&gt;'9'||c&lt;'0')&#123; if(c=='-')f=-1; if(c=='x')return inf; c=getchar(); &#125; while(c&gt;='0'&amp;&amp;c&lt;='9')num=(num&lt;&lt;3)+(num&lt;&lt;1)+c-'0',c=getchar(); return num*f;&#125;#define max(a,b) (a&gt;b?(a):(b))int n,m,q,mt[N][N],sum[N][N];int pre[N],suc[N],s[N],mx[N][N][N];int p[N][N][N],f[N][N];void init()&#123; int i,j,k; for(i=1;i&lt;=n;i++)&#123; for(j=i;j&lt;=n;j++)&#123; pre[0]=suc[m+1]=0; for(k=1;k&lt;=m;k++)s[k]=sum[j][k]-sum[j][k-1]-(sum[i-1][k]-sum[i-1][k-1]); //预处理减小常数 for(k=1;k&lt;=m;k++)pre[k]=max(0,pre[k-1])+s[k]; for(k=m;k&gt;=0;k--)suc[k]=max(0,suc[k+1])+s[k]; for(k=1;k&lt;=m;k++)mx[i][j][k]=pre[k]+suc[k]-s[k]; //mx[i][j][k]:i为上界，j为下界，必须包含第k列在上下界范围内全部值的最大值 &#125; &#125; for(i=1;i&lt;=n;i++)&#123; for(k=1;k&lt;=m;k++)&#123; //p[i][j][k]:i为上界，j为下界的上界，必须包含第k列的最大值 //只是起到简化运算的作用 p[i][n+1][k]=inf; for(j=n;j&gt;=i;j--) p[i][j][k]=max(p[i][j+1][k],mx[i][j][k]); &#125; &#125; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++)&#123; //f[i][j]=min&#123;p[up][i][j]&#125;,up&lt;=i f[i][j]=p[1][i][j]; for(k=2;k&lt;=i;k++)f[i][j]=max(f[i][j],p[k][i][j]); &#125;&#125;int main()&#123; int i,j,t,x,y; t=read(); while(t--)&#123; n=read(),m=read(); for(i=1;i&lt;=n;i++)for(j=1;j&lt;=m;j++) mt[i][j]=read(),sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+mt[i][j]; init(); q=read(); while(q--)x=read(),y=read(),printf("%d\n",f[x][y]); &#125; return 0;&#125; AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#define max(a,b) (a&gt;b?(a):(b))#define N 304int inf=-1e7;int read()&#123; char c=getchar();int f=1,num=0; while(c&gt;'9'||c&lt;'0')&#123; if(c=='-')f=-1; if(c=='x')return inf; c=getchar(); &#125; while(c&gt;='0'&amp;&amp;c&lt;='9')num=(num&lt;&lt;3)+(num&lt;&lt;1)+c-'0',c=getchar(); return num*f;&#125;int n,m,q,mt[N][N],sum[N][N];int pre[N],suc[N],mx[N][N];int p[N][N][N],f[N][N],s[N];void init()&#123; int i,j,k; for(i=1;i&lt;=n;i++)&#123;//合并到用一个i for(j=i;j&lt;=n;j++)&#123; pre[0]=suc[m+1]=0; for(k=1;k&lt;=m;k++)s[k]=sum[j][k]-sum[j][k-1]-(sum[i-1][k]-sum[i-1][k-1]); for(k=1;k&lt;=m;k++)pre[k]=max(0,pre[k-1])+s[k]; for(k=m;k&gt;=0;k--)suc[k]=max(0,suc[k+1])+s[k]; for(k=1;k&lt;=m;k++)mx[j][k]=pre[k]+suc[k]-s[k]; //i为上界，j为下界，必须包含第k列的最大值 &#125; for(k=1;k&lt;=m;k++)p[i][n][k]=mx[n][k]; for(j=n-1;j&gt;=i;j--)for(k=1;k&lt;=m;k++)p[i][j][k]=max(p[i][j+1][k],mx[j][k]); for(j=1;j&lt;=m;j++)&#123; f[i][j]=p[1][i][j]; for(k=2;k&lt;=i;k++)f[i][j]=max(f[i][j],p[k][i][j]); &#125; &#125;&#125;int main()&#123; int i,j,t,x,y; t=read(); while(t--)&#123; n=read(),m=read(); for(i=1;i&lt;=n;i++)for(j=1;j&lt;=m;j++) mt[i][j]=read(),sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+mt[i][j]; init(); q=read(); while(q--)x=read(),y=read(),printf("%d\n",f[x][y]); &#125; return 0;&#125; I 题目描述解题思路AC代码点击 12 J 题目描述解题思路AC代码点击 12 K 题目描述解题思路AC代码点击 12 L 题目描述解题思路AC代码点击 12 M 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>BCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四届北航程序设计竞赛预赛题解]]></title>
    <url>%2F2019%2F03%2F21%2F14thbcpc-pretest%2F</url>
    <content type="text"><![CDATA[整整花费了一个周的时间来做，不是依托自身实力而是依托大佬的帮助才完成了这次比赛。题目都很有意思，可惜能想出来的并不多。那集训队的事情就等明年了。 Solved A B C D E F G H I J K L 12/12 O O O O O O O O O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给出一段序列，求最少去除几个数使得剩下的数能够组成总和相同的两堆。 $1≤T≤50$，$1≤n≤50$，$0≤a,b≤10^9$，$0≤b−a≤50$ 解题思路根据$a$的个数和$b-a$的总和进行$DP$，滚动数组优化。 AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;string.h&gt;int ans,x[55];int f[2][110][5015];int max(int p,int q)&#123;return p&gt;q?p:q;&#125;int main()&#123; int i,j,k,t,n,a,b; scanf("%d",&amp;t); while(t--)&#123; memset(f,0,sizeof(f)); f[0][50][2500]=1; int p=0; scanf("%d%d%d",&amp;n,&amp;a,&amp;b); for(i=1;i&lt;=n;i++)scanf("%d",&amp;x[i]),x[i]-=a; for(i=1;i&lt;=n;i++)&#123; p^=1; for(j=50-i;j&lt;=50+i;j++)&#123;//50+ a的个数 for(k=0;k&lt;=5000;k++)&#123;//2500+ b-a累加 f[p][j][k]=f[p^1][j][k]; if(k-x[i]&gt;=0&amp;&amp;j-1&gt;=0&amp;&amp;f[p^1][j-1][k-x[i]])f[p][j][k]=max(f[p][j][k],f[p^1][j-1][k-x[i]]+1); if(k+x[i]&lt;=5000&amp;&amp;j-1&gt;=0&amp;&amp;f[p^1][j+1][k+x[i]])f[p][j][k]=max(f[p][j][k],f[p^1][j+1][k+x[i]]+1); &#125; &#125; &#125; int ans=f[p][50][2500]; for(i=0;i&lt;=100;i++)&#123; if(a*(i-50)+2500&lt;0)continue; if(a*(i-50)+2500&gt;5000)break; ans=max(ans,f[p][i][-a*(i-50)+2500]); &#125; printf("%d\n",n-(ans-1)); &#125; return 0;&#125; B 题目描述升级有两种，吃糖直接升一级，或者攒经验。给定经验值，糖果数，各级升级经验数，问最多升到多少级。 解题思路排完序暴力枚举答案就行了。（虽然可以二分答案） AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct E&#123; int d,i; bool operator &lt;(const E&amp;a)const&#123;return d&gt;a.d&#125;;&#125;exp[110];int n,m,a,b,c,t,p[110];int jud(int x)&#123; int u[110]=&#123;0&#125;; int i,temp=n,mx=m; for(i=1;i&lt;=100;i++)&#123; if(temp&amp;&amp;exp[i].i&lt;=x)u[exp[i].x]=1,temp--; &#125; for(i=1;i&lt;=x;i++)&#123; if(!u[i])&#123; if(mx&gt;=p[i])mx-=p[i]; else return 0; &#125; &#125; return 1;&#125;int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;a,&amp;b,&amp;c); for(i=1;i&lt;=100;i++)p[i]=exp[i].d=(i*a+b)%c,exp[i].i=i; sort(exp+1,exp+100); for(i=1;i&lt;=100;i++)if(!jud(i))break; printf("%d\n",i-1); &#125; return 0;&#125; C 题目描述给一棵树，求出所有节点间路径的权值和和异或和的乘积之和。 解题思路思路一：点分治，求出所有经过当前根的子树中的链，把所有链分别连起来，再减去在多算了的相同子树中链的加和。 思路二：树形DP。还暂时没有实现。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 100010#define w ((ll)(1e9+7))typedef long long ll;int max(int a,int b)&#123;return a&gt;b?a:b;&#125;struct Edge&#123; int end,near; ll len;&#125;e[N&lt;&lt;2];struct Chain&#123; ll sum,xos;&#125;sub[N&lt;&lt;4],all[N&lt;&lt;4];int head[N],cnt;void add(int a,int b,ll l)&#123; e[++cnt].end=b;e[cnt].len=l; e[cnt].near=head[a];head[a]=cnt;&#125;int n,rt,sum;int siz[N],mxt[N],vis[N];void getrt(int v,int fa)&#123; int i,p; siz[v]=1;mxt[v]=0; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(vis[p]||p==fa)continue; getrt(p,v); siz[v]+=siz[p]; mxt[v]=max(mxt[v],siz[p]); &#125; mxt[v]=max(mxt[v],sum-siz[v]); if(mxt[v]&lt;mxt[rt])rt=v;&#125;void getdis(int v,int fa,ll s,ll x)&#123; int i,p; sub[++sub[0].sum].sum=s; sub[sub[0].sum].xos=x; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(p==fa||vis[p])continue; getdis(p,v,(s+e[i].len)%w,x^e[i].len); &#125;&#125;ll allBin[N],subBin[N];ll calcsub()&#123; int i,j; ll ans=0; for(i=1;i&lt;=sub[0].sum;i++)&#123; ll r=0; for(j=0;j&lt;32;j++)&#123; if(sub[i].xos&amp;(1&lt;&lt;j))r+=(sub[0].sum-subBin[j])*(1&lt;&lt;j)%w; else r+=subBin[j]*(1&lt;&lt;j)%w; r%=w; &#125; ans+=r*sub[i].sum%w; ans%=w; &#125; return ans;&#125;ll calcall()&#123; int i,j; ll ans=0; for(i=1;i&lt;=all[0].sum;i++)&#123; ll r=0; for(j=0;j&lt;32;j++)&#123; if(all[i].xos&amp;(1&lt;&lt;j))r+=(all[0].sum-allBin[j])*(1&lt;&lt;j)%w; else r+=allBin[j]*(1&lt;&lt;j)%w; r%=w; &#125; ans+=r*all[i].sum%w; ans%=w; &#125; return ans;&#125;ll sol(int v)&#123; int i,p,j,k; vis[v]=1;all[0].sum=0; ll ans=0; for(i=0;i&lt;32;i++)allBin[i]=0; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(vis[p])continue; sub[0].sum=0; for(j=0;j&lt;32;j++)subBin[j]=0; getdis(p,v,e[i].len,e[i].len); for(j=1;j&lt;=sub[0].sum;j++) for(k=0;k&lt;32;k++) if(sub[j].xos&amp;(1&lt;&lt;k))subBin[k]++; ans-=calcsub();ans%=w; for(j=0;j&lt;32;j++)allBin[j]+=subBin[j]; for(j=1;j&lt;=sub[0].sum;j++)all[++all[0].sum]=sub[j]; &#125; ans+=calcall();ans%=w; for(i=1;i&lt;=all[0].sum;i++)&#123; ans+=all[i].sum*all[i].xos%w; ans%=w; &#125; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(!vis[p])&#123; sum=siz[p];mxt[0]=n;rt=0; getrt(p,v); ans+=sol(rt); ans%=w; &#125; &#125; return (ans+w)%w;&#125;int main()&#123; int i,a,b,t; ll c; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=1;i&lt;n;i++) scanf("%d%d%lld",&amp;a,&amp;b,&amp;c),add(a,b,c),add(b,a,c); rt=0;sum=mxt[0]=n;getrt(1,0); printf("%lld\n",sol(rt)); memset(vis,0,sizeof(int)*(n+1)); memset(head,0,sizeof(int)*(n+1)); cnt=0; &#125; return 0;&#125; D 题目描述一行点，往里头填数，每个点有最低限制，且要满足每个点相对左边的点的数满足给定条件，求最小总数。 解题思路暴力 AC代码点击 12345678910111213141516171819202122#include&lt;stdio.h&gt;int ans,now,a[110],b[110];int main()&#123; int i,t,n; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)scanf("%d",&amp;b[i]); now=ans=a[0]; for(i=1;i&lt;n;i++)&#123; now+=b[i]; if(now&lt;a[i])&#123; ans+=i*(a[i]-now); now=a[i]; &#125; ans+=now; &#125; printf("%d\n",ans); &#125; return 0;&#125; E 题目描述给定$n$个点， 两点间道路长度为两点权值的$gcd$，求最大生成树。（$a_i\leq 1e5$） 解题思路根据$krustal$算法的原理，枚举边长上界，构造生成树。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n,a[100010],f[100010],map[100010];int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;int main()&#123; int i,j,k,l,t,m; scanf("%d",&amp;t); while(t--)&#123; long long ans=0,max; int temp,p,q,u[2]=&#123;0&#125;,now=0,cnt=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); sort(a+1,a+n+1); max=a[n]; for(i=1;i&lt;n;i++)if(a[i]==a[i+1])ans+=a[i],cnt++; for(i=1;i&lt;=n;i++)map[a[i]]=i; for(i=1;i&lt;=n;i++)f[i]=i; for(i=max;i;i--)&#123; now=u[0]=u[1]=0; for(j=1;j*i&lt;=max;j++)&#123; if(map[j*i])&#123; u[now]=map[j*i]; if(u[now^1])&#123; p=find(u[now]); q=find(u[now^1]); if(p!=q)&#123; ans+=i; f[p]=q; cnt++; &#125; &#125; now^=1; &#125; &#125; if(cnt==n-1)break; &#125; printf("%lld\n",ans); memset(map,0,sizeof(map)); &#125; return 0;&#125; F 题目描述求满足$(i+1)^i*i &equiv; 0(mod&ensp; m)$的$m$的个数的前缀和，$i\leq 1e7$。 解题思路先考虑枚举每个数的质因数个数，发现会$T$飞。 故反向从枚举质因数筛原数。 AC代码点击 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#define N 10000002int ans[N+4],w=998244353;int prime[N+4]=&#123;1,1&#125;,a[N/10],tot=1;int main()&#123; int i,j,t,n,cnt; scanf("%d",&amp;t); for(i=1;i&lt;N;i++)ans[i]=1; for(i=2;i&lt;N;i++)&#123; if(!prime[i])a[tot++]=i; for(j=1;j&lt;tot;j++)&#123; if(i*a[j]&gt;=N)break; prime[i*a[j]]=1; if(i%a[j]==0)break; &#125; &#125; for(i=1;i&lt;tot;i++)&#123; for(j=1;j*a[i]&lt;N;j++)&#123; cnt=0; int now=j*a[i],temp=now; while(now%a[i]==0)now/=a[i],cnt++; ans[temp-1]=ans[temp-1]*1LL*(cnt*1LL*(temp-1)+1)%w; ans[temp]=ans[temp]*1LL*(cnt+1)%w; &#125; &#125; for(i=2;i&lt;N;i++)ans[i]=(ans[i]+ans[i-1])%w; while(t--)&#123; scanf("%d",&amp;n); printf("%d\n",ans[n]); &#125; return 0;&#125; G 题目描述给定一个非常长的序列，求其中所有上升子序列的长度 $k$次方之和，答案对$1e9+7$取模，$k\leq 20$。 解题思路先考虑$k=1$的情况。可以想到，从前到后遍历数组，用一个树状数组维护当前所有以$x$为结尾的上升子序列长度的和前缀和，每次加入（$y+query(x-1)$）更新。 在考虑$k\geq 2$的情况。维护$k+1$个树状数组，第$i$个树状数组记录上升子序列长度$l^i$的和的前缀和，更新的时候用二项式定理扫一遍即可。 注意到数据较大，需要离散化。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 131073using namespace std;typedef long long ll;int n,k,x[N],y[N],seq[N*10],M;struct number&#123; int a,b,i; bool operator&lt;(const number&amp;p)const&#123;return a&lt;p.a;&#125;&#125;a[N];ll w=1e9+7,t[21][N],c[25][25];int l(int x)&#123;return x&amp;(-x);&#125;void add(int d,int x,ll p)&#123; while(x&lt;=M)&#123; t[d][x]+=p; t[d][x]%=w; x+=l(x); &#125;&#125;ll query(int d,int x)&#123; ll ans=0; while(x)&#123; ans+=t[d][x]; ans%=w; x-=l(x); &#125; return ans;&#125;int main()&#123; int i,j,m,T; ll now[25]; for(i=0;i&lt;=20;i++)c[i][0]=1; for(i=1;i&lt;=20;i++)for(j=1;j&lt;=20;j++)c[i][j]=c[i-1][j-1]+c[i-1][j]; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;=n;i++)scanf("%d%d",&amp;x[i],&amp;y[i]),a[i].a=x[i],a[i].b=y[i],a[i].i=i; sort(a+1,a+n+1); for(i=1;i&lt;=n;i++)seq[a[i].a]=a[i].a==a[i-1].a?seq[a[i-1].a]:seq[a[i-1].a]+1; M=seq[a[n].a]+1; for(i=1;i&lt;=n;i++)&#123; int X=seq[x[i]]+1,Y=y[i]; for(j=0;j&lt;=k;j++)now[j]=query(j,X-1); for(j=0;j&lt;=k;j++)&#123; ll tot=0; for(m=0;m&lt;=j;m++)tot+=Y*c[j][m]%w*now[m]%w,tot%=w; add(j,X,(tot+Y)%w); &#125; &#125; printf("%lld\n",query(k,M)); for(i=0;i&lt;=k;i++)for(j=0;j&lt;=M;j++)t[i][j]=0; &#125; return 0;&#125; H 题目描述给定五张牌，问加入两张牌成为顺子有多少种情况。 解题思路巨麻烦的分类讨论？ 不，这题可以直接暴力。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;char a[8];int x[150];int main()&#123; int t,i,j,k; x['A']=1;x['2']=2;x['3']=3;x['4']=4; x['5']=5;x['6']=6;x['7']=7;x['8']=8; x['9']=9;x['T']=10;x['J']=11;x['Q']=12; x['K']=13; scanf("%d",&amp;t); while(t--)&#123; int t[25]=&#123;0&#125;,ans=0; int used[60]=&#123;0&#125;,num[20]=&#123;0&#125;; scanf("%s",a); for(i=0;i&lt;5;i++)&#123; int s=x[a[i]]; t[s]++; used[s*4+num[s]++]++; if(a[i]=='A')t[14]++; &#125; for(i=4;i&lt;56;i++)&#123; if(used[i])continue; t[i/4]++; for(j=i+1;j&lt;56;j++)&#123; if(used[j])continue; t[j/4]++; int flag=0; for(k=1;k&lt;=13;k++)&#123; if(t[k]&amp;&amp;t[k+1]&amp;&amp;t[k+2]&amp;&amp;t[k+3]&amp;&amp;(t[k+4]||(k+4==14&amp;&amp;t[1])))&#123; flag=1; break; &#125; &#125; if(flag)ans++; t[j/4]--; &#125; t[i/4]--; &#125; printf("%d\n",ans); &#125; return 0;&#125; I 题目描述给定一个只含有$ATGC$的环，$ATGC$分别代表一种矩阵，定义一次操作为所有矩阵乘上下一个矩阵，问$k$次操作后（$k\leq 1e9$）的环。 解题思路列个表发现$ATGC$之间的乘积具有异或的性质。 然后利用$k$的可加性，找到规律，倍增解决。 AC代码点击 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;char a[4]=&#123;'A','T','G','C'&#125;,c[1000010];int res[4][4]=&#123;&#123;0,1,2,3&#125;,&#123;1,0,3,2&#125;,&#123;2,3,0,1&#125;,&#123;3,2,1,0&#125;&#125;;int now[2][1000010];int map[510];int main()&#123; int i,t,n,k,m; scanf("%d",&amp;t); map['A']=0;map['T']=1; map['G']=2;map['C']=3; while(t--)&#123; m=0; int p,cnt; scanf("%d%d%s",&amp;n,&amp;k,c); for(i=0;i&lt;n;i++)now[1][i]=map[c[i]]; while(k)&#123; p=1;cnt=0; while(k&gt;=(1&lt;&lt;cnt+1))cnt++; int d=(1&lt;&lt;cnt); k-=d; for(i=0;i&lt;n;i++)now[m][i]=res[now[m^1][i]][now[m^1][(i+d)%n]]; m^=1; &#125; for(i=0;i&lt;n;i++)printf("%c",a[now[m^1][i]]); printf("\n"); &#125; return 0;&#125; J 题目描述求满足方程组 $x_1+x_2+…+x_n=m$$0\leq x_i \leq a_i$ 的解的个数， 对一堆素数的乘积取模。 解题思路首先，求答案用插板法，写出组合数。然后，分别对每一个模数取模，得到相应答案。最后，把取模得到的数用中国剩余定理得到最终答案。 毒瘤爆$long long$，CRT需要龟速乘 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;using namespace std;typedef long long ll;int n,k;ll m,v[20],ans[20],p[20];ll jc[20][100010];ll mul(ll x,ll y,ll mod) &#123; ll res=0;x%=mod; for(;y;y&gt;&gt;=1,(x*=2)%=mod)if(y&amp;1)(res+=x)%=mod; return res;&#125;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123;x=1,y=0;return;&#125; exgcd(b,a%b,y,x); y-=a/b*x;&#125;ll China(int n,ll *m,ll *a)&#123; int i; ll M=1,ans=0,y,x=0; for(i=0;i&lt;n;i++)M*=m[i]; for(i=0;i&lt;n;i++)&#123; ll w=M/m[i]; exgcd(m[i],w,x,y); ans=(ans+mul(mul(y,w,M),a[i],M))%M; &#125; return (ans%M+M)%M;&#125;ll pw(ll x,int y,int num)&#123; int i; ll ans=1;x%=p[num]; for(i=y;i;i&gt;&gt;=1,x=x*x%p[num])if(i&amp;1)ans=ans*x%p[num]; return ans;&#125;ll c(ll x,ll y,int num)&#123; if(x&lt;y)return 0; return mul(mul(jc[num][x],pw(jc[num][y],p[num]-2,num),p[num]),pw(jc[num][x-y],p[num]-2,num),p[num]);&#125;ll lucas(ll x,ll y,int num)&#123; if(!y)return 1; return mul(lucas(x/p[num],y/p[num],num),c(x%p[num],y%p[num],num),p[num]);&#125;int main()&#123; int i,s,cnt,t,j; ll temp; scanf("%d",&amp;t); while(t--)&#123; for(i=0;i&lt;20;i++)ans[i]=0; scanf("%d%lld%d",&amp;n,&amp;m,&amp;k); for(i=0;i&lt;n;i++)scanf("%lld",&amp;v[i]); for(i=0;i&lt;k;i++)scanf("%lld",&amp;p[i]); for(i=0;i&lt;k;i++)&#123; jc[i][0]=1; for(j=1;j&lt;=1e5;j++)jc[i][j]=jc[i][j-1]*j%p[i]; &#125; s=(1&lt;&lt;n); for(i=0;i&lt;s;i++)&#123; cnt=1; temp=0; for(j=0;j&lt;n;j++)&#123; if(i&amp;(1&lt;&lt;j))&#123; cnt*=-1; temp+=v[j]+1; &#125; &#125; if(temp&gt;m)continue; for(j=0;j&lt;k;j++) ans[j]=(ans[j]+mul(cnt&lt;0?p[j]-1:1,lucas(m-temp+n-1,n-1,j),p[j]))%p[j]; &#125; printf("%lld\n",China(k,p,ans)); &#125; return 0;&#125; K 题目描述多次操作区间对最小值（定义为非零的最小值）取模，求取模前后该区间数的总和。 解题思路线段树，区间和为$0$时特判剪枝。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt;#define N 200010typedef long long ll;struct SegmentTree&#123; int l,r; ll sum,min;&#125;t[N&lt;&lt;3];int n;ll a[N];ll minf(ll a,ll b)&#123; if(!a||!b)return b|a; return a&gt;b?b:a;&#125;void build(int p,int l,int r)&#123; if(l==r)&#123; t[p].l=t[p].r=l; t[p].min=t[p].sum=a[l]; return; &#125; t[p].l=l;t[p].r=r; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); t[p].sum=t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].sum; t[p].min=minf(t[p&lt;&lt;1].min,t[p&lt;&lt;1|1].min);&#125;ll query(int p,int l,int r)&#123; int L=t[p].l,R=t[p].r; if(l&gt;R||r&lt;L)return 0; if(l&lt;=L&amp;&amp;r&gt;=R)return t[p].sum; return query(p&lt;&lt;1,l,r)+query(p&lt;&lt;1|1,l,r);&#125;ll minquery(int p,int l,int r)&#123; int L=t[p].l,R=t[p].r; if(l&gt;R||r&lt;L)return 0; if(l&lt;=L&amp;&amp;r&gt;=R)return t[p].min; return minf(minquery(p&lt;&lt;1,l,r),minquery(p&lt;&lt;1|1,l,r));&#125;ll modify(int p,int l,int r,ll k)&#123; int L=t[p].l,R=t[p].r; if(l&gt;R||r&lt;L||!t[p].sum)return 0; if(L==R)return t[p].min=t[p].sum%=k; modify(p&lt;&lt;1,l,r,k);modify(p&lt;&lt;1|1,l,r,k); t[p].min=minf(t[p&lt;&lt;1].min,t[p&lt;&lt;1|1].min); t[p].sum=t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].sum; return t[p].min;&#125;void print()&#123; int i; for(i=1;i&lt;=44;i++) if(t[i].l)printf("%d %d %lld %lld\n",t[i].l,t[i].r,t[i].sum,t[i].min); printf("\n");&#125;int main()&#123; int q,i,l,r,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;q); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]); build(1,1,n); for(i=0;i&lt;q;i++)&#123; scanf("%d%d",&amp;l,&amp;r); ll mn=minquery(1,l,r); if(!mn)printf("0 0\n"); else&#123; printf("%lld ",query(1,l,r)); modify(1,l,r,mn); printf("%lld\n",query(1,l,r)); &#125; //print(); &#125; &#125; return 0;&#125; L 题目描述告诉每回合出现哪些神龙，每回合怎么得钱，买一个神龙一块钱，问多少回合能集齐要求的神龙。 解题思路二分答案。注意$p$爆$long long$。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 100010int n,m,p,k,l;int a[N],b[N],tmp[N];int f(int x,int y)&#123;return x*m+y;&#125;//1-&gt;2int g(int x)&#123;return x/m;&#125;//2-&gt;1int seq[N];int jud(int num)&#123; int i,mx=f(num,0)-1; memset(seq,0,sizeof(seq)); memset(tmp,0,sizeof(tmp)); for(i=0;i&lt;l;i++)tmp[b[i]]++; for(i=mx;i&gt;=0;i--)&#123; if(tmp[a[i]])&#123; seq[g(i)]++; tmp[a[i]]--; &#125; &#125; for(i=0;i&lt;l;i++)if(tmp[b[i]])return 0; long long now=p; for(i=0;i&lt;num;i++)&#123; now-=seq[i]; if(now&lt;0)return 0; if(now&lt;l)now+=now/k+p; &#125; return 1;&#125;int main()&#123; int i,j,q,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;p,&amp;k,&amp;l); for(i=0;i&lt;n;i++)for(j=0;j&lt;m;j++)scanf("%d",&amp;a[f(i,j)]); for(i=0;i&lt;l;i++)scanf("%d",&amp;b[i]); int l=0,r=n; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(jud(mid))r=mid; else l=mid+1; &#125; if(!jud(l))l++; if(l&lt;=n)printf("%d\n",l); else printf("-1\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>BCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My first blog]]></title>
    <url>%2F2019%2F03%2F09%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[啦啦啦，换到新的blog啦！ 原博客停用 标题一标题二标题三标题四标题五标题六 这是一段引用 123int mian()&#123;//这是一段代码 retrun 0;&#125; 这是一个链接 $\sum_{k|((1&lt;&lt;k)\&amp;S==0)}^{} {f[i-1][S-(1&lt;]}$ 嗯嗯 诶诶诶 黑体 斜体 a 道路千万条 你是第一条 第一条 -.- -。- 第二条~ 第三条 233 322 &lt;addr&gt; 233 $$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$ $$ \sideset{^1_2}{^3_4}\bigotimes $$ $$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$ $$\sqrt{2} \quad and \quad \sqrt[n]{3}$$ $$\vec{a} \cdot \vec{b}=0$$ $$\overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}$$ $$ \lim_{n \to +\infty} \frac{1}{n(n+1)}$$ $$\sum_{i=1}^n \frac{1}{i^2} \quad and \quad \prod_{i=1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i=1}^{2} R$$ $\smash{\displaystyle\max_{0 \leq q \leq n-1}} f(q) \le n$ $f(x + \epsilon) \approx f(x) + f’(x) \epsilon + \mathcal{O}(\epsilon^2).$ $\text{d}x$ $\lim_{n \to +\infty}{1^n}=1$]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
