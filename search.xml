<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019.4-2019.5 TO-DO LIST]]></title>
    <url>%2F2019%2F03%2F30%2F2019.4-2019.5%20to-do%20list%2F</url>
    <content type="text"><![CDATA[做自己喜欢的事是自由，喜欢自己做的事是幸福。 由于3月剩下的时间便是复习以前的题目来完成题解集，估计不会有剩余时间开新坑了。提前备好上个月没有完成的任务。 数据结构LCTblog1blog2P3690 【模板】Link Cut Tree （动态树）P1600 天天爱跑步 线段树，树状数组P1972 [SDOI2009]HH的项链P3948 数据结构CF877E Danil and a Part-time Job 自动机P3809 【模板】后缀排序P3804 【模板】后缀自动机P2414 [NOI2011]阿狸的打字机 数论P4884 多少个1？BSGS和扩展BSGSP4861 按钮P3807 【模板】卢卡斯定理P4720 【模板】扩展卢卡斯P2044 [NOI2012]随机数生成器P4783 【模板】矩阵求逆P4781 【模板】拉格朗日插值P4213 【模板】杜教筛（Sum）P4718 【模板】Pollard-Rho算法群论P4980 【模板】Polya定理莫比乌斯反演 FFTP4238 【模板】多项式求逆P4199 万径人踪灭P2553 [AHOI2001]多项式乘法P4245 【模板】任意模数NTTP4239 【模板】多项式求逆（加强版）P4721 【模板】分治 FFTP4725 【模板】多项式对数函数P4726 【模板】多项式指数函数P4717 【模板】快速沃尔什变换P4723 【模板】线性递推 博弈论P2148 [SDOI2009]E&amp;DP3185 [HNOI2007]分裂游戏 旋转卡壳P3187 [HNOI2007]最小矩形覆盖P4166 [SCOI2007]最大土地面积 其他P1032 字串变换P1026 统计单词个数blog2P3943 星空AT2442 フェーン現象 (Foehn Phenomena)题解P3193 [HNOI2008]GT考试[HDU5592] ZYB’s PremutationP3806 【模板】点分治1 某些神奇的地方最短路+差分约束好博题解库洛谷日报LaTeX图论题画图处大佬]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四届北航程序设计竞赛预赛]]></title>
    <url>%2F2019%2F03%2F21%2F14thbcpc%2F</url>
    <content type="text"><![CDATA[链接 A 题目描述给出一段序列，求最少去除几个数使得剩下的数能够组成总和相同的两堆。 $1≤T≤50$，$1≤n≤50$，$0≤a,b≤10^9$，$0≤b−a≤50$ 解题思路根据$a$的个数和$b-a$的总和进行$DP$，滚动数组优化。 AC代码Click_To_View_Code 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;string.h&gt;int ans,x[55];int f[2][110][5015];int max(int p,int q)&#123;return p&gt;q?p:q;&#125;int main()&#123; int i,j,k,t,n,a,b; scanf("%d",&amp;t); while(t--)&#123; memset(f,0,sizeof(f)); f[0][50][2500]=1; int p=0; scanf("%d%d%d",&amp;n,&amp;a,&amp;b); for(i=1;i&lt;=n;i++)scanf("%d",&amp;x[i]),x[i]-=a; for(i=1;i&lt;=n;i++)&#123; p^=1; for(j=50-i;j&lt;=50+i;j++)&#123;//50+ a的个数 for(k=0;k&lt;=5000;k++)&#123;//2500+ b-a累加 f[p][j][k]=f[p^1][j][k]; if(k-x[i]&gt;=0&amp;&amp;j-1&gt;=0&amp;&amp;f[p^1][j-1][k-x[i]])f[p][j][k]=max(f[p][j][k],f[p^1][j-1][k-x[i]]+1); if(k+x[i]&lt;=5000&amp;&amp;j-1&gt;=0&amp;&amp;f[p^1][j+1][k+x[i]])f[p][j][k]=max(f[p][j][k],f[p^1][j+1][k+x[i]]+1); &#125; &#125; &#125; int ans=f[p][50][2500]; for(i=0;i&lt;=100;i++)&#123; if(a*(i-50)+2500&lt;0)continue; if(a*(i-50)+2500&gt;5000)break; ans=max(ans,f[p][i][a*(i-50)+2500]); &#125; printf("%d\n",n-(ans-1)); &#125; return 0;&#125; B 题目描述升级有两种，吃糖直接升一级，或者攒经验。给定经验值，糖果数，各级升级经验数，问最多升到多少级。 解题思路排完序暴力枚举答案就行了。（虽然可以二分答案） AC代码Click_To_View_Code 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct E&#123; int d,i; bool operator &lt;(const E&amp;a)const&#123;return d&gt;a.d&#125;;&#125;exp[110];int n,m,a,b,c,t,p[110];int jud(int x)&#123; int u[110]=&#123;0&#125;; int i,temp=n,mx=m; for(i=1;i&lt;=100;i++)&#123; if(temp&amp;&amp;exp[i].i&lt;=x)u[exp[i].x]=1,temp--; &#125; for(i=1;i&lt;=x;i++)&#123; if(!u[i])&#123; if(mx&gt;=p[i])mx-=p[i]; else return 0; &#125; &#125; return 1;&#125;int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;a,&amp;b,&amp;c); for(i=1;i&lt;=100;i++)p[i]=exp[i].d=(i*a+b)%c,exp[i].i=i; sort(exp+1,exp+100); for(i=1;i&lt;=100;i++)if(!jud(i))break; printf("%d\n",i-1); &#125; return 0;&#125; C 题目描述给一棵树，求出所有节点间路径的权值和和异或和的乘积之和。 解题思路思路一：点分治，求出所有经过当前根的子树中的链，把所有链分别连起来，再减去在多算了的相同子树中链的加和。 AC代码Click_To_View_Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 100010#define w ((ll)(1e9+7))typedef long long ll;int max(int a,int b)&#123;return a&gt;b?a:b;&#125;struct Edge&#123; int end,near; ll len;&#125;e[N&lt;&lt;2];struct Chain&#123; ll sum,xos;&#125;sub[N&lt;&lt;4],all[N&lt;&lt;4];int head[N],cnt;void add(int a,int b,ll l)&#123; e[++cnt].end=b;e[cnt].len=l; e[cnt].near=head[a];head[a]=cnt;&#125;int n,rt,sum;int siz[N],mxt[N],vis[N];void getrt(int v,int fa)&#123; int i,p; siz[v]=1;mxt[v]=0; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(vis[p]||p==fa)continue; getrt(p,v); siz[v]+=siz[p]; mxt[v]=max(mxt[v],siz[p]); &#125; mxt[v]=max(mxt[v],sum-siz[v]); if(mxt[v]&lt;mxt[rt])rt=v;&#125;void getdis(int v,int fa,ll s,ll x)&#123; int i,p; sub[++sub[0].sum].sum=s; sub[sub[0].sum].xos=x; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(p==fa||vis[p])continue; getdis(p,v,(s+e[i].len)%w,x^e[i].len); &#125;&#125;ll allBin[N],subBin[N];ll calcsub()&#123; int i,j; ll ans=0; for(i=1;i&lt;=sub[0].sum;i++)&#123; ll r=0; for(j=0;j&lt;32;j++)&#123; if(sub[i].xos&amp;(1&lt;&lt;j))r+=(sub[0].sum-subBin[j])*(1&lt;&lt;j)%w; else r+=subBin[j]*(1&lt;&lt;j)%w; r%=w; &#125; ans+=r*sub[i].sum%w; ans%=w; &#125; return ans;&#125;ll calcall()&#123; int i,j; ll ans=0; for(i=1;i&lt;=all[0].sum;i++)&#123; ll r=0; for(j=0;j&lt;32;j++)&#123; if(all[i].xos&amp;(1&lt;&lt;j))r+=(all[0].sum-allBin[j])*(1&lt;&lt;j)%w; else r+=allBin[j]*(1&lt;&lt;j)%w; r%=w; &#125; ans+=r*all[i].sum%w; ans%=w; &#125; return ans;&#125;ll sol(int v)&#123; int i,p,j,k; vis[v]=1;all[0].sum=0; ll ans=0; for(i=0;i&lt;32;i++)allBin[i]=0; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(vis[p])continue; sub[0].sum=0; for(j=0;j&lt;32;j++)subBin[j]=0; getdis(p,v,e[i].len,e[i].len); for(j=1;j&lt;=sub[0].sum;j++) for(k=0;k&lt;32;k++) if(sub[j].xos&amp;(1&lt;&lt;k))subBin[k]++; ans-=calcsub();ans%=w; for(j=0;j&lt;32;j++)allBin[j]+=subBin[j]; for(j=1;j&lt;=sub[0].sum;j++)all[++all[0].sum]=sub[j]; &#125; ans+=calcall();ans%=w; for(i=1;i&lt;=all[0].sum;i++)&#123; ans+=all[i].sum*all[i].xos%w; ans%=w; &#125; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(!vis[p])&#123; sum=siz[p];mxt[0]=n;rt=0; getrt(p,v); ans+=sol(rt); ans%=w; &#125; &#125; return (ans+w)%w;&#125;int main()&#123; int i,a,b,t; ll c; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=1;i&lt;n;i++) scanf("%d%d%lld",&amp;a,&amp;b,&amp;c),add(a,b,c),add(b,a,c); rt=0;sum=mxt[0]=n;getrt(1,0); printf("%lld\n",sol(rt)); memset(vis,0,sizeof(int)*(n+1)); memset(head,0,sizeof(int)*(n+1)); cnt=0; &#125; return 0;&#125; D 题目描述一行点，往里头填数，每个点有最低限制，且要满足每个点相对左边的点的数满足给定条件，求最小总数。 解题思路暴力 AC代码Click_To_View_Code 12345678910111213141516171819202122#include&lt;stdio.h&gt;int ans,now,a[110],b[110];int main()&#123; int i,t,n; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)scanf("%d",&amp;b[i]); now=ans=a[0]; for(i=1;i&lt;n;i++)&#123; now+=b[i]; if(now&lt;a[i])&#123; ans+=i*(a[i]-now); now=a[i]; &#125; ans+=now; &#125; printf("%d\n",ans); &#125; return 0;&#125; E 题目描述给定$n$个点， 两点间道路长度为两点权值的$gcd$，求最大生成树。（$a_i\leq 1e5$） 解题思路根据$krustal$算法的原理，枚举边长上界，构造生成树。 AC代码Click_To_View_Code 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n,a[100010],f[100010],map[100010];int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;int main()&#123; int i,j,k,l,t,m; scanf("%d",&amp;t); while(t--)&#123; long long ans=0,max; int temp,p,q,u[2]=&#123;0&#125;,now=0,cnt=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); sort(a+1,a+n+1); max=a[n]; for(i=1;i&lt;n;i++)if(a[i]==a[i+1])ans+=a[i],cnt++; for(i=1;i&lt;=n;i++)map[a[i]]=i; for(i=1;i&lt;=n;i++)f[i]=i; for(i=max;i;i--)&#123; now=u[0]=u[1]=0; for(j=1;j*i&lt;=max;j++)&#123; if(map[j*i])&#123; u[now]=map[j*i]; if(u[now^1])&#123; p=find(u[now]); q=find(u[now^1]); if(p!=q)&#123; ans+=i; f[p]=q; cnt++; &#125; &#125; now^=1; &#125; &#125; if(cnt==n-1)break; &#125; printf("%lld\n",ans); memset(map,0,sizeof(map)); &#125; return 0;&#125; F 题目描述求满足$(i+1)^i*i mod m =0$的$m$的个数的前缀和，$i\leq 1e7$。 解题思路先考虑枚举每个数的质因数个数，发现会$T$飞。 故反向从枚举质因数筛原数。 AC代码Click_To_View_Code 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#define N 10000002int ans[N+4],w=998244353;int prime[N+4]=&#123;1,1&#125;,a[N/10],tot=1;int main()&#123; int i,j,t,n,cnt; scanf("%d",&amp;t); for(i=1;i&lt;N;i++)ans[i]=1; for(i=2;i&lt;N;i++)&#123; if(!prime[i])a[tot++]=i; for(j=1;j&lt;tot;j++)&#123; if(i*a[j]&gt;=N)break; prime[i*a[j]]=1; if(i%a[j]==0)break; &#125; &#125; for(i=1;i&lt;tot;i++)&#123; for(j=1;j*a[i]&lt;N;j++)&#123; cnt=0; int now=j*a[i],temp=now; while(now%a[i]==0)now/=a[i],cnt++; ans[temp-1]=ans[temp-1]*1LL*(cnt*1LL*(temp-1)+1)%w; ans[temp]=ans[temp]*1LL*(cnt+1)%w; &#125; &#125; for(i=2;i&lt;N;i++)ans[i]=(ans[i]+ans[i-1])%w; while(t--)&#123; scanf("%d",&amp;n); printf("%d\n",ans[n]); &#125; return 0;&#125; G 题目描述给定一个非常长的序列，求其中所有上升子序列的长度 $k$次方之和，答案对$1e9+7$取模，$k\leq 20$。 解题思路先考虑$k=1$的情况。可以想到，从前到后遍历数组，用一个树状数组维护当前所有以$x$为结尾的上升子序列长度的和前缀和，每次加入（$y+query(x-1)$）更新。 在考虑$k\beq 2$的情况。维护$k+1$个树状数组，第$i$个树状数组记录上升子序列长度$l^i$的和的前缀和，更新的时候用二项式定理扫一遍即可。 注意到数据较大，需要离散化。 AC代码Click_To_View_Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 131073using namespace std;typedef long long ll;int n,k,x[N],y[N],seq[N*10],M;struct number&#123; int a,b,i; bool operator&lt;(const number&amp;p)const&#123;return a&lt;p.a;&#125;&#125;a[N];ll w=1e9+7,t[21][N],c[25][25];int l(int x)&#123;return x&amp;(-x);&#125;void add(int d,int x,ll p)&#123; while(x&lt;=M)&#123; t[d][x]+=p; t[d][x]%=w; x+=l(x); &#125;&#125;ll query(int d,int x)&#123; ll ans=0; while(x)&#123; ans+=t[d][x]; ans%=w; x-=l(x); &#125; return ans;&#125;int main()&#123; int i,j,m,T; ll now[25]; for(i=0;i&lt;=20;i++)c[i][0]=1; for(i=1;i&lt;=20;i++)for(j=1;j&lt;=20;j++)c[i][j]=c[i-1][j-1]+c[i-1][j]; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;=n;i++)scanf("%d%d",&amp;x[i],&amp;y[i]),a[i].a=x[i],a[i].b=y[i],a[i].i=i; sort(a+1,a+n+1); for(i=1;i&lt;=n;i++)seq[a[i].a]=a[i].a==a[i-1].a?seq[a[i-1].a]:seq[a[i-1].a]+1; M=seq[a[n].a]+1; for(i=1;i&lt;=n;i++)&#123; int X=seq[x[i]]+1,Y=y[i]; for(j=0;j&lt;=k;j++)now[j]=query(j,X-1); for(j=0;j&lt;=k;j++)&#123; ll tot=0; for(m=0;m&lt;=j;m++)tot+=Y*c[j][m]%w*now[m]%w,tot%=w; add(j,X,(tot+Y)%w); &#125; &#125; printf("%lld\n",query(k,M)); for(i=0;i&lt;=k;i++)for(j=0;j&lt;=M;j++)t[i][j]=0; &#125; return 0;&#125; H 题目描述给定五张牌，问加入两张牌成为顺子有多少种情况。 解题思路巨麻烦的分类讨论？ 不，这题可以直接暴力。 AC代码Click_To_View_Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;char a[8];int x[150];int main()&#123; int t,i,j,k; x['A']=1;x['2']=2;x['3']=3;x['4']=4; x['5']=5;x['6']=6;x['7']=7;x['8']=8; x['9']=9;x['T']=10;x['J']=11;x['Q']=12; x['K']=13; scanf("%d",&amp;t); while(t--)&#123; int t[25]=&#123;0&#125;,ans=0; int used[60]=&#123;0&#125;,num[20]=&#123;0&#125;; scanf("%s",a); for(i=0;i&lt;5;i++)&#123; int s=x[a[i]]; t[s]++; used[s*4+num[s]++]++; if(a[i]=='A')t[14]++; &#125; for(i=4;i&lt;56;i++)&#123; if(used[i])continue; t[i/4]++; for(j=i+1;j&lt;56;j++)&#123; if(used[j])continue; t[j/4]++; int flag=0; for(k=1;k&lt;=13;k++)&#123; if(t[k]&amp;&amp;t[k+1]&amp;&amp;t[k+2]&amp;&amp;t[k+3]&amp;&amp;(t[k+4]||(k+4==14&amp;&amp;t[1])))&#123; flag=1; break; &#125; &#125; if(flag)ans++; t[j/4]--; &#125; t[i/4]--; &#125; printf("%d\n",ans); &#125; return 0;&#125; I 题目描述给定一个只含有$ATGC$的环，$ATGC$分别代表一种矩阵，定义一次操作为所有矩阵乘上下一个矩阵，问$k$次操作后（$k\leq 1e9$）的环。 解题思路列个表发现$ATGC$之间的乘积具有异或的性质。 然后利用$k$的可加性，找到规律，倍增解决。 AC代码Click_To_View_Code 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;char a[4]=&#123;'A','T','G','C'&#125;,c[1000010];int res[4][4]=&#123;&#123;0,1,2,3&#125;,&#123;1,0,3,2&#125;,&#123;2,3,0,1&#125;,&#123;3,2,1,0&#125;&#125;;int now[2][1000010];int map[510];int main()&#123; int i,t,n,k,m; scanf("%d",&amp;t); map['A']=0;map['T']=1; map['G']=2;map['C']=3; while(t--)&#123; m=0; int p,cnt; scanf("%d%d%s",&amp;n,&amp;k,c); for(i=0;i&lt;n;i++)now[1][i]=map[c[i]]; while(k)&#123; p=1;cnt=0; while(k&gt;=(1&lt;&lt;cnt+1))cnt++; int d=(1&lt;&lt;cnt); k-=d; for(i=0;i&lt;n;i++)now[m][i]=res[now[m^1][i]][now[m^1][(i+d)%n]]; m^=1; &#125; for(i=0;i&lt;n;i++)printf("%c",a[now[m^1][i]]); printf("\n"); &#125; return 0;&#125; J 题目描述求满足方程组 $x_1+x_2+…+x_n=M$$x_i&lt;=a_i$$x_1+x_2+…+x_n\leq m $ 的解的个数。 对一堆素数的乘积取模。 解题思路首先，求答案用插板法，写出组合数。 然后，分别对每一个模数取模，得到相应答案。 最后，把取模得到的数用中国剩余定理得到最终答案。 毒瘤爆$long long$，处处需要龟速乘 AC代码Click_To_View_Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;using namespace std;typedef long long ll;int n,k;ll m,v[20],ans[20],p[20];ll jc[20][100010];ll mul(ll x,ll y,ll mod) &#123; ll res=0;x%=mod; for(;y;y&gt;&gt;=1,(x*=2)%=mod)if(y&amp;1)(res+=x)%=mod; return res;&#125;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123;x=1,y=0;return;&#125; exgcd(b,a%b,y,x); y-=a/b*x;&#125;ll China(int n,ll *m,ll *a)&#123; int i; ll M=1,ans=0,y,x=0; for(i=0;i&lt;n;i++)M*=m[i]; for(i=0;i&lt;n;i++)&#123; ll w=M/m[i]; exgcd(m[i],w,x,y); ans=(ans+mul(mul(y,w,M),a[i],M))%M; &#125; return (ans%M+M)%M;&#125;ll pw(ll x,int y,int num)&#123; int i; ll ans=1;x%=p[num]; for(i=y;i;i&gt;&gt;=1,x=x*x%p[num])if(i&amp;1)ans=ans*x%p[num]; return ans;&#125;ll c(ll x,ll y,int num)&#123; if(x&lt;y)return 0; return mul(mul(jc[num][x],pw(jc[num][y],p[num]-2,num),p[num]),pw(jc[num][x-y],p[num]-2,num),p[num]);&#125;ll lucas(ll x,ll y,int num)&#123; if(!y)return 1; return mul(lucas(x/p[num],y/p[num],num),c(x%p[num],y%p[num],num),p[num]);&#125;int main()&#123; int i,s,cnt,t,j; ll temp; scanf("%d",&amp;t); while(t--)&#123; for(i=0;i&lt;20;i++)ans[i]=0; scanf("%d%lld%d",&amp;n,&amp;m,&amp;k); for(i=0;i&lt;n;i++)scanf("%lld",&amp;v[i]); for(i=0;i&lt;k;i++)scanf("%lld",&amp;p[i]); for(i=0;i&lt;k;i++)&#123; jc[i][0]=1; for(j=1;j&lt;=1e5;j++)jc[i][j]=jc[i][j-1]*j%p[i]; &#125; s=(1&lt;&lt;n); for(i=0;i&lt;s;i++)&#123; cnt=1; temp=0; for(j=0;j&lt;n;j++)&#123; if(i&amp;(1&lt;&lt;j))&#123; cnt*=-1; temp+=v[j]+1; &#125; &#125; if(temp&gt;m)continue; for(j=0;j&lt;k;j++) ans[j]=(ans[j]+mul(cnt&lt;0?p[j]-1:1,lucas(m-temp+n-1,n-1,j),p[j]))%p[j]; &#125; printf("%lld\n",China(k,p,ans)); &#125; return 0;&#125; K 题目描述多次操作区间对最小值（定义为非零的最小值）取模，求取模前后该区间数的总和。 解题思路线段树，区间和为$0$时特判剪枝。 AC代码Click_To_View_Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt;#define N 200010typedef long long ll;struct SegmentTree&#123; int l,r; ll sum,min;&#125;t[N&lt;&lt;3];int n;ll a[N];ll minf(ll a,ll b)&#123; if(!a||!b)return b|a; return a&gt;b?b:a;&#125;void build(int p,int l,int r)&#123; if(l==r)&#123; t[p].l=t[p].r=l; t[p].min=t[p].sum=a[l]; return; &#125; t[p].l=l;t[p].r=r; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); t[p].sum=t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].sum; t[p].min=minf(t[p&lt;&lt;1].min,t[p&lt;&lt;1|1].min);&#125;ll query(int p,int l,int r)&#123; int L=t[p].l,R=t[p].r; if(l&gt;R||r&lt;L)return 0; if(l&lt;=L&amp;&amp;r&gt;=R)return t[p].sum; return query(p&lt;&lt;1,l,r)+query(p&lt;&lt;1|1,l,r);&#125;ll minquery(int p,int l,int r)&#123; int L=t[p].l,R=t[p].r; if(l&gt;R||r&lt;L)return 0; if(l&lt;=L&amp;&amp;r&gt;=R)return t[p].min; return minf(minquery(p&lt;&lt;1,l,r),minquery(p&lt;&lt;1|1,l,r));&#125;ll modify(int p,int l,int r,ll k)&#123; int L=t[p].l,R=t[p].r; if(l&gt;R||r&lt;L||!t[p].sum)return 0; if(L==R)return t[p].min=t[p].sum%=k; modify(p&lt;&lt;1,l,r,k);modify(p&lt;&lt;1|1,l,r,k); t[p].min=minf(t[p&lt;&lt;1].min,t[p&lt;&lt;1|1].min); t[p].sum=t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].sum; return t[p].min;&#125;void print()&#123; int i; for(i=1;i&lt;=44;i++) if(t[i].l)printf("%d %d %lld %lld\n",t[i].l,t[i].r,t[i].sum,t[i].min); printf("\n");&#125;int main()&#123; int q,i,l,r,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;q); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]); build(1,1,n); for(i=0;i&lt;q;i++)&#123; scanf("%d%d",&amp;l,&amp;r); ll mn=minquery(1,l,r); if(!mn)printf("0 0\n"); else&#123; printf("%lld ",query(1,l,r)); modify(1,l,r,mn); printf("%lld\n",query(1,l,r)); &#125; //print(); &#125; &#125; return 0;&#125; L 题目描述告诉每回合出现哪些神龙，每回合怎么得钱，买一个神龙一块钱，问多少回合能集齐要求的神龙。 解题思路二分答案。注意$p$爆$long long$。 AC代码Click_To_View_Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 100010int n,m,p,k,l;int a[N],b[N],tmp[N];int f(int x,int y)&#123;return x*m+y;&#125;//1-&gt;2int g(int x)&#123;return x/m;&#125;//2-&gt;1int seq[N];int jud(int num)&#123; int i,mx=f(num,0)-1; memset(seq,0,sizeof(seq)); memset(tmp,0,sizeof(tmp)); for(i=0;i&lt;l;i++)tmp[b[i]]++; for(i=mx;i&gt;=0;i--)&#123; if(tmp[a[i]])&#123; seq[g(i)]++; tmp[a[i]]--; &#125; &#125; for(i=0;i&lt;l;i++)if(tmp[b[i]])return 0; long long now=p; for(i=0;i&lt;num;i++)&#123; now-=seq[i]; if(now&lt;0)return 0; if(now&lt;l)now+=now/k+p; &#125; return 1;&#125;int main()&#123; int i,j,q,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;p,&amp;k,&amp;l); for(i=0;i&lt;n;i++)for(j=0;j&lt;m;j++)scanf("%d",&amp;a[f(i,j)]); for(i=0;i&lt;l;i++)scanf("%d",&amp;b[i]); int l=0,r=n; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(jud(mid))r=mid; else l=mid+1; &#125; if(!jud(l))l++; if(l&lt;=n)printf("%d\n",l); else printf("-1\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Contests</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.12-2019.1 TO-DO LIST 题解集]]></title>
    <url>%2F2019%2F03%2F11%2F2018.12-2019.1%20to-do%20list%20%E9%A2%98%E8%A7%A3%E9%9B%86%2F</url>
    <content type="text"><![CDATA[因为这只Potassium太摸了，需要写一点题解，以防做了的题白做。 AC自动机P3808 【模板】AC自动机（简单版）（完成时间：2018.12.06） 题目描述给定$n$个模式串和$1$个文本串，求有多少个模式串在文本串里出现过。 解题思路$AC$自动机模板题。那么我们首先考虑跑$n$次$kmp$ 由于前$n-1$个字符串可以建一颗字典树，所以确实可以在树上跑$kmp$。但显然仅仅这样做时间复杂度会非常之高，如何解决这个问题呢？ 回想一下，在进行$kmp$字符串匹配的时候，我们通过一个p指向模式串，枚举文本串的第i个数。而$next$（或者$fail$）数组存储的是，在当前节点后一位失配之后应当比较的位置的前一位，也就是$next[i]$表示了1~next[i]和i-next[i]-1~i这两段字符串完全匹配，在下一位失配的时候应当从继续。 举个例子，$aababaababb$。先给出其对应的next[i]值。 i 1 2 3 4 5 6 7 8 9 10 11 a[i] a a b a b a a b a b b next[i] 0 1 0 1 0 1 2 3 4 5 0 举个例子，$i=8$的时候，aab$ab$aab黑线标出的两段完全相等，用模式串比对到第九个如果失配可以直接跳回到$3$（即$next[8]$），这里用的是$p$作为已经比对过全部匹配的指向模式串的指针，而如果直接无法匹配，则直接跳回到原点（即$0$）。 那么在$AC$自动机里，这个原点便是$trie$的根节点，用$fail$边起到和$kmp$中$next$数组一样的效果，从一棵枝条跳到另一棵枝条上，保证了从根节点到$fail[p]$这段路和刚刚走过来这段路是完全匹配的。这样就大大减少了时间。 AC代码Click_To_View_Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;queue&gt;#define N 1000010using namespace std;int trie[N][27],tot;int fail[N],end[N];queue&lt;int&gt;Q;char a[N];void push()&#123;//把每个模式串加入字典树中 int i,p,now=0; for(i=0;a[i]!='\0';i++)&#123; p=a[i]-'a'; if(!trie[now][p])trie[now][p]=++tot; now=trie[now][p]; &#125; end[now]++;//以now为结尾的单词数&#125;void build()&#123;//建立fail边和辅助边 int i,v; for(i=0;i&lt;26;i++)if(trie[0][i])Q.push(trie[0][i]); while(!Q.empty())&#123; v=Q.front();Q.pop(); for(i=0;i&lt;26;i++)&#123; if(trie[v][i])fail[trie[v][i]]=trie[fail[v]][i],Q.push(trie[v][i]); //这个节点的失配节点指向上个节点失配节点的对应trie节点 //也就是在kmp算法中用的next[p]和p+1，把它看成一个链好理解一些 else trie[v][i]=trie[fail[v]][i]; //建立辅助边，防止遗漏（实质上建立了trie图） &#125; &#125;&#125;int query()&#123; int i,j,ans=0,now=0; for(i=0;a[i]!='\0';i++)&#123; now=trie[now][a[i]-'a']; for(j=now;j&amp;&amp;~end[j];j=fail[j])&#123; //顺着fail边走，防止遗漏与当前匹配串后缀相同的模式串 ans+=end[j]; end[j]=-1;//标记走过了，香港新闻产业剪枝 &#125; &#125; return ans;&#125;int main()&#123; int i,n; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%s",a),push(); build(); scanf("%s",a); printf("%d",query()); return 0;&#125; P3796 【模板】AC自动机（加强版）（完成时间：2018.12.06） 题目描述有$N$个由小写字母组成的模式串以及一个文本串$T$。每个模式串可能会在文本串中出现多次。你需要找出哪些模式串在文本串$T$中出现的次数最多。 解题思路魔改简单版。 $end[i]$表示以$i$结尾的单词标号。$query$一次后对答案排序，输出即可。 AC代码Click_To_View_Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#define N 100010using namespace std;struct Ans&#123; int num,i; bool operator&lt;(const Ans&amp;x)const&#123; return num&gt;x.num||(num==x.num&amp;&amp;i&lt;x.i); &#125;&#125;ans[500];char a[160][80];char b[N*10];int trie[26][N],end[N],fail[N],tot;queue&lt;int&gt;Q;void push(int x)&#123; int i,now=0; for(i=0;a[x][i]!='\0';i++)&#123; int p=a[x][i]-'a'; if(!trie[p][now])trie[p][now]=++tot; now=trie[p][now]; &#125; end[now]=x;&#125;void build()&#123; int i,now=0,v; for(i=0;i&lt;26;i++)if(trie[i][0])Q.push(trie[i][0]),fail[trie[i][0]]=0; while(!Q.empty())&#123; v=Q.front();Q.pop(); for(i=0;i&lt;26;i++)&#123; if(trie[i][v])&#123; fail[trie[i][v]]=trie[i][fail[v]]; Q.push(trie[i][v]); &#125;else trie[i][v]=trie[i][fail[v]]; &#125; &#125;&#125;void query()&#123; int i,j,now=0; for(i=0;b[i]!='\0';i++)&#123; now=trie[b[i]-'a'][now]; for(j=now;j;j=fail[j])ans[end[j]].num++; &#125;&#125;int main()&#123; int i,n; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; for(i=1;i&lt;=n;i++)&#123; scanf("%s",a[i]); ans[i].i=i; ans[i].num=0; push(i); &#125; build(); scanf("%s",b); query(); sort(ans+1,ans+1+n); printf("%d\n%s\n",ans[1].num,a[ans[1].i]); for(i=2;i&lt;=n;i++)&#123; if(ans[i].num^ans[i-1].num)break; printf("%s\n",a[ans[i].i]); &#125; memset(trie,0,sizeof(trie)); memset(end,0,sizeof(end)); memset(fail,0,sizeof(fail)); tot=0; &#125; return 0;&#125; P2444 [POI2000]病毒（完成时间：2018.12.06） 题目描述如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。 例如，如果${011, 11, 00000}$为病毒代码段，那么一个可能的无限长安全代码就是$010101$…。如果${01, 11, 000000}$为病毒代码段，那么就不存在一个无限长的安全代码。 请写一个程序，读入病毒代码，判断是否存在一个无限长的安全代码。 解题思路建立$trie$图，进行深搜，出现过的或者具有相同后缀的（$fail$边指向的）$01$串都不可以经过，如果能成一个环，那么就是一个可行的解。 AC代码Click_To_View_Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;stdlib.h&gt;using namespace std;#define N 2019&lt;&lt;5int trie[2][N],fail[N],vis[N];int rd[N];//记录路径经过的节点 int stop[N];//记录不可以走的点 int n,tot;char s[N];void push()&#123; int i,now=0; for(i=0;s[i];i++)&#123; if(!trie[s[i]-'0'][now])trie[s[i]-'0'][now]=++tot; now=trie[s[i]-'0'][now]; &#125; stop[now]=1;&#125;queue&lt;int&gt;Q;void build()&#123; int i,t,j; for(i=0;i&lt;2;i++)if(trie[i][0])Q.push(trie[i][0]); while(!Q.empty())&#123; t=Q.front();Q.pop(); for(j=0;j&lt;2;j++)&#123; if(trie[j][t])&#123; fail[trie[j][t]]=trie[j][fail[t]]; Q.push(trie[j][t]); if(stop[trie[j][fail[t]]])stop[trie[j][t]]=1; &#125;else trie[j][t]=trie[j][fail[t]]; &#125; &#125;&#125;void dfs(int x)&#123; if(rd[x])&#123; printf("TAK"); exit(0); &#125; if(stop[x]||vis[x])return; vis[x]=rd[x]=1; dfs(trie[0][x]);dfs(trie[1][x]); rd[x]=0;&#125;int main()&#123; int i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%s",s),push(); build(); dfs(0); printf("NIE"); return 0;&#125; 回文串P3805 【模板】manacher算法 （完成时间：2018.12.10） 题目描述给出一个只由小写英文字符组成的字符串S，求S中最长回文串的长度。 解题思路马拉车算法的思路是，遍历字符串，找到目前结束点最靠后的回文串，根据这个回文串的对称性，缩短时间。同时，为了避免讨论回文串中包含奇数与偶数个元素，加入一个特殊字符使最终回文串必为奇数。 AC代码Click_To_View_Code 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#define N 22000010char c,a[N]=&#123;'#'&#125;;int len[N],cnt=1;int min(int a,int b)&#123;return a&gt;b?b:a;&#125;void read()&#123;while((c=getchar())&gt;='a'&amp;&amp;c&lt;='z')a[cnt++]=c,a[cnt++]='#';&#125;//读入、构造，如"aaa"变为"#a#a#a" int main()&#123; int i,mr=0,mid,ans=0; //mr：maxright，当前回文串结束点最靠右的位置 read(); for(i=1;i&lt;cnt;i++)&#123; if(i&lt;mr)len[i]=min(len[2*mid-i],mr-i); //当i在mr左边时，根据对称性判断其最短回文串长度 // ---|--^------|-------^--| // --- 2mid-i mid i mr else len[i]=1;//否则初始化为1 while(a[i+len[i]]&amp;&amp;a[i+len[i]]==a[i-len[i]])len[i]++;//向左右两边拓展 if(i+len[i]&gt;mr)mr=i+len[i],mid=i;//更新mid，mr if(ans&lt;len[i]-1)ans=len[i]-1;//更新ans &#125; printf("%d",ans); return 0;&#125; P1872 回文串计数（完成时间：2018.12.11） 题目描述问一个字符串中有几对互不交叉（$l \leq r&lt;L\leq R$）的回文串。 解题思路最后的答案必然是枚举每一位作为分界线时候左边回文串个数和右边回文串个数的乘积之和。这里为了避免重复，在统计个数的时候，$l[i]$表示从$1$到$i-1$的左边回文串总个数，$r[i]$表示以$i$开头的回文串个数。最后的答案便是$\sum_{i=1}^{len} {l[i-1]*r[i]}$。 跑一边马拉车，顺带差分求两边前缀和即可。注意前缀和的意义，这里调了好久。 AC代码Click_To_View_Code 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#define N 4010int min(int a,int b)&#123;return a&gt;b?b:a;&#125;char a[N]=&#123;'#'&#125;,c;int mr,mid,len[N],L=1;long long ans,l[N],r[N]; int main()&#123; int i; while((c=getchar())&gt;='a'&amp;&amp;c&lt;='z')a[L++]=c,a[L++]='#'; for(i=1;i&lt;L;i++)&#123; if(mr&gt;i)len[i]=min(len[2*mid-i],mr-i); else len[i]=1; while(a[len[i]+i]&amp;&amp;a[len[i]+i]==a[i-len[i]])len[i]++; if(i+len[i]&gt;mr)mr=len[i]+i,mid=i; l[i/2]++;l[(i+len[i])/2]--; r[(i-len[i]+1)/2]++;r[(i+1)/2]--; &#125; L&gt;&gt;=1; for(i=1;i&lt;=L;i++)l[i]+=l[i-1],r[i]+=r[i-1]; for(i=1;i&lt;=L;i++)l[i]+=l[i-1]; for(i=1;i&lt;=L;i++)ans+=l[i-1]*r[i]; printf("%lld",ans); return 0;&#125; P4555 [国家集训队]最长双回文串 （完成时间：2018.12.10） 题目描述输入长度为$n$的串$S$，求$S$的最长双回文子串$T$即可将$T$分为两部分$X$，$Y$，（$|X|,| Y| \geq 1$）且$X$和$Y$都是回文串。 解题思路又是一道魔改$manacher$的水题。 两个回文串之间必然是马拉车算法中的特殊字符，可以用$l[i]$记录$i$左边最长回文串长度，$r[i]$记录右边最长回文串长度，再递推一下求和即可。注意最后枚举井号要从第二个到倒数第二个，因为每个回文串都不能是空串，否则比如$qwq$就过不了。 AC代码Click_To_View_Code 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#define N 200010int len[N],mr,mid,cnt=1,l[N],r[N],ans;char a[N]=&#123;'#'&#125;,c;int max(int a,int b)&#123;return a&gt;b?a:b;&#125;int min(int a,int b)&#123;return a&lt;b?a:b;&#125;int main()&#123; int i; while((c=getchar())&gt;='a'&amp;&amp;c&lt;='z') a[cnt++]=c,a[cnt++]='#'; for(i=1;i&lt;cnt;i++)&#123; if(mr&gt;i)len[i]=min(len[2*mid-i],mr-i); else len[i]=1; while(a[i+len[i]]&amp;&amp;a[i+len[i]]==a[i-len[i]])len[i]++; if(i+len[i]&gt;mr)mr=i+len[i],mid=i; r[i-len[i]+1]=max(r[i-len[i]+1],len[i]-1); l[i+len[i]-1]=max(l[i+len[i]-1],len[i]-1); &#125; for(i--;i;i--)l[i]=max(l[i],l[i+2]-2); for(i++;i&lt;cnt;i++)r[i]=max(r[i],r[i-2]-2); for(i=2;i&lt;cnt-2;i+=2)ans=max(ans,l[i]+r[i]); printf("%d",ans); return 0;&#125; P4987 回文项链 （完成时间：2018.12.11） 题目描述我们把项链看作一个$n$元环，记作$s$，环上每个结点由大写$’A’-‘Z’$中的一个字母组成。我们定义回文串为环上一个首尾不重叠的连续子串（即环上每个结点最多被使用一次），且满足存在一个回文中心$i$，使得$i$之前的若干个字符分别与其关于$i$中心对称的字符相同。 给定一个字符串，求出首尾相接后的环中，回文中心不同且长度为$l$的回文串个数。数据保证$l$是奇数。 解题思路既然有回文中心，那回文串的长度就必然是奇数。这时候直接加上头和尾跑马拉车即可，不需要更改原串。 AC代码Click_To_View_Code 12345678910111213141516171819#include&lt;stdio.h&gt;#define N 3000010int min(int a,int b)&#123;return a&gt;b?b:a;&#125;char a[N];int len[N],mr,mid,ans;int main()&#123; int i,n,l; scanf("%d%d%s",&amp;n,&amp;l,a); for(i=0;i&lt;n;i++)a[i+n*2]=a[i+n]=a[i]; for(i=0;i&lt;n*2;i++)&#123; if(mr&gt;i)len[i]=min(len[2*mid-i],mr-i); else len[i]=1; while(a[i+len[i]]&amp;&amp;a[i+len[i]]==a[i-len[i]])len[i]++; if(i+len[i]&gt;mr)mr=i+len[i],mid=i; if(i&gt;=n&amp;&amp;len[i]*2-1&gt;=l)ans++; &#125; printf("%d",ans); return 0;&#125; 博弈论P2197 【模板】nim游戏（完成时间：2018.12.07） 题目描述地上有$n$堆石子（每堆石子数量小于$10000$），每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这n堆石子的数量，他想知道是否存在先手必胜的策略。 解题思路呃，这… 设$a=\prod {i=1}^{n}x_i$（$x_i$为第$i$堆石子的个数），由于异或的特殊性，一个正数异或$0$不可能为$0$，而在石堆里总能找到一个堆，让这个堆减小一定数量，使得新形成的$a=0$。（通过二进制易证）（求解方法见下题） 所以这就转换成了一个$a=0$为$N$局面，$a\neq 0$为$P$局面的问题。 AC代码Click_To_View_Code 1234567891011#include&lt;stdio.h&gt;int t,a,n,m;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n);m=0; while(n--)scanf("%d",&amp;a),m^=a; printf("%s\n",m?"Yes":"No"); &#125; return 0;&#125; P1247 取火柴游戏（完成时间：2018.12.11） 题目描述输入$k$及$k$个整数$n_1$，$n_2$，…，$n_k$，表示有$k$堆火柴棒，第i堆火柴棒的根数为$n_i$；接着便是你和计算机取火柴棒的对弈游戏。取的规则如下：每次可以从一堆中取走若干根火柴，也可以一堆全部取走，但不允许跨堆取，也不允许不取。谁取走最后一根火柴为胜利者。 编一个程序，在给出初始状态之后，判断是先取必胜还是先取必败，如果是先取必胜，请输出第一次该如何取。如果是先取必败，则输出$“lose”$。 解题思路找到减少某一堆数量后异或值到零的并输出即可。 AC代码Click_To_View_Code 12345678910111213141516#include&lt;stdio.h&gt;int a[500010],i,n,m;int main()&#123; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]),m^=a[i]; if(!m)printf("lose"); else&#123; for(i=0;i&lt;n;i++)if(a[i]&gt;=(m^a[i]))&#123; printf("%d %d\n",a[i]-(m^a[i]),i+1); a[i]^=m; break; &#125; for(i=0;i&lt;n;i++)printf("%d ",a[i]); &#125; return 0;&#125; P4018 Roy&amp;October之取石子 （完成时间：2018.12.11） 题目描述共有$n$个石子，两人每次都只能取$p^k$个（$p$为质数，$k$为自然数，且$p^k$小于等于当前剩余石子数），谁取走最后一个石子，谁就赢了。 现在$October$先取，问她有没有必胜策略。 解题思路打个表发现，$123457$都可以一步表示出来，而$6$不可以，而$6$的任意倍数不可以被一步表示出来。于是$6$的倍数是必败态。 AC代码Click_To_View_Code 12345678910#include&lt;stdio.h&gt;int t,n;int main()&#123; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); printf("%s\n",n%6?"October wins!":"Roy wins!"); &#125; return 0;&#125; P4279 [SHOI2008]小约翰的游戏（完成时间：2018.12.11） 题目描述小约翰经常和他的哥哥玩一个非常有趣的游戏：桌子上有$n$堆石子，小约翰和他的哥哥轮流取石子，每个人取的时候，可以随意选择一堆石子，在这堆石子中取走任意多的石子，但不能一粒石子也不取，我们规定取到最后一粒石子的人算输。 小约翰相当固执，他坚持认为先取的人有很大的优势，所以他总是先取石子，而他的哥哥就聪明多了，他从来没有在游戏中犯过错误。小约翰一怒之前请你来做他的参谋。自然，你应该先写一个程序，预测一下谁将获得游戏的胜利。 解题思路奇数个$1$等价于$1$个$1$，偶数个$1$等价于没有$1$。 于是非$1$的堆数不为零的时候，可以按照$nim$游戏走，即若异或和$a\neq 0$则必胜，否则必败。 而如果所有的石子都是$1$个，$1$的个数为偶数的时候必胜。 AC代码Click_To_View_Code 12 P2599 [ZJOI2009]取石子游戏（完成时间：2018.12.12） 题目描述在研究过$Nim$游戏及各种变种之后，$Orez$又发现了一种全新的取石子游戏，这个游戏是这样的： 有$n$堆石子，将这$n$堆石子摆成一排。游戏由两个人进行，两人轮流操作，每次操作者都可以从最左或最右的一堆中取出若干颗石子，可以将那一堆全部取掉，但不能不取，不能操作的人就输了。 $Orez$问：对于任意给出一个初始一个局面，是否存在先手必胜策略。 解题思路AC代码Click_To_View_Code 12 P2575 高手过招（完成时间：2018.12.12） 题目描述$AKN$玩游戏玩累了，于是他开始和同伴下棋了，玩的是跳棋！对手是$wwx$！这两位上古神遇在一起下棋，使得棋局变得玄幻莫测，高手过招，必有一赢，他们都将用最佳策略下棋，现在给你一个$n*20$的棋盘，以及棋盘上有若干个棋子，问谁赢？$akn$先手！ 游戏规则是这样的：对于一个棋子，能将它向右移动一格，如果右边有棋子，则向右跳到第一个空格，如果右边没有空格，则不能移动这个棋子，如果所有棋子都不能移动，那么将输掉这场比赛。 解题思路AC代码Click_To_View_Code 12 FFTP1919 【模板】A*B Problem升级版（FFT快速傅里叶）（完成时间：2018.12.13） 题目描述给出两个$n$位$10$进制整数$x$和$y$，你需要计算$x*y$。 解题思路AC代码Click_To_View_Code 12 P3803 【模板】多项式乘法（FFT）（完成时间：2018.12.13） 题目描述给定一个$n$次多项式$F(x)$，和一个$m$次多项式$G(x)$。请求出$F(x)$和$G(x)$的卷积。 解题思路AC代码Click_To_View_Code 12 P3338 [ZJOI2014]力 （完成时间：2018.12.14） 题目描述给出n个数qi，给出Fj的定义如下： $F_j = \sum_{i&lt;j}\frac{q_i q_j}{(i-j)^2 }-\sum_{i&gt;j}\frac{q_i q_j}{(i-j)^2 }$ 令$E_i=F_i/q_i$，求$E_i$。 解题思路AC代码Click_To_View_Code 12 扫描线P1169 [ZJOI2007]棋盘制作 （完成时间：2018.12.14） 题目描述小$Q$找到了一张由$N×M$个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。小$Q$想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。 不过小$Q$还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积。 解题思路AC代码Click_To_View_Code 12 P2701 [USACO5.3]巨大的牛棚Big Barn （完成时间：2018.12.14） 题目描述农夫约翰想要在他的正方形农场上建造一座正方形大牛棚。他讨厌在他的农场中砍树，想找一个能够让他在空旷无树的地方修建牛棚的地方。我们假定，他的农场划分成 $N x N$ 的方格。输入数据中包括有树的方格的列表。你的任务是计算并输出，在他的农场中，不需要砍树却能够修建的最大正方形牛棚。牛棚的边必须和水平轴或者垂直轴平行。 解题思路AC代码Click_To_View_Code 12 P4147 玉蟾宫 （完成时间：2018.12.14） 题目描述这片土地被分成$N*M$个格子，每个格子里写着$R$或者$F$，$R$代表这块土地被赐予了$rainbow$，$F$代表这块土地被赐予了$freda$。现在$freda$要找一块矩形土地，要求这片土地都标着$F$并且面积最大。 解题思路AC代码Click_To_View_Code 12 汉诺塔相关P1242 新汉诺塔 （完成时间：2018.12.14） 题目描述设有$n$个大小不等的中空圆盘，按从小到大的顺序从$1$到$n$编号。将这$n$个圆盘任意的迭套在三根立柱上，立柱的编号分别为$A$、$B$、$C$，这个状态称为初始状态。 现在要求找到一种步数最少的移动方案，使得从初始状态转变为目标状态。 移动时有如下要求：一次只能移一个盘；不允许把大盘移到小盘上面。 解题思路AC代码Click_To_View_Code 12 P4285 [SHOI2008]汉诺塔（完成时间：2018.12.15） 题目描述假设给定了每种操作的优先级，计算按照上述策略操作汉诺塔移动所需要的步骤数。 解题思路AC代码Click_To_View_Code 12 状压DPP1896 [SCOI2005]互不侵犯（完成时间：2018.12.15） 题目描述解题思路AC代码Click_To_View_Code 12 P2051 [AHOI2009]中国象棋（完成时间：2018.12.15） 题目描述解题思路AC代码Click_To_View_Code 12 P2704 [NOI2001]炮兵阵地（完成时间：2018.12.16） 题目描述解题思路AC代码Click_To_View_Code 12 树形DPP2014 选课（完成时间：2018.12.17） 题目描述解题思路AC代码Click_To_View_Code 12 P1131 [ZJOI2007]时态同步（完成时间：2018.12.17） 题目描述解题思路AC代码Click_To_View_Code 12 P1352 没有上司的舞会（完成时间：2018.12.17） 题目描述解题思路AC代码Click_To_View_Code 12 二分图，网络流P3386 【模板】二分图匹配（完成时间：2018.12.19） 题目描述解题思路AC代码Click_To_View_Code 12 P1129 [ZJOI2007]矩阵游戏（完成时间：2018.12.24） 题目描述解题思路AC代码Click_To_View_Code 12 P1402 酒店之王（完成时间：2019.1.7） 题目描述解题思路AC代码Click_To_View_Code 12 难题·AlvinZH的青春记忆III（完成时间：2018.12.19） 题目描述解题思路AC代码Click_To_View_Code 12 基础内容填坑P2386 放苹果（完成时间：2018.12.17） 题目描述解题思路AC代码Click_To_View_Code 12 P1019 单词接龙（完成时间：2019.1.7） 题目描述解题思路AC代码Click_To_View_Code 12 P1309 瑞士轮（完成时间：2018.12.17） 题目描述解题思路AC代码Click_To_View_Code 12 P1108 低价购买（完成时间：2018.12.23） 题目描述解题思路AC代码Click_To_View_Code 12 P1282 多米诺骨牌（完成时间：2019.1.7） 题目描述解题思路AC代码Click_To_View_Code 12 P1063 能量项链（完成时间：2019.1.7） 题目描述解题思路AC代码Click_To_View_Code 12 DPP1850 换教室（完成时间：2019.1.26） 题目描述解题思路AC代码Click_To_View_Code 12 P2577 [ZJOI2005]午餐（完成时间：2019.1.9） 题目描述解题思路AC代码Click_To_View_Code 12 P2308 添加括号（完成时间：2019.1.9） 题目描述解题思路AC代码Click_To_View_Code 12 数论P5091 【模板】欧拉定理（完成时间：2018.12.28） 题目描述解题思路AC代码Click_To_View_Code 12 P4139 上帝与集合的正确用法（完成时间：2018.12.30） 题目描述解题思路AC代码Click_To_View_Code 12 P4525 【模板】自适应辛普森法（完成时间：2018.12.25）题目描述解题思路AC代码 P4526 【模板】自适应辛普森法2（完成时间：2018.12.26） 题目描述解题思路AC代码Click_To_View_Code 12 P2613 【模板】有理数取余（完成时间：2018.12.29） 题目描述解题思路AC代码Click_To_View_Code 12 线段树，树状数组P3372 【模板】线段树 1（完成时间：2019.1.7） 题目描述解题思路AC代码Click_To_View_Code 12 P3373 【模板】线段树 2（完成时间：2019.1.8） 题目描述解题思路AC代码Click_To_View_Code 12 P3374 【模板】树状数组 1（完成时间：2019.1.8） 题目描述解题思路AC代码Click_To_View_Code 12 P3368 【模板】树状数组 2（完成时间：2019.1.8） 题目描述解题思路AC代码Click_To_View_Code 12 P2023 [AHOI2009]维护序列（完成时间：2019.1.8） 题目描述解题思路AC代码Click_To_View_Code 12 P5057 [CQOI2006]简单题 （完成时间：2019.1.8） 题目描述解题思路AC代码Click_To_View_Code 12 P2574 XOR的艺术 （完成时间：2019.1.8） 题目描述解题思路AC代码Click_To_View_Code 12 P3834 【模板】可持久化线段树 1（主席树）（完成时间：2019.1.26） 题目描述解题思路AC代码Click_To_View_Code 12 P3919 【模板】可持久化数组（可持久化线段树/平衡树）（完成时间：2019.1.26） 题目描述解题思路AC代码Click_To_View_Code 12 差分，前缀和P1083 借教室（完成时间：2019.1.19） 题目描述解题思路AC代码Click_To_View_Code 12 树链剖分P3384 【模板】树链剖分（完成时间：2019.1.19） 题目描述解题思路AC代码Click_To_View_Code 12 平衡树P3369 【模板】普通平衡树（完成时间：2019.1.28） 题目描述解题思路AC代码Click_To_View_Code 12 P3391 【模板】文艺平衡树（Splay）（完成时间：2019.1.29） 题目描述解题思路AC代码Click_To_View_Code 12 P3835 【模板】可持久化平衡树（完成时间：2019.1.29） 题目描述解题思路AC代码Click_To_View_Code 12 P5055 【模板】可持久化文艺平衡树（完成时间：2019.1.31） 题目描述解题思路AC代码Click_To_View_Code 12]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[P2467 [SDOI2010]地精部落 题解（DP）]]></title>
    <url>%2F2019%2F03%2F10%2FP2467%2F</url>
    <content type="text"><![CDATA[题目链接P2467 [SDOI2010]地精部落 解题思路神仙题（？） 我太渣了一个多小时才想出来这题怎么做 第一感就是排列组合题目。然而怎么也想不出来正确的思路。 然后突然想到这个题好像是在DP练习场里头的，于是就做出来了。 设$f[i]$表示填到第$i$个数的时候，默认第一个数是山峰的时候（山谷也行，一样的）有多少种方法。显然，$12345$的方法和$14579$的方法种数是相同的，所以说$f[i]$也代表$i$个互不相同的数填成波浪形有多少种方法。 然后从$1$到$n$递推，枚举$i$这个数塞到第$j$个位置，也就是把前$i-1$个数弄成波浪形，后$i-j$个数弄成波浪形，把$i-1$个数分成$j-1$个和$i-j$个的两组一共有$c[i-1][j-1]$种方法，故有$f[i]= \sum_{j=1}^i f[j-1]·f[i-j]·c[i-1][j-1]$。 AC代码12345678910111213141516171819#include&lt;stdio.h&gt;long long n,p,f[4210],c[4210][4210]; int main()&#123; int i,j; f[0]=1; scanf("%lld%lld",&amp;n,&amp;p); for(i=0;i&lt;=n;i++)c[i][0]=1; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=i;j++)&#123; if(j%2)&#123; f[i]+=f[j-1]*f[i-j]%p*c[i-1][j-1]%p; f[i]%=p; &#125; c[i][j]=(c[i-1][j]+c[i-1][j-1])%p; &#125; &#125; printf("%lld",(f[n]&lt;&lt;1)%p); return 0;&#125; 滚动数组优化一下组合数：12345678910111213141516171819#include&lt;stdio.h&gt;long long n,p,f[4210],c[2][4210]; int main()&#123; int i,j,q=0; f[0]=c[0][0]=c[1][0]=1; scanf("%lld%lld",&amp;n,&amp;p); for(i=1;i&lt;=n;i++)&#123; q^=1; for(j=1;j&lt;=i;j++)&#123; if(j%2)&#123; f[i]+=f[j-1]*f[i-j]%p*c[q^1][j-1]%p; f[i]%=p; &#125; c[q][j]=(c[q^1][j]+c[q^1][j-1])%p; &#125; &#125; printf("%lld",(f[n]&lt;&lt;1)%p); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一枚蒟蒻的成长]]></title>
    <url>%2F2019%2F03%2F10%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%9E%9A%E8%92%9F%E8%92%BB%E7%9A%84%E6%88%90%E9%95%BF%2F</url>
    <content type="text"><![CDATA[没啥好看的，就是篇日记。 2018.06.30 怀着一颗好奇的心从MOOC学习C 2018.07.09 加入敲键盘行列，自此迈进了一个无底深渊（ 2018.07.10午 第一道橙题过河卒 2018.07.10晚 第一道黄题八皇后 2018.08.03 第一道绿题八百标兵奔北坡 2018.08.05 第一道蓝题余数求和 2018.08.07 第二道蓝题求正整数 2018.08.08 受扫雷游戏启发，自制第一个游戏–扫雷 2018.08.09-08.10 自制简陋实数四则运算计算器 2018.08.23 第三道蓝题仪仗队 2018.09.12第四道蓝题国王游戏 2018.09.26第五道蓝题靶型数独 2018.09.28第六道蓝题幻想迷宫 2018.09.30第七道蓝题创意吃鱼法， 第八道蓝题城堡 2018.10.03第一道紫题皇后游戏 2018.10.11第二道紫题房间最短路问题 2018.11.7第三道紫题方格取数问题 2018.11.12第四道紫题小Z的 k 紧凑数 2018.11.13第五道紫题000001 2018.11.20第六道紫题最长公共子序列 2018.11.21第七道紫题平衡点 2018.11.24第八道紫题最长不下降子序列问题 2018.12.9第九道紫题生成字符串 2018.12.10第十道紫题最长双回文串 2018.12.11第十一道紫题P1872 回文串计数，第十二道紫题P4987 回文项链，第十三道紫题P4279 [SHOI2008]小约翰的游戏 2018.12.12第十四道紫题P2599 [ZJOI2009]取石子游戏 2018.12.13第十五道紫题P3803 【模板】多项式乘法（FFT） 2018.12.14第十六道紫题P3338 [ZJOI2014]力 2018.12.15第十七道紫题P2051 [AHOI2009]中国象棋，第十八道紫题P4285 [SHOI2008]汉诺塔 2018.12.25第十九道紫题P4525 【模板】自适应辛普森法1 2018.12.27第二十道紫题P4526 【模板】自适应辛普森法2 2018.12.28第二十一道紫题P5091 【模板】欧拉定理 2018.12.30第二十二道紫题P4139 上帝与集合的正确用法 2019.1.5第二十三道紫题P2529 [SHOI2001]击鼓传花，第二十四道紫题P2508 [HAOI2008]圆上的整点 2019.1.6第二十五道紫题CF1091D New Year and the Permutation Concatenation，第二十六道紫题CF1084B Kvass and the Fair Nut，第一道黑题CF1091E New Year and the Acquaintance Estimation，第二道黑题CF1091F New Year and the Mallard Expedition 2019.1.31第三道黑题P5055 【模板】可持久化文艺平衡树 2019.2.27第四道黑题P2783 有机化学之神偶尔会做作弊 2019.3.3第五道黑题P1763 蓄水池 2019.3.6第六道黑题P4847 银河英雄传说V2 2019.3.8 洛谷$AC500$ 路还在继续…… 青春如酒，成长正酣……]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.2-2019.3 TO-DO LIST]]></title>
    <url>%2F2019%2F03%2F10%2F2019.2-2019.3%20to-do%20list%2F</url>
    <content type="text"><![CDATA[做自己喜欢的事是自由，喜欢自己做的事是幸福。 算法模板复习 P3384 【模板】树链剖分 P3379 【模板】最近公共祖先（LCA） P3375 【模板】KMP字符串匹配 P3366 【模板】最小生成树 P5091 【模板】欧拉定理 P3835 【模板】可持久化平衡树 P3865 【模板】ST表 P3805 【模板】manacher算法 P3808 【模板】AC自动机（简单版） P2742 【模板】二维凸包 / [USACO5.1]圈奶牛Fencing the Cows P1919 【模板】A*B Problem升级版（FFT快速傅里叶） 2018.12-2019.1 TO-DO LIST 题解集锐意咕咕中.jpg DPP2723 丑数 Humble Numbers （完成时间：2019.3.1）P2725 邮票 Stamps （完成时间：2019.3.1）P1021 邮票面值设计 （完成时间：2019.3.1）P1070 道路游戏（完成时间：2019.3.2）P2558 [AHOI2002]网络传输（完成时间：2019.3.2）blog2（完成时间：2019.3.2）P2831 愤怒的小鸟（完成时间：2019.3.2）P3160 [CQOI2012]局部极小值 （完成时间：2019.3.3）P1763 蓄水池 （完成时间：2019.3.3）P1122 最大子树和（完成时间：2019.3.10）UVA1292 Strategic game（完成时间：2019.3.10）P2607 [ZJOI2008]骑士（完成时间：2019.3.10）P2467 [SDOI2010]地精部落（完成时间：2019.3.10）P2059 [JLOI2013]卡牌游戏（完成时间：2019.3.10） 数据结构SPFASPFA（完成时间：2019.2.17）P1841 [JSOI2007]重要的城市（完成时间：2019.2.17）P3385 【模板】负环（完成时间：2019.2.17） 差分约束P1993 小K的农场（完成时间：2019.2.25）P1250 种树)（完成时间：2019.2.25）P3084 [USACO13OPEN]照片Photo)（完成时间：2019.2.26） Tarjan，强连通分量P2194 HXY烧情侣（完成时间：2019.2.27）P3388 【模板】割点（割顶）（完成时间：2019.2.26）P2169 正则表达式（完成时间：2019.2.27）P3387 【模板】缩点（完成时间：2019.2.27）P2783 有机化学之神偶尔会做作弊（完成时间：2019.2.27）P1726 上白泽慧音（完成时间：2019.2.27）P2149 [SDOI2009]Elaxia的路线P1345 [USACO5.4]奶牛的电信Telecowmunication（完成时间：2019.2.28）P2341 [HAOI2006]受欢迎的牛（完成时间：2019.2.28）P3469 [POI2008]BLO-Blockade（完成时间：2019.2.28）P3119 [USACO15JAN]草鉴定Grass Cownoisseur （完成时间：2019.3.1）P2746 [USACO5.3]校园网Network of Schools（完成时间：2019.3.1） 并查集P1197 [JSOI2008]星球大战（完成时间：2019.2.6）P1196 [NOI2002]银河英雄传说（完成时间：2019.2.23） 堆P1801 黑匣子_NOI导刊2010提高（06）（完成时间：2019.2.28）P2278 [HNOI2003]操作系统（完成时间：2019.2.28）P1484 种树（完成时间：2019.3.1） 线段树，树状数组P1198 [JSOI2008]最大数（完成时间：2019.2.6）P2161 [SHOI2009]会场预约（完成时间：2019.2.6） 左偏树P3377 【模板】左偏树（可并堆）（完成时间：2019.3.5）P2713 罗马游戏 （完成时间：2019.3.5）P1456 Monkey King（完成时间：2019.3.5） 平衡树P4847 银河英雄传说V2（完成时间：2019.3.6） 网络流，二分图匈牙利算法（完成时间：2019.2.18）P1640 [SCOI2010]连续攻击游戏（完成时间：2019.2.18）P2764 最小路径覆盖问题（完成时间：2019.2.21）P1963 [NOI2009]变换序列（完成时间：2019.2.21）P2765 魔术球问题（完成时间：2019.2.21）P2763 试题库问题（完成时间：2019.2.22）P2526 [SHOI2001]小狗散步（完成时间：2019.2.22）P2756 飞行员配对方案问题 （完成时间：2019.2.23）P3381 【模板】最小费用最大流 （完成时间：2019.2.24）P2055 [ZJOI2009]假期的宿舍)（完成时间：2019.2.26） 基础P1268 树的重量（完成时间：2019.2.1）P1525 关押罪犯（完成时间：2019.2.1）P1983 车站分级（完成时间：2019.2.1）P2724 联系 Contact （完成时间：2019.3.1）P1092 虫食算（完成时间：2019.3.2） 怨念P3171 [CQOI2015]网络吞吐量 （完成时间：2019.3.7）P4847 银河英雄传说V2 （完成时间：2019.3.7）CF923B Producing Snow（完成时间：2019.3.6） 某些神奇的TODO名单P4777 【模板】扩展中国剩余定理（EXCRT）（完成时间：2019.2.22） 某些神奇的地方最短路+差分约束好博题解库洛谷日报LaTeX图论题画图处大佬]]></content>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My first blog]]></title>
    <url>%2F2019%2F03%2F09%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[啦啦啦，换到新的blog啦！ 原博客停用 标题一标题二标题三标题四标题五标题六 这是一段引用 123int mian()&#123;//这是一段代码 retrun 0;&#125; 这是一个链接 $\sum_{k|((1&lt;&lt;k)\&amp;S==0)}^{} {f[i-1][S-(1&lt;]}$ 嗯嗯 诶诶诶 黑体 斜体 a 道路千万条 你是第一条 第一条 -.- -。- 第二条~ 第三条 233 322 &lt;addr&gt; 233 $$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$ $$ \sideset{^1_2}{^3_4}\bigotimes $$ $$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$ $$\sqrt{2} \quad and \quad \sqrt[n]{3}$$ $$\vec{a} \cdot \vec{b}=0$$ $$\overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}$$ $$ \lim_{n \to +\infty} \frac{1}{n(n+1)}$$ $$\sum_{i=1}^n \frac{1}{i^2} \quad and \quad \prod_{i=1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i=1}^{2} R$$ $\smash{\displaystyle\max_{0 \leq q \leq n-1}} f(q) \le n$ $f(x + \epsilon) \approx f(x) + f’(x) \epsilon + \mathcal{O}(\epsilon^2).$ $\text{d}x$ $\lim_{n \to +\infty}{1^n}=1$]]></content>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
