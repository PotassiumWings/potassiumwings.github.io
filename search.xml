<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2020 CCPC Wannafly camp day7 题解]]></title>
    <url>%2F2020%2F02%2F03%2F2020ccpcwannaflycampday7%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L 11/12 O Ø O . O O O O Ø O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet coming soon 比赛链接 A 题目描述解题思路AC代码点击 12 B 题目描述解题思路AC代码点击 12 C 题目描述解题思路AC代码点击 12 D 题目描述解题思路AC代码点击 12 E 题目描述解题思路AC代码点击 12 F 题目描述解题思路AC代码点击 12 G 题目描述解题思路AC代码点击 12 H 题目描述解题思路AC代码点击 12 I 题目描述解题思路AC代码点击 12 J 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020 CCPC Wannafly camp day6 题解]]></title>
    <url>%2F2020%2F02%2F03%2F2020ccpcwannaflycampday6%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M N 13/14 O . O O Ø O O O O O O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet coming soon 比赛链接 A 题目描述解题思路AC代码点击 12 B 题目描述解题思路AC代码点击 12 C 题目描述解题思路AC代码点击 12 D 题目描述解题思路AC代码点击 12 E 题目描述解题思路AC代码点击 12 F 题目描述解题思路AC代码点击 12 G 题目描述解题思路AC代码点击 12 H 题目描述解题思路AC代码点击 12 I 题目描述解题思路AC代码点击 12 J 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020 CCPC Wannafly camp day5 题解]]></title>
    <url>%2F2020%2F02%2F03%2F2020ccpcwannaflycampday5%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 9/10 O O Ø Ø O . O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述有$k\in [1,3]$场比赛，$n\in [1,10^5]$个账号，给定每场比赛中出现的账号。一个人可以有多个号，但在一场比赛中只能最多使用一个号。问这$n$个账号里最少有多少人。 解题思路因为$k$很小，对$k$分类讨论。设参加的比赛集合为$S$的账号个数为$num[S]$。 $k=1$：所有参赛账号都是单独的人，答案为$num[1]$。 $k=2$：只参加第一场的和只参加第二场的合并，答案为$num[3]+max(num[2],num[1])$。 $k=3$：先把只参加一场的和只参加两场的合并，再把多出来的只参加一场的合并，实现时可以先把参加两场的全计入答案，然后把参加一场的对应减少，最后取$max$即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;int n,k,m,state[100010];int num[10];int main()&#123; int i; scanf("%d%d",&amp;n,&amp;k); for(i=0;i&lt;k;i++)&#123; scanf("%d",&amp;m); while(m--)&#123; int x; scanf("%d",&amp;x); state[x]+=1&lt;&lt;i; &#125; &#125; for(i=1;i&lt;=n;i++)num[state[i]]++; if(k==1)printf("%d\n",num[1]); else if(k==2)printf("%d\n",num[3]+max(num[1],num[2])); else&#123; int ans=0; for(i=0;i&lt;3;i++)&#123; int now=1&lt;&lt;i,op=(1&lt;&lt;3)-1-(1&lt;&lt;i); ans+=num[op]; if(num[op]&lt;=num[now])num[now]-=num[op]; else num[now]=0; &#125; printf("%d\n",ans+num[7]+max(max(num[1],num[2]),num[4])); &#125; return 0;&#125; B 题目描述有一个$n\leq 5\times 10^5$个点的树，点标号为$1,2,…,n$，每个点初始有一个集合$S_p=\text$。边为$p_1,p_2,…,p_{n-1}$，分别连接$u_i,v_i$。 进行$m$次操作，每次操作选一个$p_k$，使得$S_{u_i},S_{v_i}$改变为他们的并集。问最后对于每个$i$，出现在多少个集合中。 解题思路维护一个节点能够到达的集合大小$ans[p]$，从后向前递推并维护边对应历史大小即可。 AC代码点击 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 500010int ans[N],u[N],v[N],ind[N];int s[N];int main()&#123; int i,n,m; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)ans[i]=1; for(i=1;i&lt;n;i++)scanf("%d%d",&amp;u[i],&amp;v[i]); for(i=1;i&lt;=m;i++)scanf("%d",&amp;ind[i]); for(i=m;i;i--)&#123; int temp=ans[u[ind[i]]]+ans[v[ind[i]]]-s[ind[i]]; s[ind[i]]=ans[u[ind[i]]]=ans[v[ind[i]]]=temp; &#125; for(i=1;i&lt;=n;i++)printf("%d ",ans[i]); return 0;&#125; C 题目描述一棵可以随便搞孩子位置的线段树，$q$次区间查询，问最小的查询的线段树区间个数。 解题思路我们先假设，对于一个区间$[l,r]$内，每一个点$i\in [l,r]$对应的线段树区间（即节点长度为$1$的点）都会被查询到一次，记$w[l,r]$表示选择了线段树这个区间后对答案的贡献，有$w[i,i]++(i\in [l,r])$。 从$2$开始枚举线段树中的节点长度$len$，沿着线段树从底向上找，如果有区间$[L,R](L\neq R)\in[l,r]$，那么如果选择了这个区间，将可以少枚举一个子区间，对答案贡献$-1$；如果有区间$[L,R](L\neq R)\notin[l,r]$且$[L,R]$与$[l,r]$相交，那么需要访问该区间一次，而下面访问的次数并没有减少，于是对答案贡献$+1$。 算出贡献$w$之后，区间$dp$就可以了。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 520int w[N][N],f[N][N],d[N];int main()&#123; int i,j,k,n,m,l,r; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;l,&amp;r); d[l]++;d[r+1]--; w[1][l]++;w[l][l]--; w[1][n+1]--;w[l][n+1]++; w[l][r+1]++;w[l][n+1]--; w[r+1][r+1]--;w[r+1][n+1]++; w[l][l]--;w[l][r+1]++; w[r+1][l]++;w[r+1][r+1]--; &#125; for(i=1;i&lt;=n;i++)d[i]+=d[i-1]; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) w[i][j]+=w[i-1][j]+w[i][j-1]-w[i-1][j-1]; memset(f,0x3f,sizeof(f)); for(i=1;i&lt;=n;i++)w[i][i]=d[i],f[i][i]=d[i]; for(l=1;l&lt;n;l++)&#123; for(i=1;i+l&lt;=n;i++)&#123; int j=i+l,ans=1e8; for(k=i;k&lt;j;k++)ans=min(ans,f[i][k]+f[k+1][j]+w[i][j]); f[i][j]=ans; &#125; &#125; printf("%d",f[1][n]); return 0;&#125; D 题目描述有$n\leq 1000$个圆，每个圆有一定几率出现。问覆盖面积的期望。 解题思路1upsolved by qxforever 枚举每个圆$i$，对于和圆$i$相交的圆，记录下相交位置$p_j$，做一下前缀积就是这片圆弧出现在边界的概率。一个曲面的面积是绕着闭合曲线一周积分得到的，将每段弧的积分贡献加入即可求出。 比如当前积分区域$D$，圆弧集合为$C$： $S$ $=\iint_D1\text dx\text dy$ $=\frac 12\oint_Cx\text dy-y\text dx$ $=\sum_{c\in C}\frac 12\int_{\theta_1}^{\theta_{2}}(x_0+r_c\cos\theta)\text d(y_0+r_c\sin\theta)-(y_0+r_c\sin\theta)\text d(x_0+r_c\cos\theta)$ $=\sum_{c\in C}\frac 12\int_{\theta_1}^{\theta_{2}}((x_0+r_c\cos\theta)\cos\theta+(y_0+r_c\sin\theta)\sin\theta)\text d\theta$ $=\sum_{c\in C}\frac 12\int_{\theta_1}^{\theta_{2}}(x_0\cos\theta+y_0\sin\theta+r_c)\text d\theta$ AC代码 - by qxforever点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;double,double&gt; pdd;const double eps = 1e-10;const double pi = acos(-1.0);const double pi2 = 2*pi;const int maxn = 1e3+23;struct Point&#123; double x,y; Point(double x=0,double y=0):x(x),y(y) &#123;&#125; bool operator &lt; (const Point &amp;b) const &#123; return x&lt;b.x||(x==b.x&amp;&amp;y&lt;b.y); &#125;&#125;;typedef Point Vector;Point operator + (Point A,Point B)&#123;return Point(A.x+B.x,A.y+B.y);&#125;Point operator - (Point A,Point B) &#123;return Point(A.x-B.x,A.y-B.y);&#125;Point operator * (Point A,double B) &#123;return Point(A.x*B,A.y*B);&#125;Point operator / (Point A,double B) &#123;return Point(A.x/B,A.y/B);&#125;int dcmp(double x)&#123; if(fabs(x)&lt;eps) return 0; return x&lt;0 ? -1 : 1;&#125;bool operator == (const Point &amp;a,const Point &amp;b)&#123; return dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)==0;&#125; double dot(Vector a,Vector b)&#123; return a.x*b.x+a.y*b.y;&#125;double length(Vector a)&#123; return sqrt(dot(a,a));&#125;double angle(Vector v)&#123; return atan2(v.y,v.x);&#125;double cross(Vector a,Vector b)&#123; return a.x*b.y-a.y*b.x;&#125;struct Circle&#123; Point c;double r,p;double lg; Point point(double a) &#123; return Point(c.x+cos(a)*r,c.y+sin(a)*r); &#125; void read() &#123; //scanf("%lf%lf%lf",&amp;c.x,&amp;c.y,&amp;r);p=1000; scanf("%lf%lf%lf%lf",&amp;c.x,&amp;c.y,&amp;r,&amp;p); p=1-p/1000; &#125; double oint(double t1,double t2) &#123; return r*(r*(t2-t1)+c.x*(sin(t2)-sin(t1))-c.y*(cos(t2)-cos(t1))); &#125; bool operator &lt; (const Circle rhs) const &#123; return c&lt;rhs.c||(c==rhs.c&amp;&amp;r&lt;rhs.r); &#125; bool operator == (const Circle rhs) const &#123; return c==rhs.c&amp;&amp;(dcmp(r-rhs.r)==0); &#125;&#125;a[maxn];pdd p[maxn&lt;&lt;2];int cnt;double pb,base;void getCircleIntersection(const Circle &amp;C1,const Circle &amp;C2)&#123; double d=length(C1.c-C2.c); if((C1.r+C2.r-d)&lt;=0||C1.r-C2.r-d&gt;=0)&#123; return ; &#125; if(((C2.r-C1.r)-d)&gt;=0) &#123;base*=C2.p;return ;&#125; double a=angle(C2.c-C1.c); double da=acos((C1.r*C1.r+d*d-C2.r*C2.r)/(2*C1.r*d)); double l=a-da,r=a+da; if(l&lt;-pi) l+=pi2; if(r&gt;=pi) r-=pi2; if(l&gt;r) pb+=C2.lg; p[cnt++]=&#123;l,C2.lg&#125;; p[cnt++]=&#123;r,-C2.lg&#125;;&#125;int n; double cal(int x)&#123; double ans=0;cnt=1;pb=0,base=1; p[0].first=-pi; for(int i=1;i&lt;=n;i++)&#123; if(i==x) continue; getCircleIntersection(a[x],a[i]); &#125; p[cnt++].first=pi; sort(p+1,p+cnt-1); for(int i=1;i&lt;cnt;i++)&#123; ans+=(long double)exp(pb)*a[x].oint(p[i-1].first,p[i].first); pb+=p[i].second; &#125; return base*ans*(1-a[x].p);&#125; int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) a[i].read(); sort(a+1,a+1+n); for(int i=1;i&lt;=n;i++)&#123; if(a[i]==a[i+1]) a[i+1].p*=a[i].p; &#125; int m=0; for(int i=1;i&lt;=n;i++) if(!(a[i]==a[i+1])) a[++m]=a[i]; n=m; for(int i=1;i&lt;=n;i++)&#123; a[i].lg=log(a[i].p&lt;eps?eps:a[i].p); &#125; double ans=0; for(int i=1;i&lt;=n;i++) ans+=cal(i); printf("%.10f",ans/2);&#125; 解题思路2 - by nikkukun定义$f(x)$为在$x$处的线段长度，对任意$x$，$f(x)$是可以线性求出的，对$f(x)$自适应辛普森积分即可。 AC代码 - 没补点击 12 E 题目描述给定一个长度为$n$的序列$a$，以及长度为$4$的序列$b$，问$a$有多少子序列$(x_1,x_2,x_3,x_4)$满足：$\forall i,j\in [1,n]$，$x_i=x_j$当且仅当$b_i=b_j$。 解题思路solved by qxforever 暴力枚举前三个元素，第四个元素用前缀和处理一下即可。 AC代码 - by qxforever点击 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 323;int a[maxn],b[5];int pre[maxn][maxn];int n; int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) scanf("%d",a+i); for(int i=1;i&lt;=4;i++) scanf("%d",b+i); for(int i=1;i&lt;=n;i++)&#123; pre[i][a[i]]++; for(int j=1;j&lt;=n;j++) pre[i][j]+=pre[i-1][j]; &#125; ll ans=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; if((a[i]==a[j])!=(b[1]==b[2])) continue; for(int k=j+1;k&lt;=n;k++)&#123; if((a[i]==a[k])!=(b[1]==b[3])) continue; if((a[j]==a[k])!=(b[2]==b[3])) continue; //printf("%d %d %d ",a[i],a[j],a[k]); if(b[1]==b[4]) ans+=pre[n][a[i]]-pre[k][a[i]]; else if(b[2]==b[4]) ans+=pre[n][a[j]]-pre[k][a[j]]; else if(b[3]==b[4]) ans+=pre[n][a[k]]-pre[k][a[k]]; else&#123; int t=n-k-(pre[n][a[i]]-pre[k][a[i]])-(pre[n][a[j]]-pre[k][a[j]])-(pre[n][a[k]]-pre[k][a[k]]); if(b[1]==b[2]) t+=(pre[n][a[i]]-pre[k][a[i]]); if(b[3]==b[1]||b[3]==b[2]) t+=(pre[n][a[k]]-pre[k][a[k]]); ans+=t; &#125; //printf("%lld\n",ans); &#125; &#125; &#125; cout&lt;&lt;ans;&#125; F 题目描述解题思路AC代码点击 12 G 题目描述定义$f(x)$为$x$在模$p$意义下的逆元。 给定$p$，求出所有满足$2\leq x\leq p,f(x)=min_{k=2}^{x}f(k)$的$x$。 解题思路从底向上枚举$i$，有$f(f(i))=i$，同时维护左、右端点即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;ll mod;int iv[1000000];int main()&#123; int i,t; iv[0]=iv[1]=1; scanf("%d",&amp;t); while(t--)&#123; scanf("%lld",&amp;mod); vector&lt;pair&lt;int,int&gt;&gt;ans; vector&lt;pair&lt;int,int&gt;&gt;rans; ll mnnum=1e10; for(i=2;i&lt;mod;i++)&#123; int inv=(mod-mod/i)*iv[mod%i]%mod; iv[i]=inv; if(i&gt;inv)break; if(inv&lt;mnnum)&#123; ans.push_back(make_pair(inv,i)); if(i!=inv)rans.push_back(make_pair(i,inv)); mnnum=inv; &#125; &#125; printf("%d\n",ans.size()+rans.size()); for(auto i=rans.begin();i!=rans.end();i++)&#123; printf("%d %d\n",(*i).first,(*i).second); &#125; for(auto i=ans.rbegin();i!=ans.rend();i++)&#123; printf("%d %d\n",(*i).first,(*i).second); &#125; &#125; return 0;&#125; H 题目描述构造三个在一个球上的整数点，满足坐标绝对值不超过$1e6$、原点距离该平面不超过$1e-18$、把球化作单位球后三点间距离均大于$1.7$。 解题思路solved by nikkukun 均摊一下然后随机抖动搜索出结果即可。 AC代码 - by nikkukun点击 12345678910#include&lt;bits/stdc++.h&gt;using namespace std; int main()&#123; cout &lt;&lt; "333337 -666670 333333\n"; cout &lt;&lt; "333330 333338 -666668\n"; cout &lt;&lt; "-666663 333332 333331\n"; return 0;&#125; I 题目描述给一个$n\times n$矩阵，先来$m_1$次操作，每次操作把一个矩形内加上$w$，再来$m_2$次操作，每次询问区间最值。 解题思路先构造好矩阵后二维线段树查询即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;int n,m1,m2;#define N 8010ll v[N][N];ll mx[N][N];int L[N],R[N];void pushupx(int p,int x)&#123; mx[x][p]=max(mx[x&lt;&lt;1][p],mx[x&lt;&lt;1|1][p]); if(L[p]==R[p])return; pushupx(p&lt;&lt;1,x); pushupx(p&lt;&lt;1|1,x);&#125;void buildy(int p,int x,int l,int r)&#123; if(l==r)&#123; mx[x][p]=v[L[x]][l]; return; &#125; buildy(p&lt;&lt;1,x,l,(l+r)&gt;&gt;1); buildy(p&lt;&lt;1|1,x,((l+r)&gt;&gt;1)+1,r); mx[x][p]=max(mx[x][p&lt;&lt;1],mx[x][p&lt;&lt;1|1]);&#125;void buildx(int p,int l,int r)&#123; if(l==r)&#123; buildy(1,p,1,n); return; &#125; buildx(p&lt;&lt;1,l,(l+r)&gt;&gt;1); buildx(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); pushupx(1,p);&#125;ll queryy(int p,int x,int l,int r)&#123; if(L[p]&gt;r||R[p]&lt;l)return 0; if(l&lt;=L[p]&amp;&amp;R[p]&lt;=r)return mx[x][p]; return max(queryy(p&lt;&lt;1,x,l,r),queryy(p&lt;&lt;1|1,x,l,r));&#125;ll queryx(int p,int l,int r,int y1,int y2)&#123; if(L[p]&gt;r||R[p]&lt;l)return 0; if(l&lt;=L[p]&amp;&amp;R[p]&lt;=r)return queryy(1,p,y1,y2); return max(queryx(p&lt;&lt;1,l,r,y1,y2),queryx(p&lt;&lt;1|1,l,r,y1,y2));&#125;void init(int p,int l,int r)&#123; L[p]=l;R[p]=r; if(l==r)return; init(p&lt;&lt;1,l,(l+r)&gt;&gt;1); init(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r);&#125;int main()&#123; int i,j,x1,x2,y1,y2,w; scanf("%d%d%d",&amp;n,&amp;m1,&amp;m2); init(1,1,n); while(m1--)&#123; scanf("%d%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;w); v[x1][y1]+=w;v[x1][y2+1]-=w; v[x2+1][y1]-=w;v[x2+1][y2+1]+=w; &#125; for(i=1;i&lt;=n;i++)for(j=1;j&lt;=n;j++)v[i][j]+=v[i-1][j]+v[i][j-1]-v[i-1][j-1]; buildx(1,1,n); while(m2--)&#123; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); printf("%lld\n",queryx(1,x1,x2,y1,y2)); &#125; return 0;&#125; J 题目描述给定一个$n\times n$的印章，印章上的一些位置有凸起，当把印章往平面上按的时候，凸起部分的平面状态从$0$变为$1$或者反之。 印章扩展到无限大，平面也扩展到无限大。可以无限制按印章，对于$n\times n$的范围，问一共可以有多少种状态？ 解题思路solved by nikkukun 枚举印章左下角位置，其能够改变状态的点集为$s_{ij}$。由于所有状态都是由$s_{i_1j_1}\oplus s_{i_2j_2}\oplus…\oplus s_{i_kj_k}$产生的，即为一个异或和，故$s$的集合$S$的线性基个数即为答案。 用$bitset$可以维护这个线性基。 AC代码 - by nikkukun点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 14:16 - 14:25#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll; const int N = 32 + 5;const int S = 1024 + 5;const int MOD = 1e9 + 7;typedef bitset&lt;S&gt; bs; struct LBase&#123; bs b[S]; void Insert(bs x)&#123; for(int i=S-1; i&gt;=0; i--) if(x[i])&#123; if(b[i].none())&#123; b[i] = x; return; &#125;else x ^= b[i]; &#125; &#125; int Size()&#123; int cnt = 0; for(int i=S-1; i&gt;=0; i--) if(b[i].any()) cnt++; return cnt; &#125;&#125;; LBase lb;char g[N][N]; int main()&#123; ios::sync_with_stdio(0); int k; cin &gt;&gt; k; int n = 1 &lt;&lt; k; for(int i=0; i&lt;n; i++) for(int j=0; j&lt;n; j++) cin &gt;&gt; g[i][j]; for(int i=0; i&lt;n; i++) for(int j=0; j&lt;n; j++)&#123; bs b; for(int x=0; x&lt;n; x++) for(int y=0; y&lt;n; y++)&#123; int nx = (x + i) % n; int ny = (y + j) % n; int idx = nx * n + ny; b[idx] = g[x][y] - '0'; &#125; lb.Insert(b); &#125; int siz = lb.Size(); ll ans = 1; while(siz--) ans = ans * 2 % MOD; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020 CCPC Wannafly camp day3 题解]]></title>
    <url>%2F2020%2F01%2F25%2F2020ccpcwannaflycampday3%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 8/10 O . O O O O O Ø . Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述有$n(2\leq n\leq 1000)$个气球，分别有$h_i$的高度，给定$h_i+h_j=a_{ij}$的矩阵$A$，求$h$。保证答案唯一。 解题思路$n\geq 3$的时候，联立三个方程求解$h_1$，再求其他解。$n=2$时因为答案唯一，输出$\text{1 1}$。 AC代码点击 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 1010int h[N],a[N][N];int main()&#123; int i,j,n; scanf("%d",&amp;n); if(n==2)return printf("1 1"),0; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) scanf("%d",&amp;a[i][j]); h[1]=(a[1][3]+a[1][2]-a[2][3])/2; for(i=2;i&lt;=n;i++)h[i]=a[1][i]-h[1]; for(i=1;i&lt;=n;i++)printf("%d ",h[i]); return 0;&#125; B 题目描述解题思路AC代码点击 12 C 题目描述给定一个$n(1\leq n\leq 17)$点$m(1\leq m\leq 136)$边的无向图，现要对每个边定向，使之成为一个$DAG$并最小化最长路长度。求这个最小长度。 解题思路染色，连边时从颜色编号小连向颜色编号大，故最长路为最少染色数$-1$。染色通过状压$DP$，枚举合法子集标记，然后枚举状态和状态的子集转移即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N ((1&lt;&lt;18)+10)int f[N],g[N];int mt[20][20];int main()&#123; int i,j,k,n,m; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=m;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v);u--;v--; mt[u][v]=mt[v][u]=1; &#125; memset(g,0x3f,sizeof(g)); for(i=0;i&lt;(1&lt;&lt;n);i++) for(j=0;j&lt;n;j++) for(k=j+1;k&lt;n;k++) if((i&amp;(1&lt;&lt;j))&amp;&amp;(i&amp;(1&lt;&lt;k))&amp;&amp;mt[j][k])f[i]=1; g[0]=0; for(i=0;i&lt;(1&lt;&lt;n);i++) for(j=i;j;j=(j-1)&amp;i) if(!f[j])g[i]=min(g[i],g[i-j]+1); printf("%d",g[(1&lt;&lt;n)-1]-1); return 0;&#125; D 题目描述求$\sum_{i=1}^{n}f(i)$，其中$f(n)=\sum_{i=1}^{n}\sum_{j=1}^{n}gcd(i,j,n)$。 解题思路每次遇到数论题都不太会推式子，这里非常详细地推一遍。 $f(n)$ $=\sum_{d|n}\sum_{i=1}^{n}\sum_{j=1}^{n}d[gcd(i,j,n)==d]$ $=\sum_{d|n}\sum_{i=1}^{\frac nd}\sum_{j=1}^{\frac nd}d[gcd(i,j,\frac nd)==1]$ $=\sum_{d|n}\sum_{i=1}^{\frac nd}\sum_{j=1}^{\frac nd}d\epsilon (gcd(i,j,\frac nd))$ $=\sum_{d|n}\sum_{i=1}^{\frac nd}\sum_{j=1}^{\frac nd}d\sum_{e|(gcd(i,j,\frac nd))}\mu (e) $ $=\sum_{d|n}\sum_{i=1}^{\frac nd}\sum_{j=1}^{\frac nd}d\sum_{e|i,e|j,e|\frac nd}\mu (e) $ 上式有条件：$e|i,e|j,de|n,d|n$等价于：$e|i,e|j,e|n,de|n$ $=\sum_{e|n}\mu(e)\sum_{d|\frac ne}d\sum_{i=1}^{\frac nd}\sum_{j=1}^{\frac nd}[e|i,e|j]$ $=\sum_{e|n}\mu(e)\sum_{d|\frac ne}d\sum_{i=1}^{\frac n{de}}\sum_{j=1}^{\frac n{de}}1$ $=\sum_{e|n}\mu(e)\sum_{d|\frac ne}d(\frac n{de})^2$ 设$x=de$，条件$e|n,ed|n$变为$x|n,d|x$ $=\sum_{x|n}\sum_{d|x}(\frac nx)^2d\mu(\frac xd)$ $\mu\times id=\phi$ $=\sum_{x|n}(\frac nx)^2\phi(x)$ $=\sum_{x|n}x^2\phi(\frac nx)$ 于是 $\sum_{i=1}^{n}f(i)$ $=\sum_{i=1}^{n}\sum_{x|i}x^2\phi(\frac ix)$ $i=xk$ $=\sum_{x=1}^{n}x^2\sum_{k=1}^{\lfloor\frac nx\rfloor}\phi(\frac{xk}x)$ $=\sum_{x=1}^{n}x^2\sum_{k=1}^{\lfloor\frac nx\rfloor}\phi(k)$ 欧拉函数前缀和可以杜教筛，外层数论分块。 缺失知识点： $\mu\times I=\epsilon, \phi\times I=id,\mu\times id=\phi$ 另外，此题需要注意$mod$是质数，但不一定不是$2,3$，故在计算时需要避免使用逆元。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 5000000int pri[N],phi[N],cnt,isnp[N];int mod,n;void sieve()&#123; int i,j; isnp[0]=isnp[1]=1; phi[1]=1; for(i=2;i&lt;N;i++)&#123; if(!isnp[i])pri[cnt++]=i,phi[i]=i-1; for(j=0;j&lt;cnt;j++)&#123; if(1LL*i*pri[j]&gt;=N)break; isnp[i*pri[j]]=1; if(i%pri[j])phi[i*pri[j]]=phi[i]*(pri[j]-1)%mod; else&#123; phi[i*pri[j]]=phi[i]*pri[j]%mod; break; &#125; &#125; &#125; //for(i=1;i&lt;100;i++)printf("%d ",phi[i]); for(i=2;i&lt;N;i++)(phi[i]+=phi[i-1])%=mod;&#125;unordered_map&lt;int,ll&gt;ansphi;inline ll getsphi(ll n)&#123;//S=sum of f if(n&lt;N)return phi[n]; if(ansphi[n])return ansphi[n]; ll ans=(n*(n+1))/2%mod; register unsigned int l,r;//sum of f*g for(l=2;l&lt;=n;l=r+1)&#123; r=n/(n/l); (ans-=(r-l+1)*getsphi(n/l))%=mod;//sum of g(r-l),times S(n/l) &#125; return ansphi[n]=(ans%mod+mod)%mod;&#125;ll getsq(ll x)&#123;//x(x+1)(2x+1)/6 ll t=x*(x+1)/2; if(t%3)return (2*x+1)/3*(t%mod)%mod; else return t/3%mod*(2*x%mod+1)%mod;&#125;int main()&#123; int i,r; ll ans=0; scanf("%d%d",&amp;n,&amp;mod); sieve(); for(i=1;i&lt;=n;i=r+1)&#123; r=n/(n/i); (ans+=(getsq(r)-getsq(i-1))*getsphi(n/i))%=mod; &#125; printf("%lld",(ans+mod)%mod); return 0;&#125; E 题目描述两个人在下棋，都想让先手赢。棋盘是$n\times m$的黑白棋盘，每次可以翻转从左上角到任意点之间的矩形内的黑白情况，谁把棋盘全变白谁就赢，问先手能否赢。 解题思路两人都想让先手赢，所以除了左上角的格子都是可以控制黑白颜色的，但由于每回合左上角都会被翻一次，所以如果左上角是白色那么必输，否则必赢。 AC代码点击 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;char a[520][520];int main()&#123; int i,t,n,m; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)scanf("%s",a[i]); printf("%s\n",a[0][0]=='1'?"call":"aoligei"); &#125; return 0;&#125; F 题目描述给定一个数组$a$，求切成$k$段（每段非空），使得每段$[l_i,r_i]$内相同数对（$a_i=a_j,i\neq j,i,j\in[l_k,r_k]$）的数量之和最小，求这个最小值。 解题思路有显然$DP$：设$f[i][j]$表示到第$i$个元素，一共已经分成了$j$段的最小值。 $f[i][j]=min_{k&lt;i}(f[k][j-1]+cost(k,i))$，其中$cost(k,i)$表示$[k+1,i]$区间内数组$a$的相同数对个数。 固定第二维，显然有决策单调性。因为决策单调性优化$DP$的区间改动范围较小，$cost$用莫队即可求解。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 100010ll f[N][22];int n,k,a[N];int buc[N],pL,pR;ll AA;void upd(int x,ll f)&#123;AA+=f*(buc[x]-1ll)*buc[x]/2;&#125;ll calc(int l,int r)&#123; while(pL&lt;l)&#123; upd(a[pL],-1);buc[a[pL]]--; upd(a[pL],1);pL++; &#125; while(r&lt;pR)&#123; upd(a[pR],-1);buc[a[pR]]--; upd(a[pR],1);pR--; &#125; while(l&lt;pL)&#123; pL--; upd(a[pL],-1);buc[a[pL]]++; upd(a[pL],1); &#125; while(pR&lt;r)&#123; pR++; upd(a[pR],-1);buc[a[pR]]++; upd(a[pR],1); &#125; return AA;&#125;void solve(int l,int r,int pl,int pr,int now)&#123;//qiu f[mid]=f[p]...? if(l&gt;r||pl&gt;pr)return; int mid=(l+r)/2,nxt=0; for(int i=pl;i&lt;=pr;i++)&#123; ll tmp=calc(i+1,mid);//md if(f[i][now-1]+tmp&lt;f[mid][now])f[mid][now]=tmp+f[i][now-1],nxt=i; &#125; solve(l,mid-1,pl,nxt,now); solve(mid+1,r,nxt,pr,now);&#125;int main()&#123; int i,j; memset(f,0x3f,sizeof(f)); f[0][0]=0; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); pL=pR=1;buc[a[1]]++; for(i=1;i&lt;=k;i++)solve(1,n,0,n-1,i); printf("%lld",f[n][k]); return 0;&#125; G 题目描述给一棵$n$顶点的有权树，其中$k$个顶点为关键点。计算出$i(1\leq i\leq n)$为根节点时，遍历到所有关键点所需最少总权值。 解题思路答案显然为（$i$和关键点组成的生成树内权值之和）$*2-$距离$i$最远的关键点的距离。 树形$DP$求解，先解出$1$为根时，所有点对应子树有多少个关键点$sz[p]$，以及生成树内权值之和$sts[p]$（$\text{spanning tree sum}$），这样可以很容易通过换根时讨论子树大小求出每个点的$sts[p]$。 距离$p$最远的关键点距离：$md[p]=max(fadis[p],sondis[p])$，$sondis$可以通过预处理$DP$出。而$fadis$在$p$不是$fa[p]$的最远点对应节点时，为$max(fadis[fa[p]],sondis[fa[p]])+len(p,fa[p])$，否则为$max(fadis[fa[p]],\text{2nd}sondis[fa[p]])+len(p,fa[p])$，故需要再维护一下次大距离和最大距离对应的节点。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 500010int hd[N],cnt;struct Edge&#123; int e,n,l;&#125;e[N&lt;&lt;1];int n,k,x,key[N];void add(int a,int b,int l)&#123;e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;e[cnt].l=l;&#125;ll sd[N],fd[N],md[N],sdd[N],son[N],sz[N],sts[N];void dfs4dis(int p,int f)&#123; int i; sd[p]=sdd[p]=-1e16;son[p]=sz[p]=0; if(key[p])sz[p]=1,sd[p]=0,son[p]=p;//我 是 我 儿 子 for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q==f)continue; dfs4dis(q,p); if(sz[q])sts[x]+=e[i].l,sz[p]+=sz[q]; if(sd[q]+e[i].l&gt;sd[p])&#123; sdd[p]=sd[p]; sd[p]=sd[q]+e[i].l; son[p]=q; &#125;else if(sd[q]+e[i].l&gt;sdd[p])sdd[p]=sd[q]+e[i].l; &#125;&#125;void dfs4sts(int p,int f)&#123; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q==f)continue; if(sz[q]==k)sts[q]=sts[p]-e[i].l; else if(sz[q])sts[q]=sts[p]; else sts[q]=sts[p]+e[i].l; dfs4sts(q,p); &#125;&#125;void dfs4md(int p,int f)&#123; int i; md[p]=max(fd[p],sd[p]); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q==f)continue; if(q==son[p])fd[q]=max(fd[p],sdd[p])+e[i].l; else fd[q]=max(fd[p],sd[p])+e[i].l; dfs4md(q,p); &#125;&#125;int main()&#123; int i; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;n;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w);add(v,u,w); &#125; while(k--)scanf("%d",&amp;x),key[x]=1; dfs4dis(x,0); dfs4sts(x,0); dfs4md(x,0); for(i=1;i&lt;=n;i++)printf("%lld\n",2*sts[i]-md[i]); return 0;&#125; H 题目描述给一个长度为$n$的序列$a$，序列中的数互不相同。定义$g(x,y)$为序列删去了$[x,y]$区间之后的最大的$gcd$值，定义当删到只剩下$\leq 1$个元素时，$g(x,y)=0$。求$\sum_{i=1}^{n}\sum_{j=i}^{n}g(i,j)$。 解题思路从大到小枚举$\gcd$为$g$的时候对答案的贡献。找到序列中$g$的倍数的下标，组成递增序列$v_1,v_2,…,v_k$，如果有这些数里的至少两个没被删掉，那么剩余区间的$\gcd$必然$\geq g$。 不妨先假设现在枚举的是最大的$\gcd$，即剩余区间的$\gcd=g$。 设$R[i]$表示以$i$为左端点、右端最大能删到哪里能够使剩余区间$\gcd=g$，那么必然有 $i\in[1,v_1],R[i]=max(R[i],v_{k-1}-1)$ $i\in [v_1+1,v_2],R[i]=max(R[i],v_k-1)$ $i\in [v2+1,n],R[i]=max(R[i],n)$ 初始化$R[i]=i-1$。 于是每次进行这样的操作，计算出两次操作间相差了多少个区间，计算求和即可。 这种操作需要：区间置$max$；区间求和。 这怎么搞.jpg 好，学到一手神秘还复杂度正确的操作。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 200010int a[N],pos[N];ll sum[N&lt;&lt;2];int lazy[N&lt;&lt;2],mn[N&lt;&lt;2],se[N&lt;&lt;2],cnt[N&lt;&lt;2],L[N&lt;&lt;2],R[N&lt;&lt;2];vector&lt;int&gt;v[N];#define mid ((l+r)&gt;&gt;1)#define ls (p&lt;&lt;1)#define rs (p&lt;&lt;1|1)void pushup(int p)&#123; if(ls==rs)return; sum[p]=sum[ls]+sum[rs]; if(mn[ls]==mn[rs])&#123; mn[p]=mn[ls]; se[p]=min(se[ls],se[rs]); cnt[p]=cnt[ls]+cnt[rs]; &#125;else if(mn[ls]&lt;mn[rs])&#123; mn[p]=mn[ls]; se[p]=min(mn[rs],se[ls]); cnt[p]=cnt[ls]; &#125;else&#123; mn[p]=mn[rs]; se[p]=min(mn[ls],se[rs]); cnt[p]=cnt[rs]; &#125;&#125;void puttag(int p,int tag)&#123;//set min to tag if(mn[p]&gt;=tag)return; sum[p]+=1LL*(tag-mn[p])*cnt[p]; mn[p]=lazy[p]=tag;&#125;void pushdown(int p)&#123; if(lazy[p]==-1)return; puttag(ls,lazy[p]); puttag(rs,lazy[p]); lazy[p]=-1;&#125;void build(int p,int l,int r)&#123; lazy[p]=-1; L[p]=l;R[p]=r; if(l==r)&#123; mn[p]=sum[p]=l-1; se[p]=1e9; cnt[p]=1; return; &#125; build(p&lt;&lt;1,l,mid); build(p&lt;&lt;1|1,mid+1,r); pushup(p);&#125;void modify(int p,int l,int r,int x)&#123; if(L[p]&gt;r||R[p]&lt;l)return; if(mn[p]&gt;=x)return; if(l&lt;=L[p]&amp;&amp;R[p]&lt;=r&amp;&amp;se[p]&gt;=x)&#123; puttag(p,x); return; &#125; pushdown(p); modify(p&lt;&lt;1,l,r,x); modify(p&lt;&lt;1|1,l,r,x); pushup(p);&#125;int main()&#123; int i,j,t,n,g; scanf("%d",&amp;t); while(t--)&#123; ll ans=0; memset(pos,0,sizeof(pos)); scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),pos[a[i]]=i; build(1,1,n); for(i=1;i&lt;N;i++)&#123; v[i].clear(); for(j=i;j&lt;N;j+=i)if(pos[j])v[i].push_back(pos[j]); sort(v[i].begin(),v[i].end()); &#125; for(g=N-1;g;g--)&#123; ll lastsum=sum[1]; if(v[g].size()&lt;2)continue; int l1=v[g][0],l2=v[g][1],r1=v[g][v[g].size()-2],r2=v[g][v[g].size()-1]; modify(1,1,l1,r1-1); modify(1,l1+1,l2,r2-1); modify(1,l2+1,n,n); ans+=1LL*g*(sum[1]-lastsum); &#125; printf("%lld\n",ans); &#125; return 0;&#125; I 题目描述解题思路AC代码点击 12 J 题目描述对于字符串$s$和整数$k$，定义$f(s,k)$为，将$s$划分为至多$k$段$u_1,u_2,…,u_l$，最小化$max_{1\leq i\leq l}u_i$，求最小化的结果。 现在我们有一个字符串$S$，$q$次询问$f(s[l_i…|s|],k_i)$的值，每次询问输出一个区间$(a_i,b_i)$，表示$S[a_i…b_i]$。如果$a_i$有多个，输出$a_i$最小的解，要求$a_i\geq l_i$。 解题思路先学一手$Lyndon$分解： 定义一个串为$Lyndon$串，当且仅当这个字符串的所有后缀中字典序最小的是字符串本身。 对一个字符串$s$的$Lyndon$分解是存在且唯一的。 假设$s=s_1s_2s_3…s_k$，其中$s_i$为$Lyndon$串，且有$s_i\geq s_{i+1}$。 模板题链接 Lyndon分解（Duval算法）模板代码点击 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;char s[2000010];int main()&#123; int i,j,k,l; scanf("%s",s+1); l=strlen(s+1); for(i=1;i&lt;=l;)&#123; j=i,k=i+1; while(k&lt;=l&amp;&amp;s[k]&gt;=s[j])&#123; if(s[k]&gt;s[j])j=i; else j++; k++; &#125; while(i&lt;=j)&#123; printf("%d ",i+k-j-1);//每个lyndon串起始位置 i+=k-j; &#125; &#125; return 0;&#125; $Lyndon$分解还可以直接利用$Lyndon$串的性质（本身为最小的后缀），用后缀数组+单调栈求解。 对于本题，需要使用这种方法，因为需要知道以每个点开始的$Lyndon$串位置，且后面还需要用到$LCP$。 先找出$Lyndon$分解中$l$对应的下一个$Lyndon$串起始位置$r$，如果$lcp(suf(l),suf(r))=0$那么由$Lyndon$串性质，显然答案为$l,r-1$；否则中间可能会有一堆循环节，分类讨论循环节的个数能否整除、循环是否倒字符串结尾等即可。 具体讨论过程见图片： AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 100010char s[N];int n,sa[N],c[N],x[N],y[N];void getsa(int m)&#123; int i,k; for(i=0;i&lt;=m;i++)c[i]=0; for(i=1;i&lt;=n;i++)c[x[i]=s[i]]++;//also x[i]=s[i]-'a' for(i=1;i&lt;=m;i++)c[i]+=c[i-1]; for(i=n;i;i--)sa[c[x[i]]--]=i; for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int p=0; for(i=n-k+1;i&lt;=n;i++)y[++p]=i; for(i=1;i&lt;=n;i++)if(sa[i]&gt;k)y[++p]=sa[i]-k; for(i=0;i&lt;=m;i++)c[i]=0; for(i=1;i&lt;=n;i++)c[x[y[i]]]++; for(i=1;i&lt;=m;i++)c[i]+=c[i-1]; for(i=n;i;i--)sa[c[x[y[i]]]--]=y[i]; swap(x,y); p=x[sa[1]]=1; for(i=2;i&lt;=n;i++) x[sa[i]]=y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k]?p:++p; if(p&gt;=n)break; m=p; &#125;&#125;int h[N],rnk[N];void geth()&#123; int i,j,k=0; for(i=1;i&lt;=n;i++)rnk[sa[i]]=i; for(i=1;i&lt;=n;i++)&#123; if(k)k--; j=sa[rnk[i]-1]; while(s[i+k]==s[j+k])k++; h[rnk[i]]=k; &#125;&#125;int rmq[N][22],lg[N];void initlcp()&#123; int i,j; for(i=2;i&lt;N;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); getsa(260); geth(); for(i=1;i&lt;=n;i++)rmq[i][0]=h[i]; for(i=1;i&lt;=22;i++) for(j=1;j+(1&lt;&lt;i-1)&lt;=n;j++) rmq[j][i]=min(rmq[j][i-1],rmq[j+(1&lt;&lt;i-1)][i-1]);&#125;int getlcp(int x,int y)&#123; if(x==y)return n-x+1; if(rnk[x]&gt;rnk[y])swap(x,y); int l=rnk[x]+1,r=rnk[y]; int p=lg[r-l+1]; return min(rmq[l][p],rmq[r-(1&lt;&lt;p)+1][p]);&#125;int sta[N],top,nxt[N];int main()&#123; int i,q; scanf("%s%d",s+1,&amp;q); n=strlen(s+1); initlcp(); sta[top++]=n+1; for(i=n;i;i--)&#123; while(rnk[sta[top-1]]&gt;rnk[i])top--; nxt[i]=sta[top-1]; sta[top++]=i; &#125; while(q--)&#123; int r,l,k; scanf("%d%d",&amp;l,&amp;k); r=nxt[l]; if(k==1||r==n+1)printf("%d %d\n",l,n); else&#123; int lcp=getlcp(l,r); if(lcp==0)printf("%d %d\n",l,r-1); else&#123; int len=r-l,tot=lcp/len*len+len; if((tot/len)%k==0)&#123; if(l+tot==n+1)printf("%d %d\n",l,l+tot/k-1); else printf("%d %d\n",l+tot-tot/k,n); &#125;else printf("%d %d\n",l,l+((tot/len-1)/k+1)*len-1); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020 CCPC Wannafly camp day2 题解]]></title>
    <url>%2F2020%2F01%2F24%2F2020ccpcwannaflycampday2%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K 11/11 O Ø O O O Ø Ø O Ø O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给定字符串，随机取一个子串，计算元音字母占子串长度比的期望。 解题思路转化题意为求出所有子串中元音字母占子串长度比之和，除以子串个数。 枚举每个元音的贡献，设字符串$S=[S_1,S_2,…,S_l]$，$S_k$为元音，其总贡献即为$\sum_{i=1}^{k}\sum_{j=k}^{l}\frac 1{j-i+1}$，这个二维和可以通过维护$s(x)=\sum_{i=1}^{x}\frac 1x$的前缀和$t(x)=\sum_{i=1}^{x}s(x)$求出。 $\sum_{i=1}^{k}\sum_{j=k}^{l}\frac 1{j-i+1}$ $=\sum_{i=1}^{k}s(l-i+1)-s(k-i)$ $=t(l)-t(l-k)-t(k-1)$ AC代码点击 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 1000010char a[N];double s[N],s2[N];int main()&#123; int i,l; scanf("%s",a+1); l=strlen(a+1); for(i=1;i&lt;=l;i++)&#123; s[i]=s[i-1]+1.0/i; s2[i]=s2[i-1]+s[i]; &#125; double ans=0; for(i=1;i&lt;=l;i++)if(a[i]=='a'||a[i]=='e'||a[i]=='i'||a[i]=='o'||a[i]=='u'||a[i]=='y')ans+=s2[l]-s2[i-1]-s2[l-i]; printf("%.15f",ans/(l*(l+1.0)/2)); return 0;&#125; B 题目描述$x_1\oplus x_2\oplus…\oplus x_n=k$记为等式$1$，给定$x_i\in[0,m_i]$，给定$k$，求有多少种方法满足等式$1$。 解题思路数位$DP$。 从高到低枚举每一位，设当前枚举到第$k$位。设$f[i][j]$表示前$i$个$m_p$的第$k$位为$1$的数中，选了$j$个$x_p$的第$k$位为$1$的总方案数（不设置异或和限制），则对每一个第$k$位为$1$的$x_p$有显然转移： $f[i][j]=f[i-1][j-1]\times((x_p\text{&amp;}((1&lt;&lt;k)-1))+1)+f[i-1][j]\times(1&lt;&lt;k)$ 于是，设至少有一个在本位本来可以取$1$但是取$0$的数$x_l$，则其他位置怎么选都可以，但为了满足异或和为给定值$K$，$x_l$的值被确定，故$(count_k,j)$对答案的贡献为$\frac{f[i][j]}{2^k}$（$count_k$表示第$k$位为$1$的个数）。 如果可以全部取$1$，那么把$k-1$位当做最高位递归处理即可。枚举到$k&lt;0$时，显然有方案数为$1$。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 52const ll mod=1000000007;ll f[N][N],n,K,a[N];ll qp(ll a,ll p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,a=a*a%mod)if(p&amp;1)ans=ans*a%mod; return ans;&#125;ll solve(int k)&#123; int i=0,j,p; if(k&lt;0)return 1; memset(f,0,sizeof(f)); f[0][0]=1; for(p=0;p&lt;n;p++) if(a[p]&amp;(1&lt;&lt;k))&#123; i++; for(j=0;j&lt;=i;j++)&#123; if(j)f[i][j]=(f[i-1][j-1]*((a[p]&amp;((1&lt;&lt;k)-1))+1))%mod; (f[i][j]+=f[i-1][j]*(1&lt;&lt;k))%=mod; &#125; &#125;else for(j=0;j&lt;=i;j++)(f[i][j]*=(a[p]&amp;((1&lt;&lt;k)-1))+1)%=mod; ll ans=0,inv=qp(1&lt;&lt;k,mod-2); for(j=((K&gt;&gt;k)&amp;1);j&lt;i;j+=2) (ans+=f[i][j]*inv)%=mod; if(i==j)(ans+=solve(k-1))%=mod; return ans;&#125;int main()&#123; int i; while(~scanf("%lld%lld",&amp;n,&amp;K))&#123; for(i=0;i&lt;n;i++)scanf("%lld",&amp;a[i]); printf("%lld\n",solve(30)); &#125; return 0;&#125; C 题目描述$n$堆石子，第$i$堆有$a_i$个石子，对前$i$堆石子分别玩$Nim$游戏，分别求先手保证胜利情况下第一轮有多少种不同的取法。 解题思路solved by nikkukun 玩$Nim$游戏只要保证自己走完一步之后异或和为$0$即可。故设某次游戏中石子异或和为$x$，先手如果从第$p$堆石子里取，那么取完后该堆石子个数是$x\oplus a_p$，即（除了这堆石子以外的所有石子异或和）异或（这堆石子取完后剩余数量）为$0$。只要$a_p&gt;x\oplus a_p$即可，即$x$的二进制最高位位置$a_p$为$1$的$p$均可。故只需要动态求个前缀和。 AC代码点击 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;ll a[100010],b[62];int main()&#123; int i,j,n; ll x=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;a[i]); for(j=0;j&lt;60;j++)if((a[i]&gt;&gt;j)&amp;1)b[j]++; x^=a[i]; if(!x)printf("0\n"); else&#123; for(j=59;j&gt;=0;j--)if((x&gt;&gt;j)&amp;1)break; printf("%d\n",b[j]); &#125; &#125; return 0;&#125; D 题目描述给定一个字符串，求对于字符串每一个前缀，$mex(lcp(suffix(i),suffix(j))(1\leq i&lt;j\leq len))$。 解题思路设有效节点表示$endpos$集合包含当前字符串最后一位的位置的节点（即$\text{parent tree}$上从根到$cur$的一条链上的所有节点）。 容易想出，$SAM$上如果根节点有两个以上孩子，那么这个前缀存在$lcp(i,j)=0$的两个后缀，而对其他有效节点$p$，如果有有效孩子$son(p)$，那么说明该节点有 $s_{e_1+len(p)}\in endpos(p),s_{e_2+len(p)}\in endpos(p)$（$e_2+len(p)=len(s)$），而 $s_{e_1+len(p)}\notin endpos(son(p)),s_{e_2+len(p)}\in endpos(son(p))$。 于是$lcp(suffix(e_1),suffix(e_2))=len(p)$，也即$lcp(p,son(p))=len(p)$。 $upd:$队友@nikkukun指出我以前的算法错误，已经删掉 有牛逼结论：如果一个有孩子的节点$p$对应长度$len(p)\in lcp(i,j)$，那么$len(p)-1\in lcp(i,j)$。可以从直观角度理解一下： 若$lcp(suffix(a),suffix(b))=len$，则$lcp(suffix(a+1),suffix(b+1))=len-1$。 所以在动态插入的时候维护一下是否存在$lcp=0$、最大$len$为多少这两个即可均摊$O(n)$求解了。 AC代码1点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 1000010#define P 26char a[N];set&lt;int&gt;mex;struct SAM&#123; int tr[N&lt;&lt;1][P],fa[N&lt;&lt;1],len[N&lt;&lt;1],siz[N&lt;&lt;1]; int cnt,last,count; void init()&#123; cnt=last=1; count=0; memset(tr[1],0,sizeof(tr[1])); fa[1]=len[1]=0; &#125; void add(int c)&#123; int p=last,np=++cnt; memset(tr[cnt],0,sizeof(tr[cnt])); siz[np]=1; last=np; len[np]=len[p]+1; while(p&amp;&amp;!tr[p][c])tr[p][c]=np,p=fa[p]; if(!p)&#123; fa[np]=1; if(count&lt;2)&#123; count++; if(count==2)mex.insert(0); &#125; &#125; else&#123; int q=tr[p][c]; if(len[q]==len[p]+1)fa[np]=q,mex.insert(len[q]); else&#123; int nq=++cnt;len[nq]=len[p]+1; memcpy(tr[nq],tr[q],sizeof(tr[q])); fa[nq]=fa[q]; fa[q]=fa[np]=nq;mex.insert(len[nq]); while(tr[p][c]==q)tr[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void insert(char a[])&#123; int i,ans=0; for(i=0;a[i];i++)&#123; add(a[i]-'a'); while(mex.count(ans))ans++; printf("%d ",ans); &#125; puts(""); &#125;&#125;sam;int main()&#123; int i,T; scanf("%d",&amp;T); while(T--)&#123; scanf("%s",a); sam.init(); mex.clear(); sam.insert(a); &#125; return 0;&#125; AC代码2点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 1000010#define P 26char a[N];struct SAM&#123; int tr[N&lt;&lt;1][P],fa[N&lt;&lt;1],len[N&lt;&lt;1],siz[N&lt;&lt;1]; int cnt,last,count; int mxlen; void init()&#123; cnt=last=1; count=0; memset(tr[1],0,sizeof(tr[1])); fa[1]=len[1]=mxlen=0; &#125; void add(int c)&#123; int p=last,np=++cnt; memset(tr[cnt],0,sizeof(tr[cnt])); siz[np]=1; last=np; len[np]=len[p]+1; while(p&amp;&amp;!tr[p][c])tr[p][c]=np,p=fa[p]; if(!p)fa[np]=1,count++; else&#123; int q=tr[p][c]; if(len[q]==len[p]+1)fa[np]=q; else&#123; int nq=++cnt;len[nq]=len[p]+1; memcpy(tr[nq],tr[q],sizeof(tr[q])); fa[nq]=fa[q]; fa[q]=fa[np]=nq; while(tr[p][c]==q)tr[p][c]=nq,p=fa[p]; &#125; mxlen=max(mxlen,len[fa[np]]); &#125; &#125; void insert(char a[])&#123; int i,ans=0; for(i=0;a[i];i++)&#123; add(a[i]-'a'); if(count&lt;2)ans=0; else ans=mxlen+1; printf("%d ",ans); &#125; puts(""); &#125;&#125;sam;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; scanf("%s",a); sam.init(); sam.insert(a); &#125; return 0;&#125; E 题目描述定义树上一个节点的“结实程度”为，将这个节点的子树中的所有的节点编号拿出来之后，按照从小到大的顺序排列，然后将相邻元素做差之后求平方和。即假设子树的节点编号排序后的序列为$a_1,a_2,a_3,…,a_k$，这个节点的“结实程度”就是$\sum_{i=1}^{k-1}\left(a_{i+1}-a_i\right)^2$。求一棵树每个节点的”结实程度“。 解题思路直接启发式合并，维护时把节点丢进$set$处理即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 100010struct Edge&#123; int e,n;&#125;e[N];int hd[N],cnt;void add(int a,int b)&#123;e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;int siz[N],mxs[N];void dfs(int p)&#123; int i; siz[p]=1; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; dfs(q); siz[p]+=siz[q]; if(!mxs[p]||siz[mxs[p]]&lt;siz[q])mxs[p]=q; &#125;&#125;ll ans[N],ANS;set&lt;int&gt;S;void mdf(int p,int flag)&#123;//add/del p to/from S&amp;ANS int l=((!S.empty()&amp;&amp;*S.begin()&lt;p)?*(--S.lower_bound(p)):-1);//&lt;p max int r=((!S.empty()&amp;&amp;*--S.end()&gt;p)?*S.upper_bound(p):-1); int add=flag?1:-1; if(l==-1&amp;&amp;r!=-1)ANS+=add*(1LL*p-r)*(p-r); else if(l!=-1&amp;&amp;r==-1)ANS+=add*(1LL*p-l)*(p-l); else if(l!=-1&amp;&amp;r!=-1)ANS+=add*((1LL*p-l)*(p-l)+(1LL*p-r)*(p-r)-(1LL*l-r)*(l-r)); if(!flag)S.erase(p); else S.insert(p);&#125;void bf(int p,int flag)&#123; int i; mdf(p,flag); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; bf(q,flag); &#125;&#125;void dfs2(int p,int flag)&#123; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q!=mxs[p])dfs2(q,0); &#125; if(mxs[p])dfs2(mxs[p],1); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q!=mxs[p])bf(q,1); &#125; mdf(p,1); ans[p]=ANS; if(!flag)bf(p,0);&#125;int main()&#123; int i,n,f; scanf("%d",&amp;n); for(i=2;i&lt;=n;i++)&#123; scanf("%d",&amp;f); add(f,i); &#125; dfs(1); dfs2(1,1); for(i=1;i&lt;=n;i++)printf("%lld\n",ans[i]); return 0;&#125; F 题目描述在一棵树上，单点修改（在某点出现了$x$个新蘑菇），求从某处出发，采集到所有蘑菇所需的代价之和。从起点$v$收集在$u$节点的蘑菇所需代价定义为路径$(u,v)$上最靠近$v$的边的边权。 解题思路先考虑用某种方式维护子树和（即子树$p$的孩子个数）（比如用树状数组在$dfs$序上维护），询问时枚举起点所连边，边权$\times $对应子树和/父树和即可求出答案。 但这样显然会被菊花图卡掉。考虑枚举的时候只考虑重儿子、父亲、所有轻儿子三部分，在修改时不仅更新子树和，还更新所有影响到的“轻儿子”部分（每个链的$top$的父亲的”轻儿子“部分），容易证明修改到的数量是$\log n$的级别。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 1000010int n,cnt,hd[N];struct Edge&#123; int e,n,l;&#125;e[N&lt;&lt;1];void add(int a,int b,int l)&#123; e[++cnt].e=b; e[cnt].n=hd[a]; e[cnt].l=l; hd[a]=cnt;&#125;ll tosonlen[N],tofalen[N],lightsonsum[N];int depth[N],fa[N],size[N],son[N],top[N];void dfs1(int now,int f,int dep)&#123; depth[now]=dep; fa[now]=f; size[now]=1; int i,mx=0; for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=f)&#123; dfs1(p,now,dep+1); size[now]+=size[p]; if(size[p]&gt;mx)&#123; mx=size[p]; son[now]=p; &#125; &#125; &#125;&#125;void dfs2(int now,int Top)&#123; int i; top[now]=Top; if(son[now])dfs2(son[now],Top); for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=son[now]&amp;&amp;p!=fa[now])dfs2(p,p); else if(p==fa[now])tofalen[now]=e[i].l; else if(p==son[now])tosonlen[now]=e[i].l; &#125;&#125;int tot,dL[N],dR[N];void dfs(int p,int f)&#123;//full dfn dL[p]=++tot; int i; for(i=hd[p];i;i=e[i].n)if(e[i].e!=f)dfs(e[i].e,p); dR[p]=++tot;&#125;ll bit[N&lt;&lt;1];//mushroom count in subtree of p, dfn prefixvoid add(int p,int x)&#123;while(p&lt;N&lt;&lt;1)bit[p]+=x,p+=p&amp;(-p);&#125;ll query(int p)&#123; ll ans=0; if(p&lt;0)return 0; while(p)ans+=bit[p],p-=p&amp;(-p); return ans;&#125;int root=1,sum;/*int debugcnt[N];int dfs4debug(int p,int f)&#123; int i,ans=debugcnt[p]; for(i=hd[p];i;i=e[i].n) if(e[i].e!=f) ans+=dfs4debug(e[i].e,p); return ans;&#125;ll debug(int p)&#123; int i; ll ans=0; for(i=hd[p];i;i=e[i].n)ans+=1LL*e[i].l*dfs4debug(e[i].e,p); return ans;&#125;*/int main()&#123; int i,q; scanf("%d",&amp;n); for(i=1;i&lt;n;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w);add(v,u,w); &#125; dfs1(1,0,1); dfs2(1,1); dfs(1,0); scanf("%d",&amp;q); while(q--)&#123; int opt,v,x; scanf("%d%d",&amp;opt,&amp;v); if(opt==1)&#123; scanf("%d",&amp;x); sum+=x; //debugcnt[v]+=x; add(dR[v],x);//hard while(v)&#123; v=top[v]; lightsonsum[fa[v]]+=tofalen[v]*x; v=fa[v]; &#125; &#125;else root=v; ll ans=0; ans+=tofalen[root]*(sum-query(dR[root])+query(dL[root])); ans+=tosonlen[root]*(query(dR[son[root]])-query(dL[son[root]])); ans+=lightsonsum[root]; //if(ans!=debug(root)) printf("%lld\n",ans); &#125; return 0;&#125; G 题目描述平面上有一些白点和黑点，求白点内部连边、黑点内部连边，保证白点互相连通、黑点互相连通，且没有两条边在城镇点以外的地方相交。保证没有三点共线或重叠。 解题思路upsolved by qxforever 显然，凸包上必然是全黑/全白/一黑一白，不存在其余情况。 下面证明这三种情况必然能构造出连边方式： 先定义一个方法$work(w,b_1,b_2)$，表示白点$w$，黑点$b_1,b_2$（或$work(b,w_1,w_2)$）已经直接或间接相连，现在要把所有三角形内的白点同$w$相连，黑点同$b_1,b_2$相连。实现方式：如果三角形内存在白点$W$，那么连接$W,w$，执行$work(W,b_1,b_2),work(b_1,w,W),work(b_2,w,W)$；否则把所有黑点连向$b_1$即可。 对于全黑/全白两种情况，直接全连起来，枚举内部异色点$p$，不断调用$work(p,c_i,c_{i+1})$即可；否则把黑白分别相连然后找到凸包上分割黑白的点$p,q$，分别对两边剖成三角，分别进行$work$即可。 AC代码 - by qxforever点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;bits/stdc++.h&gt;using namespace std;const double pi = acos(-1.0);const double eps = 1e-8;typedef pair&lt;int,int&gt; pii;struct Point&#123; double x,y;int id,c; Point(double x=0,double y=0):x(x),y(y) &#123;&#125; bool operator &lt; (const Point &amp;b) &#123; return x&lt;b.x||(x==b.x&amp;&amp;y&lt;b.y); &#125; void read()&#123;scanf("%lf%lf",&amp;x,&amp;y);&#125;&#125;;typedef Point Vector;Point operator + (Point A,Point B)&#123;return Point(A.x+B.x,A.y+B.y);&#125;Point operator - (Point A,Point B) &#123;return Point(A.x-B.x,A.y-B.y);&#125;Point operator * (Point A,double B) &#123;return Point(A.x*B,A.y*B);&#125;Point operator / (Point A,double B) &#123;return Point(A.x/B,A.y/B);&#125;int dcmp(double x)&#123; if(fabs(x)&lt;eps) return 0; return x&lt;0 ? -1 : 1;&#125;bool operator == (const Point &amp;a,const Point &amp;b)&#123; return dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)==0;&#125; double dot(Vector a,Vector b)&#123; return a.x*b.x+a.y*b.y;&#125;double length(Vector a)&#123; return sqrt(dot(a,a));&#125;double angle(Vector a,Vector b)&#123; return acos(dot(a,b))/length(a)/length(b);&#125;double cross(Vector a,Vector b)&#123; return a.x*b.y-a.y*b.x;&#125; bool SegmentProperIntersection(Point a1,Point a2,Point b1,Point b2)&#123; double c1=cross(a2-a1,b1-a1),c2=cross(a2-a1,b2-a1); double c3=cross(b2-b1,a1-b1),c4=cross(b2-b1,a2-b1); return dcmp(c1)*dcmp(c2)&lt;0&amp;&amp;dcmp(c3)*dcmp(c4)&lt;0;&#125;int isPointInPolygon(Point p,Point* poly,int n)&#123; int wn=0; for(int i=0;i&lt;n;i++)&#123; int k=dcmp(cross(poly[(i+1)%n]-poly[i],p-poly[i])); int d1=dcmp(poly[i].y-p.y); int d2=dcmp(poly[(i+1)%n].y-p.y); if(k&gt;0&amp;&amp;d1&lt;=0&amp;&amp;d2&gt;0) wn++; if(k&lt;0&amp;&amp;d2&lt;=0&amp;&amp;d1&gt;0) wn--; &#125; if(wn!=0) return 1; return 0;&#125;int ConvexHull(Point *p,int n,Point *ch)&#123; sort(p,p+n); int m=0; for(int i=0;i&lt;n;i++)&#123; while(m&gt;1&amp;&amp;cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; int k=m; for(int i=n-2;i&gt;=0;i--)&#123; while(m&gt;k&amp;&amp;cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m;&#125;const int maxn = 3e3+23;Point a[maxn&lt;&lt;1],ch[maxn&lt;&lt;1];vector&lt;pii&gt; ans;int n,m;void work(Point x,Point y,Point z)&#123; //printf("%d %d %d\n",x.id,y.id,z.id); //ans.push_back(&#123;y.id,z.id&#125;); Point tmp[]=&#123;x,y,z&#125;,ch[5],t; ConvexHull(tmp,3,ch);ch[3]=ch[0]; bool f=true; for(int i=0;i&lt;n+m&amp;&amp;f;i++)&#123; if(a[i].c==x.c&amp;&amp;a[i].id!=x.id&amp;&amp;isPointInPolygon(a[i],ch,3)) f=false,t=a[i]; &#125; if(!f)&#123; work(t,y,z); ans.push_back(&#123;x.id,t.id&#125;);work(y,x,t); work(z,x,t); &#125; else&#123; vector&lt;Point&gt; p; for(int i=0;i&lt;n+m;i++)&#123; if(a[i].c==y.c&amp;&amp;a[i].id!=y.id&amp;&amp;a[i].id!=z.id&amp;&amp;isPointInPolygon(a[i],ch,3)) p.push_back(a[i]); &#125; for(Point i:p) ans.push_back(&#123;i.id,y.id&#125;); &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n+m;i++) a[i].read(),a[i].id=i,a[i].c=(i&gt;=n); int t=ConvexHull(a,n+m,ch);ch[t]=ch[0]; bool f=true; for(int i=0;i&lt;t;i++)&#123; if(ch[i].c!=ch[0].c) f=false; &#125; if(f)&#123; Point p; for(int i=0;i&lt;n;i++)&#123; if(a[i].c!=ch[0].c) p=a[i]; &#125; //printf("%.3f %.3f\n",p.x,p.y); for(int i=0;i&lt;t;i++) &#123; //cout&lt;&lt;i&lt;&lt;endl; //printf("%.3f %.3f\n",ch[i].x,ch[i].y); if(i!=t-1)ans.push_back(&#123;ch[i].id,ch[i+1].id&#125;); work(p,ch[i],ch[i+1]); &#125; &#125; else&#123; int c=0; for(int i=0;i&lt;t;i++)&#123; if(ch[i].c!=ch[i+1].c) c++; &#125; if(c&gt;2) return 0*printf("Poor Quailty"); int p=-1,q=-1; for(int i=0;i&lt;t;i++)&#123; if(ch[i].c!=ch[i+1].c) p&lt;0?p=i:q=i; &#125; for(int i=(p+1)%t;i!=q;i=(i+1)%t)&#123; ans.push_back(&#123;ch[i].id,ch[i+1].id&#125;); work(ch[p],ch[i],ch[i+1]); &#125; for(int i=(q+1)%t;i!=p;i=(i+1)%t)&#123; ans.push_back(&#123;ch[i].id,ch[i+1].id&#125;); work(ch[q],ch[i],ch[i+1]); &#125; &#125; //printf("ans.size : %u\n",ans.size()); sort(ans.begin(),ans.end()); //for(pii i:ans) printf("%d %d\n",i.first,i.second); for(int i=0;i&lt;n-1;i++) printf("%d %d\n",ans[i].first+1,ans[i].second+1); for(int i=n-1;i&lt;n+m-2;i++) printf("%d %d\n",ans[i].first+1-n,ans[i].second+1-n);&#125;/*3 45 00 5-5 01 11 2-1 1-1 2*/ H 题目描述一个长度为$ {n}$ 的序列$A$，元素的值域是$ {[1,m]}$。 对于任意$ x,y \in [1,m],x \neq y$，序列中存在一个位置 $p(1 \leq p &lt; n)$，满足$ {A[p]=x,A[p+1]=y}$或者 ${A[p+1]=x,A[p]=y}$。 给定$n$，求$m$最大值，并构造一个这样的序列。 解题思路转化成图论模型，是一个阶为$m$的完全图中，每一对$(u,v)$都经过的路径。 当$m$为奇数时，完全图每个节点的度即为偶数（$m-1$），直接求欧拉回路即可。 当$m$为偶数时，需要再连$\frac m2-1$条边形成一条欧拉路径。 欧拉回路求的时候用$cur[i]$代替$hd[i]$居然可以卡常数（赛时一直$TLE$，但因为情况比较少，手动构造过了 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;ll n,m;vector&lt;int&gt;ans;#define pb push_backbool check(ll x)&#123; return n&gt;=(x&amp;1?x*(x-1)/2+1:x*x/2);&#125;int main()&#123; scanf("%lld",&amp;n); ll L=0,R=2e9; while(R-L&gt;1)&#123; //cout&lt;&lt;R&lt;&lt;endl; ll mid=(L+R)/2; if(check(mid)) L=mid; else R=mid; &#125; m=L; printf("%lld\n",m); if(n&gt;2000000) return 0; if(m%2)&#123; if(m==1)return printf("1"),0; ans.pb(1);ans.pb(2);ans.pb(3);ans.pb(1); for(int o=4;o&lt;=m;o+=2)&#123; ans.pb(o); for(int p=2;p&lt;o;p+=2)&#123; ans.pb(p+1); ans.pb(o+1); ans.pb(p); ans.pb(o); &#125; ans.pb(o+1); ans.pb(1); &#125; &#125;else&#123; ans.pb(2);ans.pb(1); for(int o=3;o&lt;=m;o+=2)&#123; ans.pb(o); for(int p=2;p&lt;o;p++)&#123; ans.pb(p); ans.pb(o+((p%2)==0)); &#125; ans.pb(o); ans.pb(o+1); ans.pb(1); &#125; &#125; for(int i=0;i&lt;ans.size();i++)printf("%d%c",ans[i]," \n"[i==n-1]); for(int i=ans.size();i&lt;n;i++)printf("1%c"," \n"[i==n-1]); return 0;&#125; 直接求欧拉回路：（需要优化） AC代码2 - by qxforever点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int maxn = 2e6+23;const int N = 4e3;ll n,m;int cnt;int e[maxn&lt;&lt;1],hd[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1];int vis[maxn&lt;&lt;1];void add(int x,int y)&#123; e[++cnt]=y,nxt[cnt]=hd[x],hd[x]=cnt;&#125;int ans[maxn],tot; bool check(ll x)&#123; return n&gt;=(x&amp;1?x*(x-1)/2+1:x*x/2);&#125; int cur[maxn&lt;&lt;1]; inline void euler(int u)&#123; for(int i=cur[u];i;i=cur[u])&#123;//优化 cur[u]=nxt[i]; if(vis[i]) continue; vis[i]=vis[i+((i&amp;1)?1:-1)]=1; euler(e[i]); ans[tot++]=e[i]; &#125;&#125; int main()&#123; cin&gt;&gt;n; ll L=0,R=2e9; while(R-L&gt;1)&#123; //cout&lt;&lt;R&lt;&lt;endl; ll mid=(L+R)/2; if(check(mid)) L=mid; else R=mid; &#125; m=L; assert(!check(m+1)); printf("%lld\n",m); if(n&gt;2000000) return 0; for(int i=1;i&lt;=m;i++)&#123; for(int j=i+1;j&lt;=m;j++) add(i,j),add(j,i); &#125; if(m%2==0)&#123; for(int i=2;i&lt;m-1;i+=2) add(i,i+1),add(i+1,i); &#125; for(int i=1;i&lt;=m;i++)cur[i]=hd[i]; euler(1); cnt=1; printf("1"); for(int i=tot-1;i&gt;=0;i--) printf(" %d",ans[i]); for(int i=tot+1;i&lt;n;i++) printf(" %d",1); puts(""); return 0;&#125; I 题目描述有一个$n\times m$的矩阵，每个位置上都有一个宝箱，宝箱需要一定的投币才能打开。给定$m$个限定条件（某相邻两个宝箱的投币之和$\geq w$，求最少需要的硬币之和。 解题思路看做一个二分图的最佳匹配即可，费用流/KM算法求解。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;#include&lt;assert.h&gt;typedef long long ll;using namespace std;#define N 5000#define int long longstruct Edge&#123; int e,l,c,n;&#125;e[200*N];struct Pre&#123; int pre,edge;&#125;pre[N];int hd[N],vis[N],cnt=1,n,m,s,t;ll maxflow,mincost,dis[N],flow[N];void add(int a,int b,int l,int c)&#123; e[++cnt].e=b; e[cnt].l=l; e[cnt].c=c; e[cnt].n=hd[a]; hd[a]=cnt;&#125;void addE(int a,int b,int l,int c)&#123; add(a,b,l,c); add(b,a,0,-c);&#125;queue&lt;int&gt;Q;int spfa()&#123; memset(dis,0x3f,sizeof(dis)); memset(flow,0x3f,sizeof(flow)); memset(vis,0,sizeof(vis)); while(!Q.empty())Q.pop(); int i,top,q; Q.push(s);vis[s]=1;dis[s]=0;pre[t].pre=0; while(!Q.empty())&#123; top=Q.front(); Q.pop(); vis[top]=0; for(i=hd[top];i;i=e[i].n)&#123; q=e[i].e; if(e[i].l&amp;&amp;dis[q]&gt;dis[top]+e[i].c)&#123; dis[q]=dis[top]+e[i].c; pre[q].pre=top; pre[q].edge=i; flow[q]=min(flow[top],(ll)e[i].l); if(!vis[q])&#123; vis[q]=1; Q.push(q); &#125; &#125; &#125; &#125; return pre[t].pre;&#125;void ek()&#123; int i; while(spfa())&#123; maxflow+=flow[t]; mincost+=flow[t]*dis[t]; for(i=t;i!=s;i=pre[i].pre)&#123; e[pre[i].edge].l-=flow[t]; e[pre[i].edge^1].l+=flow[t]; &#125; &#125;&#125;signed main()&#123; int i,j,k,x1,y1,x2,y2,w; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); s=n*m;t=s+1; while(k--)&#123; scanf("%lld%lld%lld%lld%lld",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;w); x1--;y1--;x2--;y2--; int a=x1*m+y1,b=x2*m+y2; if((x1+y1)&amp;1)swap(a,b); addE(a,b,1,-w); &#125; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; if((i+j)&amp;1)addE(i*m+j,t,1,0); addE(s,i*m+j,1,0); &#125; &#125; ek(); printf("%lld",-mincost); return 0;&#125; J 题目描述给定了一个$2-sat$模板，问如何$hack$能够把时间复杂度卡到$O(n^2)$。 解题思路观察发现，这个模板的特点是枚举变量值，不确定就入栈假设为$1$，如果推翻假设那么出栈更新。这样构造一个中间始终无法确定变量的值、最后如果都是$1$那么就会产生矛盾的数据即可。 AC代码点击 1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;int main()&#123; int i,n; scanf("%d",&amp;n); printf("%d\n",n); for(i=1;i&lt;n;i++)printf("%d %d\n",-i,i+1); printf("%d %d",-n,-n); return 0;&#125; K 题目描述一个包含$n$个单词的词典，每个词有一定单价，要求恰好通过这些单词拼出给定字符串$T$，求最少花费。 解题思路对词典建立$AC$自动机，在自动机上逐字符匹配$T$，保证当前节点始终对应的是自动机上最长的匹配$T$后缀的位置。 设$f[i]$为凑出$T$的前$i$个字符的最少花费，每次沿着失配指针向上跳枚举最后一次匹配的后缀起始位置进行$dp$即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 500010ll f[N];struct ACAM&#123; int tr[N][26],tot; int fail[N],num[N],now,sign[N]; int q[N],hd,tl; ll val[N]; int len[N]; void insert(int cost,char s[])&#123; int i; now=0; for(i=0;s[i];i++)&#123; int p=s[i]-'a'; if(!tr[now][p])tr[now][p]=++tot; now=tr[now][p]; len[now]=i+1; &#125; if(!val[now])val[now]=cost; else val[now]=min(val[now],(ll)cost); &#125; void build()&#123; int i; for(i=0;i&lt;26;i++)if(tr[0][i])q[++tl]=tr[0][i]; while(hd&lt;tl)&#123; int p=q[++hd]; for(i=0;i&lt;26;i++)&#123; if(tr[p][i])fail[tr[p][i]]=tr[fail[p]][i],q[++tl]=tr[p][i]; else tr[p][i]=tr[fail[p]][i]; &#125; &#125; &#125; ll ask(char a[])&#123; int i,now=0; for(i=0;a[i];i++)&#123; now=tr[now][a[i]-'a']; int suf=now; while(suf)&#123; if(val[suf])&#123; if(i+1==len[suf])f[i]=min(f[i],0+val[suf]); else f[i]=min(f[i],f[i-len[suf]]+val[suf]); &#125; suf=fail[suf]; &#125; &#125; if(f[i-1]&gt;1e16)return -1; return f[i-1]; &#125;&#125;T;char s[N],t[N];int main()&#123; int i,n,cost; memset(f,0x3f,sizeof(f)); scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%s%d",t,&amp;cost); T.insert(cost,t); &#125; T.build(); scanf("%s",s); printf("%lld",T.ask(s)); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020 CCPC Wannafly camp day1 题解]]></title>
    <url>%2F2020%2F01%2F23%2F2020ccpcwannaflycampday1%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 9/10 O O O Ø O O O O O . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述有$n$个独立随机变量$x_1,x_2,…,x_n$，第$i$个变量的值$x_i$是从$[l_i,r_i]$中随机选取的整数。 求一个排列$p$，使得$x_{p_1},x_{p_2},…,x_{p_n}$序列的逆序对个数期望尽量少，求这个最小值。 解题思路一个比较显然的结论是，排列$p$是对区间$[l_i,r_i]$按中点坐标从小到大排序得到的，这样任意两个位置产生逆序对的概率都$\leq \frac12$。 求出排列后，问题转化为求两个长度分别为$len_1,len_2$的区间$[l_1,r_1],[l_2,r_2]$的逆序对期望。画图理解：当$r_1&gt;r_2$时，$x_1\in(r_1,r_2]$区域时，必然贡献一个逆序对，故贡献$\frac {r_2-r_1}{len_1}$；当$l_1&gt;l_2$时，$x_2\in[l_2,l_1)$区域时，必然贡献一个逆序对，故贡献$\frac {l_1-l_2}{len_2}$；当长度为$len$的区间$[l,r]$为两区间的交叉区间时，这个区间的贡献为$\frac 1{len_1len_2}\sum_{i=l}^{r}\sum_{j=i+1}^r1$ $=\frac 1{len_1len_2}\frac{len(len-1)}2$。加起来即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;const int mod=998244353;int qp(int a,int p)&#123; int ans=1; for(;p;p&gt;&gt;=1,a=1LL*a*a%mod)if(p&amp;1)ans=1LL*ans*a%mod; return ans;&#125; int inv(ll x)&#123;return qp(x,mod-2);&#125;struct P&#123; int l,r; bool operator&lt;(const P&amp;p)const&#123; return l+r&lt;p.l+p.r; &#125; &#125;a[5010];int L[5010];int main()&#123; int i,j,n,l,r; ll ans=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d%d",&amp;a[i].l,&amp;a[i].r); sort(a,a+n); for(i=0;i&lt;n;i++)&#123; int l1=a[i].l,r1=a[i].r,len1=r1-l1+1; L[i]=inv(len1); &#125; for(i=0;i&lt;n;i++)&#123; for(j=i+1;j&lt;n;j++)&#123; int l1=a[i].l,r1=a[i].r; int l2=a[j].l,r2=a[j].r; ll now=0; if(r1&gt;r2)now+=1LL*(r1-r2)*L[i]%mod; if(l1&gt;l2)now+=1LL*(l1-l2)*L[j]%mod; int cl=max(l1,l2),cr=min(r1,r2),len=cr-cl+1; if(cl&lt;cr)now+=1LL*(len-1)*len/2%mod*L[i]%mod*L[j]%mod; (ans+=now%mod)%=mod; &#125; &#125; printf("%lld\n",ans); return 0;&#125; B 题目描述大概是给定一个加密方式，给定加密后的字符串，求加密前的字符串。 解题思路solved by nikkukun AC代码 - by nikkukun点击 1234567891011121314151617181920212223242526272829303132333435363738394041// 13:03 - 13:11#include&lt;bits/stdc++.h&gt;using namespace std; int Idx(char c)&#123; if(islower(c)) return c - 'a'; else return c - 'A' + 26;&#125; char Char(int c)&#123; if(c &lt; 26) return 'a' + c; else return 'A' + c - 26;&#125; void Encrypt(string &amp;enc, string key)&#123; int len = key.size(); for(int i=0; i&lt;enc.size(); i++) enc[i] = Char((Idx(enc[i]) - Idx(key[i % len]) + 52) % 52);&#125; const int N = 1000 + 5;string s[N];int x[N], y[N]; int main()&#123; ios::sync_with_stdio(0); int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i=1; i&lt;=m; i++) cin &gt;&gt; x[i] &gt;&gt; y[i]; for(int i=1; i&lt;=n; i++) cin &gt;&gt; s[i]; for(int i=m; i&gt;=1; i--) Encrypt(s[y[i]], s[x[i]]); for(int i=1; i&lt;=n; i++) cout &lt;&lt; s[i] &lt;&lt; endl; return 0;&#125; C 题目描述定义$g(n,k)$为所有包含$n$个点的简单$k$可染色图的边数最大值。$k$可染色的意思是。 给$n,l,r$，求$\sum_{i=l}^rg(n,i)$。（$\text {mod 998244353}$） 解题思路solved by nikkukun 可以猜到，当颜色尽量均分的时候连边数最多。设有$x$种颜色染了$\lfloor\frac nk\rfloor$个点，$y$个点染了$\lfloor\frac nk\rfloor+1$个点。 显然，有$\left [\begin{aligned}&amp;x+y=k\\ &amp;y=n\text{ mod k}=n-k\lfloor\frac nk\rfloor\end{aligned}\right. $。 为了简便，下设$b=\lfloor\frac nk\rfloor$。 连边：完全图边数-同色内不能连边 $=\frac{n(n-1)}2-\frac {b(b-1)}2x-\frac{b(b+1)}2y$ $=\frac 12(n^2-n-2nb)+\frac 12k(b^2+b)$ 枚举$k$，故$b$的形式可以用数论分块解决。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;const int mod=998244353;ll qp(ll a,ll p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,a=a*a%mod)if(p&amp;1)ans=ans*a%mod; return ans;&#125;int main()&#123; int i,j; ll n,l,r,ans; ll inv2=qp(2,mod-2); int t; scanf("%d",&amp;t); while(t--)&#123; ans=0; scanf("%lld%lld%lld",&amp;n,&amp;l,&amp;r); for(i=l;i&lt;=r;i=j+1)&#123; j=min(r,n/(n/i)); ll b=n/i; (ans+=(n*n-n-2*n*b)%mod*(j-i+1)%mod*inv2)%=mod; (ans+=(b*b+b)%mod*(i+j)%mod*(j-i+1)%mod*inv2%mod*inv2)%=mod; &#125; printf("%lld\n",(ans+mod)%mod); &#125; return 0;&#125; D 题目描述定义$T(G)$表示$G$所有不同生成树形成的集合，$s(G,T)$为同时出现在树$T$和图$G$中的边的数量。 给出两张$n$个点的无向图$G_1,G_2$，求$\sum_{T\in T(G_1)}s(G_2,T)$。 解题思路之前矩阵树定理没学透，看题解还是不会，遂恶补了一番。 感觉这篇博客写的很好，除了其中一个重要定理的证明以外，其他的都给出了详细的说明和推演。 这个博客概括为以下六条： 考虑图$G$的关联矩阵$M_{m\times n}$，设$e$为连接$i,j$的边（$i&gt;j$），则$M_{ev}=\left[\begin{aligned}&amp;1&amp;v=i\\ &amp;\text-1&amp;v=j\\ &amp;0&amp;o.w.\end{aligned}\right.$，则基尔霍夫矩阵$L=M^TM$，容易推出$L=D-A$。 $L$的任意代数余子式值都相等。（非常重要的性质） $L$的任意一行、一列的和均为$0$。（非常重要的性质） $L$有一个特征值$0$，且特征值$\lambda_i$均$\geq 0$，即$L$是奇异的、半正定的。 $\det(A_{1,1})=\sum_{S}\det(M_{1,S})^2$，其中$S\in\left(\begin{aligned}\ [m]\\ n-1\end{aligned}\right)$，即$S$为从边集中任意选出的$n-1$个边的集合；$M_1$表示$M$去掉第一列（$v=1$）后的矩阵，$M_{1,S}$为$M_1$的行下标位于$S$中（边$e\in e_S$）的子矩阵。 当边不连通，有$\det(M_{1,S})=0$；连通时有$\det(M_{1,S})=\pm1$。 因此普通的基尔霍夫矩阵的任意代数余子式为生成树的个数。 以下为个人yy：（不知正误） 在此基础上，我们将$M$稍作修改： $M’_{ev}=\left[\begin{aligned}&amp;\sqrt{w_e}&amp;v=i\\ &amp;\text-\sqrt{w_e}&amp;v=j\\ &amp;0&amp;o.w.\end{aligned}\right.$ $M’^TM’$得到的矩阵$L’$仍满足上述$2,3,4$性质。此时，$L_{ij}=\left[\begin{aligned}&amp;\sum_{e}w_e[e与i关联]&amp;i=j\\ &amp;\text-w_{ij}&amp;i\neq j\end{aligned}\right.$。 同样有 $\det(A’_{1,1})$ $=\sum_{S}\det(M’_{1,S})^2$。 当边不连通时，有$\det(M’_{1,S})=0$； 连通时有$\det(M’_{1,S})=\pm\sqrt{\Pi_ew_e[e\in S]}$. 同样可以得出，$L’$任意代数余子式为生成树中所有边权之积的和。这就是变元矩阵树定理。 利用变元矩阵树定理可以求解本题： 构造矩阵$L’$，其中设只出现在$G_1$中的边对应的“边权”为$1$，同时出现在$G_1,G_2$中的边对应的“边权”为$x$，那么$L’$的代数余子式$|A(x)|$为一个$x$的$n-1$次多项式，记为$f(x)$，有$f(x)=\sum a_ix^i$，其中$a_i$表示有$i$条公共边的生成树个数。 我们要求的就是$\sum a_i\times i=f’(1)$， 故$ans=f’(1)$ $=|A(1)|\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}A(1)^{-1}[i][j]A’(1)[j][i]$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;const int N=440;const ll mod=998244353;ll a[N][N],b[N][N],inv[N][N];int equ,var;ll qp(ll a,ll p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,a=a*a%mod)if(p&amp;1)ans=ans*a%mod; return ans;&#125;int Gauss()&#123; int i,j,k,col,max_r; ll ans=1; for(k=0,col=0;k&lt;equ&amp;&amp;col&lt;var;k++,col++)&#123; max_r=k; for(i=k+1;i&lt;equ;i++) if(abs(a[i][col])&gt;abs(a[max_r][col])) max_r=i; if(!a[max_r][col])return 0; if(k!=max_r)&#123; for(j=col;j&lt;var;j++)swap(a[k][j],a[max_r][j]); for(j=0;j&lt;var;j++)swap(inv[k][j],inv[max_r][j]); ans=mod-ans; &#125; ans=ans*a[k][k]%mod; ll fm=qp(a[k][col],mod-2); for(j=0;j&lt;var;j++)inv[k][j]=inv[k][j]*fm%mod; for(j=col+1;j&lt;var;j++)a[k][j]=a[k][j]*fm%mod; a[k][col]=1; for(i=0;i&lt;equ;i++) if(i!=k)&#123; for(j=0;j&lt;var;j++)(inv[i][j]-=inv[k][j]*a[i][col])%=mod; for(j=col+1;j&lt;var;j++)(a[i][j]-=a[k][j]*a[i][col])%=mod; a[i][col]=0; &#125; &#125; //消成E|A-1 for(i=var-1;i&gt;=0;i--) for(j=i-1;j&gt;=0;j--) for(k=0;k&lt;var;k++) (inv[j][k]-=a[j][i]*inv[i][k])%=mod; return ans;&#125;char s[N];int main()&#123; int i,n,j; scanf("%d",&amp;n); equ=var=n-1; for(i=0;i&lt;n;i++)&#123; scanf("%s",s); for(j=0;j&lt;n;j++)a[i][j]=(s[j]=='1'); &#125; for(i=0;i&lt;n;i++)&#123; scanf("%s",s); for(j=0;j&lt;n;j++)b[i][j]=(s[j]=='1'&amp;&amp;a[i][j]); &#125; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)&#123; if(i==j)continue; a[i][i]+=a[i][j];b[i][i]+=b[i][j]; a[i][j]=-a[i][j];b[i][j]=-b[i][j]; &#125; &#125; for(i=0;i&lt;n-1;i++)inv[i][i]=1; ll ans=Gauss(),ans2=0; for(i=0;i&lt;var;i++)for(j=0;j&lt;var;j++) (ans2=ans2+b[i][j]*inv[j][i])%=mod; printf("%lld",((ans*ans2%mod)+mod)%mod); return 0;&#125; E 题目描述从$u$到$v$的路径可以分解为沿着向根的方向和离开根的方向两部分，设长度（经过的边数）分别为$l_1,l_2$，则该路径的权值定义为$l_1l_2$。 给定一棵树和$m$条路径，对于每一个$r\in [1,n]$，计算当$r$为根节点时，所有路径的权值和是多少。 解题思路考虑先计算出$1$为根时的答案，然后换根。 考虑$u,v$路径对各个节点的贡献：设$f=LCA(u,v)$，$l_1=len(u,f),l_2=len(v,f)$，则对$LCA$贡献$l_1l_2$，对$a_2$贡献$(l_1-1)(l_2+1)=l_1l_2-l_2+l_1-1$，对$a_1$贡献$l_1l_2-2l_2+2l_1-4$，…… 考虑路径上贡献的差值。 如图，$a_2,f$之间的差值为 $d_1=(l_1-l_2-1)$，$a_1,a_2$之间的差值为$d_2=(l_1-l_2-3)$，这是一个等差数列，在树上胡乱维护一下即可。 具体的维护方式： 差值从下到上构成一个公差为$2$的等差数列，通过树上差分（先维护孩子$\to$父亲的差值之差，再求出每个节点的差值）可以求出这个差值；通过这个差值再从上到下更新每个节点对应的答案。 点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 300010int hd[N],cnt;struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;int d[N],fa[22][N],lg[N];void dfs(int now,int f)&#123; d[now]=d[f]+1; fa[0][now]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++) fa[i][now]=fa[i-1][fa[i-1][now]]; for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=f)dfs(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y]) x=fa[lg[d[x]-d[y]]][x]; if(x==y)return x; for(i=lg[d[x]];~i;i--) if(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y]; return fa[0][x];&#125;ll f[N],a[N],dt[N];void dfs2(int p)&#123; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q==fa[0][p])continue; dfs2(q); a[p]+=a[q]-dt[q]; dt[p]+=dt[q]; &#125;&#125;void dfs3(int p)&#123; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q==fa[0][p])continue; f[q]=f[p]+a[q]; dfs3(q); &#125;&#125;int main()&#123; int i,n,m,u,v; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;n;i++)&#123; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; for(i=2;i&lt;=n;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); dfs(1,0); for(i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); int ff=lca(u,v); int l1=d[u]-d[ff]; int l2=d[v]-d[ff]; f[1]+=1LL*l1*l2; a[u]+=l1-l2-(2*l1-1); a[v]+=l2-l1-(2*l2-1); a[ff]-=2; dt[u]-=2; dt[v]-=2; dt[ff]+=4; &#125; dfs2(1); dfs3(1); for(i=1;i&lt;=n;i++)printf("%lld\n",f[i]); return 0;&#125; F 题目描述给定长度分别为$n,m$的数组$A,B$，矩阵$C=A_i\times B_j$，求$C$中第$k$大的数。 解题思路solved by qxforever 二分答案，分正负零讨论，分别单调地扫一遍进行处理。 AC代码 - by qxforever点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;const int maxn = 1e5+23;ll a[maxn],b[maxn],c[maxn],d[maxn];ll A,B,C,D;ll n,m,k; bool check(ll x)&#123; ll cnt=0; if(x&gt;=0) cnt+=n*(m-C-D)+m*(n-A-B)-(m-C-D)*(n-A-B); for(int i=1,j=C;i&lt;=A;i++)&#123; while(a[i]*c[j]&gt;x&amp;&amp;j&gt;=1) j--; cnt+=j; &#125; for(int i=A,j=D;i;i--)&#123; while(a[i]*d[j]&gt;x&amp;&amp;j&gt;=1) j--; cnt+=j; &#125; for(int i=1,j=1;i&lt;=B;i++)&#123; while(b[i]*c[j]&gt;x&amp;&amp;j&lt;=C) j++; cnt+=C-j+1; &#125; for(int i=B,j=1;i;i--)&#123; while(b[i]*d[j]&gt;x&amp;&amp;j&lt;=D) j++; cnt+=D-j+1; &#125; //printf("%lld\n",cnt); return cnt&lt;k;&#125; int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;k=n*m+1-k; for(int i=1,j;i&lt;=n;i++)&#123; scanf("%d",&amp;j); j&gt;0?a[++A]=j:b[++B]=j; &#125; for(int i=1,j;i&lt;=m;i++)&#123; scanf("%d",&amp;j); j&gt;0?c[++C]=j:d[++D]=j; &#125; sort(a+1,a+A+1); sort(b+1,b+B+1); sort(c+1,c+C+1); sort(d+1,d+D+1); ll L=-2e12-1,R=2e12+1; //check(18); while(R-L&gt;1)&#123; ll mid=(L+R)/2; //printf("mid: %lld\n",mid); if(check(mid)) L=mid; else R=mid; &#125; printf("%lld\n",R);&#125; G 题目描述给定$n$个圆，求它们凸包的周长。 解题思路先求出来所有公切点的凸包，然后如果相邻两个点在同一个圆上，那么用圆弧连接这两个点，否则用直线连接。 AC代码 - by qxforever点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;using namespace std;const double pi = acos(-1.0);const double eps = 1e-10;struct Point&#123; double x,y; Point(double x=0,double y=0):x(x),y(y) &#123;&#125; bool operator &lt; (const Point &amp;b) &#123; return x&lt;b.x||(x==b.x&amp;&amp;y&lt;b.y); &#125;&#125;;typedef Point Vector;Point operator + (Point A,Point B)&#123;return Point(A.x+B.x,A.y+B.y);&#125;Point operator - (Point A,Point B) &#123;return Point(A.x-B.x,A.y-B.y);&#125;int dcmp(double x)&#123; if(fabs(x)&lt;eps) return 0; return x&lt;0 ? -1 : 1;&#125;bool operator == (const Point &amp;a,const Point &amp;b)&#123; return dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)==0;&#125; double dot(Vector a,Vector b)&#123; return a.x*b.x+a.y*b.y;&#125;double length(Vector a)&#123; return sqrt(dot(a,a));&#125;double angle(Vector a,Vector b)&#123; return acos(dot(a,b))/length(a)/length(b);&#125;double cross(Vector a,Vector b)&#123; return a.x*b.y-a.y*b.x;&#125;struct Circle&#123; Point c;double x,y,r; //Circle(Point c,double r):c(c),r(r) &#123;&#125; Point point(double a) &#123; return Point(c.x+cos(a)*r,c.y+sin(a)*r); &#125; void read()&#123; scanf("%lf%lf%lf",&amp;c.x,&amp;c.y,&amp;r); x=c.x,y=c.y; &#125;&#125;;int getTangents(Circle A,Circle B,vector&lt;Point&gt; &amp;p)&#123; if(A.r&lt;B.r) swap(A,B); double d2=(A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y); double rdiff=A.r-B.r; double base=atan2(B.y-A.y,B.x-A.x); if(d2&lt;rdiff*rdiff) return 0; if(d2&lt;eps&amp;&amp;dcmp(A.r-B.r)==0) return 0; if(d2==rdiff*rdiff) return 0; double ang=acos((A.r-B.r)/sqrt(d2)); p.push_back(A.point(base+ang)); p.push_back(B.point(base+ang)); p.push_back(A.point(base-ang)); p.push_back(B.point(base-ang)); return 1;&#125;int ConvexHull(vector&lt;Point&gt; &amp;p,Point *ch)&#123; int n=(int)p.size(); sort(p.begin(),p.end()); int m=0; for(int i=0;i&lt;n;i++)&#123; while(m&gt;1&amp;&amp;cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; int k=m; for(int i=n-2;i&gt;=0;i--)&#123; while(m&gt;k&amp;&amp;cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])&lt;=0) m--; ch[m++]=p[i]; &#125; if(n&gt;1) m--; return m;&#125;bool in(Point a,Point b,Circle c)&#123; return dcmp(length(a-c.c)-c.r)==0&amp;&amp;(dcmp(length(b-c.c)-c.r))==0;&#125;double getang(Point a)&#123; return atan2(a.y,a.x);&#125;const int maxn = 123;Circle a[maxn];Point ch[maxn&lt;&lt;4];int n,m;int main()&#123; int t;cin&gt;&gt;t; while(t--)&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) a[i].read(); vector&lt;Point&gt; t,p; for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++) getTangents(a[i],a[j],t); &#125; for(Point i:t)&#123; bool f=false; for(int j=0;j&lt;n;j++) if(length(a[j].c-i)+eps&lt;a[j].r) f=true; if(!f) p.push_back(i); &#125; double ans=0.0; m=ConvexHull(p,ch);ch[m]=ch[0]; if(m==0)&#123; for(int i=0;i&lt;n;i++) ans=max(ans,a[i].r); printf("%.10f\n",ans*2*pi);continue; &#125; for(int i=0;i&lt;m;i++)&#123; bool f=false; for(int j=0;j&lt;n&amp;&amp;!f;j++)&#123; if(in(ch[i],ch[i+1],a[j]))&#123; f=true; double ang=getang(ch[i+1]-a[j].c)-getang(ch[i]-a[j].c); while(ang&lt;0) ang+=2*pi; ans+=ang*a[j].r; &#125; &#125; if(!f) ans+=length(ch[i]-ch[i+1]); &#125; printf("%.10f\n",ans); &#125; return 0;&#125; H 题目描述给定$n,k$，求最小的$y$使得$\forall x\in [1,n],gcd(x,y)=gcd(k,y)$，有$x=k$。 解题思路首先必有$gcd(k,y)=k$，否则有$x=gcd(k,y)&lt;k,s.t.gcd(x,y)=gcd(k,y)=x$。 故$y$为$k$的整数倍，$y=ak$。 又有$gcd(2k,y)!=k,gcd(3k,y)!=k,…,gcd(\lfloor\frac nk\rfloor k,y)!=k$。 故$2|a,3|a,4|a,…,\lfloor\frac nk\rfloor|a$，故$y=k\Pi_{p\in[2,\lfloor\frac nk\rfloor],p \in prime}p$。 AC代码点击 123456789101112131415161718192021import mathdef p(x): if x&lt;2:return False for i in range(2,int(1+math.sqrt(x))): if x%i==0: return False return Truet=int(input())while(t): t=t-1 n,k=map(int,input().split()) ans=k for i in range(2,n+1): if i*k&gt;n: break if p(i): ans=ans*i print(ans) I 题目描述给一个数列$A$，有两种操作： 区间修改为$min(A_i,x)$ 询问区间第$k$小 解题思路暴力分块大法好.jpg 块内排好序，第一种操作相当于削头，每块一个标记$top$表示最大值不能超过多少，第二种操作枚举每块，块内二分查找即可。 要注意的地方在于，第一种操作的头尾两块遍历完要重新$sort$一遍。 单次询问复杂度：设块大小为$m$，第一种操作：$O(m+m\log m+\frac nm)$，第二种操作：$O(\frac nm\log m+m)$。取$m=\sqrt n$，总复杂度$O(\sqrt n \log n)$。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;int block,top[85010];struct Ele&#123; int data,i; bool operator&lt;(const Ele &amp;a)const&#123; return data&lt;a.data; &#125; bool operator==(const Ele &amp;a)const&#123; return data==a.data; &#125;&#125;a[85010];int l[85010],r[85010],flag;int num(int L,int R,int x)&#123; int lb=(L-1)/block+1,rb=(R-1)/block+1,i,ans=0; for(i=(lb-1)*block+1;i&lt;=(lb-1)*block+block;i++) if(a[i].i&gt;=L&amp;&amp;a[i].i&lt;=R)&#123; if(min(a[i].data,top[lb])==x)flag=1; if(min(a[i].data,top[lb])&lt;x)ans++; &#125; if(lb!=rb)for(i=(rb-1)*block+1;i&lt;=(rb-1)*block+block;i++) if(a[i].i&gt;=L&amp;&amp;a[i].i&lt;=R)&#123; if(min(a[i].data,top[rb])==x)flag=1; if(min(a[i].data,top[rb])&lt;x)ans++; &#125; for(i=lb+1;i&lt;rb;i++)&#123; if(top[i]==x)flag=1; if(top[i]&lt;x)ans+=block; else ans+=lower_bound(a+l[i],a+r[i]+1,(Ele)&#123;x,0&#125;)-a-l[i]; if(a[lower_bound(a+l[i],a+r[i]+1,(Ele)&#123;x,0&#125;)-a].data==x)flag=1; &#125; return ans;&#125;int main()&#123; int i,n,m; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i].data),a[i].i=i; block=sqrt(n); memset(top,0x3f,sizeof(top)); for(i=1;r[i-1]!=n;i++)&#123; l[i]=r[i-1]+1; r[i]=min(n,l[i]+block-1); sort(a+l[i],a+r[i]+1); &#125; while(m--)&#123; int opt,L,R,k; scanf("%d%d%d%d",&amp;opt,&amp;L,&amp;R,&amp;k); int lb=(L-1)/block+1,rb=(R-1)/block+1; if(opt==1)&#123; for(i=(lb-1)*block+1;i&lt;=(lb-1)*block+block;i++) if(a[i].i&gt;=L&amp;&amp;a[i].i&lt;=R)a[i].data=min(a[i].data,k); sort(a+l[lb],a+r[lb]+1); for(i=(rb-1)*block+1;i&lt;=(rb-1)*block+block;i++) if(a[i].i&gt;=L&amp;&amp;a[i].i&lt;=R)a[i].data=min(a[i].data,k); sort(a+l[rb],a+r[rb]+1); for(i=lb+1;i&lt;rb;i++) top[i]=min(top[i],k); &#125;else&#123; int bl=1,br=n,bm,res=1; while(bl&lt;br)&#123; flag=0; bm=(bl+br+1)/2; if(num(L,R,bm)&lt;k)&#123; bl=bm; if(flag)res=bl; &#125; else br=bm-1; &#125; printf("%d\n",res); &#125; &#125; return 0;&#125; J 题目描述德州扑克？ 解题思路不太想补这个题，咕了 AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch安装]]></title>
    <url>%2F2020%2F01%2F15%2Fpytorchinstall%2F</url>
    <content type="text"><![CDATA[本来以为很好安装的东西安了三天，写个博记录一下 掉进了两个坑，第一个是python要安装3.7以下版本（这里能看到所需版本），然后在去官网下载的时候务必注意32位还是64位……然后需要添加进环境变量，把原来的3.8从环境变量里删掉 第二个是一直莫名其妙ReadTimeOut，不知道咋回事。最后把各种博客里搜集到的东西汇总起来，加了个源-i，又加了个–trusted-host，然后扔掉校园网换成流量热点，就过了……过了……了…… pip3 install torch==1.3.1+cpu torchvision==0.4.2+cpu -f https://download.pytorch.org/whl/torch_stable.html -i http://pypi.douban.com/simple/ –trusted-host pypi.douban.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机组成课程总结]]></title>
    <url>%2F2019%2F12%2F18%2FComputerOrganizationSummary%2F</url>
    <content type="text"><![CDATA[Solved P-1 P0 P1 P2 P3 P4 P5 P6 P7 P8 P7/P8 O O O O Ø O O Ø Ø . O for one pass and AK Ø for passing after one failure and AK ! for passed but not AK or after failing more than once · for having not attempted yet 这是一篇学累了学不进去习甚至懒得打标点符号的Potassium临时起兴写的关于这学期北京航空航天大学计算机组成原理课程设计这门课的总结。 P-1 Pre测试主要是针对Logisim，Verilog，MARS三大软件的预习的检测，只要能够在前几周抽出时间去从程序设计的过程思维转换成硬件设计的电路思维，应该一般不会有什么大问题。 虽说Pre测试不计入总成绩，但都进行一遍预习并尽力争取通过甚至AK是进行后面几个Project的基础。 P0 P0测试是第一场计分的测试，但其实也没什么难度。 P1 难度主要在Mealy和Moore型状态机的区分上，可以依照课本上的模型理解。 P2 只要会写C代码，转换成mips指令只需要熟能生巧，多练习一些即可。 P3 真正硬核的东西是从这里开始的。设计一个CPU从多部分组成的连线开始。教程部分讲述的很明确了，但一定要自己练习几个。笔者在P3因为一个clo指令（可以参看英文指令集）里的特殊情况（0）没想到特判，一直错一个点，另一个题光把cpu内改了，忘记把输出地址和数据修改掉，从而一题挂了P3。 P4 注意硬件设计语言的特性，把连线仔仔细细地连到verilog上就可以通过本Project。 P5 这是所有Project里最硬核的一个。教程写的又多又杂就不说了，还没啥用。 笔者建议同学从不考虑冒险搭起，先把流水线的框架（FDEMW级）搭起来，把每一级里的东西设计好，记得CMP模块要放在D级。差不多搭完之后，不要先想着加转发暂停，而是完备地测试这个CPU能否正常运行10指令，当然在造测试程序的时候别忘了每条指令后面加4个nop。 测试完备之后，再开始想转发暂停该如何加入。注意到我们主要想做的是尽可能多的转发，也就是暂停的目的是把所有无论如何不能转发的两个指令间插入nop，所以先判断一下啥时候会需要暂停。这时候用教程上的$T_{use}$、$T_{new}$的概念，画出表格，就可以判断出来哪些时候会强制要求暂停。暂停其实是在IF/ID级阻塞，ID/EX级产生空泡，这样需求者始终在D级，只需要分类讨论供给者的位置和寄存器号即可，减少了许多不必要的代码量。 转发就稍微麻烦一些，笔者建议同学们使用比较简便的“标记转发法”，即是在每个已经算出结果（存入寄存器的值）的流水级设置flag=1，这时候允许在当前流水级对应寄存器的值被转发到前面流水级。每到需要寄存器值的前面，就要从前往后依次判断哪一级流水线的该寄存器值可以被转发，如果都不能那就使用从GRF里读取的数据。这样做的合理性在于，一是暂停保证了在使用寄存器值的时候，必然已经算出结果；二是能通过这个优先级找到最近的修改该寄存器的操作，而不会错误地转发别的数值，比如： 1234li $1,1lw $1,-1($1)addu $1,$1,$1subu $11,$1,$0 在subu转发的时候，会依次比较addu（是否已经flag=1，寄存器编号是否一样），lw（是否已经flag=1，寄存器编号是否一样）。这样保证了有多个转发点的时候选取最新的数据。 对于转发暂停，建议使用指令分类，这对P6大有裨益。 P6 指令分类完了之后就是工具人的操作了，唯一的难点在于乘除块。 乘除块其实只要在暂停里加一个“如果当前乘除块在操作（busy|start），而且D级指令是与乘除有关的操作，那么暂停”，就可以了。乘除块内部相当于一个计数器，也就是小型的FSM。 DM的修改也没什么太大的难度，但建议充分测试各种对DM的操作，因为容易出错。 P7 异常中断，主要加的是CP0，Bridge两个东西。 建议先连接CP0，处理异常。异常需要在各级流水线设置ExcCode，注意判断各种ExcCode的优先级，做好各种异常的测试，一定要仔细阅读哪种异常的ExcCode是多少的要求，否则很容易翻车。 然后处理中断，其实中断只要放在异常优先级前面，然后加点东西即可。 Bridge就是一个把各个设备连在一起的模块，没有什么设计难度。TimeCounter的代码都已经给出了，研究一下发现是个FSM，只要在外面连连线连上就可。 最主要的是一定要做好充足的测试，mfc0 mtc0 eret尤其是这三个新增指令。然后处理address和EPC、BD位的时候也要注意。笔者P7因为一个神奇的bug错了一个点，从而失去了P8的机会。 这个神奇的bug估计没几个同学能遇到，就不表了。 P8 P8没有实操，看着npy做，感觉要做的东西其实挺多而且易错，并不完全是奖励关的性质，一定要在确保自己物理等科目问题不太大的前提下斟酌损益。可综合和IP Core装起来比较容易，LED和数码管硬件实现起来也不是太麻烦，串口通信我们都没太弄懂如何处理才能够不缺失输入，不过无所谓啦。一定要注意自己设计的是硬件，只是实现一些简单的接口，其余的事情留给软件操作就好了。 完整的代码应该会放到github上，仅供参考，其中也有很多自动测试工具以及测试数据，用法也不再多说，其实还是建议同学们自己动手做自动测试、做完备测试，这样理解起来会更深刻，在造数据的时候也会经常灵光一现：“诶！我这里可能会出bug，去修修”，从而更加顺利的通过本课程。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python大作业编写思路]]></title>
    <url>%2F2019%2F12%2F13%2FLogisimal%2F</url>
    <content type="text"><![CDATA[这次是python大作业（ 制作了个简易logisim。 github地址 更新日志11.14python大作业下发 11.28zyh提出idea 11.31zyh开工并完成框架（关于、退出、工具栏、状态栏） 12.1zyh完成格点设计、工具栏bind事件 my完成基本事件（放置门，对齐网格）、基础连线（黑线） drawline真的不太会搞…… 参考资料： Getting Started with wxPython wxpython编写的简单划线工具 笔记：设置一下pen和brush就可以实现填充与否、线的颜色和宽度了（12.2凌晨） 12.2my完成基本bfs设计以及基础连线（包括折线方向问题，但比较粗糙，存在不少bug） 效果： 大致框架已经具备，但可以观察到的是，从外界复制过来的bmp图存在遮挡线条的bug，同时因为bmp是一个类似panel的东西，会阻止鼠标事件的响应。同时，存在绘图刷新频率过高、闪烁的现象。同时由于对齐格点使用向下取整，只能从output的端口右下小范围拉线 第一版结束。 目标：将所有图直接使用线条画，同时改变对齐逻辑，同时解决以上bug。 12.3通过device context解决闪烁问题（找了好久资料…来直接奉上来点，方便） wxpython之解决闪烁给wxPython事件处理函数传递参数wxpython之DC绘图【wxpython】设备上下文简介 成功手动画出各种门，但无法解决statictext无法跟随移动的问题（静态文本移动个锤子） wxPython控件学习之wx.StaticText 改动bfs逻辑，修改小bug，添加鼠标悬浮在可画线点上时显示小绿圈的功能，添加左键拖拽和左键右键删除的功能，添加右键改变input gate value的功能，添加从工具栏选择门时右键可以取消选择的功能。 大致效果如下： 12.4修改颜色，修bug，删除无关工具栏按钮，第二版结束（就是当前的版本）。 12.11答辩结束，暂告一段落。（吐槽：为啥答辩全场不是pygame就是爬虫？） 目前存在的缺陷： 网格有时候无法对齐； 线无法删除； 采用bfs，无法仿真电路； 无法显示文字； 位数无法修改。 特别地纪念一下第一个和zyh合作的作品~]]></content>
  </entry>
  <entry>
    <title><![CDATA[JAVA大作业编写思路]]></title>
    <url>%2F2019%2F11%2F15%2FPVZ%2F</url>
    <content type="text"><![CDATA[最近忙于各种学业问题，算法只能先搁置一波了…… 本文出现的全部代码只是当时写完的版本，不是最终版本，最终版本（始终在更新）请移步github：MyPVZ 本来对大作业一筹莫展，在周日出去玩回来的地铁上被某人一语点醒：“可以做个植物大战僵尸呀！” 好，似乎植物大战僵尸也就是几个格子，判断一下碰撞之类的东西，应该比较好写，那就收集一下图片啥的资源开始做吧。（然而到现在还没写到判断碰撞的逻辑……真是太低估这东西的难度了） 2019.11.10既然要写java，那得先会这门语言吧…还好两天前（周五）考过了java的期末，稍微搞明白了一点java与C系列语言直接面向过程编写代码的不同之处：首先得把一种东西视作对象，实现这个对象所要的需求，然后将这个对象实例化（new一个出来），进行所需要的一系列操作。 好像确实没什么的，那就开始写吧。 先找到了一份有img的源码，拿走img。 既然是个游戏，我寻思不然就用前几天刚分析的2048的套路，controller+view+model吧（不过搞到后来似乎都没有model）。 首先植物是个模型，先写个植物再说。 Plant.java于是去学了一手JLabel和runnable实现动画效果，写了一下。 对于植物，实现了一些属性：名字name、价格price、血量hp、当前外观照片pic、产出冷却时间CD（产阳光、发射子弹等等）、图像是否可以修改canChange（update：当时觉得card类需要extend一下，所以留了这么一个接口，没想到以后card没用到，倒是其他地方起了作用）、控制器controller、位置row column、两次动画间隔时间sleepTime、对应卡片冷却时间cardCD。由于它们都是private的，需要很多public的接口供外面使用，所以添加了一堆东西，但这不是主要的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//active model of Plantspackage view;import controller.*;import javax.swing.*;import java.awt.*;public class Plant extends JLabel implements Runnable &#123; private static final long serialVersionUID = 1L; private String name; private ImageIcon img; private int hp = 0; private int price = 0; private int pic = 0; private int SumPic = 0; private int CD; // 冷却时间 private int Cnow = 0; // 积累时间 private boolean canChange = false; // 图像是否为gif（区分card） private Controller controller; private int row, column; private int sleepTime; private int cardCD;// 卡片冷却时间 // 实现一些接口 public int getR()&#123; return row; &#125; public int getC()&#123; return column; &#125; public int getCardCD() &#123; return cardCD; &#125; public int getCD() &#123; return CD; &#125; public int getCnow() &#123; return Cnow; &#125; public int getPic()&#123; return pic; &#125; public void setCnow(int Cnow) &#123; this.Cnow=Cnow; &#125; public void setPos(int row, int column) &#123; this.row = row; this.column = column; &#125; public void setController(Controller controller) &#123; this.controller = controller; &#125; public Controller getController() &#123; return controller; &#125; public String getName() &#123; return this.name; &#125; public int getPrice() &#123; return this.price; &#125; void attacked() &#123; this.hp--; if (hp == 0) &#123; die(); &#125; &#125; public void die() &#123; // System.out.println(name + " is dead."); controller.plantDeath(row, column); this.setVisible(false); &#125; public void attack() &#123; // to-do &#125; 同时实现了一些SunFlower、Plant初始化的小问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243public Plant getPlant(String name) &#123; Plant newPlant = null; switch (name) &#123; case "SunFlower": newPlant = new Plant().SunFlower(); break; //TO-DO return newPlant;&#125;public Plant() &#123; this.img = null; this.name = null; this.price = 0; this.hp = 0; //this.attack = 0; this.SumPic = 0;&#125;public Plant(String name, int price, int attack, int hp, int SumPic, boolean canChange) &#123; // System.out.println("Set " + name + "."); // System.out.println("Price:" + price); // System.out.println("Attack:" + attack); // System.out.println("HP:" + hp); this.canChange = canChange; this.img = new ImageIcon("img\\" + this.name + "\\" + this.name + "_" + "0.png"); this.name = name; this.price = price; this.hp = hp; //this.attack = attack; this.SumPic = SumPic;&#125;// various plants// price attack hp sumpic canchangepublic Plant SunFlower() &#123; Plant tempPlant = new Plant("SunFlower", 50, 0, 300, 17, true); tempPlant.CD = 24000 / 90; tempPlant.cardCD = 7500; tempPlant.sleepTime = 90; return tempPlant;&#125;// TO-DO:PLANTS 主要的就是两部分：重写paintComponent和重写run。这也是贯穿整个项目外观的两个重要部分：线程运行run，外观通过paintComponent改变。 paintComponent主要实现了当前JLabel标签的image，在植物方面大概只需要画底部阴影shadow和植物主体img就可以了。 run是Runnable接口调用的关键，是线程运行的主体。当植物存活的时候，不停积累产出冷却所需时间并重画（repaint），期间需要让线程sleep一段时间保证计算不过于频繁。 关于线程，参考资料：Java Thread线程使用、线程安全（一） - 简书 12345678910111213141516171819202122232425262728293031323334353637383940 void picChange() &#123; pic = (pic + 1) % SumPic; img = new ImageIcon("img\\" + this.name + "\\" + this.name + "_" + pic + ".png"); &#125; void accumulate() &#123;// accumulate to CD? if (this.canChange == false) return; this.picChange(); this.Cnow = this.Cnow + 1; &#125; @Override public void paintComponent(Graphics g) &#123; super.paintComponent(g); Graphics2D g2 = (Graphics2D) g; // 植物底部阴影 ImageIcon shadow = new ImageIcon("img\\shadow.png"); g2.drawImage(shadow.getImage(), -11, 45, shadow.getIconWidth(), shadow.getIconHeight(), null); g.drawImage(img.getImage(), 0, 0, img.getIconWidth(), img.getIconHeight(), null); &#125; &#125; @Override public void run() &#123; while (hp &gt;= 0) &#123; try &#123; Thread.sleep(sleepTime); this.accumulate(); if(this.getCnow()&gt;=this.getCD())&#123; this.setCnow(0); //TO-DO:SunProduce &#125; this.repaint(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 大概plant部分就到此为止。 Controller.java接下来就是最主要的控制器了。 控制器是各个部件的中枢，所有的对象通过这个控制器对其他对象产生影响。 所以除了要实现植物的矩阵之外，也要预留一下卡片、小车、僵尸、太阳等的位置（在此没有预留小车位置），同时在种植过程中，图片应当跟随鼠标进行显示，因此还需要一个鼠标事件监听器和JPanel。 同时，控制器需要向gameboardview传输信号，因此将整个gameboard作为一个JLayeredPane处理。 关于JFrame的层次结构，参考资料：JFrame 的层次结构 - CSDN 关于鼠标事件监听器，参考资料：MouseListener与MouseAdapter的区别 - CSDN 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package controller;import view.*;import java.awt.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionListener;import java.util.HashMap;import java.util.Map;import javax.swing.ImageIcon;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JLayeredPane;import javax.swing.JPanel;public class Controller &#123; //appearance private JFrame frame; private static int cardHeight = 90, cardWidth = 45; private static int tileHeight = 100, tileWidth = 80; //plants private Plant[][] plants = new Plant[5][9]; public Plant nowPlant = null; //sun private JLabel sunCount = new JLabel(); //mouse private Point mouseP; private JLayeredPane layeredPane; private TopPanel topPanel = new TopPanel(); private ImageIcon preImg; private ImageIcon blurImg; //state public boolean isRunning=false; public void setLayeredPane(JLayeredPane gameboardView) &#123; this.layeredPane = gameboardView; &#125; public JLayeredPane getLayeredPane()&#123; return layeredPane; &#125; public void setFrame(JFrame frame) &#123; this.frame = frame; &#125; public JFrame getFrame() &#123; return this.frame; &#125; public Point getP() &#123; return topPanel.getMousePosition(); &#125; public void setP(Point p) &#123; this.mouseP = p; &#125; public JPanel getTopPanel() &#123; return topPanel; &#125; public void setPreImg(ImageIcon preImg) &#123; this.preImg=preImg; &#125; public void setBlurImg(ImageIcon blurImg) &#123; this.blurImg=blurImg; &#125; //鼠标移动效果，选中的植物 class TopPanel extends JPanel &#123; private static final long serialVersionUID = 1L; Graphics2D g2; public void paintComponent(Graphics g) &#123; super.paintComponent(g); g2 = (Graphics2D) g; Point mouseP = getP(); if (mouseP != null) &#123; int c = (mouseP.x - 40) / 80; int r = (mouseP.y - 90) / 100; if (isOnGrass(r, c) &amp;&amp; plants[r][c] == null) &#123; g2.drawImage(blurImg.getImage(), 40 + c * 80, 90 + r * 100, this); &#125; g2.drawImage(preImg.getImage(), mouseP.x - 35, mouseP.y - 40, preImg.getIconWidth(), preImg.getIconWidth(), this); &#125; &#125; public void update(Graphics g) &#123; Image offScreenImage = this.createImage(800, 600); Graphics gImage = offScreenImage.getGraphics(); paint(gImage); if (mouseP != null) &#123; g.drawImage(offScreenImage, mouseP.x - 35, mouseP.y - 40, null); &#125; &#125; &#125; public void plantDeath(int row, int column) &#123; if (plants[row][column] != null) &#123; System.out.println("Error occurred:deleted a non-exist plant from (" + row + "," + column + ")"); &#125; //System.out.println(plants[row][column].getName() + " is dead at(" + row + "," + column + ")"); plants[row][column] = null; &#125; private boolean isOnGrass(int r, int c) &#123;// (r,c)-&gt;grass return r &gt;= 0 &amp;&amp; r &lt; numRow &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; numCol; &#125; //鼠标选中的植物卡牌下标 private int selectedIndex = -1; public void setSelectedIndex(int x)&#123; this.selectedIndex = x; &#125; public int getSelectedIndex()&#123; return selectedIndex; &#125; class myMouseListener extends MouseAdapter implements MouseMotionListener &#123; private TopPanel topPanel; myMouseListener(TopPanel topPanel) &#123; this.topPanel = topPanel; &#125; public void mouseClicked(MouseEvent e) &#123; Point p = getP(); if(p==null)return; //TO-DO 种植 &#125; public void mouseMoved(MouseEvent e)&#123; setP(e.getPoint()); topPanel.repaint(); &#125; public void mousePressed(MouseEvent e) &#123;&#125; public void mouseReleased(MouseEvent e) &#123;&#125; public void mouseEntered(MouseEvent e) &#123;&#125; public void mouseDragged(MouseEvent e) &#123;&#125; public void mouseExited(MouseEvent e) &#123;&#125; &#125; public void plant(int r,int c,Plant plant)&#123; plant.setController(this); plant.setVisible(true); plant.setBounds(45 + c * 80, 90 + r * 100, 300, 300); plant.setPos(r, c); layeredPane.add(plant, new Integer(50)); plants[r][c]=plant; new Thread(plant).start(); &#125; public boolean findZombie(int row,int column)&#123; return false;//TO-DO &#125; public Controller()&#123; setCardMap(); cardNum=0; this.setSunCount(150); this.topPanel.addMouseMotionListener(new myMouseListener(this.topPanel)); this.topPanel.addMouseListener(new myMouseListener(this.topPanel)); this.topPanel.setVisible(false); isRunning=true; &#125;&#125; 2019.11.11GameboardView.java我就是调参大师.jpg 实现了上来左右摇摆对准的功能以及倒计时，并分配了cardboard的进入动画和鼠标图片topPanel。 移动方面有待改进……效果还可以，留到以后再改。 这部分对准参数之后没啥好说的。每个动画效果都是在不停的对坐标进行修改、对Panel进行repaint做出来的。 这里panel、Panel分别表示了背景图片和Panel，cardboard和Cardboard同理。这里命名有问题，以后再做修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182package view;import controller.*;import java.awt.Graphics;import java.util.concurrent.Executor;import java.util.concurrent.Executors;import javax.swing.*;public class GameboardView extends JLayeredPane &#123; private static final long serialVersionUID = 1L; private JFrame GameFrame; private ImageIcon panel, cardboard; private JPanel Panel; private JPanel Cardboard; Controller controller; private int x = -10; private boolean flag = false; private int direction = 1; private JLabel SunLabel; class PaintThread implements Runnable &#123; JFrame frame; PaintThread(LaunchFrame launchFrame) &#123; this.frame = launchFrame; &#125; @Override public void run() &#123; try &#123; Thread.sleep(1600); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //左右移动对准 for (int i = 0; i &lt; 895; i++) &#123; // System.out.println("now x:" + x + ",i:" + i); if (x &lt;= -560 &amp;&amp; !flag) &#123; flag = true; direction = -1; try &#123; Thread.sleep(400); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; int j=i-551; int delaytime= i&lt;1?10: i&lt;2?9: i&lt;3?8: i&lt;4?7: i&lt;5?6: i&lt;6?5: i&lt;7?4: i&lt;8?3: i&lt;9?2: i&lt;534?1: i&lt;537?2: i&lt;540?3: i&lt;544?4: i&lt;547?5: i&lt;549?6: i&lt;550?8:14; if(j&gt;0)&#123; delaytime= j&lt;1?12: j&lt;2?11: j&lt;3?10: j&lt;4?9: j&lt;5?8: j&lt;6?7: j&lt;7?6: j&lt;8?5: j&lt;9?4: j&lt;10?3: j&lt;12?2: j&lt;314?1: j&lt;319?2: j&lt;324?3: j&lt;327?4: j&lt;330?5: j&lt;333?6: j&lt;334?8:14; &#125; try &#123; Thread.sleep(delaytime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; x-=direction; Panel.repaint(); &#125; //cardboard淡入 for (int y = -40 ; y &lt;= 5; y++) &#123; Cardboard.setBounds(20,y,cardboard.getIconWidth(), cardboard.getIconHeight()); try &#123; Thread.sleep(10); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Cardboard.repaint(); &#125; //倒计时 JLabel label; for (int i=1 ; i&lt;=3 ; i++)&#123; try &#123; label = new JLabel(new ImageIcon("img\\PrepareGrowPlants"+i+".png")); GameboardView.this.add(label,1); label.setBounds(250,200,300,200); Thread.sleep(700); label.setVisible(false); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; Thread.sleep(800); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; GameboardView(LaunchFrame launchframe)&#123; this.controller=new Controller(); this.GameFrame=launchframe; this.GameFrame.setContentPane(GameboardView.this); this.setVisible(true); //bg panel=new ImageIcon("img\\background1.jpg"); Panel=new JPanel()&#123; private static final long serialVersionUID = 1L; public void paintComponent(Graphics g)&#123; super.paintComponent(g); g.drawImage(panel.getImage(),x,0, this.getWidth(),this.getHeight(), this); &#125; &#125;; Panel.setVisible(true); Panel.setBounds(0,0,panel.getIconWidth(),panel.getIconHeight()); GameboardView.this.add(Panel,-1); //cardboard cardboard=new ImageIcon("img\\SeedBank.png"); Cardboard=new JPanel()&#123; private static final long serialVersionUID = 1L; public void paintComponent(Graphics g) &#123; super.paintComponent(g); g.drawImage(cardboard.getImage(),0,0, cardboard.getIconWidth(), cardboard.getIconHeight(),this); &#125; &#125;; Cardboard.setVisible(true); Cardboard.setLayout(null); GameboardView.this.add(Cardboard,0); Executor exec = Executors.newSingleThreadExecutor(); Thread Animation=new Thread(new PaintThread(launchframe)); exec.execute(Animation); JPanel topPanel = controller.getTopPanel(); topPanel.setVisible(false); topPanel.setBounds(0,0, panel.getIconWidth(), panel.getIconHeight()); GameboardView.this.add(topPanel, new Integer(114514)); &#125; &#125; LaunchFrame.java实现了一个开始界面（留了很多余地给之后分配，这里不是游戏主体先不去做扩展）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package view;import javax.swing.*;import java.awt.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;public class LaunchFrame extends JFrame&#123; private static final long serialVersionUID = 1L; private JLayeredPane layeredPane = new JLayeredPane(); public LaunchFrame()&#123; this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); this.setTitle("PVZ"); this.setSize(810,625); this.setResizable(false); this.setLocationRelativeTo(null); this.setVisible(true); this.setContentPane(layeredPane); this.setIconImage(new ImageIcon("img\\Icon.png").getImage()); ImageIcon background=new ImageIcon("img\\Surface.png"); JPanel panel=new JPanel()&#123; private static final long serialVersionUID = 1L; public void paintComponent(Graphics g) &#123; super.paintComponent(g); g.drawImage(background.getImage(),0,0, this.getWidth(),this.getHeight(),this); &#125; &#125;; panel.setBounds(0,0,background.getIconWidth(),background.getIconHeight()); layeredPane.add(panel,10); ImageIcon startImg=new ImageIcon("img\\SelectorScreen_Adventure_highlight.png"); ImageIcon startImg2=new ImageIcon("img\\SelectorScreen_StartAdventure_Highlight.png"); JLabel startLabel=new JLabel(startImg); startLabel.addMouseListener(new MouseAdapter() &#123; public void mouseEntered(MouseEvent e) &#123; startLabel.setIcon(startImg2); &#125; public void mouseExited(MouseEvent e) &#123; startLabel.setIcon(startImg); &#125; public void mouseClicked(MouseEvent e)&#123; layeredPane.setVisible(false); new GameboardView(LaunchFrame.this); &#125; &#125;); startLabel.setBounds(410,70,startImg.getIconWidth(),startImg2.getIconHeight()); layeredPane.add(startLabel, 0); &#125; &#125; Main.java？ 1234567import view.*;public class Main&#123; public static void main(String[] args) &#123; new LaunchFrame(); &#125;&#125; 写完这些之后终于可以运行了……感觉还不错（疯狂debug） 2019.11.12把卡片和太阳给做了（ Card.java卡片类，实现选中/非选中状态的图片切换，在Controller.java、Plant.java中也有对应修改，在此不放出。 TO-DO：实现进度条式改变冷却图片，不是只有一黑一白（注释掉了一行失败的尝试）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package view;import controller.*;import java.awt.*;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.util.Map;import javax.swing.ImageIcon;import javax.swing.JLabel;public class Card extends JLabel implements MouseListener, Runnable &#123; private static final long serialVersionUID = 1L; private boolean inCooling; private int cd; private int totTime; private String cardName; private int price; private int cardWidth; private int cardHeight; private ImageIcon card; private ImageIcon cardLight; private ImageIcon cardDark; private ImageIcon preImg; private ImageIcon blurImg; private Map&lt;String, Plant&gt; plantMap; private Controller controller; private int y; private Rectangle rectangle;//卡片位置 private int index; public int getIndex()&#123; return index; &#125; public void setIndex(int index)&#123; this.index = index; &#125; public void setRectangle(int x, int y, int w, int h) &#123; this.rectangle = new Rectangle(x, y, w, h); &#125; public Rectangle getRectangle() &#123; return rectangle; &#125; public Card(String name, Controller controller) &#123; this.controller = controller; this.plantMap = controller.getPlantMap(); this.cardName = name; this.cardLight = new ImageIcon("Img\\Cards\\" + cardName + "0.png"); this.cardDark = new ImageIcon("Img\\Cards\\" + cardName + "1.png"); this.preImg = new ImageIcon("img\\" + cardName + "\\" + cardName + "_0.png "); this.blurImg = new ImageIcon("img\\Blurs\\" + cardName + ".png "); this.card = cardDark; this.inCooling = false; this.addMouseListener(this); this.cardHeight = cardLight.getIconHeight(); this.cardWidth = cardLight.getIconWidth(); this.price = plantMap.get(cardName).getPrice(); this.cd = plantMap.get(cardName).getCardCD(); this.y = card.getIconHeight(); &#125; public void check(int SunCount) &#123;//能否选择这个卡，能：light，否：dark if (SunCount &gt;= plantMap.get(this.cardName).getPrice() &amp;&amp; !inCooling) &#123; card = cardLight; this.repaint(); &#125; else &#123; card = cardDark; this.repaint(); &#125; &#125; public void setInCooling(boolean b) &#123; this.inCooling = b; &#125; public boolean getInCooling() &#123; return inCooling; &#125; public int getPrice() &#123; return price; &#125; public String getCardName() &#123; return cardName; &#125; public int getCardWidth() &#123; return cardWidth; &#125; public int getCardHeight() &#123; return cardHeight; &#125; @Override public void paintComponent(Graphics g) &#123; super.paintComponent(g); //int h=card.getIconHeight(); g.drawImage(card.getImage(), 0, 0, card.getIconWidth(), card.getIconHeight(), this); //g.drawImage(card.getImage(), 0, h-h*totTime/cd, card.getIconWidth(), h*totTime/cd, this); g.drawImage(cardDark.getImage(), 0, y, card.getIconWidth(), card.getIconHeight(), this); &#125; public void selected() &#123;//卡牌被选中 if (!inCooling &amp;&amp; controller.getIntSunCount() &gt;= this.getPrice()) &#123; controller.getTopPanel().setVisible(true); controller.setPreImg(this.preImg); controller.setBlurImg(this.blurImg); controller.setCard(this); controller.setSelectedIndex(index); controller.nowPlant = new Plant().getPlant(this.getCardName()); //System.out.println("Selected :" + controller.nowPlant.getName()); inCooling = true; check(0); &#125; &#125; @Override public void mouseClicked(MouseEvent e) &#123; selected(); &#125; @Override public void mouseEntered(MouseEvent e) &#123;&#125; @Override public void mouseExited(MouseEvent e) &#123;&#125; @Override public void mousePressed(MouseEvent e) &#123;&#125; @Override public void mouseReleased(MouseEvent e) &#123;&#125; @Override public void run() &#123; while (controller.isRunning) &#123; while (controller.isRunning &amp;&amp; !inCooling) &#123; check(controller.getIntSunCount()); try &#123; Thread.sleep(4); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; check(controller.getIntSunCount()); while(controller.isRunning)&#123; try &#123; Thread.sleep(3); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; totTime+=3; if(totTime&gt;=cd)&#123; break; &#125; check(controller.getIntSunCount()); &#125; totTime=0; inCooling=false; &#125; &#125;&#125; Sun.java阳光有两种方式生成，向日葵掉落或者随机从天上生成。分为三个阶段，掉落、停留、消失。掉落阶段一个是抛物线，一个是直线，分别模拟一下就可以了，这里抛物线用若干条线段进行模拟；停留阶段进行旋转；消失阶段进行边收集边消失或者直接淡出。 这里太阳逐渐消失用到了一个神秘函数：g2.setComposite(AlphaComposite.SrcOver.derive((float) alpha / 100)); 其中alpha表示不透明度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210package view;import javax.swing.*;import java.awt.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import controller.*;public class Sun extends JLabel implements Runnable &#123; private static final long serialVersionUID = 1L; private Image image, offScreenImage; private int x, y; private boolean isCollected; private int nowPic; private static int totPic = 21; private Controller controller; private boolean drop;// 掉落还是随机生成 // 随机生成： private int ymax;// 下 // 向日葵掉落： private int ymin; private int startX,startY, endX,endY; public Sun(Controller controller) &#123; this.x = (int) (Math.random() * 660) + 30; this.ymin = this.y = 40; this.ymax = (int) (Math.random() * 400) + 130; this.controller = controller; this.drop = false; setVisible(true); controller.getLayeredPane().add(this, new Integer(500)); &#125; public Sun(Controller controller, int r, int c) &#123; this(controller); this.drop = true; this.ymin = r * 100 + 55; startX=c * 80 + 34 + (int) (Math.random() * 2); startY= r * 100 + 80; endX=c * 80 + 30 + (int) (Math.random() * 10); endY=r * 100 + 100; this.x = startX; this.y = startY; &#125; public void picChange() &#123; nowPic = (nowPic + 1) % totPic; &#125; public void shrink() &#123; for (int i = 1; i &lt;= 50; i++) &#123; if (i % 8 == 0) &#123; picChange(); &#125; alpha -= 2; try &#123; Thread.sleep(7); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; repaint(); &#125; setVisible(false); &#125; @Override public void run() &#123; this.addMouseListener(new MouseAdapter() &#123; @Override public void mouseEntered(MouseEvent e) &#123; if (!isCollected) &#123; isCollected = true; &#125; &#125; &#125;); //dropping if (drop) &#123; // 掉落，用线段近似二次函数 int vx=1,vy=2; boolean flag1=false,flag2=false,flag3=false,flag4=false; int dx=(endX&gt;=startX)?1:-1,dy=-1; for(int i = 1; (this.x&lt;=endX&amp;&amp;dx==1)||(this.x&gt;=endX&amp;&amp;dx==-1) || this.y&lt;=endY; i++)&#123; if(i%5==0)&#123; this.picChange(); &#125; this.setBounds(x,y,78,78); try&#123; Thread.sleep(10); &#125;catch(InterruptedException e1)&#123; e1.printStackTrace(); &#125; x+=dx*vx;y+=dy*vy; if(!flag1)&#123; if(y&lt;=(ymin+startY)/2)&#123; flag1=true; vy=1; &#125;; &#125;else if(!flag2)&#123; if(y&lt;=ymin)&#123; vy=-1; flag2=true; &#125; &#125;else if(!flag3)&#123; if((x&gt;=(endX*3+startX)/4||y&gt;=(ymin+endY)/2))&#123; vy=-2; flag3=true; &#125; &#125;else if(!flag4)&#123; if((x&gt;=(endX*7+startX)/8||y&gt;=(startY+endY)/2))&#123; vy=-3; flag4=true; &#125; &#125; this.repaint(); &#125; &#125; else &#123; // 随机生成，直线 for (int i = 1; this.y &lt; ymax &amp;&amp; !isCollected; i++) &#123; if (i % 50 == 0) &#123; this.picChange(); &#125; this.setBounds(x, y, 78, 78); try &#123; Thread.sleep(1); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; if (i % 10 == 0) this.y++; this.repaint(); &#125; &#125; // onGround for (int i = 1; i &lt;= 5000 &amp;&amp; !isCollected; i++) &#123; if (i % 50 == 0) &#123; this.picChange(); &#125; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; this.repaint(); &#125; // collected Point tempPoint=new Point(x,y); if (isCollected) &#123; controller.addSunCount(25); controller.checkCards(); int dir=x&lt;33?-1:1; for (int i = 1; (dir==1&amp;&amp;x &gt; 33||x&lt;=33&amp;&amp;dir==-1) &amp;&amp; y &gt; 33; i++) &#123; if (i % 10 == 0) &#123; this.picChange(); &#125; double ty=(x-33)*(tempPoint.getY()-33)/(tempPoint.getX()-33)+33; if((ty&lt;=y&amp;&amp;dir==1)||(ty&gt;=y&amp;&amp;dir==-1))&#123; y--; &#125;else&#123; x--; if((int)((100*x-3200)/(tempPoint.getX()-33))!=(int)((100*x-3300)/(tempPoint.getX()-33)))&#123; alpha-=(Math.random()&gt;=0.45)?1:0; //System.out.println("alpha reduced from point ("+x+","+y+")"); &#125; &#125; this.setBounds(x, y, 78, 78); this.repaint(); try &#123; Thread.sleep(1); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125;else&#123; //disappear this.shrink(); &#125; setVisible(false); Thread.currentThread().interrupt(); &#125; private double alpha = 100; @Override public void paintComponent(Graphics g) &#123; super.paintComponent(g); ImageIcon img = new ImageIcon("img\\Sun\\"+nowPic+".png"); image = img.getImage(); Graphics2D g2 = (Graphics2D) g; g2.setComposite(AlphaComposite.SrcOver.derive((float) alpha / 100)); g2.drawImage(image, 0, 0, img.getIconWidth(), img.getIconWidth(), this); &#125; public void update(Graphics g) &#123; if(offScreenImage == null) offScreenImage = this.createImage(800, 600); Graphics gImage = offScreenImage.getGraphics(); paint(gImage); g.drawImage(offScreenImage, 0, 0, null); &#125; &#125; SunProducer.java负责从天上随机掉落阳光。 123456789101112131415161718192021222324252627282930package view;import controller.*;public class SunProducer implements Runnable&#123; private Controller controller; SunProducer(Controller controller)&#123; this.controller = controller; &#125; @Override public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; while (controller.isRunning)&#123; try &#123; Thread.sleep((int) (Math.random()*1000)+7000); //7~8s随机生成一个 new Thread(new Sun(controller)).start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Thread.currentThread().interrupt(); &#125;&#125; 到此为止，基本的向日葵有关的操作已经结束了。然后又向Plant、controller、card里面加了点关于豌豆射手的东西，接下来就该添加僵尸和子弹了。 这里用了个map存名字和植物类型的关系，大概可以参考一下java笔记–Map的用法 - CSDN 2019.11.15由于前几天考计组，又在补作业，被迫停了一段时间。这段时间里，梳理了一下大致需要做的方向： 普通僵尸位置、碰撞、啃食、死亡逻辑；普通僵尸生成；子弹发射、碰撞逻辑；done 新植物及其逻辑；新僵尸及其逻辑； 对向日葵将要产出太阳时的动画进行优化； 设置关卡； 在初始界面设置其他操作； 在游戏中设置暂停、退出、重新开始、返回主菜单等功能。 不知道这些东西能实现到哪里？ Zombie.java本以为僵尸不是那么难写，结果又要掉胳膊又要掉头还要有啃食动画，搞不好被樱桃炸弹炸糊了还得有个特殊的动画，这还不算多，搜了一下还有临界血量，低于这个血量虽然失去攻击力但还能吸收伤害并不断掉血…… 好麻烦…… （还没写完，正在写） （感觉真的好难写） update: 写完了。 实现了走动、掉头（走动时及啃食时）、死亡的动画，实现了临界血量。 没掉胳膊，，，不想实现了（没图源），如果需要实现还要实现一个状态自动机。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262package view;import javax.swing.*;import java.awt.*;import controller.*;public class Zombie extends JLabel implements Runnable &#123; private static final long serialVersionUID = 1L; private static int MOVE = 1; private static int ATTACK = 2; private static int LOSTHEAD = 3; private static int LOSTHEADATTACK = 4; private static int DIE = 5; private static int BOOM = 6; private static int BOOMINJURY = 1000; private String name; // hp2:临界值 // attack: /s private int hp, hp2, state = 1; // 走一格时间/格长=走1的时间 // private int v; private int x, y; private int row; private ImageIcon img; private int[] sumPic = new int[3]; private int nowSumPic; private int nowPic = 0; private int type; private Controller controller; public int getXPos() &#123; return x; &#125; public Zombie() &#123; &#125; public Zombie(Controller controller, String name, int hp, int hp2, int row, int v) &#123; setVisible(true); this.nowPic = 0; this.controller = controller; this.name = name; this.hp = hp + hp2; this.hp2 = hp2; this.y = row * 100 + 28; this.x = 800; this.row = row; this.sumPic[0] = 22; this.sumPic[1] = 31; this.sumPic[2] = 18; this.setState(MOVE); controller.getLayeredPane().add(this, new Integer(400)); &#125; @Override public void paintComponent(Graphics g) &#123; ImageIcon Img; super.paintComponent(g); Graphics2D g2 = (Graphics2D) g; img = new ImageIcon("img\\shadow.png"); g.drawImage(img.getImage(), 70, 115, img.getIconWidth(), img.getIconHeight(), this); if (state == MOVE) &#123; Img = new ImageIcon("img\\Zombie" + type + "\\Frame" + nowPic + ".png"); g2.drawImage(Img.getImage(), 0, 0, Img.getIconWidth(), Img.getIconHeight(), this); &#125; else if (state == ATTACK) &#123; Img = new ImageIcon("img\\ZombieAttack\\Frame" + nowPic + ".png"); g2.drawImage(Img.getImage(), 0, 0, Img.getIconWidth(), Img.getIconHeight(), this); &#125; else if (state == LOSTHEAD) &#123; Img = new ImageIcon("img\\ZombieLostHead\\Frame" + nowPic + ".png"); g2.drawImage(Img.getImage(), 0, 0, Img.getIconWidth(), Img.getIconHeight(), this); // 头动画只持续前10帧 if (nowPic &lt; 10) &#123; Img = new ImageIcon("img\\ZombieHead\\Frame" + nowPic + ".png"); g2.drawImage(Img.getImage(), 60, 0, Img.getIconWidth(), Img.getIconHeight(), this); &#125; &#125; else if (state == LOSTHEADATTACK) &#123; Img = new ImageIcon("img\\ZombieLostHeadAttack\\Frame" + nowPic + ".png"); g2.drawImage(Img.getImage(), 0, 0, Img.getIconWidth(), Img.getIconHeight(), this); &#125; else if (state == DIE) &#123; Img = new ImageIcon("img\\ZombieDie\\Frame" + nowPic + ".png"); g2.drawImage(Img.getImage(), 0, 0, Img.getIconWidth(), Img.getIconHeight(), this); &#125; else if (state == BOOM) &#123; Img = new ImageIcon("img\\ZombieBoom\\Frame" + nowPic + ".png"); g2.drawImage(Img.getImage(), 0, 0, Img.getIconWidth(), Img.getIconHeight(), this); &#125; &#125; public Zombie normalZombie(Controller controller, int row) &#123; Zombie tempZombie = new Zombie(controller, "NormalZombie", 200, 70, row, 4700 / 80); tempZombie.type = (int) Math.random() * 3; return tempZombie; &#125; public void setState(int state) &#123; this.state = state; nowPic = 0; if (state == MOVE) &#123; this.nowSumPic = sumPic[type]; &#125; else if (state == ATTACK) &#123; this.nowSumPic = 21; &#125; else if (state == LOSTHEAD) &#123; this.nowSumPic = 18; &#125; else if (state == LOSTHEADATTACK) &#123; this.nowSumPic = 11; &#125; else if (state == DIE) &#123; this.nowSumPic = 14; &#125; else if (state == BOOM) &#123; this.nowSumPic = 20; &#125; &#125; public void updateState() &#123; if (hp &lt;= 0) &#123; if (this.state != DIE &amp;&amp; this.state != BOOM) setState(DIE); &#125; else if (hp &lt;= hp2) &#123; if (this.state == ATTACK) setState(LOSTHEADATTACK); else if(this.state != LOSTHEAD) setState(LOSTHEAD); &#125; &#125; public Plant getPlant() &#123; assert (findPlant()); return controller.getPlants()[row][(x + 60) / 80]; &#125; public boolean findPlant() &#123; if ((x + 60) / 80 &gt;= 9) return false; return controller.getPlants()[row][(x + 60) / 80] != null; &#125; public void reduceHP(int x) &#123; this.hp -= x; updateState(); //System.out.println("reduced to "+hp+",state="+state); &#125; public void boom() &#123; if (this.hp &gt; BOOMINJURY) &#123; reduceHP(BOOMINJURY); &#125; else &#123; this.hp = 0; setState(BOOM); &#125; &#125; @Override public void run() &#123; setState(MOVE); while (hp &gt; hp2) &#123; // MOVE while (this.state == MOVE) &#123; if (findPlant()) &#123; setState(ATTACK); break; &#125; // sleep 60ms, x-- for(int j = 0; j &lt; 2; j++) &#123; for (int i = 0; i &lt; 10 &amp;&amp; this.state == MOVE; i++) &#123; try &#123; Thread.sleep(6); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.x--; this.setBounds(x, y, 400, 300); this.repaint(); &#125; //120ms nowPic = (nowPic + 1) % nowSumPic; &#125; // ATTACK while (this.state == ATTACK) &#123; if (this.name == "NormalZombie") &#123; // 普通僵尸的攻击方式：1s 200伤害，5ms 1伤害 // sleep 120ms change for (int i = 0; i &lt; 24 &amp;&amp; this.state == ATTACK &amp;&amp; findPlant(); i++) &#123; getPlant().attacked(1); try &#123; Thread.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; nowPic = (nowPic + 1) % nowSumPic; this.repaint(); if (!findPlant()) setState(MOVE);// 不掉胳膊 &#125; &#125; &#125; while (hp &gt; 0) &#123; // 临界状态 while (this.state == LOSTHEAD || this.state == LOSTHEADATTACK) &#123; //sleep 60ms change for(int j = 0; j &lt; 2; j++) &#123; for (int i = 0; i &lt; 10 &amp;&amp; hp &gt; 0; i++) &#123; try &#123; Thread.sleep(6); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.x--; this.setBounds(x, y, 400, 300); this.repaint(); &#125; //120ms nowPic = (nowPic + 1) % nowSumPic; reduceHP(7); &#125; controller.deleteZombie(this, row); // 死亡 while (true) &#123; for (int i = 0; i &lt; nowSumPic; i++) &#123; //sleep 120ms change try &#123; Thread.sleep(120); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.repaint(); nowPic = (nowPic + 1) % nowSumPic; &#125; break; &#125; &#125; while (this.state == BOOM) &#123; // 爆炸 while (true) &#123; for (int i = 0; i &lt; nowSumPic; i++) &#123; //sleep 50ms change try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; this.repaint(); nowPic = (nowPic + 1) % nowSumPic; &#125; break; &#125; &#125; setVisible(false); Thread.currentThread().interrupt(); &#125;&#125; ZombieProducer.java实现随机生成一堆僵尸的功能，以后还需要改成一波波僵尸的样子来配合关卡。 12345678910111213141516171819202122232425262728293031323334package view;import controller.*;public class ZombieProducer implements Runnable&#123; private Controller controller; ZombieProducer(Controller controller)&#123; this.controller = controller; &#125; @Override public void run() &#123; try &#123; Thread.sleep(20000); //开局20s无生成 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; while (controller.isRunning)&#123; try &#123; Thread.sleep((int) (Math.random()*1000)+1000); //7~8s随机生成一个 int row=(int)(Math.random()*5); Zombie tempZombie=new Zombie().normalZombie(controller,row); controller.addZombie(tempZombie,row); new Thread(tempZombie).start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Thread.currentThread().interrupt(); &#125;&#125; Bullet.java配合plant、controller对僵尸进行打击。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package view;import controller.*;import javax.swing.*;import java.awt.*;public class Bullet extends JLabel implements Runnable &#123; private static final long serialVersionUID = 1L; private Controller controller; private ImageIcon img; private int x, y, row; @Override public void paintComponent(Graphics g) &#123; super.paintComponent(g); Graphics2D g2 = (Graphics2D) g; g2.drawImage(img.getImage(), 0, 0, img.getIconWidth(), img.getIconHeight(), this); &#125; public Bullet() &#123; &#125; public Bullet(Controller controller, int row, int column) &#123; setVisible(true); img = new ImageIcon("img\\Bullets\\PeaShooter.png"); this.controller = controller; this.row = row; this.x = 40 + column * 80 + 40; this.y = 90 + row * 100; this.setBounds(x, y, img.getIconWidth(), img.getIconHeight()); controller.getLayeredPane().add(this, new Integer(500)); &#125; public Bullet Pea(Controller controller, int row, int column) &#123; Bullet tempBullet = new Bullet(controller, row, column); return tempBullet; &#125; public void bulletAttack(Zombie zombie) &#123; zombie.reduceHP(20); &#125; @Override public void run() &#123; while (true) &#123; Zombie tempZombie = controller.getAttackedZombie(row, x - 40); if (tempZombie != null) &#123; this.bulletAttack(tempZombie); break; &#125; try &#123; Thread.sleep(5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; x += 5; this.setBounds(x, y, img.getIconWidth(), img.getIconHeight()); this.repaint(); if (x &gt; 810) break; &#125; // boom img = new ImageIcon("img\\Bullets\\PeaShooterHit.png"); try &#123; Thread.sleep(150); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; setVisible(false); Thread.currentThread().interrupt(); &#125; &#125; 其他的controller、plant等部分也有很多调整，其中controller中实现了对于僵尸群的列表表示，使用了ArrayList类型的List分别表示五行中的僵尸，详情还是见github上的源码吧。 2019.11.16添加了双发射手，修复了各种逻辑的小bug 并添加了etz阳光和xsy僵尸的逻辑（照片不上传）]]></content>
  </entry>
  <entry>
    <title><![CDATA[2018 ICPC Jiaozuo Regional Contest 题解]]></title>
    <url>%2F2019%2F10%2F27%2F2018icpcjiaozuo%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L 9/12 O O Ø O O O . O O Ø . . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A Xu Xiake in Henan Province 题目描述输入四个数，分情况输出。 解题思路签到，依题意做即可。 AC代码 - by Mogg点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;bitset&gt;#include &lt;unordered_map&gt;#include &lt;set&gt;using namespace std;typedef long long ll;const int ms = 1e5 + 10;const ll mod = 1000000007;typedef pair&lt;int, int&gt; pt;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; while (t--) &#123; int a; int len = 0; for (int i = 0; i &lt; 4; ++i) &#123; cin &gt;&gt; a; if (a &gt; 0)len++; &#125; switch (len) &#123; case 0: cout &lt;&lt; "Typically Otaku\n"; break; case 1: cout &lt;&lt; "Eye-opener\n"; break; case 2: cout &lt;&lt; "Young Traveller\n"; break; case 3: cout &lt;&lt; "Excellent Traveller\n"; break; case 4: cout &lt;&lt; "Contemporary Xu Xiake\n"; &#125; &#125; return 0;&#125; B Ultraman vs. Aodzilla and Bodzilla 题目描述有两只怪兽，分别有$h_1,h_2$的血量和$a_1,a_2$的攻击力。每回合你可以选择一个怪兽进行攻击，第$i$回合你的攻击力是$i$。每回合怪兽如果没死会对你造成$a_i$点的伤害。 假设你在第$i$回合攻击第一只怪兽，$s[i]=’A’$，否则$s[i]=’B’$。于是得到一个攻击的$AB$序列，求在最小化受到伤害的同时最小化这个序列的字典序。 解题思路首先，直接根据伤害血量百分比贪心的思路被10 5 6 4这组数据否定。这组数据正确的攻击序列应为ABBAA。 假设先把第一个怪兽打死。设$x$为一直打第一个怪兽直到它被打死所需的最少时间，有$\frac{x(x+1)}2\geq h_1$。设$y$为打两个怪兽且不浪费攻击力的情况下需要的最少时间，有$\frac{y(y+1)}2\geq h_1+h_2$。那么必然分别在这两个时间时把它们打死是最优的。现在只需要使得打第一只怪兽的时候尽量不浪费攻击力且使得字典序最小。 设$x$回合内一直攻击第一只怪兽浪费了$t$点攻击力，则必然能够用前$x$回合内的若干次攻击凑出$t$去攻击第二只怪兽，从而避免浪费。于是贪心地从高到低枚举攻击力分配给第二只怪兽即可。 当我们先把第二个怪兽打死时，类似的可以处理，但是因为要字典序最小，所以在贪心的时候需要从低到高枚举攻击力分配给第一只怪兽。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;#pragma GCC optimize(3)typedef long long ll;using namespace std;char a[100010],b[100010];ll ans1,ans2;void calc(char a[],ll h1,ll a1,ll h2,ll a2,ll &amp;ans)&#123; int i;ll t1=sqrt(2*h1)-1,t2=sqrt(2*h1+2*h2)-1; while(t1*(t1+1)/2&lt;h1)t1++; while(t2*(t2+1)/2&lt;h1+h2)t2++; ll tot=t1*(t1+1)/2-h1; ll remain=h2-(t2*(t2+1)/2-t1*(t1+1)/2); ans=1LL*a1*t1+1LL*a2*t2; for(i=0;i&lt;t1;i++)a[i]='B'; for(;i&lt;t2;i++)a[i]='A'; a[i]='\0'; for(i=1;i&lt;t1;i++)&#123; if((remain-i&lt;=0&amp;&amp;tot&gt;=i)||tot-i&gt;i)&#123; a[i-1]='A'; tot-=i; remain-=i; &#125; &#125; if(tot)a[tot-1]='A';&#125;void calc2(char a[],ll h1,ll a1,ll h2,ll a2,ll &amp;ans)&#123; int i;ll t1=sqrt(2*h1)-1,t2=sqrt(2*h1+2*h2)-1; while(t1*(t1+1)/2&lt;h1)t1++; while(t2*(t2+1)/2&lt;h1+h2)t2++; ans=1LL*a1*t1+1LL*a2*t2; for(i=0;i&lt;t1;i++)a[i]='A'; for(;i&lt;t2;i++)a[i]='B'; a[i]='\0'; ll remain=h2-(t2*(t2+1)/2-t1*(t1+1)/2); ll now=t1*(t1+1)/2-h1; while(remain&gt;0&amp;&amp;t1)&#123; if(now-t1&gt;=0)now-=t1,remain-=t1,a[t1-1]='B'; t1--; &#125;&#125;int main()&#123; int T;ll h1,h2,a1,a2; scanf("%d",&amp;T); while(T--)&#123; scanf("%lld%lld%lld%lld",&amp;h1,&amp;h2,&amp;a1,&amp;a2); calc2(a,h1,a1,h2,a2,ans1); calc(b,h2,a2,h1,a1,ans2); if(ans1&gt;ans2||(ans1==ans2&amp;&amp;strcmp(a,b)&gt;0))printf("%lld %s\n",ans2,b); else printf("%lld %s\n",ans1,a); &#125; return 0;&#125; C Supreme Command 题目描述给一个$n\times n$的棋盘，上面有$n$个棋子，每一列、每一行上均有且只有一个棋子。 有$m$次操作：将棋盘上所有棋子向上/下/左/右移动$x$格，棋子可重叠，不可超出边界；询问某个点坐标；询问有多少对棋子在同一个格子上。 $1\leq n,m\leq 300000$ 解题思路考虑将边界向内收，用四个变量lrud记录上下左右收到哪里了，用另四个变量LRUD记录空出来的区域大小。（现在看来似乎只用后四个就行了） 记录收起来的左上角、右上角、左下角、右下角的棋子个数（代码中使用了$cnt[1],cnt[3],cnt[7],cnt[9]$，因为刚开始的时候是当做九宫格处理的，后来发现只需要维护这四个即可），因为只有在这里相遇。然后每个点只能使用一次，记录一下即可。 调了好久结果是一个$mplr$写成$mpud$的问题…… 这题没有一个中强的数据，提供一个： 123456789101112131415161718192021221 5 151 3 2 1 3 4 4 2 5 5D 1 D 1 U 2 ! D 1 ! L 1 D 1 ! R 2 !D 2 ! R 2! 答案是0 0 0 1 2 10。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;#define mp make_pair#define fi first#define se secondtypedef long long ll;using namespace std;#define N 300010int mplr[N],mpud[N],mark[N],cnt[15];int used[N];pair&lt;int,int&gt;p[N];ll f(int x)&#123;return 1LL*x*(x-1)/2;&#125;ll calc(int l,int r,int u,int d)&#123; if(l==r&amp;&amp;u==d)return f(cnt[1]+cnt[3]+cnt[7]+cnt[9]); else if(l==r)return f(cnt[1]+cnt[3])+f(cnt[7]+cnt[9]); else if(u==d)return f(cnt[1]+cnt[7])+f(cnt[3]+cnt[9]); return f(cnt[1])+f(cnt[3])+f(cnt[7])+f(cnt[9]);&#125;int main()&#123; int i,T,n,m; scanf("%d",&amp;T); while(T--)&#123; memset(used,0,sizeof(used)); memset(mark,0,sizeof(mark)); memset(cnt,0,sizeof(cnt)); memset(mplr,0,sizeof(mplr)); memset(mpud,0,sizeof(mpud)); scanf("%d%d",&amp;n,&amp;m); int l=1,r=n,u=1,d=n; int L=0,R=0,U=0,D=0; for(i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;p[i].fi,&amp;p[i].se); mpud[p[i].fi]=mplr[p[i].se]=i; if(p[i].fi==1)&#123; if(p[i].se==1)cnt[1]++,used[i]=1; else if(p[i].se==n)cnt[3]++,used[i]=1; &#125;else if(p[i].fi==n)&#123; if(p[i].se==1)cnt[7]++,used[i]=1; else if(p[i].se==n)cnt[9]++,used[i]=1; &#125; &#125; while(m--)&#123; int x;char opt[3]=&#123;0&#125;; scanf("%s",opt); if(opt[0]!='!')scanf("%d",&amp;x); if(opt[0]=='L')&#123; if(L&gt;x)L-=x,R+=x,x=0; else x-=L,R+=L,L=0; while(x--&amp;&amp;l&lt;r)&#123; if(used[mplr[l+1]]); else if(p[mplr[l+1]].first&lt;=u)cnt[1]++,used[mplr[l+1]]=1; else if(p[mplr[l+1]].first&gt;=d)cnt[7]++,used[mplr[l+1]]=1; l++;R++; &#125; &#125;else if(opt[0]=='R')&#123; if(R&gt;x)R-=x,L+=x,x=0; else x-=R,L+=R,R=0; while(x--&amp;&amp;l&lt;r)&#123; if(used[mplr[r-1]]); else if(p[mplr[r-1]].first&lt;=u)cnt[3]++,used[mplr[r-1]]=1; else if(p[mplr[r-1]].first&gt;=d)cnt[9]++,used[mplr[r-1]]=1; r--;L++; &#125; &#125;else if(opt[0]=='U')&#123; if(U&gt;x)U-=x,D+=x,x=0; else x-=U,D+=U,U=0; while(x--&amp;&amp;u&lt;d)&#123; if(used[mpud[u+1]]); else if(p[mpud[u+1]].second&lt;=l)cnt[1]++,used[mpud[u+1]]=1; else if(p[mpud[u+1]].second&gt;=r)cnt[3]++,used[mpud[u+1]]=1; u++;D++; &#125; &#125;else if(opt[0]=='D')&#123; if(D&gt;x)D-=x,U+=x,x=0; else x-=D,U+=D,D=0; while(x--&amp;&amp;u&lt;d)&#123; if(used[mpud[d-1]]); else if(p[mpud[d-1]].second&lt;=l)cnt[7]++,used[mpud[d-1]]=1; else if(p[mpud[d-1]].second&gt;=r)cnt[9]++,used[mpud[d-1]]=1; d--;U++; &#125; &#125;else if(opt[0]=='?')printf("%d %d\n",min(d,max(u,p[x].fi))-u+1+U,min(r,max(l,p[x].se))-l+1+L); else printf("%lld\n",calc(l,r,u,d)); &#125; &#125; return 0;&#125; D Keiichi Tsuchiya the Drift King 题目描述有一辆矩形的车，从直道行驶到一个圆环弧形轨道，要求车时刻与内侧轨道相切，给定车的边长、圆环内半径和圆环的弧度，求圆环宽度最大值。 解题思路根据弧度，分两种情况讨论：在直道上取得最大值，在弧上取得最大值。 AC代码点击 12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;int main()&#123; int T,a,b,r,d; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d%d%d",&amp;a,&amp;b,&amp;r,&amp;d); double theta=d/360.0*2.0*acos(-1); double bound=atan2(b,a+r),w; if(theta&gt;bound)w=sqrt(b*b+(a+r)*(a+r)); else w=b*sin(theta)+(a+r)*cos(theta); printf("%.12f\n",w-r); &#125; return 0;&#125; E Resistors in Parallel 题目描述有$n$个电阻，定义第$i$个电阻的阻值$R_i$为：$i$，当且仅当$i$不能被某个数的平方整除；否则为$0$。 定义一个编号为$i$的电阻集合的阻值为所有$i$的因数$j$对应的电阻$R_j$并联产生的阻值。 给定$n$，求编号为$1\leq x\leq n$的电阻集合的最小阻值。$1\leq n\leq 10^{100}$。 解题思路$R=\frac{1}{\frac{1}{R_1}+\frac{1}{R_2}+…+\frac{1}{R_k}}$ 最大化分母：尽量选小的数（$\frac 12,\frac 13,\frac 15,\frac 17…,\frac 1{2\times 3},\frac 1{2\times 5},\frac 1{3\times 5},\frac1{2\times 3\times 5}…$） 容易看出，当$n$选择为前$p$个质数的乘积的时候是最优的，答案可以通过大数+前缀和求出。 AC代码 - by Mogg点击 1234567891011121314151617181920212223242526272829303132333435363738394041import mathms = 100000phi = [False for i in range(ms)]pri = []cnt = 0def init(): global cnt phi[1] = True for i in range(2,ms): if not phi[i]: pri.append(i) cnt += 1 j = 0 while j&lt; cnt and i*pri[j]&lt;ms : phi[i*pri[j]] = True if i%pri[j] == 0: break j += 1 def gcd(a,b): if(a == 0): return b return gcd(b%a,a) def solve(x): up = 1 low = 1 for i in range(cnt): if up*pri[i] &gt; x: break up*=pri[i] low = (pri[i] + 1)*(low) g = gcd(up,low) print(str(up//g) + "/" + str(low//g)) init()t = int(input())for i in range(t): solve(int(input())) F Honeycomb 题目描述字符串的形式输入一个蜂巢，求$S,T$之间的最短距离。 解题思路非常暴力（麻烦）的求出各个孔的位置和连通性，$bfs$一下即可。 AC代码 - by Mogg点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;bitset&gt;#include&lt;unordered_map&gt;#include&lt;set&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;const int ms=1e3+10;const ll mod=1000000007;typedef pair&lt;int,int&gt;pt;vector&lt;int&gt;g[ms*ms];vector&lt;pt&gt;p0=&#123;&#123;3,1&#125;,&#123;1,3&#125;,&#123;1,7&#125;,&#123;3,9&#125;,&#123;5,7&#125;,&#123;5,3&#125;,&#123;3,1&#125;&#125;;vector&lt;pt&gt;p1=&#123;&#123;5,7&#125;,&#123;3,9&#125;,&#123;3,13&#125;,&#123;5,15&#125;,&#123;7,13&#125;,&#123;7,9&#125;,&#123;5,7&#125;&#125;;vector&lt;pt&gt;p2=&#123;&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,1&#125;,&#123;1,0&#125;,&#123;1,-1&#125;&#125;;vector&lt;pt&gt;p3=&#123;&#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;;pt b0=&#123;3,5&#125;,b1=&#123;5,11&#125;;char s[ms*4][ms*6];int r,c;int po(int x,int y)&#123; return c*(x-1)+y;&#125;bool vis[ms*ms];int dij(int begin,int end)&#123; for(int i=1;i&lt;=r*c;++i)vis[i]=false; queue&lt;pt&gt;q; q.push(&#123;begin,0&#125;); vis[begin]=true; while(!q.empty())&#123; int x=q.front().first,y=q.front().second;q.pop(); for(int i:g[x])&#123; if(vis[i]) continue; vis[i]=true; if(i==end) return y+2; q.push(&#123;i,y+1&#125;); &#125; &#125; return -1;&#125;int main()&#123; ios::sync_with_stdio(false);cin.tie(nullptr); int t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;r&gt;&gt;c; vector&lt;pt&gt;tmp; cin.getline(s[0]+1,6*c+5); for(int i=1;i&lt;=4*r+3;++i)cin.getline(s[i]+1,6*c+5); for(int i=1;i&lt;=r*c;++i)g[i].clear(); int begin=0,end=0; for(int i=1;i&lt;=r;++i)&#123; for(int j=1;j&lt;=c;++j)&#123; int h=(i-1)*4,v=(j-1)/2*12; if(j&amp;1)&#123; if(s[b0.first+h][b0.second+v]=='S') begin=po(i,j); else if(s[b0.first+h][b0.second+v]=='T') end=po(i,j); for(int k=0;k&lt;6;++k)&#123; pt t1=&#123;p0[k].first+h,p0[k].second+v&#125;; pt t2=&#123;p0[k+1].first+h,p0[k+1].second+v&#125;; pt mid=&#123;(t1.first+t2.first)/2,(t1.second+t2.second)/2&#125;; if(s[mid.first][mid.second]==' ')&#123; g[po(i,j)].push_back(po(i+p3[k].first,j+p3[k].second)); g[po(i+p3[k].first,j+p3[k].second)].push_back(po(i,j)); &#125; &#125; &#125; else&#123; if(s[b1.first+h][b1.second+v]=='S') begin=po(i,j); else if(s[b1.first+h][b1.second+v]=='T') end=po(i,j); for(int k=0;k&lt;6;++k)&#123; pt t1=&#123;p1[k].first+h,p1[k].second+v&#125;; pt t2=&#123;p1[k+1].first+h,p1[k+1].second+v&#125;; pt mid=&#123;(t1.first+t2.first)/2,(t1.second+t2.second)/2&#125;; if(s[mid.first][mid.second]==' ')&#123; g[po(i,j)].push_back(po(i+p2[k].first,j+p2[k].second)); g[po(i+p2[k].first,j+p2[k].second)].push_back(po(i,j)); &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;dij(begin,end)&lt;&lt;"\n"; &#125; return 0;&#125; G Shortest Paths on Random Forests 题目描述解题思路AC代码点击 12 H Can You Solve the Harder Problem? 题目描述定义$Q(l,r)=max_{l\leq i\leq r}a_i$，两个区间是本质相同的当且仅当这两个区间长度相同且对应数相同（如$1,2,1,2$中，$[1,2][3,4]$两个区间即为本质相同的区间），求出本质不同的区间$Q$之和。 $1\leq a_i\leq 10^6,1\leq n\leq 2\times 10^5$。 解题思路一看到本质不同瞬间想到后缀自动机、后缀数组的问题。显然，$a_i$太大，用后缀自动机不好建树，于是考虑使用后缀数组。 首先将离散化的$a$扔到后缀数组中求出$sa,height$两个所需数组（没离散化$T$了无数发）。 考虑先计算出所有区间的总和，再去掉重叠区间的贡献。 总和可以通过单调栈计算出每一个数向右最近的比它大的数的位置，然后从后向前递推计算出以$i$开头的所有区间$Q$之和$cost_i$。 重叠区间贡献可以枚举后缀数组中相邻两个串的$lcp$，即为$h_i$。这个$h_i$对应下标分别为$sa_{i-1}$和$sa_{i}$开始的后缀，不妨只看$sa_i$中的贡献，即以$sa_i$为左端点、右端点在$[sa_i,sa_i+h_i]$区间内的所有区间的$Q$之和。假设在$sa_i$右边、$sa_i+h_i$左边的最右端的比$a_{sa_i}$大的数位置在$pos$，那么很容易得出$[pos,sa_i+h_i]$区间的贡献为$a_{pos}\times (sa_i+h_i-pos+1)$（这个区间内最大的数均为$a_{pos}$）。这个$pos$可以通过单调栈求出的$r_i$数组进行倍增的预处理求出来，而$[sa_i,pos-1]$的贡献即为$cost_{sa_i}-cost_{pos}$，而这已经被求出来了。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 1000010int s[N];int n,sa[N],c[N],x[N],y[N];int lsh[N];void getsa()&#123; int i,k,m; for(i=1;i&lt;=n;i++)c[i]=s[i]; sort(c+1,c+1+n); m=unique(c+1,c+1+n)-c; for(i=1;i&lt;=n;i++)x[i]=lower_bound(c+1,c+m,s[i])-c; for(i=0;i&lt;=m;i++)c[i]=0; for(i=1;i&lt;=n;i++)c[x[i]]++; for(i=1;i&lt;=m;i++)c[i]+=c[i-1]; for(i=n;i;i--)sa[c[x[i]]--]=i; for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int p=0; for(i=n-k+1;i&lt;=n;i++)y[++p]=i; for(i=1;i&lt;=n;i++)if(sa[i]&gt;k)y[++p]=sa[i]-k; for(i=0;i&lt;=m;i++)c[i]=0; for(i=1;i&lt;=n;i++)c[x[y[i]]]++; for(i=1;i&lt;=m;i++)c[i]+=c[i-1]; for(i=n;i;i--)sa[c[x[y[i]]]--]=y[i]; swap(x,y); p=x[sa[1]]=1; for(i=2;i&lt;=n;i++) x[sa[i]]=y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k]?p:++p; if(p&gt;=n)break; m=p; &#125;&#125;int h[N],rnk[N];void geth()&#123; int i,j,k=0; for(i=1;i&lt;=n;i++)rnk[sa[i]]=i; for(i=1;i&lt;=n;i++)&#123; if(k)k--; j=sa[rnk[i]-1]; while(s[i+k]==s[j+k])k++; h[rnk[i]]=k; &#125;&#125;int sta[N],top,r[N];int fa[22][N];ll cost[N];//cost start from i to r-endint main()&#123; int i,j,T; scanf("%d",&amp;T); while(T--)&#123; ll ans=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;s[i]); getsa(); geth(); top=0; for(i=1;i&lt;=n;i++)&#123; while(top&amp;&amp;s[sta[top]]&lt;s[i])&#123; r[sta[top]]=fa[0][sta[top]]=i; top--; &#125; sta[++top]=i; &#125; while(top)r[sta[top]]=fa[0][sta[top]]=n+1,top--; r[n+1]=fa[0][n+1]=n+1; for(i=1;i&lt;20;i++)&#123; if((1LL&lt;&lt;i)&lt;=n)for(j=1;j&lt;=n;j++)fa[i][j]=fa[i-1][fa[i-1][j]]; else for(j=1;j&lt;=n;j++)fa[i][j]=n+1; &#125; cost[n+1]=0; for(i=n;i&gt;=1;i--)cost[i]=cost[r[i]]+1LL*(r[i]-i)*s[i],ans+=cost[i]; for(i=2;i&lt;=n;i++)&#123; int left=sa[i],now=left; if(!h[i])continue; for(j=20;j&gt;=0;j--) if(fa[j][now]&amp;&amp;fa[j][now]&lt;=left+h[i])now=fa[j][now]; ans-=1LL*(left+h[i]-now)*s[now]; ans-=1LL*(cost[sa[i]]-cost[now]); &#125; printf("%lld\n",ans); &#125; return 0;&#125; I Distance 题目描述有一堆点，分别求出$2\leq k\leq n$的时候，选择$k$个点，使得两两间距离之和最大，这个最大值。 解题思路每次选择最外层两个点即可。 AC代码 - by qxforever点击 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+23; int T,n;int a[maxn];int p[maxn];int main()&#123; cin &gt;&gt; T; while(T--)&#123; scanf("%d",&amp;n); p[1]=0; for(int i=2;i&lt;=n;i++) scanf("%d",a+i),p[i]=p[i-1]+a[i]; int i,j;ll ans=0,dis=0; for(i=1,j=n;i&lt;=j;i++,j--)&#123; ans+=dis; printf("%lld%c",ans,i!=j?' ':'\n'); if(i!=j)&#123; ans+=dis; ans+=p[j]-p[i]; dis+=(p[j]-p[i]); printf("%lld%c",ans,j-i&gt;1?' ':'\n'); &#125; &#125; &#125;&#125; J Carpets Removal 题目描述$m\times m$的矩形地板，上面乱七八糟铺了$n$块可以相互重叠的矩形地毯。问选择两块地毯移走后，剩下还被地毯覆盖的格子最少有多少。 解题思路首先，很显然用二维前缀和维护一下每个点上有几个毯子，只考虑有一个或两个的情况。 记录下每一块毯子独立拿走后减少的格子数$cnt_i$（即只被这一种地毯覆盖的格子数），那么两块地毯的贡献就是$cnt_i+cnt_j+s$，$s$表示只被这两块地毯同时覆盖的格子数。 当$s=0$时，直接取$cnt$数组里的最大次大值加起来即可。 这里用到一个极为巧妙的算法： 二维前缀和可以维护每个点被几个毯子覆盖，但其实同时也可以维护被覆盖的编号之和，而这个编号之和在被覆盖个数为$1$的时候即为这个点对应的编号，为$2$的时候即为这个点对应的两个编号$x+y$。那么再维护一个被覆盖的编号的平方之和，这样就可以维护出$x^2+y^2$了。有了$x+y,x^2+y^2$，就能求出$x,y$了。 于是$s\neq 0$时，枚举每一个这样的$(x,y)$对即可得到答案。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define M 1520#define N 300010ll s[M][M],s2[M][M],cnt[M][M];int num[N];#define mp make_pair#define fi first#define se secondmap&lt;int,int&gt;f1;map&lt;pair&lt;int,int&gt;,int&gt;f2;int main()&#123; int i,j,T,n,m; scanf("%d",&amp;T); while(T--)&#123; ll ans=0,tot=0; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;=m;i++)for(j=0;j&lt;=m;j++)cnt[i][j]=s[i][j]=s2[i][j]=0; memset(num,0,sizeof(int)*(n+1)); f1.clear();f2.clear(); for(i=0;i&lt;n;i++)&#123; int x,y,a,b; scanf("%d%d%d%d",&amp;a,&amp;x,&amp;b,&amp;y); cnt[a][b]++;cnt[x+1][b]--;cnt[a][y+1]--;cnt[x+1][y+1]++; s[a][b]+=i;s[x+1][b]-=i;s[a][y+1]-=i;s[x+1][y+1]+=i; s2[a][b]+=1LL*i*i;s2[x+1][b]-=1LL*i*i;s2[a][y+1]-=1LL*i*i;s2[x+1][y+1]+=1LL*i*i; &#125; for(i=1;i&lt;=m;i++)&#123; for(j=1;j&lt;=m;j++)&#123; cnt[i][j]+=cnt[i-1][j]+cnt[i][j-1]-cnt[i-1][j-1]; s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1]; s2[i][j]+=s2[i-1][j]+s2[i][j-1]-s2[i-1][j-1]; if(cnt[i][j])tot++; if(cnt[i][j]==1)&#123; num[s[i][j]]++; f1[s[i][j]]++; &#125;else if(cnt[i][j]==2)&#123; int x,y,xminusy=sqrt(2*s2[i][j]-s[i][j]*s[i][j]); x=(xminusy+s[i][j])/2;y=s[i][j]-x; if(x&gt;y)swap(x,y); f2[mp(x,y)]++; &#125; &#125; &#125; for(auto i:f2)ans=max(ans,(ll)i.se+num[i.fi.fi]+num[i.fi.se]); ll mx=0,se=0; for(auto i:f1)&#123; if(i.se&gt;mx)se=mx,mx=i.se; else if(i.se&gt;se)se=i.se; &#125; ans=max(ans,mx+se); printf("%lld\n",tot-ans); &#125; return 0;&#125; K Counting Failures on a Trie 题目描述解题思路AC代码点击 12 L Connected Subgraphs 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 ICPC Beijing Regional Contest 题解]]></title>
    <url>%2F2019%2F09%2F28%2F2018icpcbeijing%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 8/10 O O O O . Ø Ø O O . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A - Jin Yong’s Wukong Ranking List 题目描述给定一堆排名顺序，求在第几个出现矛盾。 解题思路爆搜判环即可。 AC代码 - by Mogg点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;map&lt;string, set&lt;string&gt;&gt;m;void dfs(const string&amp; now, const string&amp; to)&#123; for (const string&amp; i : m[to]) &#123; dfs(now, i); &#125; m[now].insert(to);&#125;int main()&#123; string a, b; int n; while (cin &gt;&gt; n) &#123; m.clear(); vector&lt;pair&lt;string, string&gt;&gt; res; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; a &gt;&gt; b; if (m[a].count(b)) &#123; res.emplace_back(a, b); &#125; else &#123; dfs(b, a); &#125; &#125; if (res.empty()) cout &lt;&lt; 0 &lt;&lt; "\n"; for (auto i : res) &#123; cout &lt;&lt; i.first &lt;&lt; " " &lt;&lt; i.second &lt;&lt; "\n"; &#125; &#125;&#125; B - Heshen’s Account Book 题目描述给定$n$行，相邻两行最后一个字符和第一个字符都是数字则可拼接，求出数字个数并输出每行数字数量。 解题思路非常神秘的细节题，先拼接、标记再输出答案。 AC代码 - by Mogg点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;bool isNum(const string&amp;s)&#123; if (s.empty()) return false; if (s.size() == 1) &#123; return s[0] &gt;= '0' &amp;&amp; s[0] &lt;= '9'; &#125; if (s.size() &gt; 1) &#123; return s[0] &gt; '0' &amp;&amp; s[0] &lt;= '9' &amp;&amp; *s.rbegin() &gt;= '0' &amp;&amp; *s.rbegin() &lt;= '9'; &#125; return false;&#125;int main()&#123; int n = 0; string s; vector&lt;vector&lt;string&gt;&gt; lines; vector&lt;string&gt; tmp; while (getline(cin, s)) &#123; tmp.push_back(s); n++; &#125; for (int i = n - 1; i &gt; 0; --i) &#123; if (isdigit(*tmp[i - 1].rbegin()) &amp;&amp; isdigit(*tmp[i].begin())) &#123; int j = 0, len = tmp[i].size(); for (; j &lt; len &amp;&amp; isdigit(tmp[i][j]); j++); tmp[i - 1] += tmp[i].substr(0, j); tmp[i] = tmp[i].substr(j); &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; stringstream ss(tmp[i]); string t; vector&lt;string&gt; tt; while (getline(ss, t, ' ')) &#123; if (!t.empty()) tt.push_back(t); &#125; lines.push_back(tt); &#125; vector&lt;int&gt; res(n, 0); vector&lt;string&gt; rs; for (int i = 0; i &lt; n; ++i) &#123; int len = lines[i].size(); for (int j = 0; j &lt; len; ++j) &#123; if (isNum(lines[i][j])) &#123; rs.push_back(lines[i][j]); res[i]++; &#125; &#125; &#125; for (const string&amp; i : rs) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; "\n"; for (int i : res) &#123; cout &lt;&lt; i &lt;&lt; "\n"; &#125;&#125; C - Pythagorean triple 题目描述求出满足$a^2+b^2=c^2,c\leq n$且$a,b,c&gt; 0$的三元组个数。 解题思路$a^2+b^2=c^2$，于是$(a^2-b^2)^2+(2ab)^2=c^2$。故$a,b,c$必可表示为$a=x^2-y^2,b=2xy,c=x^2+y^2$的形式。易证，其中$a,b$必为一奇一偶，$c$必为奇数。 设$f(x)$表示$c\leq x$的三元组数，$g(x)$表示本原的$c\leq x$的三元组数（即$gcd(a,b)=1$）。再设$F,G$分别为$f,g$的前缀和。那么有如下关系： $g(n)=\sum_{x=1}^{n}\sum_{y=1}^{n}[x^2+y^2=n][gcd(x,y)=1][x&gt;y]([x\space is\space odd][y\space is\space even]or[x\space is\space even][y\space is\space odd])$ $=\sum_{x=1}^{n}\sum_{y=1}^{n}[x^2+y^2=n][gcd(x,y)=1][x\space is\space odd][y\space is\space even]$ $f(x)=\sum_{d|x}g(d)$ $F(n)=\sum_{i=1}^{n}f(i)=\sum_{i=1}^{n}\sum_{d|i}g(d)=\sum_{d=1}^{n}\sum_{i=1}^{\lfloor\frac nd \rfloor}g(i)=\sum_{d=1}^{n}G(\lfloor\frac nd\rfloor)$ $G(n)=\sum_{i=1}^{n}g(i)$ $=\sum_{x=1}^{n}\sum_{y=1}^{n}[x^2+y^2\leq n][gcd(x,y)=1][x\space is\space odd][y\space is\space even]$ $=\sum_{x=1,x\space is\space odd}^{n}\sum_{y=1,y\space is\space even}^{n}[x^2+y^2\leq n]\sum_{d|gcd(x,y)}\mu(d)$ $=\frac12\sum_{d=1}^{\sqrt{\frac n2}}(\sum_{x=1}^{n}\sum_{y=1}^{n}-\sum_{x=1,x\space is\space odd}^{n}\sum_{y=1,y\space is\space odd}^{n})[x^2+y^2\leq n][d|x][d|y]$ $=\frac12\sum_{d=1}^{\sqrt{\frac n2}}(\sum_{i=1}^{\lfloor\frac{\sqrt{n}}d\rfloor}\sum_{y=1}^{n}[i^2d^2+y^2\leq n][d|y]-\sum_{i=1,id\space is\space odd}^{\lfloor\frac{\sqrt{n}}d\rfloor}\sum_{y=1}^{n}[i^2d^2+y^2\leq n][d|y])$ $=\frac12\sum_{d=1}^{\sqrt{\frac n2}}(\sum_{i=1}^{\lfloor\frac {\sqrt{n}}d\rfloor}\sum_{j=1}^{\lfloor\frac {\sqrt{n-i^2d^2}}d\rfloor}1-\sum_{i=1,id\space is\space odd}^{\lfloor\frac {\sqrt{n}}d\rfloor}\sum_{j=1,jd\space is\space odd}^{\lfloor\frac {\sqrt{n-i^2d^2}}d\rfloor}1)$ $=\frac12\sum_{d=1}^{\sqrt{\frac n2}}(\sum_{i=1}^{\lfloor\frac {\sqrt{n}}d\rfloor}{\lfloor\frac {\sqrt{n-i^2d^2}}d\rfloor}-[d\space is\space odd]\sum_{i=1,i\space is\space odd}^{\lfloor\frac {\sqrt{n}}d\rfloor}\sum_{j=1,j\space is\space odd}^{\lfloor\frac {\sqrt{n-i^2d^2}}d\rfloor}1)$ 至此，可以看出，$G(n)$可以通过对$i$数论分块做到较低的复杂度，求$F$时对$G$数论分块即可。 可以通过预处理出$G(n)$的前部分项进一步减小复杂度。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 100010int isnp[N],mu[N],pr[N],tot;void sieve()&#123; int i,j; isnp[0]=isnp[1]=1; mu[1]=1; for(i=2;i&lt;N;i++)&#123; if(!isnp[i])pr[tot++]=i,mu[i]=-1; for(j=0;j&lt;tot;j++)&#123; if(pr[j]*i&gt;=N)break; isnp[pr[j]*i]=1; if(i%pr[j])mu[i*pr[j]]=-mu[i]; else&#123; mu[i*pr[j]]=0; break; &#125; &#125; &#125;&#125;#define MAX 1000000ll G[MAX+10];void initG()&#123; ll i,j; for(i=1;i&lt;=MAX;i+=2)&#123; ll mx=sqrt(MAX-i*i); for(j=2;j&lt;=mx;j+=2)if(__gcd(i,j)==1)G[i*i+j*j]++; &#125; for(i=1;i&lt;=MAX;i++)G[i]+=G[i-1];&#125;ll getG(int n)&#123; if(n&lt;=MAX)return G[n]; ll i,res=0,d,mx=sqrt(n/2); for(d=1;d&lt;=mx;d++)&#123; ll r,temp=0,my=ll(sqrt(n))/d,p; for(i=1;i&lt;=my;i=r+1)&#123; p=sqrt(n-(i*d)*(i*d))/d; r=sqrt(n-(p*d)*(p*d))/d; temp+=p*(r-i+1); if(d&amp;1)temp-=(p+1)/2*((r-i+1+(i%2))/2); &#125; temp*=mu[d]; res+=temp; &#125; return res/2;&#125;int main()&#123; int i,r,T,n; sieve(); initG(); scanf("%d",&amp;T); while(T--)&#123; ll ret=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;i=r+1)&#123; r=n/(n/i); ret+=getG(n/i)*(r-i+1); &#125; printf("%lld\n",ret); &#125; return 0;&#125; D - Frog and Portal 题目描述有一只青蛙要从$0$跳到$200$，每次可以向前跳一格或者两格。 你可以加一些传送门，当青蛙跳到其起点时会被立即传送到传送门的终点。 要求青蛙从$0$跳到$200$总方案数为$M(0\leq M&lt;2^{32})$，求传送门安装方案。 解题思路第一感是斐波那契数列，但其实完全可以依靠$1$的特殊性来做这个题。 如果$M$为奇数，从$1$连向$200$一个传送门，表示第一次跳跃到$1$时有一种到达$200$的方案，问题转化为起点为$2$的$M_2=M-1$的方案设计。 如果$M$为偶数，连接传送门$1\rightarrow3,2\rightarrow3$，问题转化为起点为$3$的$M_2=\frac M2$的方案设计。 当$M=0$时，连接传送门$3\rightarrow1,2\rightarrow1$，表示这个点出不去了。 就没了。神仙构造。 AC代码 - by Mogg点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;vector&gt;typedef long long ll;using namespace std;int main()&#123; ll m; while (cin &gt;&gt; m) &#123; vector&lt;pair&lt;int, int&gt;&gt; res; int cur = 0; while (m &gt; 0) &#123; if (m &amp; 1) &#123; res.emplace_back(cur + 1, 199); m -= 1; cur = cur + 2; &#125; else &#123; res.emplace_back(cur + 1, cur + 3); res.emplace_back(cur + 2, cur + 3); m /= 2; cur = cur + 3; &#125; &#125; if (m == 0) &#123; res.emplace_back(cur + 1, cur + 1); res.emplace_back(cur + 2, cur + 1); &#125; cout &lt;&lt; res.size() &lt;&lt; "\n"; for (auto i : res) &#123; cout &lt;&lt; i.first &lt;&lt; " " &lt;&lt; i.second &lt;&lt; "\n"; &#125; &#125;&#125; E - Xor 2 题目描述解题思路AC代码点击 12 F - The Kth Largest Value 题目描述给一个有向图，定义$(u,v)$是好的当且仅当$u$可以通过某些路径到达$v$。如果$(u,v)$是好的，这一个偶对的权值定义为$u\oplus v$。 $q$次询问，每次求第$k$大的好的偶对的权值。 $n\leq 50000,m\leq 200000,q\leq 10,T\leq 3$ 解题思路首先可以通过缩点将所有$u$能够直接连到的$v$存入一个$bitset$中（$bs[col[i]][j]=1$当且仅当$i$能走到$j$），再通过逆向拓扑排序求出所有$u$能够到达的$v$的集合。 对每次询问，我们想象一棵二叉$trie$，从上到下贪心地选择$0$或者$1$，当当前选择$1$后能够到达的点数总和$\geq k$时可以选择$1$，否则选择$0$。故枚举每个点，求有多少个点满足能够从$i$连过来且值在某区间内。这样通过求$bitset$的前缀和可以求解，但是这样的复杂度是$O(n^2+n\log n)$的，预处理复杂度太大。 考虑分块。将$bitset$分成$block$块，把每块看成一个整体求前缀和，这样预处理复杂度$O(\frac{n^2}{block})$，询问复杂度$O(q\times 2nblock\times \log n)$，空间复杂度$O(\frac{n^2}{block})$，实测$block$取$40$的时候可以非常极限地卡过。 （集齐五种错误即可召唤AC .jpg） AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;#include&lt;bitset&gt;#include&lt;ctime&gt;#include&lt;assert.h&gt;typedef long long ll;using namespace std;#define N 50010#define M 65538#define block 40int n;bitset&lt;block&gt;bs[N][M/block+3];int sb[N][M/block+3];struct Edge&#123; int e,n;&#125;e[N&lt;&lt;3];int hd[N],cnt;void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;int vmin[N];int sta[N],top,vis[N];int col[N],num;int dfn[N],low[N],tot;void tarjan(int p)&#123; int i,q; low[p]=dfn[p]=++tot; sta[++top]=p;vis[p]=1; for(i=hd[p];i;i=e[i].n)&#123; q=e[i].e; if(!dfn[q])tarjan(q),low[p]=min(low[p],low[q]); else if(vis[q])low[p]=min(low[q],low[p]); &#125; if(dfn[p]==low[p])&#123; num++; while(sta[top+1]!=p)&#123; q=sta[top]; bs[num][q/block][q%block]=1; col[q]=num; vis[q]=0; top--; &#125; &#125;&#125;void initbs()&#123; int i,j; for(i=1;i&lt;=num;i++)for(j=0;j&lt;=M/block;j++)&#123; sb[i][j]=bs[i][j].count(); if(j)sb[i][j]+=sb[i][j-1]; &#125;&#125;int a[N&lt;&lt;2],b[N&lt;&lt;2],ind[N];queue&lt;int&gt;Q;int getnum(int p,int l,int r)&#123;//[l,r) int i,s; if(r&gt;=M)r=M-1; if(r/block-l/block&lt;=1)&#123; s=0; for(i=l;i&lt;r;i++)s+=bs[p][i/block][i%block]; return s; &#125; s=sb[p][r/block-1]-sb[p][l/block]; for(i=l/block*block+block-1;i&gt;=l;i--)s+=bs[p][i/block][i%block]; for(i=r/block*block;i&lt;r;i++)s+=bs[p][i/block][i%block]; return s;&#125;int check(int p,int &amp;k)&#123;//can choose 1 int i,s=0,tmp; for(i=1;i&lt;=n;i++)&#123; tmp=vmin[i]; if(!(i&amp;(1&lt;&lt;p)))tmp+=1&lt;&lt;p; s+=getnum(col[i],tmp,tmp+(1&lt;&lt;p)); &#125; if(s&gt;=k)return 1; k-=s;return 0;&#125;void choose(int p,int x)&#123; int i; for(i=1;i&lt;=n;i++)if(x^(i&gt;&gt;p&amp;1))vmin[i]+=(1&lt;&lt;p);&#125;int main()&#123; int i,j,T,k,q,m;// double TIM=clock();// freopen("data.in","r",stdin);// freopen("out.txt","w",stdout); scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(i=0;i&lt;=n;i++)for(j=0;j&lt;=n/block;j++)sb[i][j]=0,bs[i][j].reset(); memset(hd,0,sizeof(hd));cnt=0; memset(col,0,sizeof(int)*(n+1));num=0; memset(dfn,0,sizeof(int)*(n+1)); memset(low,0,sizeof(int)*(n+1));tot=0; memset(ind,0,sizeof(int)*(n+1)); for(i=0;i&lt;m;i++)scanf("%d%d",&amp;a[i],&amp;b[i]),add(a[i],b[i]); for(i=1;i&lt;=n;i++)if(!dfn[i])tarjan(i); memset(hd,0,sizeof(hd));cnt=0; for(i=0;i&lt;m;i++)if(col[a[i]]!=col[b[i]])add(col[b[i]],col[a[i]]),ind[col[a[i]]]++; for(i=1;i&lt;=num;i++)if(!ind[i])Q.push(i); while(!Q.empty())&#123; int now=Q.front();Q.pop(); for(i=hd[now];i;i=e[i].n)&#123; int q=e[i].e; for(j=0;j&lt;=n/block;j++)bs[q][j]|=bs[now][j]; if(!--ind[q])Q.push(q); &#125; &#125; /*vector&lt;int&gt;V; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=n;j++)&#123; if(bs[col[i]][j/block][j%block]) V.push_back(i^j); &#125; &#125; sort(V.begin(),V.end());*/// for(auto j:V)printf("%d ",j);puts(""); initbs();// printf("%f\n",(clock()-TIM)/CLOCKS_PER_SEC); while(q--)&#123; scanf("%d",&amp;k); //int X=k,tmp=V[V.size()-k]; int res=0; for(i=16;i&gt;=0;i--)&#123; if(check(i,k))choose(i,1),res=res&lt;&lt;1|1; else choose(i,0),res&lt;&lt;=1; &#125; //if(res!=tmp)printf("%d %d %d\n",res,tmp,X); //assert(res==tmp); printf("%d\n",res); memset(vmin,0,sizeof(int)*(n+1)); &#125; &#125;// printf("%f",(clock()-TIM)/CLOCKS_PER_SEC); return 0;&#125; G - Solving Equations is Easy 题目描述给一个$n$次方程，其中所有根（包括复根）为$x_i(1\leq i\leq n)$。求满足所有根为$x_i^m$的$n$次方程。 解题思路牛顿恒等式：设方程$a_n+a_{n-1}x+a_{n-2}x^2+…+a_0x^n=0$的根为$x_1,x_2,…,x_n$，$S_k=\sum_{i=1}^{n}x_i^k$，则有$\sum_{i=1}^{k}S_ia_{k-i}+ka_k=0(\forall k\in N)$。 列一下前几项简单体会一下： $S_1a_0+a_1=0$ $S_1a_1+S_2a_0+2a_2=0$ $S_1a_2+S_2a_1+S_3a_0+3a_3=0$ 我们发现，可以通过$a$序列递推出所有的$S$，反之亦可。 于是正向推出$S$在$im(1\leq i\leq n)$上的取值，再逆推系数即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 40ll b[N],s[N],res[N];int main()&#123; int i,j,n,m; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;(n|m))&#123; memset(b,0,sizeof(b)); memset(s,0,sizeof(s)); memset(res,0,sizeof(res)); for(i=n;i;i--)scanf("%lld",&amp;b[i]); res[0]=b[0]=1; for(i=1;i&lt;=m*n;i++)&#123; for(j=1;j&lt;i;j++)s[i]-=s[j]*b[i-j]; s[i]-=i*b[i]; s[i]/=b[0]; &#125; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=i;j++)res[i]-=s[j*m]*res[i-j]; res[i]/=i; &#125; for(i=0;i&lt;n;i++)printf("%lld ",res[n-i]); puts(""); &#125; return 0;&#125; H - Approximate Matching 题目描述定义两个串$S,T$为匹配的，当且仅当$S$存在一个子串$s$，满足$s$和$T$最多相差一个字符。 给定长度为$n$的串$T$，以及$S$的长度$m$，求有多少个$S$满足要求。 解题思路设$f[i][j]$表示$S$从第$i$位开始第一次匹配到$T$，即$S[i…i+n-1]$和$T[1…m]$最多相差一个字符，这个相差的字符在$T_{j}$处，这时的方案数。 于是可以愉快地推式子： $f[i][j]=2^{m-(i+n-1)}(2^{i-1}-\sum_{k+n-1&lt;i}\sum_{l}f[k][l]\times 2^{i-(k+n)}-\sum_{k+n-1\geq i,k&lt;i}\sum_{l}w_{ijkl}f[k][l])$ 解释一下：在匹配区有且仅有一种方法，匹配前后均可任选，再减去前面出现过匹配到$T$的种数即为所求。第一个减去的是上次匹配$[k…k+n-1]$和本次匹配不相交的情况，这两次匹配之间可以任意选择；第二个减去的是两次匹配相交的情况，用$w_{ijkl}$判断需不需要删除，当两个匹配部分的交相等时，需要删除$f[k][l]$的影响。 故预处理出$w_{ijkl}$（不妨固定一个串移动另一个串，枚举$j,l$再线性求即可$O(n^4)$预处理出），再进行$dp$，所有$f[i][j]$的和即为答案。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;char s[45];ll f[45][45];int w[45][45][45],n,m;int W(int a,int b,int c,int d)&#123; if(a&gt;c)return w[a-c+1][b][d]; return w[c-a+1][d][b];&#125;int main()&#123; int i,j,k,l,T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d%s",&amp;n,&amp;m,s+1); memset(w,0,sizeof(w)); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=n+1;j++)&#123; for(k=1;k&lt;=n+1;k++)&#123; w[i][j][k]=1; for(l=i;l&lt;=n;l++)&#123; int c1,c2; if(l-i+1==j)c1=(s[l-i+1]-'0')^1; else c1=s[l-i+1]-'0'; if(l==k)c2=(s[l]-'0')^1; else c2=s[l]-'0'; if(c1!=c2)&#123;w[i][j][k]=0;break;&#125; &#125; &#125; &#125; &#125; memset(f,0,sizeof(f)); ll res=0; for(i=1;i+n-1&lt;=m;i++)&#123; for(j=1;j&lt;=n+1;j++)&#123; f[i][j]=1LL&lt;&lt;(i-1); for(k=1;k+n-1&lt;i;k++) for(l=1;l&lt;=n+1;l++) f[i][j]-=f[k][l]*(1LL&lt;&lt;(i-n-k)); for(;k&lt;i;k++) for(l=1;l&lt;=n+1;l++) f[i][j]-=f[k][l]*W(i,j,k,l); res+=f[i][j]*(1LL&lt;&lt;(m-(i+n)+1)); &#125; &#125; printf("%lld\n",res); &#125; return 0;&#125; I - Palindromes 题目描述问第$k$个回文数是多少，$k$的位数在$100000$级别。 解题思路找规律，推式子+高精度。 AC代码 - by qxforever点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1e5+23;int b[maxn];char s[maxn];int len;void sub(int h)&#123; h/=2; b[h+1]-=2; for(int i=h;i&lt;=len;i++) if(b[i]&lt;0) b[i]+=10,b[i+1]--; while(b[len]==0&amp;&amp;len&gt;0) len--;&#125;void pp(int &amp;h)&#123; int t=(h+1-1)/2+1; if(len&gt;t||(len==t&amp;&amp;b[t]==9))&#123; b[t]-=9; for(int i=t;i&lt;=len;i++)&#123; if(b[t]&lt;0) b[t]+=10,b[t+1]--; &#125; while(b[len]==0&amp;&amp;len&gt;0) len--; h++; &#125;&#125;int ans[maxn];int main()&#123; int T;cin &gt;&gt; T; while(T--)&#123; scanf("%s",s+1); len=strlen(s+1); for(int i=1;i&lt;=len;i++) b[i]=s[i]-'0'; reverse(b+1,b+len+1); int h; if(b[len]&gt;=2) h=(len-1)*2; else h=(len-2)*2; sub(h); pp(h); h++; memset(ans,0,sizeof(ans)); int t=(h+1)/2; for(int i=t;i;i--) ans[i]=ans[h+1-i]=b[t+1-i]; ans[1]++;if(h!=1)ans[h]++; for(int i=1;i&lt;=h;i++) printf("%d",ans[i]); if(h&lt;=0) printf("0"); puts(""); &#125;&#125; J - Rikka with Triangles 题目描述给$n$个点（$3\leq n\leq 2000$），求所有锐角三角形面积之和。 解题思路对每个点极角排序，枚举每一条边，二分或者双指针找出两端超出直角区的位置，利用前缀和可求出这部分包含的面积之和。复杂度$O(Tn^2\log n)$。 AC代码 - 待补点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 ICPC上海赛区网络赛 题解]]></title>
    <url>%2F2019%2F09%2F15%2F2019icpcshanghaiinternet%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L 7/12 Ø O . O Ø O . . . O . O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A Lightning Routing I 题目描述给一棵树，有$Q$次操作，每次改变某个边权或者询问距离某点最远的点的距离。 解题思路发现树的直径这个知识点没有点亮…! 先学习一下树的直径好了。树的直径有几个性质： 直径两端点必为叶子节点。（显然） 距离任一点最远的点必为直径的一个端点。（下面会证） 对于两棵树，如果两棵树分别以$(u,v)(a,b)$作为直径，将他们用一条边连起来后，新的树直径必为这四点中的某两点。 若一棵树存在多条直径，那么这些直径交于一点，且交点为这些直径的中点。（显然） 现在来证明第二条性质： 假设树的直径为$AB$，当前点为$P$，距离$P$最远点为$Q$。 讨论： $PQ,AB$交于点$R$：$PR+RQ&gt;PR+RB$，故$RQ&gt;RB$，$dis_{AB}&lt;dis_{AQ}$，与$AB$为直径矛盾 $PQ,AB$不相交：设$PQ,AB$通过$CR$相连，则$PR+RQ&gt;PR+CR+BC$，故$RQ&gt;CR+BC,AQ=AC+CR+RQ&gt;AC+CR+CR+BC=AB+2CR$，同样矛盾 故$P$的最远点必为$AB$两点中的某一点。同样地，如果有多条直径，任意一条直径中必包含一个距离$P$最远的点。 利用这条性质，本题就可转化为：可修改边权，维护树直径及其端点。 首先将树用全$dfs$序表示，即遍历树所经过的路径。 如：样例输入中，以$1$为根的全$dfs$序为：$131252421$或$124252131$。 全$dfs$序有一个性质：任意两位置代表的顶点的$lca$必定包含在这两位置之间（如$5,4:$131252421，$LCA$为$2$）。很容易通过遍历方法证明这一点。 利用这个性质以及边权为正，设$dis_p$为$p$到根的距离，容易得出$min_{p=l}^{r}(dis_p)$为$LCA$到根的距离。故有树的直径$d=max_{1\leq L\leq LCA\leq R\leq 2n-1}(dis[L]+dis[R]-2dis[LCA])$。用一棵线段树维护$L,LCA,R$即可。 具体维护步骤：$ML,MR$分别表示区间之中$L\leq LCA,LCA\leq R$的$dis[L]-2dis[LCA],dis[R]-2dis[LCA]$的值，$val$表示区间$dis$最大的值，$dia$表示区间直径，合并区间时使用这些值，再加入点维护直径端点即可。 同时，需要维护每一点到根节点距离，这里可以用$dfs$序上$BIT$，每次改变边权时，在$st[p],ed[p]$区间更改，在区间左端点查询即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include&lt;cstdio&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;#define N 200010int u[N],v[N],w[N],n;struct Edge&#123; int e,n,l;&#125;e[N&lt;&lt;1];int cnt,hd[N];void add(int a,int b,int l)&#123;e[++cnt].e=b;e[cnt].n=hd[a];e[cnt].l=l;hd[a]=cnt;&#125;ll dis[N];int d[N],st[N],ed[N],tot,id[N&lt;&lt;1];ll bit[N&lt;&lt;2];void add(int p,ll x)&#123; while(p&amp;&amp;p&lt;(N&lt;&lt;2))bit[p]+=x,p+=p&amp;(-p);&#125;ll getdis(int p)&#123; ll ans=0; while(p)ans+=bit[p],p-=p&amp;(-p); return ans;&#125;int fa[22][N],lg[N];void dfs(int p,int f)&#123; d[p]=d[f]+1; id[st[p]=++tot]=p; fa[0][p]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[p];i++)fa[i][p]=fa[i-1][fa[i-1][p]]; for(;i&lt;22;i++)fa[i][p]=0;//!!! for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q==f)continue; dis[q]=dis[p]+e[i].l; dfs(q,p); id[++tot]=p; &#125; ed[p]=tot;&#125;int LCA(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y]) x=fa[lg[d[x]-d[y]]][x]; if(x==y)return x; for(i=lg[d[x]];~i;i--) if(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y]; return fa[0][x];&#125;int L[N&lt;&lt;2],R[N&lt;&lt;2],A[N&lt;&lt;2],B[N&lt;&lt;2];int Lx[N&lt;&lt;2],Rx[N&lt;&lt;2],Dx[N&lt;&lt;2];ll ML[N&lt;&lt;2],MR[N&lt;&lt;2],lca[N&lt;&lt;2],dia[N&lt;&lt;2];ll lazy[N&lt;&lt;2],val[N&lt;&lt;2];ll getdis2(int x,int y)&#123; int fa=LCA(x,y); ll ans=dis[x]+dis[y]-2*dis[fa]+getdis(st[x])+getdis(st[y])-2*getdis(st[fa]); return ans;&#125;void pushup(int p)&#123; lca[p]=max(lca[p&lt;&lt;1],lca[p&lt;&lt;1|1]); val[p]=max(val[p&lt;&lt;1],val[p&lt;&lt;1|1]); if(val[p]==val[p&lt;&lt;1])Dx[p]=Dx[p&lt;&lt;1]; else Dx[p]=Dx[p&lt;&lt;1|1]; ML[p]=max(max(ML[p&lt;&lt;1],ML[p&lt;&lt;1|1]),val[p&lt;&lt;1]+lca[p&lt;&lt;1|1]); if(ML[p]==ML[p&lt;&lt;1])Lx[p]=Lx[p&lt;&lt;1]; else if(ML[p]==ML[p&lt;&lt;1|1])Lx[p]=Lx[p&lt;&lt;1|1]; else Lx[p]=Dx[p&lt;&lt;1]; MR[p]=max(max(MR[p&lt;&lt;1],MR[p&lt;&lt;1|1]),val[p&lt;&lt;1|1]+lca[p&lt;&lt;1]); if(MR[p]==MR[p&lt;&lt;1])Rx[p]=Rx[p&lt;&lt;1]; else if(MR[p]==MR[p&lt;&lt;1|1])Rx[p]=Rx[p&lt;&lt;1|1]; else Rx[p]=Dx[p&lt;&lt;1|1]; dia[p]=max(max(dia[p&lt;&lt;1],dia[p&lt;&lt;1|1]),max(val[p&lt;&lt;1]+MR[p&lt;&lt;1|1],val[p&lt;&lt;1|1]+ML[p&lt;&lt;1])); if(dia[p]==dia[p&lt;&lt;1])A[p]=A[p&lt;&lt;1],B[p]=B[p&lt;&lt;1]; else if(dia[p]==dia[p&lt;&lt;1|1])A[p]=A[p&lt;&lt;1|1],B[p]=B[p&lt;&lt;1|1]; else if(dia[p]==val[p&lt;&lt;1]+MR[p&lt;&lt;1|1])A[p]=Dx[p&lt;&lt;1],B[p]=Rx[p&lt;&lt;1|1]; else A[p]=Dx[p&lt;&lt;1|1],B[p]=Lx[p&lt;&lt;1];&#125;void pushdown(int p)&#123; if(lazy[p])&#123; ll t=lazy[p]; if(L[p]!=R[p])&#123; val[p&lt;&lt;1]+=t,val[p&lt;&lt;1|1]+=t; lazy[p&lt;&lt;1]+=t,lazy[p&lt;&lt;1|1]+=t; ML[p&lt;&lt;1]-=t,ML[p&lt;&lt;1|1]-=t; MR[p&lt;&lt;1]-=t,MR[p&lt;&lt;1|1]-=t; lca[p&lt;&lt;1]-=2*t,lca[p&lt;&lt;1|1]-=2*t; &#125; lazy[p]=0; &#125;&#125;void build(int p,int l,int r)&#123; L[p]=l;R[p]=r; lazy[p]=0; if(l==r)&#123; Lx[p]=Rx[p]=Dx[p]=id[l]; A[p]=B[p]=id[l]; ML[p]=MR[p]=-dis[id[l]]; lca[p]=-2*dis[id[l]]; val[p]=dis[id[l]]; dia[p]=0; return; &#125; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); pushup(p);&#125;void modify(int p,int l,int r,ll delta)&#123; if(L[p]&gt;r||R[p]&lt;l)return; if(l&lt;=L[p]&amp;&amp;R[p]&lt;=r)&#123; lazy[p]+=delta; lca[p]-=2*delta; ML[p]-=delta; MR[p]-=delta; val[p]+=delta; pushdown(p); getAB(p); return; &#125; pushdown(p); modify(p&lt;&lt;1,l,r,delta); modify(p&lt;&lt;1|1,l,r,delta); pushup(p);&#125;int main()&#123; int i,q; scanf("%d",&amp;n); for(i=1;i&lt;n;i++)&#123; int x,y,l; scanf("%d%d%d",&amp;x,&amp;y,&amp;l); add(x,y,l);add(y,x,l); u[i]=x;v[i]=y;w[i]=l; &#125; dfs(1,0); build(1,1,tot); for(i=2;i&lt;=n;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); scanf("%d",&amp;q); while(q--)&#123; char s[10]=&#123;0&#125;;int x,y; scanf("%s%d",s,&amp;x); if(s[0]=='Q')&#123; ll ans=getdis2(A[1],x); ans=max(ans,getdis2(B[1],x)); printf("%lld\n",ans); &#125;else&#123; scanf("%d",&amp;y); int p=d[u[x]]&gt;d[v[x]]?u[x]:v[x]; add(st[p],y-w[x]); add(ed[p]+1,w[x]-y); modify(1,st[p],ed[p],y-w[x]); w[x]=y; &#125; &#125; return 0;&#125; B Light bulbs 题目描述初始时所有灯都是灭的，有$m$次翻转操作，每次一个区间$L[i],R[i]$，问最终灯有多少是亮的。 解题思路对询问排序做一下就好了。 AC代码点击 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;struct Seg&#123; int pos;char sign; bool operator&lt;(const Seg&amp;a)const&#123;return pos&lt;a.pos||(pos==a.pos&amp;&amp;sign&gt;a.sign);&#125;&#125;a[2010];int main()&#123; int i,T,n,m,Cas=0; scanf("%d",&amp;T); while(T--)&#123; int tot=0; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;m;i++)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); a[++tot]=&#123;l,1&#125;; a[++tot]=&#123;r+1,0&#125;; &#125; sort(a+1,a+1+tot); int now=0,last=0,ans=0; for(i=1;i&lt;=tot;i++)&#123; if(now&amp;&amp;now%2)ans+=a[i].pos-last; if(a[i].sign)now++; else now--; last=a[i].pos; &#125; printf("Case #%d: %d\n",++Cas,ans); &#125; return 0;&#125; C Triple 题目描述解题思路AC代码点击 12 D Counting Sequences I 题目描述定义一个长度为$n$的序列为好序列，当且仅当$\sum_{i=1}^{n}a_i=\prod_{i=1}^{n}a_i$。给定$2\leq n\leq 3000$，求好序列个数。 解题思路爆搜剪枝打表。 打表代码 - by nikkukun点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 6000 + 5;const int MOD = 1e9 + 7;int n;ll fac[N], inv[N], ifac[N];int ans = 0;ll QPow(ll bas, int t)&#123; ll ret = 1; while(t)&#123; if(t &amp; 1) ret = ret * bas % MOD; bas = bas * bas % MOD; t &gt;&gt;= 1; &#125; return ret;&#125;ll Inv(ll x)&#123; return QPow(x, MOD-2);&#125;void Cnt(int p, int v, int sum, int prod, int cnt, ll _ans)&#123; if(sum &gt; 2*n || prod &gt; 2*n) return; if(sum + v * (n-p) &gt; 2*n) return; if(prod * pow(v, n-p) &gt; 2*n) return; if(p == n)&#123; if(prod != sum) return; ans = (ans +_ans) % MOD; return; &#125; Cnt(p+1, v, sum+v, prod*v, cnt+1, _ans * inv[cnt+1] % MOD); for(int i=v+1; i&lt;=n; i++) Cnt(p+1, i, sum+i, prod*i, 1, _ans);&#125;int main()&#123; // freopen("data2.out", "w", stdout); ios::sync_with_stdio(0); cin.tie(0); fac[0] = 1; for(int i=1; i&lt;N; i++) fac[i] = fac[i-1] * i % MOD; ifac[N-1] = Inv(fac[N-1]); for(int i=N-1; i&gt;0; i--) ifac[i-1] = ifac[i] * i % MOD; for(int i=1; i&lt;N; i++) inv[i] = fac[i-1] * ifac[i] % MOD; int t; cin &gt;&gt; t; while(t--)&#123; cin &gt;&gt; n; ans = 0; Cnt(0, 1, 0, 1, 0, fac[n]); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; $AC$代码就不放了。 E Counting Sequences II 题目描述问有多少个长为$n$的数列满足$1\leq a_i\leq m$，且每个偶数在数列中都出现偶数次。 $1\leq n\leq 10^{18},1\leq m\leq 200000$ 解题思路枚举偶数对数，奇数可任选，记$f(n)$为用$\lfloor\frac m2\rfloor$种偶数填$n$个元素，且每个元素均出现偶数次的方案个数，则$ans=\sum_{k=0}^{\lfloor\frac n2\rfloor}C_n^{2k}\lceil\frac m2\rceil^{n-2k}f(2k)$ 考虑如何求$f(n)$：构造生成函数$g(x)$表示每一种偶数值的选择个数与总方案数之间的关系，则$g(x)^{\lfloor\frac m2\rfloor}$在$x^n$处的取值即为所求。于是$g(x)=n!(1+\frac {x^2}{2!}+\frac{x^4}{4!}+…)=n!\frac{e^x+e^{-x}}2$。求幂次，牛顿二项式展开得： $f(n)=g(x)^{\lfloor\frac m2\rfloor}[x^n]=\frac {\sum_{i=0}^{\lfloor\frac m2\rfloor}C_{\lfloor\frac m2\rfloor}^i(\lfloor\frac m2\rfloor-2i)^{n}}{2^{\lfloor\frac m2\rfloor}}$ 方便起见，设$p=\lfloor\frac m2\rfloor$，则$f(n)=\frac {\sum_{i=0}^{p}C_{p}^i(p-2i)^n}{2^{p}}$ $ans=\sum_{k=0}^{\frac n2}C_{n}^{2k}\lceil\frac m2\rceil^{n-2k}\cdot \frac{\sum_{i=0}^pC_p^i(p-2i)^{2k}}{2^p}$ 交换求和符号，提出与变量无关量： $=\frac{\lceil\frac m2\rceil^n}{2^p}\sum_{i=0}^{p}C_p^i\sum_{k=0}^{\lfloor\frac n2\rfloor}C_n^{2k}\frac{(p-2i)^{2k}}{\lceil\frac m2\rceil^{2k}}$ 对于$s=\sum_{i=0}^{n}C_{2n}^{2i}x^{2i}$，有$s=\frac{(1+x)^{2n}+(1-x)^{2n}}2$（牛顿二项式展开） 于是$ans=\frac{\lceil\frac m2\rceil^n}{2^{p+1}}\sum_{i=0}^{p}C_p^i((1+\frac{p-2i}{\lceil\frac m2\rceil})^n+(1-\frac{p-2i}{\lceil\frac m2\rceil})^n)$ $=\frac{1}{2^{p+1}}\sum_{i=0}^{p}C_p^i((\lceil\frac m2\rceil+p-2i)^n+(\lceil\frac m2\rceil-p+2i)^n)$ 这就可以$O(m\log n)$地计算了。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;int mod=1000000007;#define N 200010ll qp(ll a,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,a=a*a%mod)if(p&amp;1)ans=ans*a%mod; return ans;&#125;ll fac[N],inv[N];ll c(int n,int m)&#123; if(n&lt;0||n&lt;m||m&lt;0)return 0; return fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;ll n,m;int main()&#123; int i,T; fac[0]=inv[0]=1; for(i=1;i&lt;N;i++)fac[i]=fac[i-1]*i%mod,inv[i]=qp(fac[i],mod-2); scanf("%d",&amp;T); while(T--)&#123; ll ans=0; scanf("%lld%lld",&amp;n,&amp;m);n%=(mod-1); for(i=0;i&lt;=m/2;i++)(ans+=c(m/2,i)*(qp(m-2*i,n)+qp(2*i+(m%2),n)))%=mod; ans=ans*qp(qp(2,m/2+1),mod-2)%mod; printf("%lld\n",ans); &#125; return 0;&#125; F Rhyme scheme 题目描述求长度为$n$的韵律序列第$k$项。 解题思路可以看做在字典树上选择，可以递推求出$f[i][j][k]$表示长度为$i$的第$j$层第$k$个前面共有多少种选择。 AC代码 - by Mogg点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647stir = [[0 for i in range(30)] for j in range(30)]f = [[0 for i in range(30)] for j in range(30)]def init(): stir[1][1] = 1 for i in range(2,27): for j in range(1,i+1): stir[i][j] = stir[i - 1][j - 1] + j * stir[i - 1][j] for i in range(2,27): for j in range(1,i+1): stir[i][j] += stir[i][j - 1] for i in range(1,27): f[i][0] = 1 f[i][1] = min(26, i + 1) for j in range(2,27): for i in range(1,27): f[i][j] = i * f[i][j - 1] + f[min(i + 1, 26)][j - 1]def work(n,m): if n == 1: return "A" if m &lt;= stir[n-1][n-1]: res = work(n-1,m) return "A" + res res = "AB" mc = 2 m -= stir[n-1][n-1] for i in range(3,n): r = mc + 2 for j in range(1,r): mc = max(mc,j) if m &gt; f[mc][n-i]: m -= f[mc][n-i] continue else: res+=chr(64+j) break if (n &gt; 2): res+=chr(64+m) return res init()#print(stir[3][3])t = int(input())for i in range(t): s = input().split() #print(s) print("Case #"+str(i+1)+": "+work(int(s[0]),int(s[1]))) G Substring 题目描述解题思路AC代码点击 12 H Luhhy’s Matrix 题目描述解题思路AC代码点击 12 I Debug 题目描述解题思路AC代码点击 12 J Stone game 题目描述从长度为$n$的数列$a$里找出一个子集$S$满足$sum(S)\geq sum(a-S)$且$\forall s\in S,sum(S-s)\leq sum(a-S)$ 求方案数。 解题思路将数列由大到小排序，$f[i][j]$表示选到$i$且最后一个元素为$i$，当前总和为$j$的方案数，$g[i][j]$表示选到$i$且最后一个元素不为$i$，当前总和为$j$的方案数，可以递推求出这两个序列，对每一个$f$判断加入答案即可。 智障题卡取模的常数 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#pragma GCC optimize(2)typedef long long ll;using namespace std;int mod=1000000007,g[150010],f[2][150010],a[305];void add(int &amp;a,int b)&#123; a+=b; if(a&gt;=mod)a-=mod;&#125;int main()&#123; int i,j,T,n; scanf("%d",&amp;T); while(T--)&#123; int s=0,cur=0,res=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); s+=a[i]; &#125; a[n]=0; sort(a,a+n);reverse(a,a+n+1); for(j=0;j&lt;=s;j++)f[0][j]=f[1][j]=g[j]=0; f[0][0]=1; for(i=1;i&lt;=n;i++)&#123; cur^=1; for(j=0;j&lt;a[i];j++)f[cur][j]=0; for(j=a[i];j&lt;=s;j++)&#123; f[cur][j]=(f[cur^1][j-a[i]]+g[j-a[i]]); if(f[cur][j]&gt;=mod)f[cur][j]-=mod; &#125; for(j=0;j&lt;=s;j++)&#123; add(g[j],f[cur^1][j]); if(j&gt;=s-j&amp;&amp;j-a[i]&lt;=s-j)add(res,f[cur][j]); &#125; &#125; printf("%d\n",res); &#125; return 0;&#125; K Peekaboo 题目描述解题思路AC代码点击 12 L Digit sum 题目描述求$b$进制下$\sum_{i=1}^{n}digitnum(i)$。 解题思路预处理出来即可。 AC代码 - by nikkukun点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e6 + 5, K = 10 + 3;ll f[N][K];int cal(int n,int b)&#123; int now = 0; while (n) &#123; now += n % b; n /= b; &#125; return now;&#125;void Init()&#123; for(int i=1; i&lt;N; i++) for(int b=2; b&lt;=10; b++) f[i][b] = f[i-1][b] + cal(i, b);&#125;ll Solve()&#123; int n, b; cin &gt;&gt; n &gt;&gt; b; return f[n][b];&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); Init(); int t; cin &gt;&gt; t; for(int i=1; i&lt;=t; i++)&#123; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; cout &lt;&lt; Solve() &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 ICPC南昌赛区网络赛 题解]]></title>
    <url>%2F2019%2F09%2F08%2F2019icpcnanchanginternet%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I 10/11 Ø O Ø Ø O Ø O O . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A Enju With math problem 题目描述给定一个数列，问是不是欧拉函数前$1.5e8$项中的子列。 解题思路考虑内存和时间限制，对质数$31$的倍数三元组打表进行$check$。 AC代码 - by qxforever点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = (int)1.5e8+2;const int N = 5e6;const int B = 31 ;int phi[N],prime[1000000],cnt,ans,n,tot,a[500][103],t,p;bool mark[N];struct Triple&#123; int x,y,z; Triple (int x=0,int y=0,int z=0): x(x),y(y),z(z) &#123;&#125; bool operator &lt; (const Triple &amp;b) const &#123; if(x!=b.x) return x&lt;b.x; if(y!=b.y) return y&lt;b.y; return z&lt;b.z; //return x&lt;b.x||y&lt;b.y||z&lt;b.z; &#125; bool operator == (const Triple &amp;b) const &#123; return x==b.x&amp;&amp;y==b.y&amp;&amp;z==b.z; &#125;&#125;;struct Triple_hash&#123; std::size_t operator() (const Triple &amp;p) const &#123; int h1=std::hash&lt;int&gt;&#123;&#125;(p.x); int h2=std::hash&lt;int&gt;&#123;&#125;(p.y); int h3=std::hash&lt;int&gt;&#123;&#125;(p.z); return h1^h2^h3; &#125;&#125;;unordered_map&lt;Triple,int,Triple_hash&gt; m;int T;void getphi()&#123; int maxn = N ; phi[1]=1;cnt=0; for(int i=2;i&lt;maxn;i++)&#123; if(!mark[i])&#123; prime[cnt++]=i; phi[i]=i-1; &#125; for(int j=0;j&lt;cnt;j++)&#123; if(1LL*i*prime[j]&gt;=maxn) break; mark[i*prime[j]]=1; if(i%prime[j]==0)&#123; phi[i*prime[j]]=phi[i]*prime[j];break; &#125; else phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125;&#125;int calphi(int n)&#123; int m=sqrt(n+0.5); int ans=n; for(int i=2;i&lt;=m;i++)&#123; if(n%i==0)&#123; ans=ans/i*(i-1); while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) ans=ans/n*(n-1); return ans;&#125;int main()&#123; getphi(); int x,y,z; scanf("%d",&amp;T);n=100; for(int i=0;i&lt;T;i++)&#123; for(int j=0;j&lt;n;j++) scanf("%d",&amp;a[i][j]); &#125; for(int i=0;i&lt;T;i++)&#123; for(int j=0;j+(B&lt;&lt;1)&lt;n;j++)&#123; m[Triple(a[i][j],a[i][j+B],a[i][j+(B&lt;&lt;1)])]=0; &#125; &#125; x=phi[31],y=phi[62],z=phi[93]; for(int i=4,j=93;j&lt;=maxn;i++,j+=B)&#123; //if(j&lt;1000) printf("%d %d\n",phi[j],z); if(m.find(Triple(x,y,z))!=m.end()) m[Triple(x,y,z)]=j-(B&lt;&lt;1); x=y,y=z; if(i%B==0) z=B*phi[i]; else z=(B-1)*phi[i]; &#125; for(int k=0;k&lt;T;k++)&#123; bool flag=false; for(int i=0;i&lt;B;i++)&#123; t=m[Triple(a[k][i],a[k][i+B],a[k][i+(B&lt;&lt;1)])]-i; if(t&gt;=1)&#123; for(int j=0;j&lt;100;j++)&#123; if(a[k][j]!=calphi(j+t)) goto A; &#125; flag=true; &#125; A:; if(flag) &#123;printf("YES\n%d\n",t);break;&#125; &#125; if(!flag) printf("NO\n"); &#125;&#125; B Fire-Fighting Hero 题目描述有一个消防英雄和一些消防队，消防英雄速度为$c$，消防队每个人速度都为$1$。 有一张无向图，所有人初始时都在其特定位置，问消防队厉害还是消防英雄厉害，厉害的标准是到所有点最短路的最大值最小。 解题思路跑多次$dijkstra$比较一下即可。 AC代码 - by Mogg点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;random&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int ms = 1010;const int mx = 1000;int g[ms][ms], point[ms], d[ms],d1[ms];vector&lt;int&gt; gr[ms];int n, m, cnt;priority_queue&lt;pair&lt;int, int&gt;&gt;q;bool vis[ms];void dij(int begin)&#123; memset(d, 0x3f, sizeof(d)); memset(vis, false, sizeof(vis)); q.push(&#123; 0,begin &#125;); d[begin] = 0; while (!q.empty()) &#123; int x = q.top().second; q.pop(); if (vis[x]) continue; vis[x] = true; for (int i : gr[x]) &#123; int y = i, z = g[x][i]; if (d[y] &gt; d[x] + z) &#123; d[y] = d[x] + z; q.push(&#123; -d[y],y &#125;); &#125; &#125; &#125;&#125;int main()&#123; int t; scanf("%d", &amp;t); while (t--) &#123; int s, k, c; scanf("%d%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;k, &amp;c); for (int i = 0; i &lt; k; ++i) &#123; scanf("%d", &amp;point[i]); &#125; memset(g, 0x3f, sizeof(g)); memset(d1, 0x3f, sizeof(d1)); int x, y, z; for (int i = 0; i &lt; m; ++i) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); if (g[x][y] == 0x3f3f3f3f) &#123; gr[x].push_back(y); gr[y].push_back(x); &#125; g[x][y] = min(g[x][y], z); g[y][x] = min(g[y][x], z); &#125; dij(s); int t1 = *max_element(d + 1, d + n + 1); int res = 0, t2 = 0; for (int i = 0; i &lt; k; ++i) &#123; dij(point[i]); for (int j = 1; j &lt;= n; ++j) &#123; d1[j] = min(d1[j], d[j]); &#125; &#125; t2 = max(t2, *max_element(d1 + 1, d1 + n + 1)); if (1ll*t2*c &gt;= 1ll * t1) res = t1; else res = t2; printf("%d\n", res); for (int i = 0; i &lt; n; ++i) &#123; gr[i].clear(); &#125; &#125; return 0;&#125; C Hello 2019 题目描述一个字符串称为好串，当且仅当它包含$9102$而不包含$8102$，多次询问一个串$S$中$[l,r]$区间中最少删除多少个元素才能形成一个好串。 解题思路考虑将字符串倒置，问题转化成在区间中找包含$2019$的串而不包含$2018$的串。 建立一个有限状态自动机，设当前构成的串具有$2019$前缀长度为$l_1$的子串转化成长度为$l_2$的子串需要至少删掉$f[l_1][l_2]$个元素，则当当前元素为$2,0,1,9$其中某一个时，有$f[pos][pos]=1$（保持前缀长度不变需要删掉这个元素，比如当前为$2$，那么有$f[0][0]=1$，即前缀长度为$0$的保持为$0$必然需要删掉当前元素，否则前缀长度会变成$1$），$f[pos][pos+1]=0$（用这个元素将前缀加一）；当当前元素为$8$时，有$f[4][4]=1,f[3][3]=1$。用线段树维护两个自动机的合并即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;#define N 200010struct node&#123; int a[5][5]; void init()&#123; memset(a,0x3f,sizeof(a)); int i; for(i=0;i&lt;5;i++)a[i][i]=0; &#125;&#125;;node emp;node tr[N&lt;&lt;2];int L[N&lt;&lt;2],R[N&lt;&lt;2];char a[N];node merge(node a,node b)&#123; int i,j,k; node temp; memset(temp.a,0x3f,sizeof(temp.a)); for(i=0;i&lt;5;i++) for(j=i;j&lt;5;j++) for(k=i;k&lt;=j;k++) temp.a[i][j]=min(temp.a[i][j],a.a[i][k]+b.a[k][j]); return temp;&#125;int id[257];void build(int p,int l,int r)&#123; L[p]=l;R[p]=r; if(l==r)&#123; tr[p].init(); if(a[l]=='2'||a[l]=='0'||a[l]=='1'||a[l]=='9')&#123; tr[p].a[id[a[l]]][id[a[l]]]=1; tr[p].a[id[a[l]]][id[a[l]]+1]=0; &#125;else if(a[l]=='8')&#123; int i; tr[p].a[4][4]=tr[p].a[3][3]=1; &#125; return; &#125; int mid=(l+r)&gt;&gt;1; build(p&lt;&lt;1,l,mid); build(p&lt;&lt;1|1,mid+1,r); tr[p]=merge(tr[p&lt;&lt;1],tr[p&lt;&lt;1|1]);&#125;node query(int p,int l,int r)&#123; if(L[p]&gt;r||R[p]&lt;l)return emp; if(L[p]&gt;=l&amp;&amp;R[p]&lt;=r)return tr[p]; return merge(query(p&lt;&lt;1,l,r),query(p&lt;&lt;1|1,l,r));&#125;int main()&#123; int n,q; id['2']=0;id['0']=1;id['1']=2;id['9']=3; emp.init(); scanf("%d%d",&amp;n,&amp;q); scanf("%s",a); reverse(a,a+n+1); build(1,1,n); while(q--)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); node ans=query(1,n-r+1,n-l+1); if(ans.a[0][4]&lt;1e9)printf("%d\n",ans.a[0][4]); else printf("-1\n"); &#125; return 0;&#125; D Interesting Series 题目描述定义函数$F_i=aF_{i-1}+1,F_1=1$，并定义一个集合$s$的$value$为其中所有元素和的$F$（即$value(s)=F_{sum_s}$）。 给定$S,K$，求$\sum_{s\in subsets\space of\space S\space and\space |s|=K}value(s)$。 解题思路化简$F$，$F_i=\frac{a^i-1}{a-1}$。只考虑与$i$有关的东西，即求$g_i=a^i$。 于是有生成函数$(x+a^{S_1})(x+a^{S_2})\cdot …\cdot (x+a^{S_n})$，答案即为这个多项式$x^{n-k}$的系数。 对生成函数分治$FFT$，剩余部分组合数学。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;cstdio&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;#define M 262144struct comp&#123; double x,y; comp():x(0),y(0)&#123;&#125; comp(const double &amp;_x,const double &amp;_y):x(_x),y(_y)&#123;&#125;&#125;;comp operator+(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x+b.x,a.y+b.y);&#125;comp operator-(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x-b.x,a.y-b.y);&#125;comp operator*(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;comp conj(const comp &amp;a)&#123;return comp(a.x,-a.y);&#125;double PI=acos(-1);comp w[M+5];int rev[M+5];int A[M+5],B[M+5],C[M+5],lim,mx,mod=100003;void fft(comp *a,int n)&#123; int i,j,k,lyc; for(i=0;i&lt;n;i++)if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(i=2,lyc=n&gt;&gt;1;i&lt;=n;i&lt;&lt;=1,lyc&gt;&gt;=1) for(j=0;j&lt;n;j+=i)&#123; comp *l=a+j,*r=a+j+(i&gt;&gt;1),*p=w; for(k=0;k&lt;(i&gt;&gt;1);k++)&#123; comp tmp=*r**p; *r=*l-tmp,*l=*l+tmp; ++l,++r,p+=lyc; &#125; &#125;&#125;void fft_prepare()&#123; int i; for(i=0;i&lt;lim;i++)rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(mx-1)); for(i=0;i&lt;lim;i++)w[i]=comp(cos(2*PI*i/lim),sin(2*PI*i/lim));&#125;comp a[M+5],b[M+5],ta[M+5],tb[M+5];void conv(int *x,int *y,int *z)&#123; int i,j; for(i=0;i&lt;lim;i++)(x[i]+=mod)%=mod,(y[i]+=mod)%=mod; for(i=0;i&lt;lim;i++)&#123; ta[i]=comp(x[i]&amp;32767,x[i]&gt;&gt;15); tb[i]=comp(y[i]&amp;32767,y[i]&gt;&gt;15); &#125; fft(ta,lim);fft(tb,lim); for(i=0;i&lt;lim;i++)&#123; j=(lim-i)%lim;//0的特判 comp da,db,dc,dd; da=(ta[i]+conj(ta[j]))*comp(0.5,0); db=(ta[i]-conj(ta[j]))*comp(0,-0.5); dc=(tb[i]+conj(tb[j]))*comp(0.5,0); dd=(tb[i]-conj(tb[j]))*comp(0,-0.5); a[j]=da*dc+da*dd*comp(0,1); b[j]=db*dc+db*dd*comp(0,1); &#125; fft(a,lim);fft(b,lim); for(i=0;i&lt;lim;i++)&#123; ll da,db,dc,dd; da=(ll)(a[i].x/lim+0.5)%mod; db=(ll)(a[i].y/lim+0.5)%mod; dc=(ll)(b[i].x/lim+0.5)%mod; dd=(ll)(b[i].y/lim+0.5)%mod; z[i]=(da+((db+dc)&lt;&lt;15)+(dd&lt;&lt;30))%mod; &#125;&#125;int qp(ll a,int p)&#123; int ans=1; for(;p;p&gt;&gt;=1,a=a*a%mod)if(p&amp;1)ans=ans*a%mod; return ans;&#125;vector&lt;int&gt;G[M];vector&lt;int&gt;conv(vector&lt;int&gt;a,vector&lt;int&gt;b,int n,int m)&#123; static int x[M],y[M],z[M]; vector&lt;int&gt;tmp;tmp.clear(); int i; mx=0; while((1&lt;&lt;mx)&lt;n+m)mx++; lim=1&lt;&lt;mx; for(i=0;i&lt;n;i++)x[i]=a[i];for(;i&lt;lim;i++)x[i]=0; for(i=0;i&lt;m;i++)y[i]=b[i];for(;i&lt;lim;i++)y[i]=0; fft_prepare(); conv(x,y,z); for(i=0;i&lt;n+m-1;i++)tmp.push_back(z[i]); return tmp;&#125;#define mid ((l+r)&gt;&gt;1)vector&lt;int&gt;dc(int l,int r)&#123; if(l==r)return G[l]; vector&lt;int&gt;L=dc(l,mid); vector&lt;int&gt;R=dc(mid+1,r); vector&lt;int&gt;temp=conv(L,R,L.size(),R.size()); return temp;&#125;int fac[M],inv[M];int c(int n,int m)&#123; if(n&lt;m||m&lt;0)return 0; return 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;int main()&#123; int i,n,a,q,k; fac[0]=inv[0]=1; for(i=1;i&lt;=M/2;i++)fac[i]=1LL*fac[i-1]*i%mod,inv[i]=qp(fac[i],mod-2); scanf("%d%d%d",&amp;n,&amp;a,&amp;q); for(i=1;i&lt;=n;i++)&#123; int s; scanf("%d",&amp;s); G[i].push_back(qp(a,s)); G[i].push_back(1); &#125; vector&lt;int&gt;ans=dc(1,n); while(q--)&#123; scanf("%d",&amp;k); printf("%d\n",((1LL*ans[n-k]-c(n,k))*qp(a-1,mod-2)%mod+mod)%mod); &#125; return 0;&#125; E Magic Master 题目描述根据题意移动卡牌，问最后得到的卡牌最初的位置。 解题思路约瑟夫问题，倒推即可。 AC代码点击 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int T,n,m,q,k;const int maxn = 4e7+23;int f[maxn];int main()&#123; cin &gt;&gt; T; while(T--)&#123; scanf("%d%d",&amp;n,&amp;m);m++; scanf("%d",&amp;q); for(int i=0;i&lt;q;i++)&#123; scanf("%d",&amp;k); int now=n,v=k,step; while(now&gt;=1)&#123; //printf("%d %d\n",now,v); if((v-1)%m==0)&#123; printf("%d\n",n-now+1+(v-1)/m); goto A; &#125; step=(v-1)/m+1; now-=step,v=((v-step*m)); while(v&lt;=0) v+=now; &#125; A:; &#125; &#125;&#125; F Megumi With String 题目描述定义一个字符串$s$的价值$G(p)$为一个关于$p$的多项式，其中$p$为$s$的长度且$s$为$S$的子串。 给定$S$，$q$次操作，每次向$S$后插入一个新字符。随机生成一个字符串$T$，求$T$中所有子串的价值之和的期望。 解题思路不同的子串在随机生成的字符串$T$中具有相等的概率出现，故问题很容易转化成：对于一个长度$l$的$S$中子串，有多少种方式生成$T$中包含这个子串。 建立一个$SAM$，对于每一个新添节点，通过$SAM$上节点与父节点之间的关系，求出每一个长度区间对答案的贡献，过程中求一个前缀和即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;#define N 200010#define P 26const int mod=998244353;int fac[N],inv[N];char s[N];int a[52],f[52],n,m,k,l;ll res,sum[N];struct SAM&#123; int tr[N&lt;&lt;1][P],fa[N&lt;&lt;1],len[N&lt;&lt;1],siz[N&lt;&lt;1]; int cnt,last; void init()&#123;//dont forget!!! cnt=last=1; memset(tr[1],0,sizeof(tr[1])); fa[1]=len[1]=0; &#125; void add(int c)&#123; int p=last,np=++cnt; memset(tr[cnt],0,sizeof(tr[cnt])); siz[np]=1; last=np; len[np]=len[p]+1; while(p&amp;&amp;!tr[p][c])tr[p][c]=np,p=fa[p]; if(!p)fa[np]=1; else&#123; int q=tr[p][c]; if(len[q]==len[p]+1)fa[np]=q; else&#123; int nq=++cnt;len[nq]=len[p]+1; memcpy(tr[nq],tr[q],sizeof(tr[q])); fa[nq]=fa[q]; fa[q]=fa[np]=nq; while(tr[p][c]==q)tr[p][c]=nq,p=fa[p]; &#125; &#125; (res+=sum[min(n,len[last])]-sum[min(n,len[fa[last]])]+mod)%=mod; &#125; void insert(char a[])&#123; int i; for(i=0;a[i];i++)add(a[i]-'a');//can be changed &#125;&#125;sam;ll qp(ll a,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,a=a*a%mod)if(p&amp;1)ans=ans*a%mod; return ans;&#125;int main()&#123; int i,j,T; scanf("%d",&amp;T); while(T--)&#123; res=0; scanf("%d%d%d%d",&amp;l,&amp;k,&amp;n,&amp;m); scanf("%s",s); for(i=0;i&lt;=k;i++)scanf("%d",&amp;a[i]); int mx=min(l+m,n); ll pow26=26; for(i=1;i&lt;=mx;i++)&#123; ll s=0,x=1; for(j=0;j&lt;=k;j++)(s+=a[j]*x)%=mod,x=x*i%mod; s=s*qp(pow26,mod-2)%mod*(n-i+1)%mod; pow26=pow26*26%mod; sum[i]=(sum[i-1]+s)%mod; &#125; sam.init(); sam.insert(s); printf("%lld\n",res); while(m--)&#123; char t[10]=&#123;0&#125;; scanf("%s",t); sam.add(t[0]-'a'); printf("%lld\n",res); &#125; &#125; return 0;&#125; G Pangu Separates Heaven and Earth 题目描述这道题目没有描述。 解题思路强行签到… AC代码 - by Mogg点击 1234567891011121314151617181920212223242526272829303132#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;random&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int ms = 50050;int main()&#123; int r, t, m; scanf("%d", &amp;t); while (t--) &#123; scanf("%d", &amp;r); if(r == 1) &#123; printf("%d\n", 18000); &#125; else &#123; printf("%d\n", 0); &#125; &#125; return 0;&#125; H The Nth Item 题目描述定义数列$f_n=3f_{n-1}+2f_{n-2},f_0=0,f_1=1$。有$n\leq 10^7$次询问，每次询问一个$n\leq 10^{18}$，求$f_n$。 解题思路先求出来循环节（其实没必要），然后分两段打表，数较小的部分直接递推，数较大的部分矩阵快速幂求出一个后递推即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define X 100000#define N Xconst int mod=998244353;int f[N+2];struct Mt&#123; int a[2][2];&#125;tmp[N];Mt mul(Mt a,Mt b)&#123; int i,j,k; Mt t; t.a[0][0]=(1LL*a.a[0][0]*b.a[0][0]+1LL*a.a[0][1]*b.a[1][0])%mod; t.a[0][1]=(1LL*a.a[0][0]*b.a[0][1]+1LL*a.a[0][1]*b.a[1][1])%mod; t.a[1][0]=(1LL*a.a[1][0]*b.a[0][0]+1LL*a.a[1][1]*b.a[1][0])%mod; t.a[1][1]=(1LL*a.a[1][0]*b.a[0][1]+1LL*a.a[1][1]*b.a[1][1])%mod; return t;&#125;Mt qp(Mt a,int p)&#123; Mt t;t.a[0][0]=t.a[1][1]=1;t.a[1][0]=t.a[0][1]=0; for(;p;p&gt;&gt;=1,a=mul(a,a))if(p&amp;1)t=mul(t,a); return t;&#125;int cir=499122176;int main()&#123; int i; Mt a; a.a[0][0]=3;a.a[0][1]=2;a.a[1][0]=1;a.a[1][1]=0; f[0]=0;f[1]=1; for(i=2;i&lt;=N;i++)f[i]=(f[i-2]*2LL+f[i-1]*3LL)%998244353; int q; ll n,ans=0; ll res=0; scanf("%d%lld",&amp;q,&amp;n); tmp[0].a[0][0]=tmp[0].a[1][1]=1;tmp[0].a[1][0]=tmp[0].a[0][1]=0; tmp[1]=qp(a,X); for(i=1;i&lt;X;i++)tmp[i]=mul(tmp[i-1],tmp[1]); while(q--)&#123; ll temp=n%cir; int R=temp%X; int DIV=temp/X; Mt now=tmp[DIV]; ans=(1LL*now.a[1][0]*f[R+1]+1LL*now.a[1][1]*f[R])%mod; n=n^(ans*ans); res^=ans; &#125; printf("%lld\n",res); return 0;&#125; I Yukino With Subinterval 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 ICPC徐州赛区网络赛 题解]]></title>
    <url>%2F2019%2F09%2F07%2F2019icpcxuzhouinternet%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M 10/13 O O O O O . O . O O O . O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A Who is better? 题目描述两个人玩游戏，一共有$n$个石子，第一个人不能全拿走，后面每个人拿走的石子数不能超过上一个人拿走个数的两倍，问最终谁能获胜。$n$通过解一个同余方程组解出。 解题思路很僵硬的斐波那契博弈和中国剩余定理的结合。很容易发现这个博弈是一个斐波那契博弈，套上$EXCRT$板子即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768def mul(a,b,mod): res = 0 while(b&gt;0): if(b%2==1): res = (res + a)%mod a = (a + a)%mod b //=2 return res gcd = 0def exgcd(a, b): global gcd if (b == 0): gcd = a return 1,0 x,y = exgcd(b,a%b) return y,x-a//b * ydef excrt(a,b,n): global gcd M = b[0] a[0]=a[0]%b[0] ans = a[0] x = 0 for i in range(1,n): x,y=exgcd(M, b[i]) B = b[i] a[i]=a[i]%b[i] c = (a[i] - ans % B + B) % B g = B // gcd x = mul(x, c // gcd, g) ans += x * M M *= g ans = (ans%M + M) % M return ans%M def check(x,n,a,b): for i in range(n): if (x%b[i] != a[i]): return False return True s = input()n = int(s)a = []b = []for i in range(n): s = input().split() a.append(int(s[1])) b.append(int(s[0]))now = excrt(a,b,n)fib = [1,1]l = 0 r = 1while fib[l] + fib[r] &lt;= 1000000000000001: fib.append( fib[l] + fib[r]) l+=1 r+=1#print(now)if (check(now,n,a,b)): if (now in fib): print("Lbnb!") else: print("Zgxnb!")else: print("Tankernb!") B so easy 题目描述初始有一个$1-n$的数列，有$q$次操作，操作有两种 删掉某个位置$pos$处的元素 问位置不在$pos$之前的没被删掉的最靠前的元素位置 解题思路并查集，每个被删掉区域并到区间末端即可。 AC代码 - by Mogg点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;int n, q;typedef long long ll;const int ms = 1e6;int a[ms * 3], cnt;pair&lt;int, int&gt;b[ms];//unordered_map&lt;int, int&gt;id;void init()&#123; sort(a, a + cnt); cnt = unique(a, a + cnt) - a; /*for (int i = 0; i &lt; cnt; ++i) &#123; id[a[i]] = i + 1; &#125;*/&#125;int pre[ms * 3];int find(int x) &#123; return x == pre[x] ? pre[x] : pre[x] = find(pre[x]);&#125;void join(int x, int y) &#123; pre[find(x)] = pre[find(y)];&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;q); for (int i = 0; i &lt; q; ++i) &#123; scanf("%d%d", &amp;b[i].first, &amp;b[i].second); a[cnt++] = b[i].second; a[cnt++] = b[i].second + 1; &#125; a[cnt++] = n + 1; init(); int id = 0; for (int i = 0; i &lt; cnt; ++i) &#123; id = (lower_bound(a, a + cnt, a[i]) - a) + 1; pre[id] = id; &#125; for (int i = 0; i &lt; q; ++i) &#123; id = (lower_bound(a, a + cnt, b[i].second) - a) + 1; if (b[i].first == 1) &#123; join(id, id + 1); &#125; else &#123; int res = find(id); res = a[res - 1]; if (res == n + 1) res = -1; printf("%d\n", res); &#125; &#125; return 0;&#125; C Buy Watermelon 题目描述$SB$题没有题目描述。 解题思路$SB$题没有解题思路。 AC代码点击 12345678910#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int main()&#123; int n; scanf("%d",&amp;n); if(n&gt;=4&amp;&amp;n%2==0)printf("YES"); else printf("NO"); return 0;&#125; D Carneginon 题目描述给定两个字符串$S,T$，当$S$比$T$长或短时，分别求出是否互为串与子串关系。 解题思路分情况$kmp$求解即可。 AC代码 - by Mogg点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;cstdio&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int n, m;typedef long long ll;const int ms = 1e5 + 10;char a[ms], b[ms];int nxa[ms], nxb[ms];int main()&#123; scanf("%s", a); int lena = strlen(a); int i = 0, j = -1; nxa[0] = -1; while (i &lt; lena) &#123; if (j == -1 || a[i] == a[j]) &#123; i++, j++; nxa[i] = j; &#125; else j = nxa[j]; &#125; int t; scanf("%d", &amp;t); while (t--) &#123; scanf("%s", b); int lenb = strlen(b); if (lena &lt; lenb) &#123; i = 0, j = 0; bool flag = false; while (i &lt; lenb) &#123; if (j == -1 || b[i] == a[j]) &#123; ++i; ++j; &#125; else &#123; j = nxa[j]; &#125; if (j == lena) &#123; flag = true; break; j = nxa[j]; &#125; &#125; if(flag) &#123; printf("my teacher!\n"); &#125; else &#123; printf("senior!\n"); &#125; &#125;else if(lena == lenb) &#123; if (strcmp(a,b)==0) &#123; printf("jntm!\n"); &#125; else &#123; printf("friend!\n"); &#125; &#125; else &#123; i = 0, j = -1; nxb[0] = -1; while (i &lt; lenb) &#123; if (j == -1 || b[i] == b[j]) &#123; i++, j++; nxb[i] = j; &#125; else j = nxb[j]; &#125; i = 0, j = 0; bool flag = false; while (i &lt; lena) &#123; if (j == -1 || a[i] == b[j]) &#123; ++i; ++j; &#125; else &#123; j = nxb[j]; &#125; if (j == lenb) &#123; flag = true; &#125; &#125; if (flag) &#123; printf("my child!\n"); &#125; else &#123; printf("oh, child!\n"); &#125; &#125; &#125; return 0;&#125; E XKC’s basketball team 题目描述给定一个$1-n$的排列$w$，定义一个人$i$右边的目标人为$w_j\geq w_i+m$的最大$j$，对于每一个$i$求出他与其目标人之间的总人数。 解题思路根据$w$排序，从右向左双指针更新符合要求的最靠右的位置即可。 AC代码 - by Mogg &amp; Potassium点击 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;int n, m;typedef long long ll;const int ms = 1e6;pair&lt;int, int&gt;a[ms];int res[ms];int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;a[i].first); a[i].second = i; &#125; sort(a, a + n); res[a[n - 1].second] = -1; int r = n - 1, mi = 0; for (int i = n - 2; i &gt;= 0; --i) &#123; while (a[r].first &gt;= a[i].first + m) &#123; mi = max(mi, a[r].second); r--; &#125; res[a[i].second] = max(-1, mi - a[i].second - 1); &#125; for (int i = 0; i &lt; n - 1; ++i) &#123; printf("%d ", res[i]); &#125; printf("%d", res[n - 1]); return 0;&#125; F Little M’s attack plan 题目描述解题思路AC代码点击 12 G Colorful String 题目描述定义一个字符串的价值为其所有回文子串的包含的不同字符数，求$s$的价值。 解题思路状态压缩，建立一个回文树，记录下每一个本质不同的回文串出现的次数计数即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1200010#define P 26char a[N];ll ans;ll f(int x)&#123;return 1LL&lt;&lt;x;&#125;struct PT&#123; int tr[N][P],fail[N],len[N]; int cnt[N],num[N]; ll state[N]; int tot,s[N],n,last,i; int newnode(int l)&#123; for(i=0;i&lt;P;i++)tr[tot][i]=0; len[tot]=l; cnt[tot]=0; state[tot]=0; num[tot]=1; return tot++; &#125; void init()&#123; n=last=tot=0; newnode(0);newnode(-1); s[0]=-1; fail[0]=1; &#125; int getfail(int p)&#123; while(s[n-len[p]-1]!=s[n])p=fail[p]; return p; &#125; void add(int p)&#123; s[++n]=p; int cur=getfail(last); if(!tr[cur][p])&#123; int now=newnode(len[cur]+2); int getf=getfail(fail[cur]); fail[now]=tr[getf][p]; tr[cur][p]=now; state[now]=state[cur]|f(p); num[now]=num[fail[now]]+1; &#125; last=tr[cur][p]; cnt[last]++; &#125; void insert(char a[])&#123; int i; for(i=0;a[i];i++)add(a[i]-'a'); &#125; void count()&#123; for(i=tot-1;i&gt;=0;i--)cnt[fail[i]]+=cnt[i]; for(i=0;i&lt;tot;i++)ans+=1LL*cnt[i]*__builtin_popcount(state[i]); &#125;&#125;pam;int main()&#123; scanf("%s",a); pam.init(); pam.insert(a); pam.count(); printf("%lld",ans); return 0;&#125; H function 题目描述解题思路AC代码点击 12 I query 题目描述给定$1-n$的排列$p$，求一个区间中$min(p_i,p_j)=gcd(p_i,p_j),i&lt;j$的$(i,j)$对数。 解题思路问题转化为一个区间中某个元素的倍数有多少个，从左到右枚举元素及其倍数，用树状数组计数即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010int a[N],bit[N],l[N],r[N],pos[N],res[N];vector&lt;int&gt;q[N],temp[N];int query(int p)&#123; if(!p)return 0; int i,ans=0; for(i=p;i;i-=i&amp;(-i))ans+=bit[i]; return ans;&#125;void add(int p)&#123; int i; for(i=p;i&lt;N;i+=i&amp;(-i))bit[i]++;&#125;int main()&#123; int i,j,n,m; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),pos[a[i]]=i; for(i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;l[i],&amp;r[i]); q[r[i]].push_back(i); &#125; for(i=1;i&lt;=n;i++)&#123; for(auto j:temp[i])add(j); for(j=2*a[i];j&lt;=n;j+=a[i])&#123; int id=pos[j]; if(id&lt;=i)add(id); else temp[id].push_back(i); &#125; for(auto j:q[i]) res[j]=query(r[j])-query(l[j]-1); &#125; for(i=1;i&lt;=m;i++)printf("%d\n",res[i]); return 0;&#125; J Random Access Iterator 题目描述求树的深度，到点$p$的时候，设$p$的儿子个数为$k$，每次随机$k$次$p$的子树$dfs$，问最后得出正确结果的概率。 解题思路从叶子向根枚举，设某个节点$q$的失败概率$p_q$，则$p_q=(\frac{\sum_{x是q的儿子}p_x}k)^k$，即选$k$次，每次失败的概率为孩子的失败平均值，只有$k$次全部失败才会失败。 AC代码 - by qxforever点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int mod = 1e9+7;const int maxn = 1e6+23;int M;int qpow(int a,int b)&#123; a%=mod; int ans=1,base=a; while(b)&#123; if(b&amp;1) ans=(1ll*ans*base)%mod; b&gt;&gt;=1; base=(1ll*base*base)%mod; &#125; return ans;&#125;int u,v,n;int d[maxn],p[maxn];int vis[maxn],sz[maxn];vector&lt;int&gt; g[maxn];inline int inv(int x)&#123; return qpow(x,mod-2);&#125;void dfs1(int x,int dep)&#123; vis[x]=1; M=max(M,dep); d[x]=dep; for(auto i:g[x]) if(!vis[i]) dfs1(i,dep+1),sz[x]++;&#125;void dfs(int x,int dep)&#123; vis[x]=1; if(sz[x]==0)&#123; if(d[x]==M)&#123; p[x]=0;return; &#125; else&#123; p[x]=1;return; &#125; &#125; int num=sz[x]; ll sum=0; for(auto i:g[x])&#123; if(!vis[i]) dfs(i,dep+1),sum=(sum+p[i])%mod; &#125; sum=sum*inv(num)%mod; sum=qpow(sum,num); p[x]=sum;&#125;int main()&#123; //printf("%d",1ll*19*inv(27)%mod); scanf("%d",&amp;n); for(int i=0;i&lt;n-1;i++)&#123; scanf("%d%d",&amp;u,&amp;v); g[u].push_back(v); g[v].push_back(u); &#125; dfs1(1,1); memset(vis,0,sizeof(vis)); dfs(1,1); //for(int i=1;i&lt;=n;i++) printf("%d: %d\n",i,d[i]); printf("%d",(1-p[1]+mod)%mod);//769958502&#125; K Center 题目描述求最少要多少个点能够把一堆点变成一个中心对称图形。 解题思路枚举每两个元素的连线中点，求出交点对数以及在交点上点的个数取最大值，剩余元素个数即为答案。 AC代码 - by qxforever点击 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3+23;struct Point&#123; int x,y; Point (int x=0,int y=0) :x(x),y(y) &#123;&#125; bool operator &lt;(const Point &amp;a) const &#123; if(a.x!=x) return x&lt;a.x; return y&lt;a.y; &#125;&#125;;Point operator + (Point A,Point B)&#123;return Point(A.x+B.x,A.y+B.y);&#125;map&lt;Point,int&gt; m;Point p[maxn];int n;int main()&#123; cin &gt;&gt; n; for(int i=0;i&lt;n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y); for(int i=0;i&lt;n;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; m[p[i]+p[j]]+=2; &#125; m[p[i]+p[i]]++; &#125; int ans=0; for(auto it=m.begin();it!=m.end();it++) ans=max(ans,it-&gt;second); printf("%d",n-ans);&#125; L Dice 题目描述解题思路AC代码点击 12 M Longest subsequence 题目描述求出$S$中最长的满足字典序严格$&gt;t$的子序列长度。 解题思路开始看成子串了，求了一手$exkmp$，$WA$了。 维护一个最多匹配到$t$的第几位，如果遇到更大的直接对答案进行更新，特判与$t$串相等的情况即可。 AC代码 - by Mogg点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int n, m;typedef long long ll;const int ms = 1e6 + 10;char a[ms], b[ms], c[ms];int fx[ms][26], cnt;int main()&#123; scanf("%d%d", &amp;n, &amp;m); scanf("%s", a); scanf("%s", b); memset(fx, -1, sizeof(fx)); for (int i = 0; i &lt; m; ++i) &#123; if (i &gt; 0) for (int j = 0; j &lt; 26; ++j) &#123; fx[i][j] = fx[i - 1][j]; &#125; fx[i][b[i] - 'a'] = i; &#125; int res = -1; for (int i = 0; i &lt; n; ++i) &#123; if (a[i] &gt; b[cnt]) &#123; res = max(cnt + n - i, res); &#125; else &#123; int idx = -1; for (int j = 'a'; j &lt; a[i]; ++j) &#123; idx = max(idx, fx[cnt][j - 'a']); &#125; if (idx &gt; -1) &#123; res = max(idx + n - i, res); &#125; if (a[i] == b[cnt]) cnt++; &#125; &#125; printf("%d", res); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 ICPC Shenyang Regional Contest 题解]]></title>
    <url>%2F2019%2F09%2F05%2F2018shenyang%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M 7/13 . . O . . . O . O O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A Sockpuppets 题目描述解题思路AC代码点击 12 B Sequences Generator 题目描述解题思路AC代码点击 12 C Insertion Sort 题目描述求插入排序$k$轮，最后得到的序列是$almost\space sorted$序列的序列种数。 解题思路插入排序$k$轮保证了前$k$位有序，故枚举所有$almost\space sorted$序列，则原序列前$k$个元素必然为前$1-k$或$1-k$中的$k-1$个元素加一个后面的数字。当前$k$个元素为$1-k$时，后半段产生一对插入错误的数，即除掉有序数列的$almost\space sorted\space array$，种数为$(n-k-1)^2$。否则必然为取$1-（k-1）$中某个元素放到后面的第一个位置，后面选$n-k$个元素中的某个元素放到前面，共有$k\times (n-k)$种方法。此外，对于数$k$，可以与后面的任何数交换，交换后仍保证几乎排序，故需要再加$n-k-1$。以上只枚举了有一个错位的情况，还需要加一个有序排列。前$k$个元素全排列，再乘一个$k!$即可。 AC代码点击 12345678910111213141516#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int main()&#123; int i,T,Cas=0; scanf("%d",&amp;T); while(T--)&#123; int n,k,mod; scanf("%d%d%d",&amp;n,&amp;k,&amp;mod);k=min(n,k); ll ans=1ll*(n-k)*(n-k-1)+1ll*k*(n-k)+1; ans%=mod; for(i=1;i&lt;=k;i++)ans=ans*i%mod; printf("Case #%d: %lld\n",++Cas,ans); &#125; return 0;&#125; D Diameter of a Tree 题目描述解题思路AC代码点击 12 E The Kouga Ninja Scrolls 题目描述解题思路AC代码点击 12 F Counting Sheep in Ami Dongsuo 题目描述解题思路AC代码点击 12 G Best ACMer Solves the Hardest Problem 题目描述有一个平面，上面有一些有权值的点。有四种操作： 在$(x,y)$处插入一个权值为为$w$的点，保证操作前这个坐标上不存在点； 删除$(x,y)$处的点； 将与$(x,y)$之间欧几里得距离为$\sqrt k$的所有点权值$+w$； 求与$(x,y)$之间欧几里得距离为$\sqrt k$的所有点权值之和。 解题思路由于$x^2+y^2=k$的$(x,y)$较少，可以预处理一下暴力修改，特判$\Delta x=0$或$\Delta y=0$的情况。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 6010#define M 200010#define P 10000010vector&lt;pair&lt;int,int&gt;&gt;pos[P];int v[N][N],x[P],y[P];int jud(int x,int y)&#123; return x&gt;=1&amp;&amp;x&lt;=6000&amp;&amp;y&gt;=1&amp;&amp;y&lt;=6000&amp;&amp;v[x][y];&#125;int main()&#123; int i,j,n,m,T,Cas=0; for(i=0;i&lt;=6000;i++)&#123; for(j=0;j&lt;=6000;j++)&#123; if(i*i+j*j&lt;P)pos[i*i+j*j].push_back(make_pair(i,j)); else break; &#125; &#125; scanf("%d",&amp;T); while(T--)&#123; printf("Case #%d:\n",++Cas); scanf("%d%d",&amp;n,&amp;m); int val,X,Y; for(i=1;i&lt;=n;i++)scanf("%d%d%d",&amp;x[i],&amp;y[i],&amp;val),v[x[i]][y[i]]=val; ll lastans=0; int opt,k; while(m--)&#123; scanf("%d",&amp;opt); scanf("%d%d",&amp;X,&amp;Y); X=(X+lastans)%6000+1; Y=(Y+lastans)%6000+1; if(opt==1)&#123; scanf("%d",&amp;val); x[++n]=X;y[n]=Y; v[X][Y]=val; &#125;else if(opt==2)&#123; v[X][Y]=0; &#125;else if(opt==3)&#123; scanf("%d%d",&amp;k,&amp;val); for(auto j:pos[k])&#123; if(!j.first&amp;&amp;!j.second)&#123; if(jud(X+j.first,Y+j.second))v[X+j.first][Y+j.second]+=val; &#125;else if(!j.first)&#123; if(jud(X+j.first,Y+j.second))v[X+j.first][Y+j.second]+=val; if(jud(X+j.first,Y-j.second))v[X+j.first][Y-j.second]+=val; &#125;else if(!j.second)&#123; if(jud(X+j.first,Y+j.second))v[X+j.first][Y+j.second]+=val; if(jud(X-j.first,Y+j.second))v[X-j.first][Y+j.second]+=val; &#125;else&#123; if(jud(X+j.first,Y+j.second))v[X+j.first][Y+j.second]+=val; if(jud(X+j.first,Y-j.second))v[X+j.first][Y-j.second]+=val; if(jud(X-j.first,Y+j.second))v[X-j.first][Y+j.second]+=val; if(jud(X-j.first,Y-j.second))v[X-j.first][Y-j.second]+=val; &#125; &#125; &#125;else&#123; ll ans=0; scanf("%d",&amp;k); for(auto j:pos[k])&#123; if(!j.first&amp;&amp;!j.second)&#123; if(jud(X+j.first,Y+j.second))ans+=v[X+j.first][Y+j.second]; &#125;else if(!j.first)&#123; if(jud(X+j.first,Y+j.second))ans+=v[X+j.first][Y+j.second]; if(jud(X+j.first,Y-j.second))ans+=v[X+j.first][Y-j.second]; &#125;else if(!j.second)&#123; if(jud(X+j.first,Y+j.second))ans+=v[X+j.first][Y+j.second]; if(jud(X-j.first,Y+j.second))ans+=v[X-j.first][Y+j.second]; &#125;else&#123; if(jud(X+j.first,Y+j.second))ans+=v[X+j.first][Y+j.second]; if(jud(X+j.first,Y-j.second))ans+=v[X+j.first][Y-j.second]; if(jud(X-j.first,Y+j.second))ans+=v[X-j.first][Y+j.second]; if(jud(X-j.first,Y-j.second))ans+=v[X-j.first][Y-j.second]; &#125; &#125; printf("%lld\n",ans); lastans=ans; &#125; &#125; for(i=1;i&lt;=n;i++)v[x[i]][y[i]]=0; &#125; return 0;&#125; H Rainbow Graph 题目描述解题思路AC代码点击 12 I Distance Between Sweethearts 题目描述有六个整数变量$I_{girl},U_{girl},A_{girl},I_{boy},U_{boy},A_{boy}$。分别给定他们的上限（均为$\leq 2000$的正整数），它们的下限为$0$。 求所有在合法区间内的$max(|I_{girl}-I_{boy}|,|U_{girl}-U_{boy}|,|A_{girl}-A_{boy}|)\oplus I_{girl}\oplus U_{girl}\oplus A_{girl}\oplus I_{boy}\oplus U_{boy}\oplus A_{boy}$之和。 解题思路从小到大枚举绝对值里面的东西，分别将绝对值符合要求的对应异或值存到三个数组里，累计求和即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;typedef unsigned long long ull;using namespace std;#define N 2050#define M 11int u[N],v[N],w[N];ull f[M][2],g[M][2],h[M][2];//x对应位数种数，y对应位数种数，xy元素异或对应种数void solve(int *x,int *y)&#123; memset(f,0,sizeof(f));memset(g,0,sizeof(g));memset(h,0,sizeof(h)); int i,j,k; for(i=0;i&lt;N;i++)&#123; if(x[i])for(j=0;j&lt;M;j++)f[j][!!((1&lt;&lt;j)&amp;i)]+=x[i]; if(y[i])for(j=0;j&lt;M;j++)g[j][!!((1&lt;&lt;j)&amp;i)]+=y[i]; &#125; for(i=0;i&lt;M;i++) for(j=0;j&lt;2;j++) for(k=0;k&lt;2;k++) h[i][j^k]+=(1ll&lt;&lt;i)*f[i][j]*g[i][k];&#125;int main()&#123; int i,j,k,T,Cas=0; scanf("%d",&amp;T); while(T--)&#123; ull ans=0; vector&lt;int&gt;vu[N],vv[N],vw[N]; for(i=0;i&lt;N;i++)&#123; vu[i].clear(),vv[i].clear(),vw[i].clear(); u[i]=v[i]=w[i]=0; &#125; int u0,u1,v0,v1,w0,w1; scanf("%d%d%d%d%d%d",&amp;u0,&amp;v0,&amp;w0,&amp;u1,&amp;v1,&amp;w1); for(i=0;i&lt;=u0;i++)for(j=0;j&lt;=u1;j++)vu[abs(i-j)].push_back(i^j); for(i=0;i&lt;=v0;i++)for(j=0;j&lt;=v1;j++)vv[abs(i-j)].push_back(i^j); for(i=0;i&lt;=w0;i++)for(j=0;j&lt;=w1;j++)vw[abs(i-j)].push_back(i^j); for(i=0;i&lt;N;i++)&#123; if(!vu[i].empty())&#123; solve(v,w); for(auto j:vu[i])&#123; u[j]++; for(k=0;k&lt;M;k++)ans+=h[k][!((1&lt;&lt;k)&amp;(i^j))]; &#125; &#125; if(!vv[i].empty())&#123; solve(u,w); for(auto j:vv[i])&#123; v[j]++; for(k=0;k&lt;M;k++)ans+=h[k][!((1&lt;&lt;k)&amp;(i^j))]; &#125; &#125; if(!vw[i].empty())&#123; solve(u,v); for(auto j:vw[i])&#123; w[j]++; for(k=0;k&lt;M;k++)ans+=h[k][!((1&lt;&lt;k)&amp;(i^j))]; &#125; &#125; &#125; printf("Case #%d: %llu\n",++Cas,ans); &#125; return 0;&#125; J How Much Memory Your Code Is Using? 题目描述求一些变量占用的内存。 解题思路签到题 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;map&lt;string,int&gt;mp;int main()&#123; int i,t,Cas=0; mp["char"]=mp["bool"]=1; mp["int"]=mp["float"]=4; mp["double"]=mp["longlong"]=8; mp["__int128"]=mp["longdouble"]=16; scanf("%d",&amp;t); while(t--)&#123; ll ans=0,now; int n; scanf("%d",&amp;n); string x,y; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;x; if(x=="long")&#123; cin&gt;&gt;y; x=x+y; &#125; now=mp[x]; cin&gt;&gt;x; int flag=0,num=0;//kuohao for(auto j:x)&#123; if(j=='[')flag=1; else if(j==']')flag=0; else if(flag)num=num*10+j-'0'; &#125; if(!num)num=1;//meiyoukuohao ans+=num*now; &#125; printf("Case #%d: %d\n",++Cas,(ans+1023)/1024); &#125; return 0;&#125; K Let the Flames Begin 题目描述求约瑟夫环第$m$轮退出游戏的人，其中总人数为$n$，每轮报数到$k$的人退出游戏。 $1\leq n,m,k\leq 10^{18}$，$min(m,k)&lt;2\times 10^6$。 解题思路考虑后一半数据范围，当$k$较大的时候，$m$较小，直接逆推即可；当$m$较大的时候，$k$较小，考虑到$n$较大，于是每轮模拟可以删除多个人（一圈以内求多次），逆推即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn= 2e6+23;ll f[maxn];ll n,m,k;int T;int main()&#123; cin &gt;&gt; T;int cas=0; while(T--)&#123; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); printf("Case #%d: ",++cas); f[0]=(k-1)%(n-m+1); if(m&lt;=k)&#123; for(int i=1;i&lt;m;i++) f[i]=(f[i-1]+k)%(n-m+i+1); printf("%lld\n",f[m-1]+1); &#125; else&#123; if(k==1) &#123;printf("%lld\n",m);continue;&#125; for(int i=1;i&lt;k;i++) f[i]=(f[i-1]+k)%(n-m+i+1); ll now=k-1,step=0,v=f[k-1]; while(now+step&lt;m)&#123; if(step!=0) now+=step,v=(v+step*k)%(now+n-m+1); step=(now+n-m+1-v-1)/(k-1)+1; &#125; v=(m-now-1)*k+v; printf("%lld\n",v%n+1); &#125; &#125;&#125; L Machining Disc Rotors 题目描述给一个圆心在原点上的初始圆，有$n$个圆形锯，在这些锯范围内的初始圆的部分会被切除。问最后的圆中，距离最远的两点之间距离是多少。 解题思路最后的距离必然为一对圆交点或直径，枚举即可。 AC代码 - by qxforever点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;#define point Point#define v Vectorconst double eps = 1e-9;struct Point&#123; double x,y; Point(double x=0,double y=0):x(x),y(y) &#123;&#125; bool operator &lt; (const point &amp;b) &#123; return x&lt;b.x||(x==b.x&amp;&amp;y&lt;b.y); &#125;&#125;;typedef Point Vector;Point operator + (Point A,Point B)&#123;return Point(A.x+B.x,A.y+B.y);&#125;Point operator - (Point A,Point B) &#123;return point(A.x-B.x,A.y-B.y);&#125;point operator * (point A,double B) &#123;return point(A.x*B,A.y*B);&#125;point operator / (point A,double B) &#123;return point(A.x/B,A.y/B);&#125;int dcmp(double x)&#123; if(fabs(x)&lt;eps) return 0; return x&lt;0 ? -1 : 1;&#125;bool operator == (const point &amp;a,const point &amp;b)&#123; return dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)==0;&#125;double dot(Vector a,Vector b)&#123; return a.x*b.x+a.y*b.y;&#125;double length(Vector a)&#123; return sqrt(dot(a,a));&#125;double angle(v a,v b)&#123; return acos(dot(a,b))/length(a)/length(b);&#125;double cross(v a,v b)&#123; return a.x*b.y-a.y*b.x;&#125;struct Circle&#123; Point c;double r; //Circle(Point c,double r) :c(c),r(r)&#123;&#125; Point pnt(double a) &#123; return Point(c.x+cos(a)*r,c.y+sin(a)*r); &#125;&#125;;double Angle(Vector v)&#123; return atan2(v.y,v.x);&#125;int getCircleCircleIntersection(Circle c1,Circle c2,vector&lt;Point&gt; &amp;sol)&#123; double d=length(c1.c-c2.c); if(dcmp(d)==0) return 0; if(dcmp(c1.r+c2.r-d)&lt;0) return 0; if(dcmp(fabs(c1.r-c2.r)-d)&gt;0) return 0; double a=Angle(c2.c-c1.c); double da=acos(( c1.r*c1.r + d*d - c2.r*c2.r )/( 2*c1.r * d )); Point p1 =c1.pnt(a-da),p2=c1.pnt(a+da); sol.push_back(p1); if(p1==p2) return 1; sol.push_back(p2); return 2;&#125;const int maxn = 123;int T,n;Circle a[maxn],c;vector&lt;point&gt; pt;inline double dis(int i,int j)&#123; return sqrt((pt[i].x-pt[j].x)*(pt[i].x-pt[j].x)+(pt[i].y-pt[j].y)*(pt[i].y-pt[j].y));&#125;bool check(Point k)&#123; Point p=Point(0,0)-k; for(int i=0;i&lt;n;i++)&#123; if(dot(p-a[i].c,p-a[i].c)&lt;a[i].r*a[i].r) return true; &#125; return false;&#125;int main()&#123; cin &gt;&gt; T;int cas=1; while(T--)&#123; scanf("%d%lf",&amp;n,&amp;c.r); c.c.x=c.c.y=0; pt.resize(0); for(int i=0;i&lt;n;i++) scanf("%lf%lf%lf",&amp;a[i].c.x,&amp;a[i].c.y,&amp;a[i].r),getCircleCircleIntersection(c,a[i],pt); printf("Case #%d: ",cas++); double ans=0; for(int i=0;i&lt;pt.size();i++)&#123; if(!check(pt[i]))&#123; printf("%.10f\n",2*c.r); goto A; &#125; &#125; for(int i=0;i&lt;pt.size();i++)&#123; for(int j=i+1;j&lt;pt.size();j++)&#123; ans=max(ans,dis(i,j)); &#125; &#125; printf("%.10f\n",ans); A:; &#125;&#125; M Renaissance Past in Nancy 题目描述有$n$种物品，第$i$种物品有$a_i$种，其价格为$b_i$。有$q$次询问，每次询问一个区间$[l,r]$，问总花费钱数最多为$c$，在$[l,r]$种物品之内买物品的方案数。 解题思路将每一种物品用生成函数表示为$1+x^b+x^{2b}+…+x^{ab}$ $=\frac{x^{(a+1)b}-1}{x^b-1}=(1-x^{(a+1)b})(1+x^b+…+x^{kb}+…)$ 于是$[l,r]$方案数即为$\prod_{i=l}^{r}(1+x^{b_i}+…+x^{a_ib_i})$中指数在$c$以下的系数之和。 考虑做一个前缀积，但要做前缀积需要类似重载减法运算符。对应在这个生成函数上，求$\prod_{i=l}^{r}=\prod_{i=1}^{r}\frac{x^{(a+1)b}-1}{x^b-1}\prod_{i=1}^{l-1}\frac{x^b-1}{x^{(a+1)b}-1}$，故可以维护两种背包，分别对分子分母做完全背包和$01$背包。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;#define N 10010#define M 2010const int mod=1000000007;int f[M],g[M],sf[N][M],sg[N][M];void add01(int *f,int v)&#123; int i; for(i=M-1;i&gt;=v;i--)f[i]=(f[i]-f[i-v]+mod)%mod;&#125;void addcomplete(int *f,int v)&#123; int i; for(i=v;i+v&lt;M;i++)f[i]=(f[i]+f[i-v])%mod;&#125;int main()&#123; int i,j,T,Cas=0,n,m; scanf("%d",&amp;T); while(T--)&#123; memset(f,0,sizeof(f)); memset(g,0,sizeof(g)); scanf("%d%d",&amp;n,&amp;m); f[0]=g[0]=sg[0][0]=sf[0][0]=1; for(j=1;j&lt;M;j++)sf[0][j]=1,sg[0][j]=0; for(i=1;i&lt;=n;i++)&#123; int a,b; scanf("%d%d",&amp;a,&amp;b); add01(f,b*(a+1)); add01(g,b); addcomplete(f,b); addcomplete(g,b*(a+1)); sf[i][0]=f[0];sg[i][0]=g[0]; for(j=1;j&lt;M;j++)&#123; sf[i][j]=(sf[i][j-1]+f[j])%mod; sg[i][j]=g[j]; &#125; &#125; int lastans=0; printf("Case #%d:\n",++Cas); while(m--)&#123; int l,r,c; scanf("%d%d%d",&amp;l,&amp;r,&amp;c); l=(l+lastans)%n+1; r=(r+lastans)%n+1; if(l&gt;r)swap(l,r); ll ans=0; for(i=0;i&lt;=c;i++)ans=(ans+1LL*sf[r][i]*sg[l-1][c-i])%mod; printf("%lld\n",ans); lastans=ans; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 ICPC Xuzhou Regional Contest 题解]]></title>
    <url>%2F2019%2F09%2F04%2F2018icpcxuzhou%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M 8/13 O . Ø O . . O O O . Ø . O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A Rikka with Minimum Spanning Trees 题目描述给一个随机数生成器生成一张图，问最小生成树乘上最小生成树的个数是多少。 解题思路因为随机的是$64$位的边权，有两个最小生成树的可能极小，故直接$kruskal$即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;typedef long long ll;typedef unsigned long long ull;typedef unsigned int uint;using namespace std;#define N 100010int f[N];ull k1, k2;ull xorShift128Plus()&#123; ull k3=k1,k4=k2; k1=k4; k3^=k3&lt;&lt;23; k2=k3^k4^(k3&gt;&gt;17)^(k4&gt;&gt;26); return k2+k4;&#125;int n,m,tot;struct Edge&#123; int u,v;ull w; bool operator&lt;(const Edge&amp;e)const&#123;return w&lt;e.w;&#125;&#125;e[N&lt;&lt;2];void gen()&#123; int i,u,v;ull w; scanf("%d%d%llu%llu",&amp;n,&amp;m,&amp;k1,&amp;k2); for(i=1;i&lt;=m;i++)&#123; u=xorShift128Plus()%n+1; v=xorShift128Plus()%n+1; w=xorShift128Plus(); if(u!=v)e[tot++]=(Edge)&#123;u,v,w&#125;; &#125;&#125;int find(int x)&#123; return x==f[x]?f[x]:f[x]=find(f[x]);&#125;int main()&#123; int i,T; scanf("%d",&amp;T); while(T--)&#123; int cnt=0;tot=0; ull ans=0,mod=1000000007; gen(); sort(e,e+tot); for(i=1;i&lt;=n;i++)f[i]=i; for(i=0;i&lt;tot;i++)&#123; int x=find(e[i].u),y=find(e[i].v); if(x!=y)&#123; f[x]=y;cnt++; ans=(ans+e[i].w%mod)%mod; &#125; &#125; if(cnt==n-1)printf("%llu\n",ans); else printf("0\n"); &#125; return 0;&#125; B Rikka with Line Graphs 题目描述解题思路AC代码点击 12 C Rikka with Consistency 题目描述给定一个折线段（共$n$段，$n\leq 50$），左端点在$(0,0)$，右端点在$(n,0)$，中间第$i$个点在$(n,hi)$。所有高度在$0-50$之间整数。 一开始，一个人$A$在左端点，一个人$B$在右端点。$A$要走到右端点，$B$要走到左端点，要求时时刻刻两个人的高度总保持一致。求最小总路程和。 解题思路用一个三元组$(x,y,h)$保存第一个人位于$[x,x+1]$，第二个人位于$[y,y+1]$，两个人高度均为$h$时的最小总路程和，如果$[x,x+1]$区间线段高度相等，定义位于左端点。于是可以跑一边最短路。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;double dis[52][52][52],unit[52];int h[52],vis[52][52][52];struct Point&#123; double ds; int x,y,z; bool operator&lt;(const Point&amp;p)const&#123; return ds&gt;p.ds; &#125;&#125;;Point Get(double a,int x,int y,int z)&#123;return (Point)&#123;a,x,y,z&#125;;&#125;priority_queue&lt;Point&gt;Q;void get(double ds,int x,int y,int z)&#123; if(dis[x][y][z]&gt;ds)&#123; dis[x][y][z]=ds; Q.push(Get(ds,x,y,z)); &#125;&#125;int in(int h,int h1,int h2)&#123; return h&gt;=min(h1,h2)&amp;&amp;h&lt;=max(h1,h2);&#125;int main()&#123; int i,j,k,T,n; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); memset(vis,0,sizeof(vis)); for(i=0;i&lt;=n;i++)for(j=0;j&lt;=n;j++)for(k=0;k&lt;=50;k++)dis[i][j][k]=1e9; for(i=0;i&lt;=n;i++)scanf("%d",&amp;h[i]); for(i=1;i&lt;=n;i++) unit[i-1]=h[i]==h[i-1]?1:sqrt((h[i]-h[i-1])*(h[i]-h[i-1])+1.0)/fabs(h[i]-h[i-1]); h[n+1]=-1e9; dis[0][n][0]=0; Q.push(Get(0,0,n,0)); while(!Q.empty())&#123; Point tmp=Q.top();Q.pop(); double ds=tmp.ds; int x=tmp.x; int y=tmp.y; int z=tmp.z; if(vis[x][y][z])continue; vis[x][y][z]=1; if(z==h[x]&amp;&amp;x&gt;0)get(ds+(h[x]==h[x-1]),x-1,y,z); if(z==h[x+1]&amp;&amp;x+1&lt;=n)get(ds+(h[x+1]==h[x]),x+1,y,z); if(z==h[y+1]&amp;&amp;y+1&lt;=n)get(ds+(h[y+1]==h[y]),x,y+1,z); if(z==h[y]&amp;&amp;y&gt;0)get(ds+(h[y]==h[y-1]),x,y-1,z); if(in(z-1,h[x],h[x+1])&amp;&amp;in(z-1,h[y],h[y+1]))get(ds+unit[x]+unit[y],x,y,z-1); if(in(z+1,h[x],h[x+1])&amp;&amp;in(z+1,h[y],h[y+1]))get(ds+unit[x]+unit[y],x,y,z+1); &#125; printf("%.15f\n",dis[n][0][0]); &#125; return 0;&#125; D Rikka with Subsequences 题目描述给了一个$n\times n$的$01$矩阵$M$，还给了一个长度为$n$的序列$a_i$，$a_i\in [1,n]$。其中任意一个子序列，如果满足相邻的元素$a_i,a_j$满足$M_{a_ia_j}=1$，则被称作$Yuta$序列。 对于给定序列的每一个$Yuta$序列，统计出现的总数$cnt$，然后求$cnt^3$的和。 解题思路先将$cnt^3$拆为计算三个完全相同的$Yuta$序列的选择个数。 设$f[j][k]$表示第一个序列选到$i$，第二个序列选到$j$，第三个序列选到$k$的、三个序列为相同的$Yuta$序列的种数。用前缀和优化，设$s[j][k]$代表选到$i$，且之前能完全对应匹配某个$l&lt;i$，且能够与$i$匹配的二元组$(j,k)$个数，这里不需要考虑重复，因为$f[j][k]$会选择性地匹配。于是有$f[j][k]=s[j][k]+1$， $s[j][k]=s[j][k-1]+s[j-1][k]-s[j-1][k-1]+(M_{a[j-1]a[i]}==1?f[j-1][k-1]:0)$ AC代码点击 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char m[210][210];int a[210];ll s[210][210],f[210][210],mod=1000000007;int main()&#123; int i,j,k,T,n; scanf("%d",&amp;T); while(T--)&#123; ll ans=0; memset(f,0,sizeof(f)); scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++)scanf("%s",m[i]+1); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=n;j++)&#123; for(k=1;k&lt;=n;k++)&#123; if(m[a[j]][a[i]]=='1')s[j+1][k+1]=f[j][k]; else s[j+1][k+1]=0; (s[j+1][k+1]+=s[j+1][k]+s[j][k+1]-s[j][k])%=mod; &#125; &#125; for(j=1;j&lt;=n;j++)&#123; for(k=1;k&lt;=n;k++)&#123; if(a[i]==a[k]&amp;&amp;a[j]==a[k])&#123; (ans+=s[j][k]+1)%=mod; (f[j][k]+=s[j][k]+1)%=mod; &#125; &#125; &#125; &#125; printf("%lld\n",(ans+mod)%mod); &#125; return 0;&#125; E Rikka with Data Structures 题目描述解题思路AC代码点击 12 F Rikka with Nice Counting Striking Back 题目描述解题思路AC代码点击 12 G Rikka with Intersections of Paths 题目描述给定一个$n$个节点的树和$m$个简单路，求有多少个选择$k$个给定简单路并使得这$k$个简单路交于同一点的方案。答案对$1e9+7$取模。 解题思路居然是这里的原题 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 300010const int mod=1000000007;int n,m;struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int cnt;int d[N],fa[22][N],lg[N],hd[N];void add(int a,int b)&#123; e[++cnt].e=b; e[cnt].n=hd[a]; hd[a]=cnt;&#125;void dfs(int now,int f)&#123; d[now]=d[f]+1; fa[0][now]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++)fa[i][now]=fa[i-1][fa[i-1][now]]; for(;i&lt;22;i++)fa[i][now]=0; for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=f)dfs(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y]) x=fa[lg[d[x]-d[y]]][x]; if(x==y)return x; for(i=lg[d[x]];~i;i--) if(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y]; return fa[0][x];&#125;int lcanum[N],x[N],y[N];int edges[N],k;ll res;ll fac[N],inv[N];int qp(ll a,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,a=a*a%mod)if(p&amp;1)ans=ans*a%mod; return ans;&#125;int c(int n,int m)&#123; if(n&lt;m||m&lt;0)return 0; return fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;void getans(int p,int f)&#123; int i,q; for(i=hd[p];i;i=e[i].n)&#123; q=e[i].e; if(q!=f)&#123; getans(q,p); edges[p]+=edges[q]; &#125; &#125; res=(res+c(edges[p],k)-c(edges[p]-lcanum[p],k)+mod)%mod;&#125;int main()&#123; int i,x,y,T; fac[0]=inv[0]=1; for(i=1;i&lt;N;i++)fac[i]=fac[i-1]*i%mod,inv[i]=qp(fac[i],mod-2); for(i=2;i&lt;N;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); scanf("%d",&amp;T); while(T--)&#123; res=0; memset(hd,0,sizeof(int)*(n+1));cnt=0; memset(lcanum,0,sizeof(int)*(n+1)); memset(edges,0,sizeof(int)*(n+1)); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); int rt=1; for(i=1;i&lt;n;i++)&#123; scanf("%d%d",&amp;x,&amp;y); add(x,y);add(y,x); &#125; d[rt]=0; dfs(rt,0); for(i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;x,&amp;y);int lc=lca(x,y); lcanum[lc]++; edges[x]++;edges[y]++; edges[lc]--;edges[fa[0][lc]]--; &#125; getans(rt,0); printf("%lld\n",res); &#125; return 0;&#125; H Rikka with A Long Colour Palette 题目描述数轴上有$n$条线段，对每条线段染色$[1,k]$，问最多有多少个区间包含了所有颜色，并输出染色方案。 解题思路贪心地维护一个未染色集合和待定染色集合即可。 将线段分为左端点右端点两种，如果当前到达左端点，未染色集合如果空那么将这个线段加入待定染色集合，否则拿出未染色集合任意一个元素进行染色；如果当前是右端点， 将颜色加回未染色集合，从待定集合中依次拿出线段，如果线段右端点比当前右端点还小，说明可以任意染色，否则拿出未染色集合进行染色。不必要用集合，用一个队列即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 200010queue&lt;int&gt;S,col;int tot;struct Point&#123; int sign,id,x; bool operator&lt;(const Point&amp;a)const&#123; return x&lt;a.x||(x==a.x&amp;&amp;(sign&gt;a.sign||sign==a.sign&amp;&amp;x&lt;a.x)); &#125;&#125;p[N&lt;&lt;1];int c[N];int main()&#123; int i,T,n,k,l,r; scanf("%d",&amp;T); while(T--)&#123; ll ans=0; while(!S.empty())S.pop(); while(!col.empty())col.pop(); memset(c,0,sizeof(c)); scanf("%d%d",&amp;n,&amp;k); tot=0; for(i=1;i&lt;=n;i++) scanf("%d%d",&amp;l,&amp;r), p[++tot]=(Point)&#123;1,i,l&#125;,p[++tot]=(Point)&#123;-1,i,r&#125;; sort(p+1,p+1+tot); for(i=1;i&lt;=k;i++)col.push(i); for(i=1;i&lt;=tot;i++)&#123; if(col.empty())ans+=p[i].x-p[i-1].x; if(p[i].sign==1)&#123; if(col.empty())S.push(p[i].id); else&#123; c[p[i].id]=col.front(); col.pop(); &#125; &#125;else&#123; if(c[p[i].id])col.push(c[p[i].id]); else c[p[i].id]=1; while(!col.empty()&amp;&amp;!S.empty())&#123; int now=S.front();S.pop(); int cl=col.front(); if(c[now])continue; c[now]=cl; col.pop(); &#125; &#125; &#125; printf("%lld\n",ans); for(i=1;i&lt;=n;i++)printf("%d%c",c[i],i==n?'\n':' '); &#125; return 0;&#125; I Rikka with Sorting Networks 题目描述对于一个长度为$n$（$n&lt;=50$）的数列，尝试最多$10$次指定的比较（比较某$2$个指定的位置），如果比较的结果是”$&gt;$”，就交换着两个位置的权值。 问有多少$1-n$的排列，满足经过这个处理后，会形成一个”最长上升子序列长度是$n-1$”的序列。 解题思路由于$almost\space sorted\space array$只有$(n-1)^2+1$种（枚举每一个长度为$n-1$的数列，有$n-1$个空可以插，再加一种$1-n$的排列），故可以枚举这个东西回推。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int mod;vector&lt;int&gt;v;set&lt;vector&lt;int&gt;&gt;S;struct Query&#123; int u,v;&#125;q[52];int ans;void dfs(int d)&#123; if(!d)&#123;ans++;return;&#125; if(v[q[d].u]&lt;v[q[d].v])&#123; swap(v[q[d].u],v[q[d].v]);dfs(d-1); swap(v[q[d].u],v[q[d].v]);dfs(d-1); &#125;&#125;int main()&#123; int i,j,l,T; scanf("%d",&amp;T); while(T--)&#123; int n,k; S.clear();v.clear(); ans=0; scanf("%d%d%d",&amp;n,&amp;k,&amp;mod); for(i=1;i&lt;=k;i++)scanf("%d%d",&amp;q[i].u,&amp;q[i].v),q[i].u--,q[i].v--; for(i=1;i&lt;=n;i++)v.push_back(i); S.insert(v);dfs(k); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=n;j++)&#123; int now=0; v.clear(); for(l=1;l&lt;j;l++)&#123; if(++now==i)now++; v.push_back(now); &#125; v.push_back(i); for(l=j+1;l&lt;=n;l++)&#123; if(++now==i)now++; v.push_back(now); &#125; if(S.find(v)==S.end())&#123; S.insert(v); //for(auto m:v)printf("%d ",m); dfs(k); //puts(""); &#125; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; J Rikka with An Unnamed Temple 题目描述解题思路AC代码点击 12 K Rikka with Ants 题目描述有一个环，每个边有边权。两只蚂蚁，一只要从$u_0$走到$v_0$，另一只要从$u_1$走到$v_1$，如果两只蚂蚁都经过某个边，这边的边权变为三倍。边权总和越小越好，问两只蚂蚁都采取最优策略的情况下，走过的权值和期望。 解题思路先计算出蚂蚁分别顺时针、逆时针走的路程，判断出必然利己的决策。 然后假设蚂蚁$0$走逆时针的概率为$p_1$，蚂蚁$1$走逆时针的概率为$p_2$。那么能求出蚂蚁$0$的期望$E_0$，用$p_1,p_2$表示。假设$E_0=c+x\times p_1+y\times p_2+z\times p_1p_2$，现在要求$p_1,p_2$。 采取最利己策略，令$p_2=0,p_2=1$的期望相等，求出$p_1=-\frac yz$，同理根据$E_1$求出$p_2$； 采取使对方不存在纯策略，最优策略是概率分布：$p_2=-\frac xz$，同理根据$E_0$求出$p_1$。 这两种情况求出的$p_1,p_2$不相同，但期望总是相同的。很玄学，但都能过。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int u[2],v[2],a[52],ans[2][2][2];int state[52],n;void calc(int f1,int t1,int f2,int t2,int* ans)&#123; int i,d1=0,d2=0; memset(state,0,sizeof(state)); for(i=f1;i!=t1;i=(i+1)%n)state[i]+=1; for(i=f2;i!=t2;i=(i+1)%n)state[i]+=2; for(i=0;i&lt;n;i++)&#123; if(state[i]==1)d1+=a[i]; else if(state[i]==2)d2+=a[i]; else if(state[i])d1+=a[i]*3,d2+=a[i]*3; &#125; ans[0]=d1;ans[1]=d2;&#125;int main()&#123; int i,T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); scanf("%d%d%d%d",&amp;u[0],&amp;v[0],&amp;u[1],&amp;v[1]); u[0]--;u[1]--;v[0]--;v[1]--; calc(u[0],v[0],u[1],v[1],ans[0][0]); calc(u[0],v[0],v[1],u[1],ans[0][1]); calc(v[0],u[0],u[1],v[1],ans[1][0]); calc(v[0],u[0],v[1],u[1],ans[1][1]); if(ans[0][0][1]&lt;=ans[0][1][1]&amp;&amp;ans[1][0][1]&lt;=ans[1][1][1])&#123;//0怎么选 1选0都是优的 if(ans[1][0][0]&lt;=ans[0][0][0])printf("%d %d\n",ans[1][0][0],ans[1][0][1]); else printf("%d %d\n",ans[0][0][0],ans[0][0][1]); &#125;else if(ans[0][0][1]&gt;=ans[0][1][1]&amp;&amp;ans[1][0][1]&gt;=ans[1][1][1])&#123;//0怎么选 1选1都是优的 if(ans[1][1][0]&lt;=ans[0][1][0])printf("%d %d\n",ans[1][1][0],ans[1][1][1]); else printf("%d %d\n",ans[0][1][0],ans[0][1][1]); &#125;else if(ans[0][0][0]&lt;=ans[1][0][0]&amp;&amp;ans[0][1][0]&lt;=ans[1][1][0])&#123;//1怎么选 0选0都是优的 if(ans[0][1][1]&lt;=ans[0][0][1])printf("%d %d\n",ans[0][1][0],ans[0][1][1]); else printf("%d %d\n",ans[0][0][0],ans[0][0][1]); &#125;else if(ans[0][0][0]&gt;=ans[1][0][0]&amp;&amp;ans[0][1][0]&gt;=ans[1][1][0])&#123;//1怎么选 0选1都是优的 if(ans[1][1][1]&lt;=ans[1][0][1])printf("%d %d\n",ans[1][1][0],ans[1][1][1]); else printf("%d %d\n",ans[1][0][0],ans[1][0][1]); &#125;else&#123; double p1,p2; int c[2],x[2],y[2],z[2]; c[0]=ans[0][0][0]; x[0]=-ans[0][0][0]+ans[1][0][0]; y[0]=-ans[0][0][0]+ans[0][1][0]; z[0]=ans[0][0][0]+ans[1][1][0]-ans[0][1][0]-ans[1][0][0]; c[1]=ans[0][0][1]; x[1]=-ans[0][0][1]+ans[1][0][1]; y[1]=-ans[0][0][1]+ans[0][1][1]; z[1]=ans[0][0][1]+ans[1][1][1]-ans[0][1][1]-ans[1][0][1]; p1=-1.0*y[0]/z[0];//改变的p1 p2=-1.0*x[1]/z[1];//改变的p2 /*p2=-1.0*x[0]/z[0];//改变的p1 p1=-1.0*y[1]/z[1];//改变的p2*/ //printf("%f %f\n",p1,p2); printf("%.12f ",c[0]+x[0]*p1+y[0]*p2+z[0]*p1*p2); printf("%.12f\n",c[1]+x[1]*p1+y[1]*p2+z[1]*p1*p2); &#125; &#125; return 0;&#125; L Rikka with Grid Graphs 题目描述解题思路AC代码点击 12 M Rikka with Illuminations 题目描述给一个凸包，外面有多个点光源，问最少使用多少个点光源才能照亮所有边。保证不存在三点共线。 解题思路暴力枚举起点，贪心求解即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1010struct Point&#123; int x,y;&#125;p[N],t[N];Point operator-(Point a,Point b)&#123; return (Point)&#123;a.x-b.x,a.y-b.y&#125;;&#125;ll cross(Point a,Point b)&#123;return 1LL*a.x*b.y-1LL*a.y*b.x;&#125;int id[N],ext[N];int main()&#123; int i,j,T,n,m; scanf("%d",&amp;T); while(T--)&#123; memset(ext,0,sizeof(ext)); memset(id,0,sizeof(id)); scanf("%d%d",&amp;n,&amp;m); int ans=n+1,start=0,flag=0; for(i=0;i&lt;n;i++)scanf("%d%d",&amp;p[i].x,&amp;p[i].y); for(i=0;i&lt;m;i++)scanf("%d%d",&amp;t[i].x,&amp;t[i].y); for(i=0;i&lt;m;i++)&#123; int l=0,r=0; for(j=1;j&lt;n;j++)&#123; if(cross(p[j]-t[i],p[l]-t[i])&lt;0)l=j; if(cross(p[j]-t[i],p[r]-t[i])&gt;0)r=j; &#125; for(j=l;j!=r;j=(j+1)%n)&#123; j%=n; if(ext[j]&lt;(r-j+n)%n)ext[j]=(r-j+n)%n,id[j]=i; &#125; &#125; for(i=0;i&lt;n;i++)if(ext[i]&lt;1)flag=1; if(flag)&#123; printf("-1\n"); continue; &#125; for(i=0;i&lt;n;i++)&#123; j=i;int cnt=0; while(j&lt;(i+n)) j+=ext[j%n],cnt++; if(ans&gt;cnt)ans=cnt,start=i; &#125; printf("%d\n",ans); while(ans--)printf("%d%c",id[start]+1,!ans?'\n':' '),(start+=ext[start])%=n; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 ICPC南京赛区网络赛 题解]]></title>
    <url>%2F2019%2F09%2F02%2F2019icpcnanjinginternet%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I 9/9 O O Ø Ø Ø O Ø O Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A The beautiful values of the palace 题目描述按照从外到内螺旋构造出$n \times n$的矩阵$M$，给定$m$个点是需要被考虑的，其他元素不予考虑，$p$次询问，每次询问一个区间代表问这个区间所有元素的数位和的和是多少。$n\leq 10^6;m,p\leq 10^5$。 解题思路首先可以$O(1)$地求出每一个点上的数值是多少，再将每个询问利用容斥分解为四块，用一个树状数组维护一下就行了。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010int bit[N];int n,m,p;ll cal(int a, int b)&#123; a--;b--; int ra = max(max(a, n - a + 1), max(b, n - b + 1)); int la = n - ra + 1; ll res = 4ll * n*(la - 1) - 4ll * (la - 1)*(la - 1); if (a == ra) &#123; return res + ra - b + 1; &#125; if (b == ra) &#123; return 4ll * n*(la)-4ll * (la)*(la)-(ra - a) + 1; &#125; if (b == la) &#123; return res + (ra - a) + n - 2 * (la - 1); &#125; return res + b - la + 2 * n - 4 * (la - 1) - 1;&#125;int calc(int x,int y)&#123; ll tmp=cal(x,y); int now=0; while(tmp)&#123; now+=tmp%10; tmp/=10; &#125; return now;&#125;struct Point&#123; int id,sign,x,y; bool operator&lt;(const Point&amp;p)const&#123; return x&lt;p.x||x==p.x&amp;&amp;y&lt;p.y; &#125;&#125;P[N&lt;&lt;2];pair&lt;int,int&gt;poi[N];int res[N],tot;void add(int ind)&#123; int i,x=poi[ind].first,y=poi[ind].second,temp=calc(x,y); for(i=y;i&lt;N;i+=i&amp;(-i))bit[i]+=temp;&#125;int query(int y)&#123; int i,ans=0; for(i=y;i;i-=i&amp;(-i))ans+=bit[i]; return ans;&#125;int main()&#123; int i,t; scanf("%d",&amp;t); while(t--)&#123; tot=0; memset(res,0,sizeof(res)); memset(bit,0,sizeof(bit));//bitclear scanf("%d%d%d",&amp;n,&amp;m,&amp;p); for(i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;poi[i].first,&amp;poi[i].second); poi[i].first++;poi[i].second++; &#125; sort(poi,poi+m); for(i=0;i&lt;p;i++)&#123; int x1,x2,y1,y2; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); x1++;y1++;x2++;y2++; P[++tot]=&#123;i,1,x1-1,y1-1&#125;; P[++tot]=&#123;i,-1,x1-1,y2&#125;; P[++tot]=&#123;i,1,x2,y2&#125;; P[++tot]=&#123;i,-1,x2,y1-1&#125;; &#125; sort(P+1,P+tot+1); int j=0; for(i=1;i&lt;=tot;i++)&#123; while(j&lt;m&amp;&amp;poi[j]&lt;=make_pair(P[i].x,P[i].y)) add(j),j++; res[P[i].id]+=P[i].sign*query(P[i].y); &#125; for(i=0;i&lt;p;i++)printf("%d\n",res[i]); &#125; return 0;&#125; B super_log 题目描述求$a^{a^{a^{.^{.^{.}}}}}(b层)\space mod\space m$的值 解题思路欧拉降幂，$a,m$互质或$b&lt;\phi(m)$的时候$a^b\space mod\space m=a^{b\space mod\space \phi(m)}\space mod\space m$，$b\geq \phi(m)$时$a^b\space mod\space m=a^{b\space mod\space \phi(m)+\phi(m)}\space mod\space m$，用$double$估计一下到当前位置的$b$的大小区分这两种情况即可。另外欧拉函数会在迭代几次之后就变为$1$，可以特判一下剪枝，否则会$T$。 AC代码 - by qxforever &amp; Potassium点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e7+23;int phi[maxn],prime[maxn],cnt;bool mark[maxn];int T,a,b,m;int md[maxn];int qpow(int a,int b,int mod)&#123; int ans=1,base=a; while(b)&#123; if(b&amp;1) ans=(1ll*ans*base)%mod; base=(1ll*base*base)%mod; b&gt;&gt;=1; &#125; return ans%mod;&#125;void getphi()&#123; phi[1]=1;cnt=0; for(int i=2;i&lt;maxn;i++)&#123; if(!mark[i])&#123; prime[cnt++]=i; phi[i]=i-1; &#125; for(int j=0;j&lt;cnt;j++)&#123; if(1LL*i*prime[j]&gt;=maxn) break; mark[i*prime[j]]=1; if(i%prime[j]==0)&#123; phi[i*prime[j]]=phi[i]*prime[j];break; &#125; else phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125;&#125;int main()&#123; getphi(); cin &gt;&gt;T; while(T--)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;m); if(b==0) &#123;printf("%d\n",1%m);continue;&#125; md[0]=m; for(int i=1;i&lt;=b;i++)&#123; md[i]=phi[md[i-1]]; if(md[i]==1)&#123; b=i; break; &#125; &#125; int ans=a,flag=0; double now=a; for(int i=b-1;i&gt;=1;i--)&#123; if(now&gt;1e7)flag=1; if(now&gt;=md[i]||flag)ans=qpow(a,ans%md[i]+md[i],md[i-1]); else ans=qpow(a,ans,md[i-1]); now=pow(a,now); &#125; printf("%d\n",ans%m); &#125;&#125; C Tsy’s number 5 题目描述给定$n\leq 10^5$，求$\sum_{i=1}^{n}\sum_{j=1}^{n}\phi(i)\phi(j)2^{\phi(i)\phi(j)}$。 解题思路首先$\phi$函数出现在指数上很难处理，考虑枚举$\phi(i)$和$\phi(j)$。于是不妨设$f[x]$表示$\phi(i)=x$的$i$的个数，然后化一下式子： $\sum_{i=1}^{n}\sum_{j=1}^{n}\phi(i)\phi(j)2^{\phi(i)\phi(j)}$ $=\sum_{i=1}^{n}\sum_{j=1}^{n}ijf[i]f[j]2^{ij}$ 两个常见套路：将上界变为$i$，$2^{ij}=2^{\frac{-(i-j)^2+i^2+j^2}2}$ $=\sum_{i=1}^{n}\sum_{j=1}^{n}if[i]2^{\frac{i^2}2}\cdot jf[j]2^{\frac{j^2}2}\cdot 2^{\frac{-(i-j)^2}2}$ $=2\sum_{i=1}^{n}if[i]2^{\frac{i^2}2}\sum_{j=1}^{i}jf[j]2^{\frac{j^2}2}\cdot 2^{\frac{-(i-j)^2}2}-\sum_{i=1}^{n}i^2f[i]^22^{i^2}$ 设$C[i]=\sum_{j=1}^{i}jf[j]2^{\frac{j^2}2}\cdot 2^{\frac{-(i-j)^2}2}$，很显然这是一个卷积的形式，可以通过$NTT$或者拆系数$FFT$来做，预处理一下$2^{\frac 12}\space mod\space 998244353$的值（二次剩余）以及它的$i^2$次幂即可。 代码中注释掉的部分替换掉拆系数$FFT$就是$NTT$，不过似乎比拆系数要慢一些（$200ms$）。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define M 262144int qp(ll a,int p,int mod)&#123; ll ans=1; for(;p;p&gt;&gt;=1,a=a*a%mod)if(p&amp;1)ans=ans*a%mod; return ans;&#125;/*const int G=3;int R[M+5],mod,lim,mx;int A[M+5],B[M+5],C[M+5];void NTT(int* a,int f)&#123; int i,j,k; for(i=0;i&lt;lim;i++)if(i&lt;R[i])swap(a[i],a[R[i]]); for(i=1;i&lt;lim;i&lt;&lt;=1)&#123; int gn=qp(G,(mod-1)/(i&lt;&lt;1),mod); for(j=0;j&lt;lim;j+=(i&lt;&lt;1))&#123; int g=1; for(k=0;k&lt;i;k++,g=1ll*g*gn%mod)&#123; int x=a[j+k],y=1ll*g*a[j+k+i]%mod; a[j+k]=(x+y)%mod;a[j+k+i]=(x-y+mod)%mod; &#125; &#125; &#125; if(f==1)return; int nv=qp(lim,mod-2,mod);reverse(a+1,a+lim); for(i=0;i&lt;lim;i++)a[i]=1ll*a[i]*nv%mod;&#125;void fft_prepare()&#123; int i; for(i=0;i&lt;lim;i++)R[i]=R[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(mx-1));&#125;void conv(int *x,int *y,int *z)&#123; NTT(x,1);NTT(y,1); for(int i=0;i&lt;lim;i++)z[i]=1LL*x[i]*y[i]%mod; NTT(z,-1);&#125;*/struct comp&#123; double x,y; comp():x(0),y(0)&#123;&#125; comp(const double &amp;_x,const double &amp;_y):x(_x),y(_y)&#123;&#125;&#125;;comp operator+(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x+b.x,a.y+b.y);&#125;comp operator-(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x-b.x,a.y-b.y);&#125;comp operator*(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;comp conj(const comp &amp;a)&#123;return comp(a.x,-a.y);&#125;double PI=acos(-1);comp w[M+5];int rev[M+5];int A[M+5],B[M+5],C[M+5],lim,mx,mod=998244353;void fft(comp *a,int n)&#123; int i,j,k,lyc; for(i=0;i&lt;n;i++)if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(i=2,lyc=n&gt;&gt;1;i&lt;=n;i&lt;&lt;=1,lyc&gt;&gt;=1) for(j=0;j&lt;n;j+=i)&#123; comp *l=a+j,*r=a+j+(i&gt;&gt;1),*p=w; for(k=0;k&lt;(i&gt;&gt;1);k++)&#123; comp tmp=*r**p; *r=*l-tmp,*l=*l+tmp; ++l,++r,p+=lyc; &#125; &#125;&#125;void fft_prepare()&#123; int i; for(i=0;i&lt;lim;i++)rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(mx-1)); for(i=0;i&lt;lim;i++)w[i]=comp(cos(2*PI*i/lim),sin(2*PI*i/lim));&#125;comp a[M+5],b[M+5],ta[M+5],tb[M+5];void conv(int *x,int *y,int *z)&#123;//from x,y to z int i,j; //for(i=0;i&lt;lim;i++)(x[i]+=mod)%=mod,(y[i]+=mod)%=mod; for(i=0;i&lt;lim;i++)&#123; ta[i]=comp(x[i]&amp;32767,x[i]&gt;&gt;15); tb[i]=comp(y[i]&amp;32767,y[i]&gt;&gt;15); &#125; fft(ta,lim);fft(tb,lim); for(i=0;i&lt;lim;i++)&#123; j=(lim-i)%lim; comp da,db,dc,dd; da=(ta[i]+conj(ta[j]))*comp(0.5,0); db=(ta[i]-conj(ta[j]))*comp(0,-0.5); dc=(tb[i]+conj(tb[j]))*comp(0.5,0); dd=(tb[i]-conj(tb[j]))*comp(0,-0.5); a[j]=da*dc+da*dd*comp(0,1); b[j]=db*dc+db*dd*comp(0,1); &#125; fft(a,lim);fft(b,lim); for(i=0;i&lt;lim;i++)&#123; ll da,db,dc,dd; da=(ll)(a[i].x/lim+0.5)%mod; db=(ll)(a[i].y/lim+0.5)%mod; dc=(ll)(b[i].x/lim+0.5)%mod; dd=(ll)(b[i].y/lim+0.5)%mod; z[i]=((da+((db+dc)&lt;&lt;15)+(dd&lt;&lt;30))%mod+mod)%mod; &#125;&#125;int f[M+5];int phi[M+5],np[M+5],pri[M+5],tot;void sieve()&#123; phi[1]=1; int i,j;np[0]=np[1]=1; for(i=2;i&lt;M;i++)&#123; if(!np[i])pri[tot++]=i,phi[i]=i-1; for(j=0;j&lt;tot;j++)&#123; if(pri[j]*i&gt;=M)break; np[i*pri[j]]=1; if(i%pri[j]==0)&#123; phi[i*pri[j]]=phi[i]*pri[j]; break; &#125;else phi[i*pri[j]]=phi[i]*phi[pri[j]]; &#125; &#125;&#125;int sqrt2=116195171;//2的二次剩余int ini[M],ini2[M];//sqrt2^&#123;i^2&#125;,invvoid calc(int x)&#123; static int AA[M+5]; int i; memset(f,0,sizeof(f)); for(i=1;i&lt;=x;i++)f[phi[i]]++; /*ll tmp=0; for(int i=1;i&lt;=x;i++) for(int j=1;j&lt;=x;j++) (tmp+=1LL*phi[i]*phi[j]%mod*qp(2,phi[i]*phi[j]%(mod-1),mod)%mod)%=mod; printf("%lld\n",tmp);*/ int tmp; mx=0;for(tmp=1;tmp&lt;=2*x+2;tmp&lt;&lt;=1)mx++; lim=tmp; for(i=0;i&lt;=x;i++)AA[i]=A[i]=1LL*i*f[i]%mod*ini[i]%mod; for(;i&lt;=lim;i++)AA[i]=A[i]=0; for(i=0;i&lt;=x;i++)B[i]=ini2[i]; for(;i&lt;=lim;i++)B[i]=0; fft_prepare(); conv(AA,B,C);//0-index ll res=0; for(i=1;i&lt;=x;i++)(res+=1LL*A[i]*C[i]%mod*2%mod-1LL*i*i%mod*f[i]%mod*f[i]%mod*ini[i]%mod*ini[i]%mod+mod)%=mod; printf("%lld\n",res);&#125;void init()&#123; int i; for(i=0;i&lt;M;i++)ini[i]=qp(sqrt2,1LL*i*i%(mod-1),mod),ini2[i]=qp(ini[i],mod-2,mod);&#125;int main()&#123; int t,n; sieve(); init(); scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); calc(n); &#125; return 0;&#125; D Robots 题目描述给定一个有向无环图，机器人从$1$开始走，每天等概率走向当前节点的后继或留在原地，第$i$天消耗代价为$i$，问到$n$点的代价之和的期望。 解题思路设$f[i][j]$表示$j$时刻，机器人在$i$点的概率，那么显然有$q_i=\sum_{j=0}^{\infty} \times j\times (j+1)\times f[i][j]$，$\frac{q_n}2$即为所求。 设$a_i=\frac 1{oud[i]+1}$，记$u$为$i$前驱为$u\rightarrow i$，对于不为$n$的点$i$，有转移$f[i][j]=a_if[i][j-1]+\sum_{u\rightarrow i}a_uf[u][j-1]$，对于点$n$，有$f[i][j]=\sum_{u\rightarrow i}a_uf[u][j-1]$。 以不为$n$的点为例： $q_i=\sum_{j=0}^{\infty}j(j+1)f[i][j]=\sum_{j=1}^{\infty}j(j+1)(a_if[i][j-1]+\sum_{u\rightarrow i}a_uf[u][j-1])$ $=\sum_{j=0}^{\infty}(j+1)(j+2)a_if[i][j]+\sum_{u\rightarrow i}\sum_{j=0}^{\infty}(j+1)(j+2)a_uf[u][j]$ $=\sum_{j=0}^{\infty}j(j+1)a_if[i][j]+\sum_{u\rightarrow i}\sum_{j=0}^{\infty}j(j+1)a_uf[u][j]+\sum_{j=0}^{\infty}(2j+2)(a_if[i][j]+\sum_{u\rightarrow i}a_uf[u][j])$ $=a_iq_i+\sum_{u\rightarrow i}a_uq_u+2a_it_i+2a_is_i+\sum_{u\rightarrow i}2a_ut_u+2a_us_u$ 其中$t,s$为类似$q$定义的数组，$t_i=\sum_{j=0}^{\infty}jf[i][j],s_i=\sum_{j=0}^{\infty}f[i][j]$，可以类似$q$地推出式子。我们发现这是一个按拓扑序$dp$的问题，每次更新一下即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010double a[N],p[N],t[N],s[N];int ind[N],oud[N];struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int hd[N],cnt;void add(int a,int b)&#123;e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;queue&lt;int&gt;Q;int main()&#123; int i,T,n,m,u,v; scanf("%d",&amp;T); while(T--)&#123; cnt=0; memset(hd,0,sizeof(hd)); memset(ind,0,sizeof(ind)); memset(oud,0,sizeof(oud)); scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); add(u,v); oud[u]++;ind[v]++; &#125; for(i=1;i&lt;=n;i++)&#123; p[i]=s[i]=t[i]=0; a[i]=1.0/(oud[i]+1); &#125; Q.push(1); p[1]=-2*a[1]/pow(a[1]-1,3); t[1]=a[1]/pow(a[1]-1,2); s[1]=1/(1-a[1]); while(!Q.empty())&#123; int now=Q.front();Q.pop(); for(i=hd[now];i;i=e[i].n)&#123; int q=e[i].e; if(!--ind[q])Q.push(q); if(q==n)&#123; s[q]+=a[now]*s[now]; t[q]+=a[now]*(s[now]+t[now]); p[q]+=a[now]*(p[now]+2*t[now]+2*s[now]); &#125;else&#123; double deltaS=a[now]*s[now]/(1-a[q]); double deltaT=a[now]*(s[now]+t[now])/(1-a[q])+deltaS*a[q]/(1-a[q]); double deltaP=a[now]*(p[now]+2*t[now]+2*s[now])/(1-a[q]); deltaP+=a[q]*(2*deltaS+2*deltaT)/(1-a[q]); s[q]+=deltaS; t[q]+=deltaT; p[q]+=deltaP; &#125; &#125; &#125; printf("%.2f\n",p[n]/2); &#125; return 0;&#125; 还有一种更简便也更巧妙的做法： 设$t[i]$表示到点$i$的时间期望，有$t[i]=(a_i(t[i]+1)+a_i\sum_{i\rightarrow u}(t[u]+1))$（$u$是$i$的后继，从后向前递推） 再设$e[i]$表示到点$i$的花费的期望，有$e[i]=(a_i(e[i]+0)+a_i\sum_{i\rightarrow u}(e[u]+t[u]))$。 如何理解这两个式子？ 你知道时间的期望了 那转移的时候的cost就是每个点的时间的期望 第一个式子转移的cost相当于1 ——qxforever 没了。 AC代码 - by qxforever点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;//typedef long long ll;int T,n,m,u,v;const int maxn = 1e5+23;vector&lt;int&gt; g[maxn];double dp[maxn],f[maxn];int vis[maxn],out[maxn];void dfs(int now)&#123; vis[now]=1; if(now==n) return; for(auto i:g[now])&#123; if(!vis[i])&#123; dfs(i); &#125; dp[now]+=dp[i]; f[now]+=f[i]+dp[i]; &#125; int deg=g[now].size(); double d=1.0/(1.0+deg); dp[now]=(d*(dp[now])+1)/(1-d); f[now]=(d*(f[now]+dp[now])+1)/(1-d);&#125;int main()&#123; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; dp[i]=f[i]=0; g[i].resize(0); vis[i]=0; &#125; for(int i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); //out[v]++; g[u].push_back(v); &#125; dfs(1); //for(int i=1;i&lt;=n;i++) printf("%.2f ",dp[i]); printf("%.2f\n",f[1]); &#125;&#125; E K Sum 题目描述给定$1\leq n\leq 10^9,2\leq k\leq 10^{10^5}$，求$\sum_{i=2}^{k}f_n(i)$，其中$f_n(i)=\sum_{l_1=1}^{n}\sum_{l_2=1}^{n}…\sum_{l_i=1}^{n}(gcd(l_1,l_2,…,l_i))^2$。 解题思路一个套路，先枚举$gcd$： $f_n(i)=\sum_{g=1}^{n}\sum_{l_1=1}^{n}\sum_{l_2=1}^{n}…\sum_{l_i=1}^{n}g^2[gcd(l_1,l_2,…,l_n)=g]$ $=\sum_{g=1}^{n}\sum_{l_1=1}^{\lfloor\frac ng\rfloor}\sum_{l_2=1}^{\lfloor\frac ng\rfloor}…\sum_{l_i=1}^{\lfloor\frac ng\rfloor}g^2[gcd(l_1,l_2,…,l_n)=1]$ 对于$p(x)=\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=x]$，有 $q(d)=\sum_{d|x}p(x)$ $=\sum_{i=1}^{n}\sum_{j=1}^{m}[d|gcd(i,j)]$ $=\sum_{i=1}^{n}\sum_{j=1}^{m}[d|i][d|j]$ $=\lfloor\frac nd\rfloor\lfloor\frac md\rfloor$ 莫比乌斯反演可得$p(x)=\sum_{x|d}\mu(\frac dx)q(d)=\sum_{x|d}\mu(\frac dx)\lfloor\frac nd\rfloor\lfloor\frac md\rfloor$ 同理，对于$f_n(i)$，类似的可以得出 $f_n(i)=\sum_{g=1}^{n}g^2\sum_{1|d}\mu(d)\lfloor\frac{\frac ng}d\rfloor^i$ $=\sum_{g=1}^{n}g^2\sum_{d=1}^{\lfloor\frac ng\rfloor}\mu(d)\lfloor\frac n{gd}\rfloor^i$ 改变枚举对象为$l=gd$，范围为$1-n$，$g$只需满足$g|l$： $=\sum_{l=1}^{n}\lfloor\frac n{l}\rfloor^i\sum_{g|l}g^2\mu(\frac lg)$ 第一个求和号里是一个等比数列$G$，对于$k$可以欧拉降幂求解，于是我们如果能快速知道第二个求和号里的前缀和，就可以用数论分块快速求解。 观察到第二个求和号里是$idid\mu$的形式，卷上一个$I$之后就变成了$id*id$，这很容易求和，杜教筛筛一下即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 5000000int np[N+10],p[N+10],tot,n;ll q[N+10];int mod=1000000007;int qp(ll a,int p,int mod)&#123; ll ans=1; for(;p;p&gt;&gt;=1,a=a*a%mod)if(p&amp;1)ans=ans*a%mod; return ans;&#125;void sieve()&#123; q[1]=np[0]=np[1]=1; register int i,j; for(i=2;i&lt;N;i++)&#123; if(!np[i])p[tot++]=i,q[i]=(1ll*i*i-1)%mod; for(j=0;j&lt;tot;j++)&#123; if(p[j]*i&gt;=N)break; np[p[j]*i]=1; if(i%p[j]==0)&#123; q[i*p[j]]=1ll*q[i]*p[j]%mod*p[j]%mod; break; &#125;else q[i*p[j]]=q[i]*q[p[j]]%mod; &#125; &#125; for(i=1;i&lt;N;i++)(q[i]+=q[i-1])%=mod;&#125;unordered_map&lt;int,ll&gt;ansq;inline ll getsQ(ll n)&#123;//S=sum of f if(n&lt;N)return q[n]; if(ansq[n])return ansq[n]; ll ans=n*(n+1)%mod*(2*n%mod+1)%mod*qp(6,mod-2,mod)%mod;//sum of f*g register ll l,r; for(l=2;l&lt;=n;l=r+1)&#123; r=n/(n/l); (ans-=(r-l+1)*getsQ(n/l))%=mod;//sum of g(r-l),times S(n/l) &#125; return ansq[n]=(ans+mod)%mod;&#125;inline pair&lt;int,int&gt; read()&#123; register int x1=0,x2=0;register char c=getchar(); while(c&lt;'0'||c&gt;'9')c=getchar(); while(c&gt;='0'&amp;&amp;c&lt;='9')x1=(1LL*x1*10+c-48)%mod,x2=(1LL*x2*10+c-48)%(mod-1),c=getchar(); return make_pair(x1,x2);&#125;inline ll getsG(int x,int k,int pk)&#123; if(x==1)return (k-1+mod)%mod; return 1LL*x*x%mod*qp(x-1,mod-2,mod)%mod*(qp(x,pk-1,mod)+mod-1)%mod;&#125;int main()&#123; int t,l,r,n,k; sieve(); t=read().first; while(t--)&#123; ll res=0; n=read().first; pair&lt;int,int&gt;tmp=read(); k=tmp.first;int pk=tmp.second; for(l=1;l&lt;=n;l=r+1)&#123; r=n/((n/l)); ll t1=getsG(n/l,k,pk); ll t2=getsQ(r)-getsQ(l-1)+mod; (res+=t1*t2%mod)%=mod; &#125; printf("%lld\n",res); &#125; return 0;&#125; F Greedy Sequence 题目描述按要求造一个数列。 解题思路签到题，线段树动态加点查询区间最大值即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 200010int mx[N&lt;&lt;2],L[N&lt;&lt;2],R[N&lt;&lt;2];int pos[N],a[N];void build(int p,int l,int r)&#123; L[p]=l;R[p]=r;mx[p]=0; if(l==r)return; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r);&#125;int query(int p,int l,int r)&#123; if(L[p]&gt;=l&amp;&amp;r&gt;=R[p])return mx[p]; if(L[p]&gt;r||R[p]&lt;l)return 0; return max(query(p&lt;&lt;1,l,r),query(p&lt;&lt;1|1,l,r));&#125;void modify(int p,int pos,int x)&#123; if(L[p]&gt;pos||R[p]&lt;pos)return; if(L[p]==R[p])&#123; mx[p]=x; return; &#125; modify(p&lt;&lt;1,pos,x); modify(p&lt;&lt;1|1,pos,x); mx[p]=max(mx[p&lt;&lt;1],mx[p&lt;&lt;1|1]);&#125;int ans[N];int main()&#123; int i,t,n,k; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),pos[a[i]]=i; build(1,1,n); ans[0]=0; for(i=1;i&lt;=n;i++)&#123; ans[i]=ans[query(1,max(1,pos[i]-k),min(n,pos[i]+k))]+1; modify(1,pos[i],i); printf("%d%c",ans[i],i==n?'\n':' '); &#125; &#125; return 0;&#125; G Quadrilateral 题目描述给定$a,b,c,d$的范围，求有多少对$a,b,c,d$能构成一个四边形。 解题思路枚举$d$，先考虑$abc$的范围都能表示成$[1,x]$的情况，即$a\in[1,r_1],b\in[1,r_2],c\in[1,r_3]$ 这时，合法的四边形即为所有情况减去$x+y+z\leq w$形式的四元组个数。 当$d$为最大边时，可以表示成$[1,r_1]+[1,r_2]\leq [d-r_3,d-1]$；当$a$为最大边（$b,c$同理）时，可以表示成$[1,r_2]+[1,r_3]\leq [1-d,r_1-d]$。而这都可以转化为类似$[1,x_1]+[1,x_2]\leq [1,x_3]$的三元组个数容斥求解。 纵坐标表示和，横坐标表示$b$的取值，可以列出一张表，对这张表进行容斥即可求出$[1,x_1]+[1,x_2]\leq [1,x_3]$的个数。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int x[10];ll t(ll x)&#123; if(x&lt;0)return 0; return x*(x+1)/2*(x+2)/3;&#125;ll f(ll a,ll b,ll r)&#123; r--; a=min(a,r);b=min(b,r); return t(r)-t(r-a)-t(r-b)+t(r-a-b);&#125;ll calc(int d,int a,int b,int c)&#123; ll t=1LL*a*b*c; t-=f(a,b,d-1)-f(a,b,d-c-1)+f(b,c,a-d)+f(c,a,b-d)+f(a,b,c-d); return t;&#125;int main()&#123; int i,T; scanf("%d",&amp;T); while(T--)&#123; for(i=1;i&lt;=8;i++)scanf("%d",&amp;x[i]); ll res=0; for(i=x[7];i&lt;=x[8];i++)&#123; res+=calc(i,x[2],x[4],x[6]); res-=calc(i,x[2],x[4],x[5]-1); res-=calc(i,x[2],x[3]-1,x[6]); res+=calc(i,x[2],x[3]-1,x[5]-1); res-=calc(i,x[1]-1,x[4],x[6]); res+=calc(i,x[1]-1,x[4],x[5]-1); res+=calc(i,x[1]-1,x[3]-1,x[6]); res-=calc(i,x[1]-1,x[3]-1,x[5]-1); &#125; printf("%lld\n",res); &#125; return 0;&#125; H Holy Grail 题目描述给一个有向无负环的图，依次加六个边使得每次边加入后不能有负环且边权尽量小。 解题思路签到题，$floyd$即可水过，每次加边$O(n^2)$松弛。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 520ll dis[N][N];int main()&#123; int i,j,k,t,n,m; scanf("%d",&amp;t); while(t--)&#123; memset(dis,0x3f,sizeof(dis)); scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;=n;i++)dis[i][i]=0; for(i=0;i&lt;m;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); dis[u][v]=min(dis[u][v],(ll)w); &#125; for(k=0;k&lt;=n;k++) for(i=0;i&lt;=n;i++) for(j=0;j&lt;=n;j++) if(dis[i][j]&gt;dis[i][k]+dis[k][j]) dis[i][j]=dis[i][k]+dis[k][j]; for(k=0;k&lt;6;k++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); printf("%d\n",-dis[v][u]); dis[u][v]=min(dis[u][v],-dis[v][u]); for(i=0;i&lt;=n;i++) for(j=0;j&lt;=n;j++) if(dis[i][j]&gt;dis[i][u]+dis[u][v]+dis[v][j]) dis[i][j]=dis[i][u]+dis[u][v]+dis[v][j]; &#125; &#125; return 0;&#125; I Washing clothes 题目描述有$n$ 个人在不同时刻到达洗衣服的地点。每个人可以选择花费$y$时间手洗，也可选择花费$x$时间机洗，但洗衣机只有一台。对于每一个$x\in[1,y]$，求出最后一个洗完衣服的人最早在什么时候能够洗完衣服。 解题思路设$p=\frac yx$，于是倒数第$p+1$个人即使手洗也一定比后$p$个人全部依次机洗结束的早，于是只考虑后$p$个人的情况即可。 保证最后的几个人都不间断使用机洗必然是不劣的，于是对于倒数$p$个人中的每个人，算出从这个人开始一直不间断使用洗衣机的最大时间，再与倒数$p+1$个人的手洗时间取一个$max$即可。复杂度是调和级数$O(y\log y)$。 AC代码点击 123456789101112131415161718#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,y,t[1000010];int main()&#123; int i,j; while(~scanf("%d%d",&amp;n,&amp;y))&#123; for(i=1;i&lt;=n;i++)scanf("%d",&amp;t[i]); sort(t+1,t+n+1); for(i=1;i&lt;=y;i++)&#123; int p=min(n,y/i),res=0; if(p&lt;n)res=max(res,t[n-p]+y); for(j=n-p+1;j&lt;=n;j++)res=max(res,t[j]+(n-j+1)*i); printf("%d%c",res,i==y?'\n':' '); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Summer Training 11 题解]]></title>
    <url>%2F2019%2F08%2F30%2F2019summertraining-11%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K 10/11 O O O O O O O Ø O . Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 题目来源：2016-2017 ACM-ICPC, Asia Tsukuba Regional Contest 比赛链接 A Rearranging a Sequence 题目描述有个$1-n$的序列，每次把一个数扔到序列前，输出最终序列。 解题思路签到题。 AC代码点击 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int b[400010];int vis[200010];int main()&#123; int i,n,m,a; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)b[i+m]=i; for(i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;a); b[m-i+1]=a; &#125; for(i=1;i&lt;=n+m;i++)&#123; if(vis[b[i]]); else vis[b[i]]=1,printf("%d\n",b[i]); &#125; return 0;&#125; B Quality of Check Digits 题目描述给定一个$table$定义的$\times $运算，求有多少个五元组$(a,b,c,d,e)$不满足$(((a\times b)\times c)\times d\times e=0$且任意改变$a,b,c,d,e$的值或者交换相邻两个元素得到的值均非零。 解题思路暴力模拟一下即可。 AC代码 - by Mogg点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;algorithm&gt;#include&lt;iostream&gt; using namespace std;typedef long long ll;const int ms = 10 * 2;const int inf = 0x3f3f3f3f;int table[10][10];int f[10][10][10][10];int cal(int a, int b, int c, int d)&#123; a = table[0][a]; b = table[a][b]; c = table[b][c]; return table[c][d];&#125;int check2(int a, int b, int c, int d, int e)&#123; if (a != b &amp;&amp; table[cal(b, a, c, d)][e] == 0) return 1; if (b != c &amp;&amp; table[cal(a, c, b, d)][e] == 0) return 1; if (c != d &amp;&amp; table[cal(a, b, d, c)][e] == 0) return 1; if (d != e &amp;&amp; table[cal(a, b, c, e)][d] == 0) return 1; return 0;&#125;int check(int a, int b, int c, int d)&#123; if (check2(a, b, c, d, f[a][b][c][d])) return 1; for (int i = 0; i &lt; 10; ++i) &#123; if (i != a) &#123; if (table[cal(i, b, c, d)][f[a][b][c][d]] == 0) return 1; &#125; if (i != b) &#123; if (table[cal(a, i, c, d)][f[a][b][c][d]] == 0) return 1; &#125; if (i != c) &#123; if (table[cal(a, b, i, d)][f[a][b][c][d]] == 0) return 1; &#125; if (i != d) &#123; if (table[cal(a, b, c, i)][f[a][b][c][d]] == 0) return 1; &#125; if (i != f[a][b][c][d]) &#123; if (table[f[a][b][c][d]][i] == 0) return 1; &#125; &#125; return 0;&#125;int main()&#123; for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; 10; ++j) &#123; scanf("%d", &amp;table[i][j]); &#125; &#125; for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; 10; ++j) &#123; for (int k = 0; k &lt; 10; ++k) &#123; for (int l = 0; l &lt; 10; ++l) &#123; f[i][j][k][l] = cal(i, j, k, l); &#125; &#125; &#125; &#125; int res = 0; for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; 10; ++j) &#123; for (int k = 0; k &lt; 10; ++k) &#123; for (int l = 0; l &lt; 10; ++l) &#123; res += check(i, j, k, l); &#125; &#125; &#125; &#125; printf("%d\n", res); return 0;&#125; C Distribution Center 题目描述有$n$个轨道，某些道路的某些位置上有$m$个机器人，机器人可以将$i,i+1$之间的货物双向运输，问最右端每个轨道上的货物可以从多少个轨道上过来。 解题思路记录一下每个轨道分别从上面、下面运来的种类数更新答案即可。 AC代码 - by qxforever点击 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std; const int maxn = 2e5+23; int ans[maxn];int u[maxn],d[maxn]; struct P&#123; int x,y; bool operator &lt; (const P&amp;a) &#123; return x&lt;a.x; &#125;&#125;;int n,m;P a[maxn];int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;a[i].x,&amp;a[i].y); &#125; for(int i=1;i&lt;=n;i++) u[i]=d[i]=ans[i]=1; sort(a,a+m); for(int i=0;i&lt;m;i++)&#123; int t=a[i].y; ans[t]+=u[t+1]; ans[t+1]+=d[t]; u[t]+=u[t+1];u[t+1]=0; d[t+1]+=d[t];d[t]=0; &#125; for(int i=1;i&lt;=n;i++) printf("%d ",ans[i]);&#125; D Hidden Anagrams 题目描述问两个字符串中最长的同构串的长度。 解题思路给每个字母编号双$hash$，暴力枚举子集即可。复杂度$O(n^2\log n)$。 AC代码 - by qxforever &amp; Potassium点击 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char a[4010],b[4010];int la,lb;ll bas=929292929,mod=991145149;ll table[26]=&#123;73243,76343,78539,79669,80207,81031,81509,83219,86137,86341,87433,88993,89653,90271,90473,90731,90931,92243,93103,93493,93607,93979,95071,95239,95311,95917&#125;;ll table1[26]=&#123;73243,76343,78539,79669,80207,81031,81509,83219,86137,86341,87433,88993,89653,90271,90473,90731,90931,92243,93103,93493,93607,93979,95071,95239,95311,95917&#125;;int check(int x)&#123; int i; set&lt;ll&gt;S;S.clear(); set&lt;ll&gt; S1; ll hash1=0,hash2=0; ll hash11=0,hash22=0; for(i=0;i&lt;x;i++)(hash1+=table[a[i]-'a'])%=mod,(hash11+=table1[a[i]-'a'])%=mod; S.insert(hash1);S1.insert(hash11); for(i=0;i+x&lt;la;i++)&#123; hash1=(hash1+(table[a[i+x]-'a']-table[a[i]-'a'])+mod)%mod; hash11=(hash11+(table1[a[i+x]-'a']-table1[a[i]-'a'])+mod)%mod; S.insert(hash1);S1.insert(hash11); &#125; for(i=0;i&lt;x;i++)(hash2+=table[b[i]-'a'])%=mod,(hash22+=table1[b[i]-'a'])%=mod; for(i=0;i+x&lt;=lb;i++)&#123; if(S.find(hash2)!=S.end()&amp;&amp;S1.find(hash22)!=S1.end())return 1; hash2=(hash2+(table[b[i+x]-'a']-table[b[i]-'a'])+mod)%mod; hash22=(hash22+(table1[b[i+x]-'a']-table1[b[i]-'a'])+mod)%mod; &#125; return 0;&#125;int main()&#123; int i; scanf("%s%s",a,b); for(int i=0;i&lt;26;i++) table[i]*=(i*13+11),table1[i]*=(i*131+7); la=strlen(a),lb=strlen(b); for(i=min(la,lb);i&gt;=0;i--)if(check(i))break; printf("%d",i); return 0;&#125; E Infallibly Crack Perplexing Cryptarithm 题目描述给一串加密后的、原串只由$+-01()=*$构成的字符串，问有多少种安排方法使得原串是一个合法且正确的表达式。 解题思路爆搜，利用$python$库中的$eval$加一些特判解决问题。 AC代码 - by Mogg &amp; qxforever点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091l1 = ['+', '-', '*', '(']l2 = ['0','1']l3 = ['-', '(','0','1']def to2(ss): i = 1 while i &lt; len(ss): if ss[i-1] in l1 and ss[i] in l2: ss = ss[0:i] + "0b" + ss[i:] i+=2 i+=1 if(ss[0]=='1' or ss[0]=='0'): ss = "0b" + ss return ssdef check(ss): try: eval(ss) except (SyntaxError,TypeError): return False if(ss[0] == "+"): return False for i in range(1,len(ss)): if ss[i] in ["+","*"] and ss[i-1] in ["+","-","*"]: return False if ss[i] in ["+","-","*"] and (i+1==len(ss) or ss[i+1] not in l3): return False if ss[i] == "+" and ss[i-1] == "(": return False if ss[i] == '0': tmp = i while tmp&gt;=0 and ss[tmp] == '0': tmp -= 1 if (i-tmp &gt; 1) and (tmp&lt;0 or ss[tmp] != "1"): return False if ss[i]==")" and ss[i-1] == "(": return False return Truedef solve(ss): ss = ss.split("=") if (len(ss)!=2): return False if(not check(ss[0])): return False if(not check(ss[1])): return False ss[0] = to2(ss[0]) ss[1] = to2(ss[1]) return eval(ss[0]) == eval(ss[1]) l = ['0','1', '+', '-', '*', '(', ')', '=']d = []v = [False for i in range(len(l))] def dfs(ss,x): if(x==len(d)): if(solve(ss)): #print(ss) return 1 return 0 res = 0 for i in range(len(l)): if not v[i]: v[i] = True dd = [] for j in range(len(ss)): if(ss[j] == d[x]): ss =ss[0:j]+ l[i]+ss[j+1:] dd.append(j) res += dfs(ss,x+1) for j in dd: ss =ss[0:j]+ d[x]+ss[j+1:] v[i] = False return reswhile False: s = input() if(check(s)): print(to2(s)) print(eval(to2(s)))s = input() for i in s: if (i not in l) and (i not in d): d.append(i)res = 0if len(d) == 0: if(solve(s)): res+=1elif len(d) &lt;= 8: res = dfs(s,0)print(res) F Three Kingdoms of Bourdelot 题目描述有$n$个文件，每个文件中描述一堆形如$a_i$是$b_i$祖先的言论。对于每个文件，他可能是真的，也可能是假的，但是必定是全真或全假。 问有没有一种方式分配文件的真假，使得$p$是$q$的祖先。 解题思路对于每一对$a,b$，若$a$是$b$的祖先，那么所有提到“$a$是$b$的祖先”言论的文件都需要判断成真的。同时，对于$a$的每一个既有祖先$i$，$b$的每一个既有后辈$j$，都有$i$是$j$的祖先。 于是很容易想到$dfs$的方法去合并一对确定关系的$a,b$，用一个二维数组$f[i][j]$记录祖先关系。为了保证复杂度，在枚举$j$的时候，从未被$i$合并过的$j$集合中寻找。所以可以用$bitset$存这个二维数组，每次寻找$j$只需要从~f[i]&amp;f[b])中枚举。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;map&lt;string,int&gt;mp;int tot;vector&lt;pair&lt;int,int&gt;&gt;doc[1010];vector&lt;int&gt;id[1010][1010];string a,b;bitset&lt;1010&gt;f[1010],temp;int vis[100010],n;void merge(int fa,int son)&#123; for(auto i:id[fa][son])&#123; if(!vis[i])&#123; vis[i]=1; for(auto j:doc[i])if(!f[j.first][j.second])getf(j.first,j.second); &#125; &#125;&#125;void getf(int fa,int son)&#123; f[fa][son]=1; merge(fa,son); int i,j; for(i=1;i&lt;=tot;i++)&#123;//ancestor of fa if(!f[i][fa])continue; temp=(f[son])&amp;(~f[i]);//new added f[i]|=f[son]; for(j=1;j&lt;=tot;j++)&#123; if(!temp[j])continue; merge(i,j); &#125; &#125;&#125;int main()&#123; int i,j,m; cin&gt;&gt;a&gt;&gt;b; scanf("%d",&amp;n); if(mp.count(a)==0)mp[a]=++tot; if(mp.count(b)==0)mp[b]=++tot; int st=mp[a],ed=mp[b]; for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;m); for(j=0;j&lt;m;j++)&#123; cin&gt;&gt;a&gt;&gt;b; if(!mp.count(a))mp[a]=++tot; if(!mp.count(b))mp[b]=++tot; int ida=mp[a],idb=mp[b]; doc[i].push_back(make_pair(ida,idb)); id[ida][idb].push_back(i); &#125; &#125; for(i=1;i&lt;=tot;i++)f[i][i]=1; getf(st,ed); for(i=1;i&lt;=tot;i++) for(j=i+1;j&lt;=tot;j++) if(f[i][j]&amp;&amp;f[j][i])return printf("No"),0; printf("Yes"); return 0;&#125; G Placing Medals on a Binary Tree 题目描述依次存放$n$个物品，每个物品$i$有要求放在满二叉树的第$dep_i$层。放置完后，这个点到根的路径就不可以再放其他物品了，依次输出物品能否放置。 解题思路很容易看出来问题就是$1-\frac 1 {2^{dep_i}}-…$，要求这个和式不小于零。可以用二进制表示减去的部分，存一个$map$表示第$i$位的状态（$0$或$1$），当插入某个$dep$的时候，如果$dep$位前没有全满，或者全满了但这一个位置是最后一个（加上恰好总和为$1$）那么就可以插入。插入的时候模拟一下二进制进位即可，复杂度$O(n\log n)$。 AC代码点击 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;map&lt;int,int&gt;mp;int mn=1;int main()&#123; int i,n,x; mp[0]=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x); if(x&lt;mn-1||mp[0]==1||(mp.size()&amp;&amp;x==mn-1&amp;&amp;(*(--mp.end())).first&gt;x))printf("No\n"); else&#123; while(mp[x])mp.erase(x),x--; mp[x]++; while(mp.count(mn))mn++; printf("Yes\n"); &#125; &#125; return 0;&#125; H Animal Companion in Maze 题目描述给一个混合图，两点之间的边权为$1$，求最长路。 解题思路如果有环，那么答案显然为$infinite$，故可以先求一下强连通分量，在每个强连通分量里$dfs$找环特判掉这种情况。 显然，如果一个有向边在某个强连通分量里，那么这个强连通分量必然存在环。所以不存在环时必然有：每个强连通分量都是一棵树，树与树之间通过单向边连接。 于是考虑对强连通分量拓扑序$dp$，再对于每一个强连通分量进行树形$dp$，分两种情况从根节点向下走、从叶子节点向上走，设$dp[i]$表示到达$i$点的最大权值是多少。第一种情况很容易得到，$dp[son]=max(dp[fa]+1,dp[son])$；但当考虑第二种情况时，因为不能走回头路，需要判断一下每一个$dp$是从哪一个孩子节点过来的。所以保存一个到达$i$节点的最大权值、次大权值以及从最大权值是从哪里过来的即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010int n,m;struct Edge&#123; int e,n;&#125;e[N&lt;&lt;4];int hd[N],cnt;int sign[N&lt;&lt;4];void add(int a,int b,int s)&#123;e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;sign[cnt]=s;&#125;int sta[N],top,vis[N];int col[N],num,val[N];int dfn[N],low[N],tot;int root[N];//tree root in SCCvoid tarjan(int p)&#123; int i,q; low[p]=dfn[p]=++tot; sta[++top]=p;vis[p]=1; for(i=hd[p];i;i=e[i].n)&#123; q=e[i].e; if(!dfn[q])tarjan(q),low[p]=min(low[p],low[q]); else if(vis[q])low[p]=min(low[q],low[p]); &#125; if(dfn[p]==low[p])&#123; num++; while(sta[top+1]!=p)&#123; q=sta[top]; col[q]=num; vis[q]=0; val[num]++; top--; &#125; root[num]=p; &#125;&#125;struct E2&#123; int b,e,n;&#125;E[N&lt;&lt;2];int HD[N],CNT,indeg[N];//directed edge from different SCCsvoid add2(int a,int b)&#123;E[++CNT].e=b;E[CNT].b=a;E[CNT].n=HD[col[a]];HD[col[a]]=CNT;&#125;int scccircle(int p,int f)&#123;//同一个强连通分量中的环（不含双向边） int i; vis[p]=1; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(col[q]==col[p]&amp;&amp;(sign[i]==1||(sign[i]==2&amp;&amp;q!=f))&amp;&amp;(vis[q]||scccircle(q,p)))return 1; &#125; return 0;&#125;int find_circle()&#123; int i; for(i=1;i&lt;=n;i++)if(!vis[i]&amp;&amp;scccircle(i,-1))return 1; return 0;&#125;int dp[N][2];//到这个点的最大，次大int from[N];void dfs1(int p,int f)&#123; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q!=f&amp;&amp;col[p]==col[q])&#123; dfs1(q,p); if(dp[p][0]&lt;dp[q][0]+1)&#123; dp[p][1]=dp[p][0]; dp[p][0]=dp[q][0]+1; from[p]=q; &#125;else dp[p][1]=max(dp[p][1],dp[q][0]+1); &#125; &#125;&#125;void dfs2(int p,int f)&#123; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q!=f&amp;&amp;col[p]==col[q])&#123; if(q==from[p])&#123; if(dp[q][0]&lt;dp[p][1]+1)&#123; dp[q][1]=dp[q][0]; dp[q][0]=dp[p][1]+1; from[q]=p; &#125;else dp[q][1]=max(dp[q][1],dp[p][1]+1); &#125;else&#123; if(dp[q][0]&lt;dp[p][0]+1)&#123; dp[q][1]=dp[q][0]; dp[q][0]=dp[p][0]+1; from[q]=p; &#125;else dp[q][1]=max(dp[q][1],dp[p][0]+1); &#125; dfs2(q,p); &#125; &#125;&#125;queue&lt;int&gt;Q;int main()&#123; int i,j; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;m;i++)&#123; int a,b,w; scanf("%d%d%d",&amp;a,&amp;b,&amp;w); if(w==2)add(b,a,w); add(a,b,w); &#125; for(i=1;i&lt;=n;i++)if(!dfn[i])tarjan(i); if(find_circle())return printf("Infinite"),0; for(i=1;i&lt;=n;i++) for(j=hd[i];j;j=e[j].n) if(col[i]!=col[e[j].e]) add2(i,e[j].e),++indeg[col[e[j].e]]; for(i=1;i&lt;=num;i++)if(!indeg[i])Q.push(i); while(!Q.empty())&#123; int tp=Q.front();Q.pop(); dfs1(root[tp],0); dfs2(root[tp],0); for(i=HD[tp];i;i=E[i].n)&#123; int b=E[i].b,e=E[i].e; if(!--indeg[col[e]])Q.push(col[e]); dp[e][0]=max(dp[e][0],dp[b][0]+1); &#125; &#125; int res=0; for(i=1;i&lt;=n;i++)res=max(res,dp[i][0]); printf("%d",res); return 0;&#125; I Skinny Polygon 题目描述给定一个$1e9$范围内的$x,y$，求构造一个三角形或四边形满足： 所有点的横坐标至少包含一个$0$一个$x$ 所有点的纵坐标至少包含一个$0$一个$y$ 围成的面积小于$25000$ 解题思路在对角线上做文章。要么是一个凹四边形，要么是一个三角形。 分类讨论一下即可，假设$gcd(x,y)=g$，$xg=\frac xg,yg=\frac yg$。 求一下$(0,0)(x,y-1)(xg,yg)(x-1,y)$构成的凹四边形面积，显然是$\frac{xg+ yg}2$，故当这个面积小于$25000$的时候可以输出这个凹四边形。 再找到一点$(a,b)$满足$(0,0)(x,y)(a,b)$构成的三角形面积满足条件，也即$\frac{|bx-ay|}2\leq 25000$。而由于$xg+yg&gt;50000$，则$\frac{x+y}{g}&gt;50000,g&lt;\frac{2\times 10^{9}}{5\times 10^4}=40000&lt;50000$。对于$|b\times xg-a\times yg|=1$很容易用扩展欧几里得求出$a,b$，故$|bx-ay|=g\times |b\times xg-a\times yg|=g$有解。解出即可。 AC代码点击 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;void exgcd(int a,int b,int&amp;gcd,int&amp;x,int&amp;y)&#123; if(b==0)x=1,y=0,gcd=a; else&#123; exgcd(b,a%b,gcd,y,x); y-=x*(a/b); &#125;&#125;int main()&#123; int i,n,x,y; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;x,&amp;y); int a,b,d; exgcd(x,y,d,a,b); int xg=x/d,yg=y/d; if((xg+yg)&lt;=50000)printf("4\n%d %d\n0 0\n%d %d\n%d %d\n",x-1,y,x,y-1,xg,yg); else&#123; printf("3\n0 0\n%d %d\n",x,y); while(a&gt;0&amp;&amp;b&gt;0)a-=yg,b-=xg; printf("%d %d\n",(int)fabs(b),(int)fabs(a)); &#125; &#125; return 0;&#125; J Cover the Polygon with Your Disk 题目描述解题思路AC代码点击 12 K Black and White Boxes 题目描述有黑白两种方块，摞成一摞，有两个人分别只能取走黑色和白色的块。取走某个块后，上面的所有块都会消失，当某个人无法取块的时候他就输了。 有$n$摞，选择其中的某些摞使得每个人先手后手的胜负状态不一致，最大化黑白块的总个数。 解题思路神秘博弈，$surreal\space number$，具体看$cf$题解吧。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char a[45];map&lt;ll,int&gt;mp;ll ans[45];int len[45],sc[225];ll calc(char a[])&#123; int i,mx=40; ll now=sc[a[0]]*(1LL&lt;&lt;mx); for(i=1;a[i];i++)&#123; if(a[i]!=a[0])break; now+=sc[a[i]]*(1LL&lt;&lt;mx); &#125; for(;a[i];i++)&#123; mx--; now+=sc[a[i]]*(1LL&lt;&lt;mx); &#125; return now;&#125;int main()&#123; int i,j,n; sc['W']=1;sc['B']=-1; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%s",a); ans[i]=calc(a); len[i]=strlen(a); &#125; int num1=n/2,s1=(1&lt;&lt;num1)-1; for(i=0;i&lt;=s1;i++)&#123; ll t=0,num=0; for(j=0;j&lt;num1;j++)if(i&amp;(1&lt;&lt;j))t+=ans[j],num+=len[j]; if(mp.count(t)==0||mp[t]&lt;num)mp[t]=num; &#125; int num2=n-n/2,s2=(1&lt;&lt;num2)-1;ll res=0; for(i=0;i&lt;=s2;i++)&#123; ll t=0,num=0; for(j=num1;j&lt;num1+num2;j++)if(i&amp;(1&lt;&lt;(j-num1)))t+=ans[j],num+=len[j]; if(mp.count(-t))res=max(res,mp[-t]+num); &#125; printf("%lld\n",res); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Summer Training 10 题解]]></title>
    <url>%2F2019%2F08%2F29%2F2019summertraining-10%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M 9/13 O O Ø . O O O O . O . O . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 题目来源：2015 ACM-ICPC Asia Changchun Regional Contest 比赛链接 A Too Rich 题目描述给定一些价值为$1,5,10,20,50,100,200,500,1000,2000$的金币，要用最多的个数表示给定的$p$，问最多个数是多少。 解题思路反向思考，求一下表示$sum-p$最小的个数。可以贪心的从上到下求解，对于每一种金币，每次选的个数必然是$max$或$max-1$（$max$代表到当前状态选这种金币最多能选的个数），否则显然不优（更低价值的金币必然能够被更高价值金币表示）。 AC代码 - by Mogg点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;const int ms = 10 * 2;const int inf = 0x3f3f3f3f;int f[ms], a[ms];int n, res;void dfs(int x, int val, int m)&#123; if (x == -1) &#123; if (val == 0) &#123; res = min(m, res); &#125; return; &#125; int tmp = min(f[x], val / a[x]); dfs(x - 1, val - tmp * a[x], m + tmp); if (tmp &gt; 0) &#123; tmp--; dfs(x - 1, val - tmp * a[x], m + tmp); &#125;&#125;int main()&#123; a[0] = 1; a[1] = 5; a[2] = 10; a[3] = 20; a[4] = 50; a[5] = 100; a[6] = 200; a[7] = 500; a[8] = 1000; a[9] = 2000; int t; scanf("%d", &amp;t); while (t--) &#123; scanf("%d", &amp;n); int sum = 0; int cnt = 0; res = inf; for (int i = 0; i &lt; 10; ++i) &#123; scanf("%d", &amp;f[i]); sum += a[i] * f[i]; cnt += f[i]; &#125; if (sum &lt; n) &#123; res = -1; &#125; else if (sum == n) &#123; res = cnt; &#125; else &#123; dfs(9, sum - n, 0); if (res != inf) res = cnt - res; else res = -1; &#125; printf("%d\n", res); &#125; return 0;&#125; B Count a × b 题目描述定义$f(m)$为满足$0\leq i\leq m-1,0\leq j\leq m-1,i\times j\space mod \space m\neq 0$的二元组$(i,j)$个数。 求$g(n)=\sum_{m|n}f(m)$。 解题思路求$ij\space mod\space m\neq 0$的个数可转化为求$m|ij$的个数，即求原表格中$0$的个数： $f(m)=m^2-\sum_{i=0}^{m-1}\sum_{j=0}^{m-1}[m|ij]$ 显然，求和符号从$0$到$m-1$和从$1$到$m$是等价的。于是考虑$[1,m]\times [1,m]$的表格，对于第$i$行，满足$m|ij$的$j$可以从$\frac mg,2\frac mg,…,g\frac mg$中取得，其中$g=gcd(m,i)$。也即，对于每个$gcd(m,i)=g$的$i$，对二元组$(i,j)$的贡献均为$g$。 枚举$m$的因子$g$，对于每个$g$，满足条件（$gcd(m,i)=g,1\leq i\leq m$）的$i$的个数为$\phi(\frac mg)$，其中$\phi(x)$为欧拉函数，表示$&lt;x$且与$x$互质的数的个数（证明：$gcd(m,i)=g,gcd(\frac mg,\frac ig)=1$，对于每一个与$\frac mg$互质且小于$\frac mg$的数$x$，有$i=xg\leq m$）。于是式子转化为： $f(m)=m^2-\sum_{g|m}g\times \phi(\frac mg)=m^2-\sum_{xy=m}x\phi(y)$ 于是$g(n)=\sum_{m|n}(m^2-\sum_{xy=m}x\phi(y))=\sum_{m|n}m^2-\sum_{xy|n}x\phi(y)$ 对于前半部分，每个$1e9$以内的数的因数个数$\leq 1344$，因此可以直接暴力枚举因数求解；也可质因数分解后变为$\prod (1+p_i^2+p_i^4+…+p_i^{2k_i})$的形式再预处理解决。 对于后半部分，枚举$x,y$，变为$\sum_{x|n}x\sum_{y|\frac nx}\phi(y)$。而欧拉函数和$e=[n=1]$的狄利克雷卷积为$id$，故$\sum_{d|n}\phi(d)=n$，即原式$=\sum_{x|n}x\frac nx=\sum_{x|n} n$。暴力枚举因数即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define NN 100000#define N (NN+10)int np[N],cnt;ll phi[N],p[N];void sieve()&#123; int i,j;np[0]=np[1]=1; for(i=2;i&lt;N;i++)&#123; if(!np[i])p[cnt++]=i,phi[i]=i-1; for(j=0;j&lt;cnt;j++)&#123; if(p[j]*i&gt;=N)break; np[i*p[j]]=1; if(i%p[j]==0)&#123; phi[i*p[j]]=phi[i]*p[j]; break; &#125;else phi[i*p[j]]=phi[i]*phi[j]; &#125; &#125;&#125;unsigned long long pw[N][35];void init()&#123; int i,j; for(i=0;i&lt;cnt;i++)pw[i][0]=1; for(i=0;i&lt;cnt;i++) for(j=1;j&lt;35;j++) pw[i][j]=pw[i][j-1]*p[i]*p[i]; for(i=0;i&lt;cnt;i++) for(j=1;j&lt;35;j++) pw[i][j]+=pw[i][j-1];&#125;int main()&#123; int t,i,n; scanf("%d",&amp;t); sieve(); init(); while(t--)&#123; scanf("%d",&amp;n); unsigned long long tmp=n; vector&lt;pair&lt;int,int&gt;&gt;fac; for(i=0;i&lt;cnt;i++)&#123; if(tmp%p[i]==0)&#123; int num=0; while(tmp%p[i]==0)num++,tmp/=p[i]; fac.push_back(make_pair(i,num)); &#125; &#125; unsigned long long now=1; if(tmp&gt;1)now=tmp*tmp+1; for(auto i:fac)now*=pw[i.first][i.second]; unsigned long long now2=n; if(tmp&gt;1)now2=now2*2; for(auto i:fac)now2=now2*(i.second+1); now2=(1ull&lt;&lt;64)-now2; printf("%llu\n",now+now2); &#125; return 0;&#125; C Play a game 题目描述给一个字符串$s$和一个字符串集合$T$，在$s$上给定的多组区间上玩游戏，每个人可以取走一个开头的元素或结尾的元素，到达空串或$T$中任意一个串的时候，游戏立即结束，下一手要操作的玩家失败，另一方获胜。问都采取最优策略的情况下谁能胜利。 解题思路$f[i][j]$ 表示当前$[i,j]$区间先手必败还是必胜，先手必败当且仅当$[i,j]$是终止状态或$[i,j-1][i+1,j]$均为必胜状态，先手必胜当且仅当$[i+1,j][i,j-1]$至少有一个是先手必败状态。故$f[i][j]=!(f[i][j-1]\&amp;f[i+1][j])$。 问题转化成了区间$dp$，用$AC$自动机跑出终止状态对应的位置，再进行区间$dp$即可。 但是这样的复杂度太高，会获得$TLE$。 考虑使用$bitset$对区间$dp$进行优化。改变$f[i][j]$的含义，变为当前区间长度为$i$，起始位置为$j$的必胜必败状态。于是有f[i][j]=~(f[i-1][j]&amp;f[i-1][j+1])​， 即f[i]=~(f[i-1]&amp;(f[i-1]&gt;&gt;1))​。复杂度$O(\frac{n^2}{64})$，可以勉强卡过。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 80010//int f[N][N];bitset&lt;N&gt;f[N];char a[N],s[N];vector&lt;int&gt;pos[N];struct ACAM&#123; int tr[N][26],tot; int fail[N],pre[N],num[N],now; queue&lt;int&gt;Q; void init()&#123; tot=0; num[0]=fail[0]=pre[0]=0; memset(tr[0],0,sizeof(tr[0])); &#125; void insert(char s[])&#123; int i; now=0; for(i=0;s[i];i++)&#123; int p=s[i]-'a'; if(!tr[now][p])&#123; tr[now][p]=++tot; num[tot]=fail[tot]=pre[tot]=0; memset(tr[tot],0,sizeof(tr[tot])); &#125; now=tr[now][p]; &#125; num[now]=i; &#125; void build()&#123; int i; for(i=0;i&lt;26;i++)if(tr[0][i])Q.push(tr[0][i]); while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=0;i&lt;26;i++)&#123; if(tr[p][i])&#123; fail[tr[p][i]]=tr[fail[p]][i]; Q.push(tr[p][i]); pre[tr[p][i]]=num[fail[tr[p][i]]]?fail[tr[p][i]]:pre[fail[tr[p][i]]]; &#125; else tr[p][i]=tr[fail[p]][i]; &#125; &#125; &#125; void solve(char a[])&#123; int i,now=0; for(i=0;a[i];i++)&#123; now=tr[now][a[i]-'a']; int temp=now; while(temp)&#123; if(num[temp])pos[num[temp]].push_back(i-num[temp]+2); temp=pre[temp]; &#125; &#125; &#125;&#125;T;int main()&#123; int i,t,n,m,q;// freopen("in.txt","r",stdin);// freopen("out.txt","w",stdout);// double time=clock(); scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); scanf("%s",a); T.init(); for(i=0;i&lt;=n;i++)pos[i].clear(); for(i=0;i&lt;m;i++)&#123; scanf("%s",s); T.insert(s); &#125; T.build(); T.solve(a); f[0].reset(); for(i=1;i&lt;=n;i++)&#123; f[i]=~(f[i-1]&amp;(f[i-1]&gt;&gt;1)); for(auto j:pos[i])f[i][j]=0; &#125; while(q--)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",(int)f[r-l+1][l]); &#125; &#125;// printf("%.5f\n",clock()-time); return 0;&#125; D Pipes selection 题目描述解题思路AC代码点击 12 E Rebuild 题目描述给定$n$个点组成的多边形，要求以每个点为圆心画圆，相邻两个点之间的圆相切，求最大圆面积之和。 解题思路任意找一个点作为起始点，设这个点对应半径$r_1$，那么有$r_2=d_{12}-r_1,r_3=d_{23}-r_2,…,r_1=d_{n1}-r_n$ 这是一个$n$元$1$次方程组，我们将它化为矩阵，以$4$为例： $\left(\begin{aligned}1\space1\space0\space 0\\ 0\space 1\space 1\space 0 \\ 0\space0\space1\space1\\ 1\space0\space0\space1\end{aligned}\right)\left(\begin{aligned}r_1\\ r_2\\ r_3\\ r_4\end{aligned}\right)=\left(\begin{aligned}d_{12}\\ d_{23}\\ d_{34}\\ d_{41}\end{aligned}\right)$ 化简这个矩阵，当$n$为偶数时矩阵的秩为$n-1$，方程无解或有无穷多组解，解出$r_1$范围后问题转化成一个一元二次方程；$n$为奇数时秩为$n$，方程有唯一解。 AC代码 - by qxforever点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+23;int T,n;int a[maxn],b[maxn];double dis[maxn];double ans[maxn];const double eps = 1e-8;const double pi = acos(-1.0);bool eq(double a,double b)&#123; if(abs(a-b)&lt;eps) return true; return false;&#125;double getd(int i,int j)&#123; double aa=a[i],bb=b[i]; double cc=a[j],dd=b[j]; return sqrt((aa-cc)*(aa-cc)+(bb-dd)*(bb-dd));&#125;bool check()&#123; ans[0]=1; for(int i=1;i&lt;=n;i++)&#123; ans[i]=dis[i-1]-ans[i-1]; &#125; return eq(ans[0],ans[n]);&#125;int main()&#123; cin &gt;&gt; T ; while(T--)&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d%d",a+i,b+i); a[n]=a[0],b[n]=b[0]; double sumd=0; for(int i=0;i&lt;n;i++)&#123; dis[i]=getd(i,i+1); sumd+=dis[i]; &#125; if(n%2==0)&#123; //for(int i=0;i&lt;n;i++) printf("%.2f ",dis[i]); if(!check()) &#123;printf("IMPOSSIBLE\n");continue;&#125; double d=0,kl,kr,pred=0; kl=0,kr=dis[0]; for(int i=1;i&lt;=n;i++)&#123; pred=dis[i-1]-pred; if(i%2)&#123; kr=min(kr,pred); &#125; else&#123; kl=max(kl,-pred); &#125; &#125; //printf("kk: %.2f %.2f\n",kl,kr); if(kl&gt;kr+eps) &#123;printf("IMPOSSIBLE\n");continue;&#125; for(int i=0;i&lt;n-1;i++)&#123; int t=1; if(i%2==0) t=-1; d+=1.0*t*(n-i-1)*dis[i]; &#125; d*=2; ans[0]=d/(-2*n); if(ans[0]&lt;kl) ans[0]=kl; else if(ans[0]&gt;kr) ans[0]=kr; sumd=ans[0]*ans[0]; for(int i=1;i&lt;n;i++)&#123; ans[i]=dis[i-1]-ans[i-1]; sumd+=ans[i]*ans[i]; &#125; printf("%.2f\n",pi*sumd); for(int i=0;i&lt;n;i++) printf("%.2f\n",ans[i]); &#125; else&#123; sumd/=2; bool can=true; int t=n/2; for(int i=0;i&lt;n;i++)&#123; ans[i]=sumd; for(int j=0;j&lt;t;j++)&#123; int now=(i+1+2*j)%n; ans[i]-=dis[now]; &#125; if(ans[i]&lt;0) can=false; &#125; if(can)&#123; double sum=0; for(int i=0;i&lt;n;i++) sum+=ans[i]*ans[i]; printf("%.2f\n",sum*pi); for(int i=0;i&lt;n;i++) printf("%.2f\n",ans[i]); &#125; else&#123; printf("IMPOSSIBLE\n"); &#125; &#125; &#125;&#125; F Almost Sorted Array 题目描述问一个数列能否删掉某个数使得最终序列有序。 解题思路升序降序讨论一番贪心删除就可以了。 AC代码 - by qxforever点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+23;int T,n;int a[maxn];int main()&#123; cin &gt;&gt; T; while(T--)&#123; scanf("%d",&amp;n); bool can=true; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",a+i); &#125; int mx=-1,cnt=0; for(int i=1;i&lt;=n;i++)&#123; if(a[i]&gt;=mx)&#123; mx=a[i]; continue; &#125; else&#123; if(cnt==0)&#123; if(a[i]&gt;=a[i-2])&#123; mx=a[i]; cnt++; &#125; else&#123; cnt++; &#125; &#125; else&#123; can=false;break; &#125; &#125; &#125; reverse(a+1,a+n+1); bool can2=true; mx=-1,cnt=0; for(int i=1;i&lt;=n;i++)&#123; if(a[i]&gt;=mx)&#123; mx=a[i]; continue; &#125; else&#123; if(cnt==0)&#123; if(a[i]&gt;=a[i-2])&#123; mx=a[i]; cnt++; &#125; else&#123; cnt++; &#125; &#125; else&#123; can2=false;break; &#125; &#125; &#125; if(can2||can)&#123; printf("YES\n"); &#125; else printf("NO\n"); &#125;&#125; G Dancing Stars on Me 题目描述整数格上给$n$个点，问是不是正多边形。 解题思路直接判断正方形即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;double basx,basy;struct Point&#123; int x,y;&#125;a[110];Point operator-(Point a,Point b)&#123; return (Point)&#123;a.x-b.x,a.y-b.y&#125;;&#125;int dot(Point a,Point b)&#123; return a.x*b.x+a.y*b.y;&#125;int dis2(Point a,Point b)&#123; return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);&#125;int check(int i,int j,int k,int l)&#123; if(fabs(dot(a[j]-a[i],a[l]-a[i]))&gt;1e-8)return 0; if(fabs(dot(a[i]-a[j],a[k]-a[j]))&gt;1e-8)return 0; if(fabs(dot(a[l]-a[k],a[j]-a[k]))&gt;1e-8)return 0; if(fabs(dot(a[k]-a[l],a[i]-a[l]))&gt;1e-8)return 0; int ds=dis2(a[i],a[j]); if(ds==dis2(a[j],a[k])&amp;&amp;ds==dis2(a[k],a[l])&amp;&amp;ds==dis2(a[l],a[i]))return 1; else return 0;&#125;int main()&#123; int i,j,k,l,t,n; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d%d",&amp;a[i].x,&amp;a[i].y); if(n!=4)&#123; printf("NO\n"); continue; &#125; int flag=0; for(i=0;i&lt;4;i++)&#123; for(j=0;j&lt;4;j++)&#123; for(k=0;k&lt;4;k++)&#123; for(l=0;l&lt;4;l++)&#123; if(i!=j&amp;&amp;j!=k&amp;&amp;k!=l&amp;&amp;i!=k&amp;&amp;i!=l&amp;&amp;j!=l)&#123; if(check(i,j,k,l))flag=1; &#125; &#125; &#125; &#125; &#125; if(flag)printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; H Partial Tree 题目描述给一个函数$f$，让你建一棵树，它的度序列为$d_i$，最大化$\sum_{i=1}^{n}f(d_i)$。 解题思路先对每一个点连一个度，还剩下$n-2$个度没有被使用，$f[i][j]$记录现在到了第$i$个$f$，用掉了$j$个度的$f$ 的总和最大值。这是一个完全背包问题。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;algorithm&gt;#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;const int ms = 2020 * 2;const int inf = 0x3f3f3f3f;int f[ms], dp[ms];int n, m, res, mx;void solve()&#123; mx = n - 2; for (int i = 0; i &lt;= mx; i++) dp[i] = -inf; dp[0] = 0; for (int i = 1; i &lt; n; i++) &#123; for (int j = i; j &lt;= mx; j++) &#123; if (dp[j - i] != -inf) dp[j] = max(dp[j], dp[j - i] + f[i]); &#125; &#125;&#125;int main()&#123; int t; scanf("%d", &amp;t); while (t--) &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; n - 1; ++i) &#123; scanf("%d", &amp;f[i]); &#125; for (int i = 1; i &lt; n - 1; ++i) &#123; f[i] -= f[0]; &#125; if (n &gt; 2) &#123; solve(); printf("%d\n", dp[mx] + n * f[0]); &#125; else &#123; printf("%d\n", n * f[0]); &#125; &#125; return 0;&#125; I Chess Puzzle 题目描述解题思路AC代码点击 12 J Chip Factory 题目描述给定一个数列，求$max(a_i+a_j)\oplus(a_k)$。 解题思路暴力即可。复杂度$O(\frac 12n^3)$。 也可以将所有元素加入一棵$trie$，再枚举$i,j$进行判断，复杂度$O(n^2\log max)$，常数挺大。 AC代码点击 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int a[1010];int main()&#123; int i,j,k,T,n; scanf("%d",&amp;T); while(T--)&#123; int ans=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)&#123; for(j=i+1;j&lt;n;j++)&#123; for(k=j+1;k&lt;n;k++)&#123; ans=max(ans,(a[i]+a[j])^a[k]); ans=max(ans,(a[k]+a[j])^a[i]); ans=max(ans,(a[i]+a[k])^a[j]); &#125; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; K Maximum Spanning Forest 题目描述解题思路AC代码点击 12 L House Building 题目描述有一堆立方体积木，给定一个积木高度，求露在外面的表面积。 解题思路暴力枚举每一层即可。 AC代码 - by Mogg点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;algorithm&gt;#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;typedef long long ll;const int ms = 55;int c[ms][ms];int n, m, res, mx;void solve(int x)&#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (c[i][j] &gt;= x) &#123; if (c[i + 1][j] &gt;= x) res--; if (c[i - 1][j] &gt;= x) res--; if (c[i][j + 1] &gt;= x) res--; if (c[i][j - 1] &gt;= x) res--; &#125; &#125; &#125;&#125;int main()&#123; int t; scanf("%d", &amp;t); while (t--) &#123; scanf("%d %d", &amp;n, &amp;m); res = 0, mx = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; scanf("%d", &amp;c[i][j]); if (c[i][j]) &#123; res++; res += 4 * c[i][j]; mx = max(c[i][j], mx); &#125; c[i][m + 1] = 0; c[n + 1][j] = 0; &#125; &#125; for (int i = 1; i &lt;= mx; ++i) &#123; solve(i); &#125; printf("%d\n", res); &#125; return 0;&#125; M Security Corporation 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Summer Training 9 题解]]></title>
    <url>%2F2019%2F08%2F25%2F2019summertraining-9%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L 10/12 O Ø O O Ø . O O O Ø O . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 题目来源：2015-2016 NEERC Moscow Subregional Contest 比赛链接 A Anagrams 题目描述$b$进制下，$x$和$y$称为$b-anagram$当且仅当$y$是由$x$数位变换得到的。 $k$被称作$b-stable$当且仅当任意能被$k$整除的$m$，其所有$b-anagram$都能被$k$整除。 给定$b$，求出所有$b-stable$。 解题思路打表发现（？答案就是$b-1$的因数 AC代码 - by qxforever点击 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int n;int main()&#123; cin &gt;&gt;n ; int inf=sqrt(n-1)+0.1; vector&lt;int&gt; ans; for(int i=1;i&lt;=inf;i++)&#123; if((n-1)%i==0)&#123; ans.push_back(i); if(i!=(n-1)/i) ans.push_back((n-1)/i); &#125; &#125; sort(ans.begin(),ans.end()); for(int i=0;i&lt;ans.size();i++) printf("%d ",ans[i]);&#125; B Banana Brain’s Bracelet 题目描述有一个绕成一圈的字符串$A$，求一个最长的$A$的子串$B$满足$B$绕成一圈后，$C$是$B$的子串。 解题思路绕成一圈的字符串$A$中选择子串，等价于将$A$扩充为$AA$之后选择一段长度$\leq strlen(A)$的子串。设$A’=AA$。 显然可以将$C$划分为前缀和后缀。现在要求的就是：$A ‘$中，选择出一段靠后的$C$的前缀$c_1…c_{l}$，靠前的$C$的后缀$c_{l+1}…c_{strlen(c)}$。枚举前缀的长度$l$，如果能够知道对于每个$i$，其能够向后匹配的最长$A’$前缀的长度，那便能求出对于每个$i$，其能够向前匹配的最长$A’$后缀的长度（翻转字符串求出即可），就能用$set$存储所有$len\geq strlen(c)-l$的后缀匹配的终止下标，从而$O(\log n)$地更新答案。 然后这就是个$z-box$模板。$z-box$和$exkmp$有异曲同工之妙，因此本题也可用$exkmp$求解。注意$kmp$求出的$next$是不容易求出对于每个$i$向后匹配的最大长度的，不能够直接用$kmp$更新。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1500010char c[N],revc[N],a[N],b[N];vector&lt;int&gt;pre[N],suf[N];set&lt;int&gt;S;//合法后缀对应前缀int len1[N],len2[N];//i开头maxlenvoid getzbox(int box[],char a[],int len)&#123; int i,l=0,r=0,now; for(i=1;i&lt;len;i++)&#123; if(i&gt;r)&#123; now=0;while(a[now]==a[now+i])now++; if(now)&#123; r=i+now-1; l=i; &#125; box[i]=now; &#125;else&#123; if(box[i-l]&lt;r-i+1)box[i]=box[i-l]; else&#123; now=1;while(a[r+now]==a[r+now-i])now++; box[i]=r-i+now; r+=now-1; l=i; &#125; &#125; &#125;&#125;int main()&#123; int i; scanf("%s%s",a,b);int la=strlen(a),lb=strlen(b); for(i=0;i&lt;lb;i++)c[i]=b[i]; for(i=0;i&lt;lb;i++)revc[i]=c[lb-1-i]; c[lb]=revc[lb]='#'; for(i=0;i&lt;la;i++)c[i+lb+1]=c[i+lb+la+1]=a[i]; for(i=0;i&lt;2*la;i++)revc[i+lb+1]=c[lb+2*la-i]; getzbox(len1,c,lb+2*la+1); getzbox(len2,revc,lb+2*la+1); for(i=lb+1;i&lt;lb+2*la+1;i++)&#123; pre[len1[i]].push_back(i-(lb+1));//prefix最左下标 suf[len2[i]].push_back(lb+2*la-i);//suffix最右下标 &#125; int ans=-1; for(i=0;i&lt;=lb;i++)&#123; for(auto j:suf[lb-i])S.insert(j);//S: 长度&gt;=lb-i的后缀，最左下标的集合 for(auto j:pre[i])&#123; auto k=S.lower_bound(j-la+(lb-1));//保证长度&lt;=la int num=*k; if(k!=S.end()&amp;&amp;(*k)&lt;j) ans=max(ans,j-(*k)+lb-1); &#125; &#125; printf("%d",ans); return 0;&#125; C Colder-Hotter 题目描述交互题，二维平面上有一个点，每次告诉你这次询问的点比上次询问的点离这个点近还是远，求出这个点。 解题思路分别对$x,y$二分查找即可。 AC代码 - by qxforever点击 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int x,y;int L=1,R=0;int main()&#123; int xl=0,xr=(int)1e9,yl=0,yr=(int)1e9; int x=0,y=0,mid,c; while(xr-xl&gt;1)&#123; printf("%d %d\n",xl,y); cout.flush();scanf("%d",&amp;c); printf("%d %d\n",xr,y); cout.flush();scanf("%d",&amp;c); if(c==0)&#123; xr=((xl+xr)&gt;&gt;1); &#125; else xl=(xl+xr)&gt;&gt;1; &#125; printf("%d %d\n",xl,y); cout.flush();scanf("%d",&amp;c); printf("%d %d\n",xr,y); cout.flush();scanf("%d",&amp;c); if(c==0) x=xl;else x=xr; while(yr-yl&gt;1)&#123; printf("%d %d\n",x,yl); cout.flush();scanf("%d",&amp;c); printf("%d %d\n",x,yr); cout.flush();scanf("%d",&amp;c); if(c==0)&#123; yr=(yl+yr)&gt;&gt;1; &#125; else yl=(yl+yr)&gt;&gt;1; &#125; printf("%d %d\n",x,yl); cout.flush();scanf("%d",&amp;c); printf("%d %d\n",x,yr); cout.flush();scanf("%d",&amp;c); if(c==0) y=yl;else y=yr; printf("A %d %d\n",x,y); return 0;&#125; D Delay Time 题目描述计算重力加速度$g$的过程中，产生了一些误差，是由开始时间的测量产生的，求这个$delay\space time$。 解题思路高中物理，推式子即可。 AC代码 - by Mogg点击 1234567891011121314151617181920#include &lt;algorithm&gt;#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt; using namespace std;const int ms = 1e5 + 10;const int inf = 0x3f3f3f3f;typedef long long ll; int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); double t1, t2, h1, h2; cin &gt;&gt; h1 &gt;&gt; t1 &gt;&gt; h2 &gt;&gt; t2; h1 = sqrt(h1 / h2); printf("%.6lf", (t1 - h1 * t2) / (1 - h1)); &#125; E Entertainment 题目描述有$tot=2^n$个人，编号$1-tot$。随机安排淘汰赛，淘汰赛形成一棵满二叉树。每次如果第$i$个人和第$j$个人比赛，将会产生$a_ia_j$的娱乐值，求总娱乐值的期望。 解题思路最底层的排列一共有$A_{tot}^{tot}=tot!$种排列方式。如果能求出所有方案的娱乐值之和$sum$，那么答案即为$\frac{sum}{tot!}$。 考虑计算$i,j(i&lt;j)$在第满二叉树从上往下数第$k+1$层相遇产生的娱乐值对答案的贡献（$2\leq k+1\leq n$）。 单考虑$i$，以这一层的$i$为根的满二叉树中，除了$i$，其他所有叶子节点都为$&lt;i$的某个值，而叶子节点共有$2^{n-k}$个，从前$i-1$个数中选择$2^{n-k}-1$个数字进行排列，再将$i$插入到$2^{n-k}-1+1$个空中，故共有$A_{i-1}^{2^{n-k}-1}\times 2^{n-k}$种排列方式。 再考虑$j$，$j$的子树一共能够从前$j-1-2^{n-k}$个数中选取（因为需要除掉$i$子树中已经选过的人），同理可得排列方式为$A_{j-1-2^{n-k}}^{2^{n-k}-1}\times 2^{n-k}$。 由于$i,j$要在第$k+1$层相遇，他们的胜者必然在$k$层的某个位置出现。第$k$层共有$2^{k-1}$个位置，故排列方式还需乘$2^{k-1}$；$ij$位置可以互换，故还需乘$2$；剩余元素任意排列，还需乘$(2^{n}-2\times 2^{n-k})!$。 于是$i,j,k$对答案的贡献即为：$(2^n-2^{n-k+1})!\times 2^{2n-k}A_{i-1}^{2^{n-k}-1}a_i\times A_{j-1-2^{n-k} }^{2^{n-k}-1}a_j$ 显然，单这么算的复杂度为$O(n4^n)$，需要优化。很容易看出来，$i$无论怎么选，不会影响到$j$的方案数。于是可以前缀和优化，预处理出来$&gt; i$的$j$对于$i$的影响之和，这样就可以$O(n2^n)$求解了。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N ((1&lt;&lt;19)+10)ll fac[N],inv[N],mod=1000000007;ll qp(ll x,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,x=x*x%mod)if(p&amp;1)ans=ans*x%mod; return ans;&#125;ll a(int n,int m)&#123; if(n&lt;m||m&lt;0)return 0; return fac[n]*inv[n-m]%mod;&#125;int b[N];int main()&#123; int i,j,k,n; fac[0]=inv[0]=1; for(i=1;i&lt;N;i++)fac[i]=fac[i-1]*i%mod,inv[i]=qp(fac[i],mod-2); scanf("%d",&amp;n); for(i=1;i&lt;=(1&lt;&lt;n);i++)scanf("%d",&amp;b[i]); reverse(b+1,b+(1&lt;&lt;n)+1); ll ans=0; for(k=1;k&lt;=n;k++)&#123; ll sum=0; for(j=(1&lt;&lt;n);j&gt;1;j--)&#123; (sum+=b[j]*a(j-1-(1&lt;&lt;(n-k)),(1&lt;&lt;(n-k))-1))%=mod; (ans+=b[j-1]*a(j-2,(1&lt;&lt;(n-k))-1)%mod*sum%mod*fac[(1&lt;&lt;n)-(1&lt;&lt;(n-k+1))]%mod*((1LL&lt;&lt;(2*n-k))%mod)%mod)%=mod; &#125; &#125; printf("%lld\n",ans*inv[1&lt;&lt;n]%mod); return 0;&#125; F Flow Management 题目描述解题思路AC代码点击 12 G Garden Gathering 题目描述给定一堆二维平面上的整数点，点与点之间的距离定义为，在方格上只能沿着上下、左右以及斜对角方向走到整数格上，两点间最短需要的路线总长度。求最远两个点的距离。 解题思路对于两个点$(x_1,y_1),(x_2,y_2)$，其距离为$\sqrt2 min(\Delta x,\Delta y)+((max(\Delta x,\Delta y)-(min(\Delta x,\Delta y)))=(\sqrt2-1)min(\Delta x,\Delta y)+max(\Delta x,\Delta y)$，即为$((\sqrt2-1)x_1,y_1)((\sqrt2-1)x_2,y_2)$之间的曼哈顿距离$((\sqrt2-1)\Delta x+\Delta y)$与$(x_1,(\sqrt2-1)y_1)(x_2,(\sqrt2-1)y_2)$之间的曼哈顿距离$((\sqrt2-1)\Delta y+\Delta x)$的最大值（$\sqrt 2-1&lt;1$）。 曼哈顿距离的最大值只需要拆开绝对值符号存一下$x+y,x-y,y-x,-x-y$四个值的最大最小值即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 200010int n,idm[4],idn[4];struct Point&#123;double x,y;&#125;p1[N],p2[N];double mx[4],mn[4];double sol(Point a[],int &amp;ans1,int &amp;ans2)&#123; int i;double ans=0; for(i=0;i&lt;4;i++)mx[i]=-1e18,mn[i]=1e18; for(i=0;i&lt;n;i++)&#123; double x=a[i].x,y=a[i].y; if(mx[0]&lt;x+y)mx[0]=x+y,idm[0]=i; if(mx[1]&lt;-x+y)mx[1]=-x+y,idm[1]=i; if(mx[2]&lt;x-y)mx[2]=x-y,idm[2]=i; if(mx[3]&lt;-x-y)mx[3]=-x-y,idm[3]=i; if(mn[0]&gt;x+y)mn[0]=x+y,idn[0]=i; if(mn[1]&gt;-x+y)mn[1]=-x+y,idn[1]=i; if(mn[2]&gt;x-y)mn[2]=x-y,idn[2]=i; if(mn[3]&gt;-x-y)mn[3]=-x-y,idn[3]=i; &#125; for(i=0;i&lt;4;i++)if(ans&lt;mx[i]-mn[i])ans=mx[i]-mn[i],ans1=idm[i],ans2=idn[i]; return ans;&#125;int main()&#123; int a,b,c,d,i,x,y; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;x,&amp;y); p1[i]=&#123;(sqrt(2)-1)*x,y&#125;;p2[i]=&#123;x,(sqrt(2)-1)*y&#125;; &#125; if(sol(p1,a,b)&gt;sol(p2,c,d))printf("%d %d",a+1,b+1); else printf("%d %d",c+1,d+1); return 0;&#125; H Hashing 题目描述从一列$0\leq a_i\leq 255$的数中，选取一个不要求连续的子序列$s_i$，其$hash$值定义为$\sum_{i=0}^{len(s)}i\oplus a_{s_i}$，求所有子串中最大的$hash$值。 解题思路$dp[i][j]$ 表示到了第$i$个元素，当前已选择的数列$s$长度为$j$的当前最大$hash$值。于是有$dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]+j\oplus a_{i})$ 这样的复杂度是$O(n^2)$的，不太可行。 考虑到所有$a_i$都在$255$以内，在$j$对$a_i$异或操作的时候，只会修改后半部分。考虑用$dp[i][j]$表示到了第$i$个元素，已选择的长度$mod\space 256$为$j$的当前最大$hash$值。因为所有$a_i\geq 0$，选择更长的序列必然是不劣的，于是根据余数$j$可以算出对应的原长度$len$，采用同样的$dp$方式解决即可。 AC代码 - by Mogg &amp; Potassium点击 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;algorithm&gt;#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;queue&gt; using namespace std;const int ms = 1e5 + 10;const int inf = 0x3f3f3f3f;typedef long long ll;int a[ms];ll dp[ms][300];int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; hex &gt;&gt; a[i]; &#125; ll mx = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; 256; ++j) &#123; int temp = (i / 256) * 256 + j; if (temp &gt; i)temp -= 256; if (temp &gt;= 0) &#123; if(i&gt;=1)dp[i][j] = max(dp[i - 1][j], dp[i - 1][(j + 255) % 256] + (a[i] ^ temp)); else dp[i][j]=(a[i] ^ temp); mx = max(dp[i][j], mx); &#125; &#125; &#125; cout &lt;&lt; mx;&#125; I Illegel or Not? 题目描述判断护照的合法使用。 解题思路模拟一下即可 AC代码 - by qxforever点击 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+23;int a[maxn],b[maxn];int vis[maxn];int n,m; int main()&#123; cin &gt;&gt;n ; for(int i=1;i&lt;=n;i++)&#123; scanf("%d %d",a+i,b+i); for(int j=a[i];j&lt;=b[i];j++) vis[j]=1; &#125; int pre=0; for(int i=1;i&lt;=180;i++) pre+=vis[i]; if(pre&gt;90) return 0*printf("No"); for(int i=181;i&lt;=1826;i++)&#123; pre-=vis[i-180]; pre+=vis[i];if(pre&gt;90) return 0*printf("No"); &#125; printf("Yes");&#125; J Jealousy 题目描述有$k$个男生$m$个女生，$n$个照片，第$i$个照片上有$size_i$个女生，每次钦定每个女生$x$和某个男生$y$互为情侣，按照照片顺序钦定所有照片上出现的女生。当某次钦定时，男生$y$之前已经被钦定过和另一个女生互为情侣，那么需要额外花费$q_x$。问如何钦定使得总花费最少。 解题思路这个费用流绝了。因为男生是谁不重要，重要的是这个男生以前有没有被钦定过。于是对于某个女生$x$的出现，考虑几种情况： 如果这个女生不是第一次出现，沿用上次钦定给她的女生；否则钦定一个没被钦定过的男生给她 从渣男里面找一个男生钦定给她。 没了。 按照片顺序可以建一个关于时间的图：$s=0,t=n+1$，$i\rightarrow i+1$流量为$k$，花费为$0$ 一个流量代表一个男生。按照上面的两种情况建图，对于每个照片中的女生$x$： 拆点，连流量$1$花费$-inf$的边，保证被选到； 如果女生之前出现过，那么从上次出现的点连流量$1$花费$0$的边，否则从$1$连过来流量$1$花费$0$的边； 从时间轴上拉一条流量$1$花费$q[x]$的边，找一个渣男； 连向时间轴一个流量$1$花费$0$的边，表示这个男生可能去变成渣男。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 40010ll inf=1e9;struct Edge&#123; int e,n;ll len,cost;&#125;e[20*N];int hd[N],cnt=1;struct Pre&#123; int pre,e;&#125;pre[N];ll dis[N],flow[N];int vis[N],n,m,s,t;ll maxflow,mincost;void adde(int a,int b,ll l,ll c)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt; e[cnt].len=l;e[cnt].cost=c;&#125;void add(int a,int b,ll l,ll c)&#123; adde(a,b,l,c); adde(b,a,0,-c);&#125;queue&lt;int&gt;Q;int spfa()&#123; memset(vis,0,sizeof(vis)); memset(dis,0x7f,sizeof(dis)); memset(flow,0x7f,sizeof(flow)); while(!Q.empty())Q.pop(); int i,top,q; Q.push(s);vis[s]=1;dis[s]=0;pre[t].pre=0; while(!Q.empty())&#123; top=Q.front(); Q.pop(); vis[top]=0; for(i=hd[top];i;i=e[i].n)&#123; q=e[i].e; if(e[i].len&amp;&amp;dis[q]&gt;dis[top]+e[i].cost)&#123; dis[q]=dis[top]+e[i].cost; pre[q].pre=top; pre[q].e=i; flow[q]=min(flow[top],e[i].len); if(!vis[q])&#123; vis[q]=1; Q.push(q); &#125; &#125; &#125; &#125; return pre[t].pre;&#125;void ek()&#123; int i; while(spfa())&#123; maxflow+=flow[t]; mincost+=flow[t]*dis[t]; for(i=t;i!=s;i=pre[i].pre)&#123; e[pre[i].e].len-=flow[t]; e[pre[i].e^1].len+=flow[t]; &#125; &#125;&#125;int added[N],tot,q[N];int start[N],res[N];void get(int num,int p)&#123;//p:当前节点 num:当前npy编号 int i; res[p]=num; if(!p)return; for(i=hd[p];i;i=e[i].n)&#123; if(i%2&amp;&amp;e[i].len)&#123; e[i^1].len++; e[i].len--; get(num,e[i].e); return; &#125; &#125;&#125;int main()&#123; int i,j,k; scanf("%d%d%d",&amp;n,&amp;k,&amp;m); for(i=1;i&lt;=m;i++)scanf("%d",&amp;q[i]); s=0,t=n+1,tot=t+1; ll sum=0; for(i=0;i&lt;=n;i++)add(i,i+1,k,0); for(i=1;i&lt;=n;i++)&#123; int x,y; start[i]=tot; scanf("%d",&amp;x); sum+=x; while(x--)&#123; scanf("%d",&amp;y); add(tot,tot+1,1,-inf);//拆点，必选这个女生 if(added[y])add(added[y],tot,1,0);//继承上次的npy else add(1,tot,1,0);//新找个npy add(i,tot,1,q[y]);//从以前被分配过的npy中找 add(tot+1,i+1,1,0);//方便下一个女生使用这个npy added[y]=tot+1; tot+=2; &#125; &#125; start[i]=tot; ek(); printf("%lld\n",mincost+sum*inf); for(i=1;i&lt;=k;i++)get(i,t); for(i=1;i&lt;=n;i++)&#123; for(j=start[i];j&lt;start[i+1];j+=2)printf("%d ",res[j]); puts(""); &#125; return 0;&#125; K King’s Rout 题目描述给两个数列$a,b$，要求$a_i$比$b_i$早出现，且出现的顺序数列满足字典序最小。 解题思路考虑反向建边，每次选出最大的元素拓扑排序，反向输出即可。 AC代码 - by Mogg点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;algorithm&gt;#include&lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;queue&gt; using namespace std;const int ms = 200000 + 10;const int inf = 0x3f3f3f3f;typedef long long ll;int res[ms];int d[ms];vector&lt;int&gt; g[ms];int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; int a, b; for (int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; a &gt;&gt; b; g[b].push_back(a); d[a]++; &#125; priority_queue&lt;int&gt;q; for (int i = 1; i &lt;= n; ++i) &#123; if (d[i] == 0) q.push(i); &#125; int cnt = 0; while (!q.empty()) &#123; int cur = q.top(); q.pop(); res[++cnt] = cur; for (auto i : g[cur]) &#123; if (!--d[i]) &#123; q.push(i); &#125; &#125; &#125; for (int i = n; i &gt; 0; --i) &#123; cout &lt;&lt; res[i] &lt;&lt; " "; &#125;&#125; L Locomotive 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Summer Training 7 题解]]></title>
    <url>%2F2019%2F08%2F19%2F2019summertraining-7%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K 8/11 O O . O . . O Ø O O Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 题目来源：2014-2015 neerc-northern-subregional-contest 比赛链接 pdf A Alarm Clock 题目描述用火柴棒拼出合法时间。 解题思路爆搜即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int a[14][14]=&#123;&#123;1&#125;,&#123;4,7&#125;,&#123;2,3,5&#125;,&#123;0,6,9&#125;,&#123;8&#125;,&#123;7&#125;&#125;;int cnt[15]=&#123;1,2,3,3,1,1&#125;;int num[15]=&#123;2,4,5,6,7,3&#125;;int seq[15];void dfs(int x,int nu)&#123; if(nu&lt;0)return; if(!x)&#123; if(nu)return; if(seq[1]*10+seq[2]&lt;24&amp;&amp;seq[3]*10+seq[4]&lt;60)&#123; printf("%d%d:%d%d",seq[1],seq[2],seq[3],seq[4]); exit(0); &#125; return; &#125; int i,j; for(i=0;i&lt;6;i++)&#123; for(j=0;j&lt;cnt[i];j++)&#123; seq[x]=a[i][j]; dfs(x-1,nu-num[i]); &#125; &#125;&#125;void solve(int x)&#123; dfs(4,x); printf("Impossible");&#125;int main()&#123; freopen("alarm.in","r",stdin); freopen("alarm.out","w",stdout); int n; scanf("%d",&amp;n); solve(n); return 0;&#125; B Buffcraft 题目描述选$k$个$a_i$中的元素，$l$个$b_i$中的元素，要求$0\leq k+l\leq m$，最大化$(\sum_{i=1}^{k}a_{x_k})\times (d+\sum_{i=1}^{l}b_{y_l})$。 解题思路排完序枚举即可。 AC代码 - by Mogg点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;#include &lt;set&gt;using namespace std; typedef long long ll;const int ms = 50000 + 10;pair&lt;int, int&gt; dir[ms], per[ms];ll sd[ms], sp[ms];int main()&#123; freopen("buffcraft.in", "r", stdin); freopen("buffcraft.out", "w", stdout); ios::sync_with_stdio(false); cin.tie(nullptr); int b, k, n, m; cin &gt;&gt; b &gt;&gt; k &gt;&gt; n &gt;&gt; m; //b *= 100; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; dir[i].first; dir[i].second = i + 1; //dir[i].first *= 100; &#125; for (int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; per[i].first; per[i].second = i + 1; &#125; sort(dir, dir + n, greater&lt;&gt;()); sort(per, per + m, greater&lt;&gt;()); for (int i = 1; i &lt;= n; ++i) &#123; sd[i] = sd[i - 1] + dir[i - 1].first; &#125; for (int i = 1; i &lt;= m; ++i) &#123; sp[i] = sp[i - 1] + per[i - 1].first; &#125; ll mx = 0; int mi = 0; for (int i = 0; i &lt;= k &amp;&amp; i &lt;= n; ++i) &#123; ll t = 1ll * (b + sd[i])*(100 + sp[min(m, k - i)]); if (t &gt; mx) &#123; mx = t; mi = i; &#125; &#125; cout &lt;&lt; mi &lt;&lt; " " &lt;&lt; min(m, k - mi) &lt;&lt; "\n"; for (int i = 0; i &lt; mi; ++i) &#123; cout &lt;&lt; dir[i].second &lt;&lt; ' '; &#125; cout &lt;&lt; '\n'; mi = min(m, k - mi); for (int i = 0; i &lt; mi; ++i) &#123; cout &lt;&lt; per[i].second &lt;&lt; ' '; &#125;&#125; C Combinator Expression 题目描述解题思路AC代码点击 12 D Digits 题目描述问$n$个数位和相等的数，最小化它们的和，这个数位和应该为多少。 解题思路暴力枚举，记录下每个数位和出现的次数，打表即可。 AC代码 - by qxforever点击 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; int main()&#123; freopen("digits.in","r",stdin); freopen("digits.out","w",stdout); ll ans[]=&#123;0,1,11,33,66,110,165,231,308,396,495,603,720,846,981,1125,1278,1440,1611,1791,1998,2214,2439,2673,2916,3168,3429,3699,4005,4320,4644,4977,5319,5670,6030,6435,6849,7272,7704,8139,8572,9014,9465,9925,10430,10944,11467,11999,12540,13090,13694,14307,14929,15560,16200,16903,17615,18336,19066,19868,20613,21344,22084,22887,23699,24520,25350,26252,27163,28083,29102,30130,31167,32213,33268,34332,35405,36487,37578,38687,39804,40896,42015,43143,44280,45426,46581,47745,48918,50100,51291,52500,53718,54945,56181,57426,58680,59943,61215,62496,63786,65094,66411,67737,69072,70416,71769,73131,74502,75882,77289,78705,80130,81564,83007,84459,85920,87390,88896,90411,91935,93468,95010,96561,98121,99726,101340,102963,104595,106236,107886,109590,111303,113025,114756,116496,118299,120111,121932,123762,125664,127575,129495,131514,133542,135579,137625,139557,141487,143516,145554,147601,149657,151722,153796,155879,157971,160090,162218,164355,166501,168656,170820,172993,175175,177366,179575,181793,184020,186256,188501,190755,193018,195290,197571,199861,202169,204486,206812,209147,211491,213844,216206,218577,220957,223364,225780,228205,230639,233082,235534,237995,240465,242971,245486,248010,250543,253085,255636,258196,260801,263415,266038,268670,271311,273961,276665,279378,282100,284831,287571,290374,293186,296007,298837,301739,304650,307570,310589,313617,316654,319700,322755,325819,328892,331974,335065,338174,341292,344419,347555,350700,353854,357017,360189,363370,366560,369768,372985,376211,379446,382690,385943,389205,392476,395756,399063,402379,405704,409038,412381,415733,419094,422464,425870,429285,432709,436142,439584,443035,446495,450000,453514,457037,460569,464110,467660,471264,474821,478336,481860,485393,488935,492486,496046,499651,503265,506888,510520,514161,517811,521515,525228,528950,532681,536421,540224,544036,547857,551687,555589,559500,563420,567439,571467,575504,579550,583605,587669,591742,595824,599915,604024,608142,612269,616405,620550,624704,628867,633039,637220,641410,645618,649835,654061,658296,662540,666793,671055,675326,679606,683913,688229,692554,696888,701231,705583,709944,714314,718720,723135,727559,731992,736434,740885,745345,749850,754364,758887,763419,767960,772510,777114,781727,786349,790980,795620,800323,805035,809756,814486,819288,824099,828919,833820,838730,843739,848757,853784,858820,863865,868919,873982,879054,884135,889225,894333,899450,904576,909711,914855,920008,925170,930341,935521,940728,945944,951169,956403,961646,966898,972159,977429,982735,988050,993374,998707,1004049,1009400,1014760,1020165,1025579,1031002,1036434,1041875,1047325,1052829,1058342,1063864,1069395,1074935,1080538,1086150,1091771,1097401,1103103,1108814,1114534,1120335,1126145,1131879,1137402,1142934,1148475,1154025,1159629,1165242,1170864,1176495,1182135,1187838,1193550,1199271,1205001,1210803,1216614,1222434,1228335,1234245,1240254,1246272,1252299,1258335,1264380,1270434,1276497,1282569,1288650,1294740,1300848,1306965,1313091,1319226,1325370,1331523,1337685,1343856,1350036,1356243,1362459,1368684,1374918,1381161,1387413,1393674,1399944,1406250,1412565,1418889,1425222,1431564,1437915,1444275,1450680,1457094,1463517,1469949,1476390,1482840,1489344,1495857,1502379,1508910,1515450,1522053,1528665,1535286,1541916,1548618,1555329,1562049,1568850,1575660,1582560,1589568,1596585,1603611,1610646,1617690,1624743,1631805,1638876,1645956,1653063,1660179,1667304,1674438,1681581,1688733,1695894,1703064,1710270,1717485,1724709,1731942,1739184,1746435,1753695,1761000,1768314,1775637,1782969,1790310,1797660,1805064,1812477,1819899,1827330,1834770,1842273,1849785,1857306,1864836,1872438,1880049,1887669,1895370,1903080,1910880,1918887,1926903,1934928,1942962,1951005,1959057,1967118,1975188,1983294,1991409,1999533,2007666,2015808,2023959,2032119,2040324,2048538,2056761,2064993,2073234,2081484,2089788,2098101,2106408,2114416,2122433,2130459,2138494,2146538,2154591,2162653,2170724,2178804,2186911,2195027,2203152,2211286,2219429,2227581,2235742,2243912,2252118,2260333,2268557,2276790,2285032,2293283,2301543,2309848,2318162,2326485,2334817,2343158,2351508,2359912,2368325,2376747,2385178,2393618,2402121,2410633,2419154,2427684,2436286,2444897,2453517,2462218,2470928,2479728,2488735,2497751,2506776,2515810,2524853,2533905,2542966,2552036,2561142,2570257,2579381,2588514,2597656,2606807,2615967,2625172,2634386,2643609,2652841,2662082,2671332,2680636,2689949,2699271,2708602,2717942,2727345,2736757,2746178,2755608,2765110,2774621,2784141,2793742,2803352,2813052,2823121,2833199,2843286,2853382,2863541,2873709,2883886,2894072,2904267,2914516,2924774,2935041,2945317,2955602,2965896,2976235,2986583,2996940,3007306,3017681,3028065,3038458,3048887,3059325,3069772,3080228,3090693,3101167,3111650,3122142,3132661,3143189,3153726,3164272,3174827,3185391,3195964,3206546,3217137,3227746,3238364,3248991,3259627,3270272,3280926,3291589,3302261,3312942,3323632,3334340,3345057,3355783,3366518,3377262,3388015,3398777,3409548,3420328,3431135,3441951,3452776,3463610,3474453,3485305,3496166,3507036,3517942,3528857,3539781,3550714,3561656,3572607,3583567,3594626,3605694,3616771,3627857,3638952,3650101,3661259,3672426,3683602,3694787,3705981,3717220,3728468,3739725,3750991,3762266,3773550,3784843,3796172,3807510,3818857,3830213,3841578,3852952,3864335,3875727,3887146,3898574,3910011,3921457,3932912,3944376,3955849,3967331,3978822,3990331,4001849,4013376,4024912,4036457,4048011,4059574,4071146,4082727,4094317,4105925,4117476,4128923,4140379,4151844,4163318,4174801,4186293,4197812,4209340,4220877,4232423,4243978,4255542,4267115,4278697,4290288,4301897,4313515,4325142,4336778,4348423,4360077,4371740,4383412,4395093,4406783,4418491,4430208,4441934,4453669,4465413,4477166,4488928,4500699,4512479,4524286,4536102,4547927,4559761,4571604,4583456,4595317,4607187,4619093,4631008,4642932,4654865,4666807,4678758,4690718,4702777,4714845,4726922,4739008,4751103,4763252,4775410,4787577,4799753,4811938,4824132,4836371,4848619,4860876,4873142,4885417,4897701,4909994,4922323,4934661,4947008,4959364,4971729,4984103,4996486,5008878,5021297,5033725,5046162,5058608,5071063,5083527,5096000,5108482,5120973,5133482,5146000,5158527,5171063,5183608,5196162,5208725,5221297,5233878,5246468,5259076,5271693,5284319,5296954,5309598,5322251,5334913,5347584,5360264,5372971,5385687,5398412,5411146,5423889,5436641,5449402,5462172,5474978,5487793,5500617,5513450,5526292,5539143,5552003,5564908,5577822,5590745,5603677,5616618,5629568,5642617,5655675,5668742,5681818,5694903,5707997,5721136,5734284,5747441,5760607,5773782,5786966,5800159,5813388,5826626,5839873,5853129,5866394,5879668,5892951,5906243,5919562,5932890,5946227,5959573,5972928,5986292,5999665,6013047,6026438,6039847,6053265,6066692,6080128,6093573,6107027,6120490,6133962,6147443,6160933,6174441,6187958,6201484,6215019,6228563,6242116,6255678,6269249,6282829,6296436,6310052,6323677,6337311,6350954,6364606,6378267,6391937,6405643,6419358,6433082,6446815,6460557,6474308,6488068,6501873,6515687,6529510,6543342,6557183,6571033,6584937,6598850,6612772,6626703,6640643,6654682,6668730,6682787,6696853,6710928,6725012,6739105,6753234,6767372,6781519,6795675,6809840,6824014,6838197,6852389,6866608,6880836,6895073,6909319,6923574,6937838,6952111,6966393,6980684,6994993,7009311,7023638,7037974,7052319,7066673,7081036,7095408,7109789,7124179,7138587,7153004,7167430,7181865,7196309,7210762,7225224,7239695,7254175,7268682,7283198,7297723,7312257,7326800,7341352,7355913,7370483,7385089,7399704,7414328,7428961,7443603,7458254,7472914,7487619,7502333,7517056,7531788,7546529,7561279,7576083,7590896,7605718,7620549,7635389,7650292,7665204,7680125,7695055,7710084,7725122,7740169,7755225,7770290,7785364,7800447,7815539,7830658,7845786,7860923,7876069,7891224,7906388,7921561,7936743,7951934,7967143,7982361,7997588,8012824,8028069,8043323,8058586,8073858,8089139,8104429,8119737,8135054,8150380,8165715,8181059,8196412,8211774,8227145,8242525,8257932,8273348,8288773,8304207,8319650,8335102,8350563,8366033,8381539,8397054,8412578,8428111,8443653,8459204,8474764,8490369,8505983,8521606,8537238,8552879,8568529,8584233,8599946,8615668,8631399,8647139,8662942,8678754,8694575,8710405,8726307,8742218,8758138,8774157,8790185,8806222,8822268,8838323,8854387,8870460,8886542,8902633,8918742,8934860,8950987,8967123,8983268,8999422,9015585,9031757,9047938,9064128,9080336,9096553,9112779,9129014,9145258,9161511,9177773,9194044,9210324,9226631,9242947,9259272,9275606,9291949,9308301,9324662,9341032,9357438,9373853,9390277,9406710,9423152,9439603,9456063,9472568,9489082,9505605,9522137,9538678,9555228,9571832,9588445,9605067,9621698,9638338,9655041,9671753,9688474,9705204,9722006,9738817,9755637,9772538,9789448,9806457,9823475,9840502,9857538,9874583,9891637,9908700,9925772,9942853,9959943,9977051,9994168,10011294,10028429,10045573,10062726,10079888,10097059,10114239,10131446,10148662,10165887,10183121,10200364,10217616,10234877,10252147,10269453,10286768,10304092,10321425,10338767,10356118,10373478,10390883,10408297,10425720,10443152,10460593,10478043,10495547,10513060,10530582,10548113,10565653,10583256,10600868,10618489,10636119,10653821,10671532,10689252,10707053,10724863,10742763,10760771,10778788,10796814,10814849,10832893,10850946,10869008,10887079,10905159,10923266,10941382,10959507,10977641,10995784,11013936,11032097,11050267,11068473,11086688,11104912,11123145,11141387,11159638,11177898,11196203,11214517,11232840,11251172,11269513,11287863,11306267,11324680,11343102,11361533,11379973,11398476,11416988,11435509,11454039,11472641,11491252,11509872,11528573,11547283,11566083,11585090,11604106,11623131,11642165,11661208,11680260,11699321,11718391,11737497,11756612,11775736,11794869,11814011,11833162,11852322,11871527,11890741,11909964,11929196,11948437,11967687,11986991,12006304,12025626,12044957,12064297,12083700,12103112,12122533,12141963,12161465,12180976,12200496,12220097,12239707,12259407,12279476,12299554,12319641,12339737,12359896,12380064,12400241,12420427,12440622,12460871,12481129,12501396,12521672,12541957,12562251,12582590,12602938,12623295,12643661,12664036,12684420,12704813,12725242,12745680,12766127,12786583,12807048,12827522,12848005,12868497,12889016,12909544,12930081,12950627,12971182,12991746,13012319,13032901,13053492,13074101,13094719,13115346,13135982,13156627,13177281,13197944,13218616,13239297,13259987,13280695,13301412,13322138,13342873,13363617,13384370,13405132,13425903,13446683,13467490,13488306,13509131,13529965,13550808,13571660,13592521,13613391,13634297,13655212,13676136,13697069,13718011,13738962,13759922,13780981,13802049,13823126,13844212,13865307,13886456,13907614,13928781,13949957,13971142,13992336,14013575,14034823,14056080,14077346,14098621,14119905,14141198,14162527,14183865,14205212,14226568,14247933,14269307,14290690,14312082,14333501,14354929,14376366,14397812,14419267,14440731,14462204,14483686,14505177,14526686,14548204,14569731,14591267,14612812,14634366,14655929,14677501,14699082,14720672,14742280,14763897,14785523,14807158,14828802,14850455,14872117,14893788,14915468,14937175,14958891,14980616,15002350,15024093,15045845,15067606,15089376,15111182,15132997,15154821,15176654,15198496,15220347,15242207,15264112,15286026,15307949,15329881,15351822,15373772,15395821,15417879,15439946,15462022,15484107,15506201,15528340,15550488,15572645,15594811,15616986,15639170,15661363,15683592,15705830,15728077,15750333,15772598,15794872,15817155,15839447,15861766,15884094,15906431,15928758,15950673,15972597,15994530,16016472,16038423,16060383,16082442,16104510,16126587,16148673,16170768,16192917,16215075,16237242,16259418,16281603,16303797,16326036,16348284,16370541,16392807,16415082,16437366,16459659,16481988,16504326,16526673,16549029,16571394,16593768,16616151,16638543,16660962,16683390,16705827,16728273,16750728,16773192,16795665,16818147,16840638,16863147,16885665,16908192,16930728,16953273,16975827,16998390,17020962,17043543,17066133,17088741,17111358,17133984,17156619,17179263,17201916,17224578,17247249,17269929,17292636,17315352,17338077,17360811,17383554,17406306,17429067,17451837,17474643,17497458,17520282,17543115,17565957,17588808,17611668,17634573,17657487,17680410,17703342,17726283,17749233,17772282,17795340,17818407,17841483,17864568,17887662,17910801,17933949,17957106,17980272,18003447,18026631,18049824,18073053,18096291,18119538,18142794,18166059,18189333,18212616,18235908,18259227,18282555,18305892,18329238,18352593,18375957,18399330,18422712,18446103,18469512,18492930,18516357,18539793,18563238,18586692,18610155,18633627,18657108,18680598,18704106,18727623,18751149,18774684,18798228,18821781,18845343,18868914,18892494,18916101,18939717,18963342,18986976,19010619,19034271,19057932,19081602,19105308,19129023,19152747,19176480,19200222,19223973,19247733,19271538,19295352,19319175,19343007,19366848,19390698,19414602,19438515,19462437,19486368,19510308,19534347,19558395,19582452,19606518,19630593,19654677,19678770,19702899,19727037,19751184,19775340,19799505,19823679,19847862,19872054,19896273,19920501,19944738,19968984,19993239,20017503,20041776,20066058,20090349,20114658,20138976,20163303,20187639,20211984,20236338,20260701,20285073,20309454,20333844,20358252,20382669,20407095,20431530,20455974,20480427,20504889,20529360,20553840,20578347,20602863,20627388,20651922,20676465,20701017,20725578,20750148,20774754,20799369,20823993,20848626,20873268,20897919,20922579,20947284,20971998,20996721,21021453,21046194,21070944,21095748,21120561,21145383,21170214,21195054,21219957,21244869,21269790,21294720,21319749,21344787,21369834,21394890,21419955,21445029,21470112,21495204,21520323,21545451,21570588,21595734,21620889,21646053,21671226,21696408,21721599,21746808,21772026,21797253,21822489,21847734,21872988,21898251,21923523,21948804,21974094,21999402,22024719,22050045,22075380,22100724,22126077,22151439,22176810,22202190,22227597,22253013,22278438,22303872,22329315,22354767,22380228,22405698,22431204,22456719,22482243,22507776,22533318,22558869,22584429,22610034,22635648,22661271,22686903,22712544,22738194,22763898,22789611,22815333,22841064,22866804,22892607,22918419,22944240,22970070,22995972,23021883,23047803,23073822,23099850,23125887,23151933,23177988,23204052,23230125,23256207,23282298,23308407,23334525,23360652,23386788,23412933,23439087,23465250,23491422,23517603,23543793,23570001,23596218,23622444,23648679,23674923,23701176,23727438,23753709,23779989,23806296,23832612,23858937,23885271,23911614,23937966,23964327,23990697,24017103,24043518,24069942,24096375,24122817,24149268,24175728,24202233,24228747,24255270,24281802,24308343,24334893,24361497,24388110,24414732,24441363,24468003,24494706,24521418,24548139,24574869,24601671,24628482,24655302,24682203,24709113,24736122,24763140,24790167,24817203,24844248,24871302,24898365,24925437,24952518,24979608,25006716,25033833,25060959,25088094,25115238,25142391,25169553,25196724,25223904,25251111,25278327,25305552,25332786,25360029,25387281,25414542,25441812,25469118,25496433,25523757,25551090,25578432,25605783,25633143,25660548,25687962,25715385,25742817,25770258,25797708,25825212,25852725,25880247,25907778,25935318,25962921,25990533,26018154,26045784,26073486,26101197,26128917,26156718,26184528,26212428,26240436,26268453,26296479,26324514,26352558,26380611,26408673,26436744,26464824,26492931,26521047,26549172,26577306,26605449,26633601,26661762,26689932,26718138,26746353,26774577,26802810,26831052,26859303,26887563,26915868,26944182,26972505,27000837,27029178,27057528,27085932,27114345,27142767,27171198,27199638,27228141,27256653,27285174,27313704,27342306,27370917,27399537,27428238,27456948,27485748,27514755,27543771,27572796,27601830,27630873,27659925,27688986,27718056,27747162,27776277,27805401,27834534,27863676,27892827,27921987,27951192,27980406,28009629,28038861,28068102,28097352,28126656,28155969,28185291,28214622,28243962,28273365,28302777,28332198,28361628,28391130,28420641,28450161,28479762,28509372,28539072,28569141,28599219,28629306,28659402,28689561,28719729,28749906,28780092,28810287,28840536,28870794,28901061,28931337,28961622,28991916,29022255,29052603,29082960,29113326,29143701,29174085,29204478,29234907,29265345,29295792,29326248,29356713,29387187,29417670,29448162,29478681,29509209,29539746,29570292,29600847,29631411,29661984,29692566,29723157,29753766,29784384,29815011,29845647,29876292,29906946,29937609,29968281,29998962,30029652,30060360,30091077,30121803,30152538,30183282,30214035,30244797,30275568,30306348,30337155,30367971,30398796,30429630,30460473,30491325,30522186,30553056,30583962,30614877,30645801,30676734,30707676,30738627,30769587,30800646,30831714,30862791,30893877,30924972,30956121,30987279,31018446,31049622,31080807,31112001,31143240,31174488,31205745,31237011,31268286,31299570,31330863,31362192,31393530,31424877,31456233,31487598,31518972,31550355,31581747,31613166,31644594,31676031,31707477,31738932,31770396,31801869,31833351,31864842,31896351,31927869,31959396,31990932,32022477,32054031,32085594,32117166,32148747,32180337,32211945,32243562,32275188,32306823,32338467,32370120,32401782,32433453,32465133,32496840,32528556,32560281,32592015,32623758,32655510,32687271,32719041,32750847,32782662,32814486,32846319,32878161,32910012,32941872,32973777,33005691,33037614,33069546,33101487,33133437,33165486,33197544,33229611,33261687,33293772,33325866,33358005,33390153,33422310,33454476,33486651,33518835,33551028,33583257,33615495,33647742,33679998,33712263,33744537,33776820,33809112,33841431,33873759,33906096,33938442,33970797,34003161,34035534,34067916,34100307,34132716,34165134,34197561,34229997,34262442,34294896,34327359,34359831,34392312,34424802,34457310,34489827,34522353,34554888,34587432,34619985,34652547,34685118,34717698,34750305,34782921,34815546,34848180,34880823,34913475,34946136,34978806,35011512,35044227,35076951,35109684,35142426,35175177,35207937,35240742,35273556,35306379,35339211,35372052,35404902,35437806,35470719,35503641,35536572,35569512,35602551,35635599,35668656,35701722,35734797,35767881,35800974,35834103,35867241,35900388,35933544,35966709,35999883,36033066,36066258,36099477,36132705,36165942,36199188,36232443,36265707,36298980,36332262,36365553,36398862,36432180,36465507,36498843,36532188,36565542,36598905,36632277,36665658,36699048,36732456,36765873,36799299,36832734,36866178,36899631,36933093,36966564,37000044,37033551,37067067,37100592,37134126,37167669,37201221,37234782,37268352,37301958,37335573,37369197,37402830,37436472,37470123,37503783,37537488,37571202,37604925,37638657,37672398,37706148,37739952,37773765,37807587,37841418,37875258,37909161,37943073,37976994,38010924,38044953,38078991,38113038,38147094,38181159,38215233,38249316,38283408,38317527,38351655,38385792,38419938,38454093,38488257,38522430,38556612,38590803,38625012,38659230,38693457,38727693,38761938,38796192,38830455,38864727,38899008,38933298,38967606,39001923,39036249,39070584,39104928,39139281,39173643,39208014,39242394,39276801,39311217,39345642,39380076,39414519,39448971,39483432,39517902,39552408,39586923,39621447,39655980,39690522,39725073,39759633,39794238,39828852,39863475,39898107,39932748,39967398,40002102,40036815,40071537,40106268,40141008,40175811,40210623,40245444,40280274,40315176,40350087,40385007,40420026,40455054,40490091,40525137,40560192,40595256,40630329,40665411,40700502,40735611,40770729,40805856,40840992,40876137,40911291,40946454,40981626,41016807,41051997,41087205,41122422,41157648,41192883,41228127,41263380,41298642,41333913,41369193,41404500,41439816,41475141,41510475,41545818,41581170,41616531,41651901,41687307,41722722,41758146,41793579,41829021,41864472,41899932,41935437,41970951,42006474,42042006,42077547,42113097,42148701,42184314,42219936,42255567,42291207,42326910,42362622,42398343,42434073,42469875,42505686,42541506,42577407,42613317,42649326,42685344,42721371,42757407,42793452,42829506,42865569,42901641,42937722,42973812,43009920,43046037,43082163,43118298,43154442,43190595,43226757,43262928,43299108,43335315,43371531,43407756,43443990,43480233,43516485,43552746,43589016,43625322,43661637,43697961,43734294,43770636,43806987,43843347,43879752,43916166,43952589,43989021,44025462,44061912,44098416,44134929,44171451,44207982,44244522,44281125,44317737,44354358,44390988,44427690,44464401,44501121,44537922,44574732,44611632,44648640,44685657,44722683,44759718,44796762,44833815,44870877,44907948,44945028,44982135,45019251,45056376,45093510,45130653,45167805,45204966,45242136,45279342,45316557,45353781,45391014,45428256,45465507,45502767,45540072,45577386,45614709,45652041,45689382,45726732,45764136,45801549,45838971,45876402,45913842,45951345,45988857,46026378,46063908,46101510,46139121,46176741,46214442,46252152,46289952,46327959,46365975,46404000,46442034,46480077,46518129,46556190,46594260,46632366,46670481,46708605,46746738,46784880,46823031,46861191,46899396,46937610,46975833,47014065,47052306,47090556,47128860,47167173,47205495,47243826,47282166,47320569,47358981,47397402,47435832,47474334,47512845,47551365,47589966,47628576,47667276,47706282,47745297,47784321,47823354,47862396,47901447,47940507,47979612,48018726,48057849,48096981,48136122,48175272,48214476,48253689,48292911,48332142,48371382,48410685,48449997,48489318,48528648,48568050,48607461,48646881,48686382,48725892,48765492,48805551,48845619,48885696,48925782,48965877,49006026,49046184,49086351,49126527,49166712,49206906,49247145,49287393,49327650,49367916,49408191,49448475,49488768,49529097,49569435,49609782,49650138,49690503,49730877,49771260,49811652,49852071,49892499,49932936,49973382,50013837,50054301,50094774,50135256,50175747,50216256,50256774,50297301,50337837,50378382,50418936,50459499,50500071,50540652,50581242,50621850,50662467,50703093,50743728,50784372,50825025,50865687,50906358,50947038,50987745,51028461,51069186,51109920,51150663,51191415,51232176,51272946,51313752,51354567,51395391,51436224,51477066,51517917,51558777,51599682,51640596,51681519,51722451,51763392,51804342,51845391,51886449,51927516,51968592,52009677,52050771,52091910,52133058,52174215,52215381,52256556,52297740,52338933,52380162,52421400,52462647,52503903,52545168,52586442,52627725,52669017,52710336,52751664,52793001,52834347,52875702,52917066,52958439,52999821,53041212,53082621,53124039,53165466,53206902,53248347,53289801,53331264,53372736,53414217,53455707,53497215,53538732,53580258,53621793,53663337,53704890,53746452,53788023,53829603,53871210,53912826,53954451,53996085,54037728,54079380,54121041,54162711,54204417,54246132,54287856,54329589,54371331,54413082,54454842,54496647,54538461,54580284,54622116,54663957,54705807,54747711,54789624,54831546,54873477,54915417,54957456,54999504,55041561,55083627,55125702,55167786,55209879,55252008,55294146,55336293,55378449,55420614,55462788,55504971,55547163,55589382,55631610,55673847,55716093,55758348,55800612,55842885,55885167,55927458,55969767,56012085,56054412,56096748,56139093,56181447,56223810,56266182,56308563,56350953,56393361,56435778,56478204,56520639,56563083,56605536,56647998,56690469,56732949,56775456,56817972,56860497,56903031,56945574,56988126,57030687,57073257,57115863,57158478,57201102,57243735,57286377,57329028,57371688,57414393,57457107,57499830,57542562,57585303,57628053,57670857,57713670,57756492,57799323,57842163,57885066,57927978,57970899,58013829,58056858,58099896,58142943,58185999,58229064,58272138,58315221,58358313,58400727,58442983,58485248,58527522,58569805,58612097,58654416,58696744,58739081,58781427,58823782,58866146,58908519,58950901,58993292,59035701,59078119,59120546,59162982,59205427,59247881,59290344,59332816,59375297,59417787,59460295,59502812,59545338,59587873,59630417,59672970,59715532,59758103,59800683,59843290,59885906,59928531,59971165,60013808,60056460,60099121,60141791,60184497,60227212,60269936,60312669,60355411,60398162,60440922,60483727,60526541,60569364,60612196,60655037,60697887,60740791,60783704,60826626,60869557,60912497,60955536,60998584,61041641,61084707,61127782,61170866,61213959,61257088,61300226,61343373,61386529,61429694,61472868,61516051,61559243,61602462,61645690,61688927,61732173,61775428,61818692,61861965,61905247,61948538,61991847,62035165,62078492,62121828,62165173,62208527,62251890,62295262,62338643,62382033,62425441,62468858,62512284,62555719,62599163,62642616,62686078,62729549,62773029,62816536,62860052,62903577,62947111,62990654,63034206,63077767,63121337,63164943,63208558,63252182,63295815,63339457,63383108,63426768,63470473,63514187,63557910,63601642,63645383,63689133,63732937,63776750,63820572,63864403,63908243,63952146,63996058,64039979,64083909,64127938,64171976,64216023,64260079,64304144,64348218,64392301,64436393,64480512,64524640,64568777,64612923,64657078,64701242,64745415,64789597,64833788,64877997,64922215,64966442,65010678,65054923,65099177,65143440,65187712,65231993,65276283,65320591,65364908,65409234,65453569,65497913,65542266,65586628,65630999,65675379,65719786,65764202,65808627,65853061,65897504,65941956,65986417,66030887,66075393,66119908,66164432,66208965,66253507,66298058,66342618,66387223,66431837,66476460,66521092,66565733,66610383,66655087,66699800,66744522,66789253,66833993,66878796,66923608,66968429,67013259,67058161,67103072,67147992,67193011,67238039,67283076,67328122,67373177,67418241,67463314,67508396,67553487,67598596,67643714,67688841,67733977,67779122,67824276,67869439,67914611,67959792,68004982,68050190,68095407,68140633,68185868,68231112,68276365,68321627,68366898,68412178,68457485,68502801,68548126,68593460,68638803,68684155,68729516,68774886,68820292,68865707,68911131,68956564,69002006,69047457,69092917,69138422,69183936,69229459,69274991,69320532,69366082,69411686,69457299,69502921,69548552,69594192,69639895,69685607,69731328,69777058,69822860,69868671,69914491,69960392,70006302,70052311,70098329,70144356,70190392,70236437,70282491,70328554,70374626,70420707,70466797,70512905,70559022,70605148,70651283,70697427,70743580,70789742,70835913,70882093,70928300,70974516,71020741,71066975,71113218,71159470,71205731,71252001,71298307,71344622,71390946,71437279,71483621,71529972,71576332,71622737,71669151,71715574,71762006,71808447,71854897,71901401,71947914,71994436,72040967,72087507,72134110,72180722,72227343,72273973,72320675,72367386,72414106,72460907,72507717,72554617,72601625,72648642,72695668,72742703,72789747,72836800,72883862,72930933,72978013,73025120,73072236,73119361,73166495,73213638,73260790,73307951,73355121,73402327,73449542,73496766,73543999,73591241,73638492,73685752,73733057,73780371,73827694,73875026,73922367,73969717,74017121,74064534,74111956,74159387,74206827,74254330,74301842,74349363,74396893,74444495,74492106,74539726,74587427,74635137,74682937,74730944,74778960,74826985,74875019,74923062,74971114,75019175,75067245,75115351,75163466,75211590,75259723,75307865,75356016,75404176,75452381,75500595,75548818,75597050,75645291,75693541,75741845,75790158,75838480,75886811,75935151,75983554,76031966,76080387,76128817,76177319,76225830,76274350,76322951,76371561,76420261,76469267,76518282,76567306,76616339,76665381,76714432,76763492,76812597,76861711,76910834,76959966,77009107,77058257,77107461,77156674,77205896,77255127,77304367,77353670,77402982,77452303,77501633,77551035,77600446,77649866,77699367,77748877,77798477,77848536,77898604,77948681,77998767,78048862,78099011,78149169,78199336,78249512,78299697,78349891,78400130,78450378,78500635,78550901,78601176,78651460,78701753,78752082,78802420,78852767,78903123,78953488,79003862,79054245,79104637,79155056,79205484,79255921,79306367,79356822,79407286,79457759,79508241,79558732,79609241,79659759,79710286,79760822,79811367,79861921,79912484,79963056,80013637,80064227,80114835,80165452,80216078,80266713,80317357,80368010,80418672,80469343,80520023,80570730,80621446,80672171,80722905,80773648,80824400,80875161,80925931,80976737,81027552,81078376,81129209,81180051,81230902,81281762,81332667,81383581,81434504,81485436,81536377,81587327,81638376,81689434,81740501,81791577,81842662,81893756,81944895,81996043,82047200,82098366,82149541,82200725,82251918,82303147,82354385,82405632,82456888,82508153,82559427,82610710,82662002,82713321,82764649,82815986,82867332,82918687,82970051,83021424,83072806,83124197,83175606,83227024,83278451,83329887,83381332,83432786,83484249,83535721,83587202,83638692,83690200,83741717,83793243,83844778,83896322,83947875,83999437,84051008,84102588,84154195,84205811,84257436,84309070,84360713,84412365,84464026,84515696,84567402,84619117,84670841,84722574,84774316,84826067,84877827,84929632,84981446,85033269,85085101,85136942,85188792,85240696,85292609,85344531,85396462,85448402,85500441,85552489,85604546,85656612,85708687,85760771,85812864,85864993,85917131,85969278,86021434,86073599,86125773,86177956,86230148,86282367,86334595,86386832,86439078,86491333,86543597,86595870,86648152,86700443,86752752,86805070,86857397,86909733,86962078,87014432,87066795,87119167,87171548,87223938,87276346,87328763,87381189,87433624,87486068,87538521,87590983,87643454,87695934,87748441,87800957,87853482,87906016,87958559,88011111,88063672,88116242,88168848,88221463,88274087,88326720,88379362,88432013,88484673,88537378,88590092,88642815,88695547,88748288,88801038,88853842,88906655,88959477,89012308,89065148,89118051,89170963,89223884,89276814,89329843,89382881,89435928,89488984,89542049,89595123,89648206,89701298,89754417,89807545,89860682,89913828,89966983,90020147,90073320,90126502,90179693,90232902,90286120,90339347,90392583,90445828,90499082,90552345,90605617,90658898,90712188,90765496,90818813,90872139,90925474,90978818,91032171,91085533,91138904,91192284,91245691,91299107,91352532,91405966,91459409,91512861,91566322,91619792,91673298,91726813,91780337,91833870,91887412,91940963,91994523,92048128,92101742,92155365,92208997,92262638,92316288,92369992,92423705,92477427,92531158,92584898,92638701,92692513,92746334,92800164,92854066,92907977,92961897,93015916,93069944,93123981,93178027,93232082,93286146,93340219,93394301,93448392,93502501,93556619,93610746,93664882,93719027,93773181,93827344,93881516,93935697,93989887,94044095,94098312,94152538,94206773,94261017,94315270,94369532,94423803,94478083,94532390,94586706,94641031,94695365,94749708,94804060,94858421,94912791,94967197,95021612,95076036,95130469,95184911,95239362,95293822,95348327,95402841,95457364,95511896,95566437,95620987,95675591,95730204,95784826,95839457,95894097,95948800,96003512,96058233,96112963,96167765,96222576,96277396,96332297,96387207,96442216,96497234,96552261,96607297,96662342,96717396,96772459,96827531,96882612,96937702,96992810,97047927,97103053,97158188,97213332,97268485,97323647,97378818,97433998,97489205,97544421,97599646,97654880,97710123,97765375,97820636,97875906,97931212,97986527,98041851,98097184,98152526,98207877,98263237,98318642,98374056,98429479,98484911,98540352,98595802,98651306,98706819,98762341,98817872,98873412,98929015,98984627,99040248,99095878,99151580,99207291,99263011,99318812,99374622,99430522,99486530,99542547,99598573,99654608,99710652,99766705,99822767,99878838,99934918,99991025,100047141,100103266,100159400,100215543,100271695,100327856,100384026,100440232,100496447,100552671,100608904,100665146,100721397,100777657,100833962,100890276,100946599,101002931,101059272,101115622,101172026,101228439,101284861,101341292,101397732,101454235,101510747,101567268,101623798,101680400,101737011,101793631,101850332,101907042,101963842,102020849,102077865,102134890,102191924,102248967,102306019,102363080,102420150,102477256,102534371,102591495,102648628,102705770,102762921,102820081,102877286,102934500,102991723,103048955,103106196,103163446,103220750,103278063,103335385,103392716,103450056,103507459,103564871,103622292,103679722,103737224,103794735,103852255,103909856,103967466,104025166,104083172,104141187,104199211,104257244,104315286,104373337,104431397,104489502,104547616,104605739,104663871,104722012,104780162,104838366,104896579,104954801,105013032,105071272,105129575,105187887,105246208,105304538,105362940,105421351,105479771,105538272,105596782,105655382,105714387,105773401,105832424,105891456,105950497,106009547,106068651,106127764,106186886,106246017,106305157,106364360,106423572,106482793,106542023,106601325,106660636,106719956,106779357,106838767,106898267,106958316,107018374,107078441,107138517,107198602,107258696,107318835,107378983,107439140,107499306,107559481,107619665,107679858,107740087,107800325,107860572,107920828,107981093,108041367,108101650,108161942,108222261,108282589,108342926,108403272,108463627,108523991,108584364,108644746,108705137,108765546,108825964,108886391,108946827,109007272,109067726,109128189,109188661,109249142,109309632,109370140,109430657,109491183,109551718,109612262,109672815,109733377,109793948,109854528,109915135,109975751,110036376,110097010,110157653,110218305,110278966,110339636,110400342,110461057,110521781,110582514,110643256,110704007,110764767,110825572,110886386,110947209,111008041,111068882,111129732,111190636,111251549,111312471,111373402,111434342,111495381,111556429,111617486,111678552,111739627,111800711,111861804,111922933,111984071,112045218,112106374,112167539,112228713,112289896,112351088,112412307,112473535,112534772,112596018,112657273,112718537,112779810,112841092,112902383,112963692,113025010,113086337,113147673,113209018,113270372,113331735,113393107,113454488,113515878,113577286,113638703,113700129,113761564,113823008,113884461,113945923,114007394,114068874,114130381,114191897,114253422,114314956,114376499,114438051,114499612,114561182,114622788,114684403,114746027,114807660,114869302,114930953,114992613,115054318,115116032,115177755,115239487,115301228,115362978,115424782,115486595,115548417,115610248,115672088,115733991,115795903,115857824,115919754,115981783,116043821,116105868,116167924,116229989,116292063,116354146,116416238,116478357,116540485,116602622,116664768,116726923,116789087,116851260,116913442,116975633,117037842,117100060,117162287,117224523,117286768,117349022,117411285,117473557,117535838,117598128,117660436,117722753,117785079,117847414,117909758,117972111,118034473,118096844,118159224,118221631,118284047,118346472,118408906,118471349,118533801,118596262,118658732,118721238,118783753,118846277,118908810,118971352,119033903,119096463,119159068,119221682,119284305,119346937,119409578,119472228,119534932,119597645,119660367,119723098,119785838,119848641,119911453,119974274,120037104,120100006,120162917,120225837,120288856,120351884,120414921,120477967,120541022,120604086,120667159,120730241,120793332,120856441,120919559,120982686,121045822,121108967,121172121,121235284,121298456,121361637,121424827,121488035,121551252,121614478,121677713,121740957,121804210,121867472,121930743,121994023,122057330,122120646,122183971,122247305,122310648,122374000,122437361,122500731,122564137,122627552,122690976,122754409,122817851,122881302,122944762,123008267,123071781,123135304,123198836,123262377,123325927,123389531,123453144,123516766,123580397,123644037,123707740,123771452,123835173,123898903,123962705,124026516,124090336,124154237,124218147,124282156,124346174,124410201,124474237,124538282,124602336,124666399,124730471,124794552,124858642,124922750,124986867,125050993,125115128,125179272,125243425,125307587,125371758,125435938,125500145,125564361,125628586,125692820,125757063,125821315,125885576,125949846,126014152,126078467,126142791,126207124,126271466,126335817,126400177,126464582,126528996,126593419,126657851,126722292,126786742,126851246,126915759,126980281,127044812,127109352,127173955,127238567,127303188,127367818,127432520,127497231,127561951,127626752,127691562,127756462,127821470,127886487,127951513,128016548,128081592,128146645,128211707,128276778,128341858,128406965,128472081,128537206,128602340,128667483,128732635,128797796,128862966,128928172,128993387,129058611,129123844,129189086,129254337,129319597,129384902,129450216,129515539,129580871,129646212,129711562,129776966,129842379,129907801,129973232,130038672,130104175,130169687,130235208,130300738,130366340,130431951,130497571,130563272,130628982,130694782,130760789,130826805,130892830,130958864,131024907,131090959,131157020,131223090,131289196,131355311,131421435,131487568,131553710,131619861,131686021,131752226,131818440,131884663,131950895,132017136,132083386,132149690,132216003,132282325,132348656,132414996,132481399,132547811,132614232,132680662,132747164,132813675,132880195,132946796,133013406,133080106,133147112,133214127,133281151,133348184,133415226,133482277,133549337,133616442,133683556,133750679,133817811,133884952,133952102,134019306,134086519,134153741,134220972,134288212,134355515,134422827,134490148,134557478,134624880,134692291,134759711,134827212,134894722,134962322,135030327,135098341,135166364,135234396,135302437,135370487,135438591,135506704,135574826,135642957,135711097,135779300,135847512,135915733,135983963,136052265,136120576,136188896,136257297,136325707,136394207,136463211,136532224,136601246,136670277,136739317,136808420,136877532,136946653,137015783,137084985,137154196,137223416,137292717,137362027,137431427,137501466,137571514,137641571,137711637,137781712,137851796,137921889,137992018,138062156,138132303,138202459,138272624,138342798,138412981,138483173,138553392,138623620,138693857,138764103,138834358,138904622,138974895,139045177,139115468,139185777,139256095,139326422,139396758,139467103,139537457,139607820,139678192,139748573,139818963,139889371,139959788,140030214,140100649,140171093,140241546,140312008,140382479,140452959,140523466,140593982,140664507,140735041,140805584,140876136,140946697,141017267,141087873,141158488,141229112,141299745,141370387,141441038,141511698,141580550,141647062,141713583,141780113,141846715,141913326,141979946,142046647,142113357,142180157,142247164,142314180,142381205,142448239,142515282,142582334,142649395,142716465,142783571,142850686,142917810,142984943,143052085,143119236,143186396,143253601,143320815,143388038,143455270,143522511,143589761,143657065,143724378,143791700,143859031,143926371,143993774,144061186,144128607,144196037,144263539,144331050,144398570,144466171,144533781,144601481,144669487,144737502,144805526,144873559,144941601,145009652,145077712,145145817,145213931,145282054,145350186,145418327,145486477,145554681,145622894,145691116,145759347,145827587,145895890,145964202,146032523,146100853,146169255,146237666,146306086,146374587,146443097,146511697,146580702,146649716,146718739,146787771,146856812,146925862,146994966,147064079,147133201,147202332,147271472,147340675,147409887,147479108,147548338,147617640,147686951,147756271,147825672,147895082,147964582,148034631,148104689,148174756,148244832,148314917,148385011,148455150,148525298,148595455,148665621,148735796,148805980,148876173,148946402,149016640,149086887,149157143,149227408,149297682,149367965,149438257,149508576,149578904,149649241,149719587,149789942,149860306,149930679,150001061,150071452,150141861,150212279,150282706,150353142,150423587,150494041,150564504,150634976,150705457,150775947,150846455,150916972,150987498,151058033,151128577,151199130,151269692,151340263,151410843,151481450,151552066,151622691,151693325,151763968,151834620,151905281,151975951,152046657,152117372,152188096,152258829,152329571,152400322,152471082,152541887,152612701,152683524,152754356,152825197,152896047,152966951,153037864,153108786,153179717,153250657,153321696,153392744,153463801,153534867,153605942,153677026,153748119,153819248,153890386,153961533,154032689,154103854,154175028,154246211,154317403,154388622,154459850,154531087,154602333,154673588,154744852,154816125,154887407,154958698,155030007,155101325,155172652,155243988,155315333,155386687,155458050,155529422,155600803,155672193,155743601,155815018,155886444,155957879,156029323,156100776,156172238,156243709,156315189,156386696,156458212,156529737,156601271,156672814,156744366,156815927,156887497,156959103,157030718,157102342,157173975,157245617,157317268,157388928,157460633,157532347,157604070,157675802,157747543,157819293,157891097,157962910,158034732,158106563,158178403,158250306,158322218,158394139,158466069,158538098,158610136,158682183,158754239,158826304,158898378,158970461,159042553,159114672,159186800,159258937,159331083,159403238,159475402,159547575,159619757,159691948,159764157,159836375,159908602,159980838,160053083,160125337,160197600,160269872,160342153,160414443,160486751,160559068,160631394,160703729,160776073,160848426,160920788,160993159,161065539,161137946,161210362,161282787,161355221,161427664,161500116,161572577,161645047,161717553,161790068,161862592,161935125,162007667,162080218,162152778,162225383,162297997,162370620,162443252,162515893,162588543,162661247,162733960,162806682,162879413,162952153,163024956,163097768,163170589,163243419,163316321,163389232,163462152,163535171,163608199,163681236,163754282,163827337,163900401,163973474,164046556,164119647,164192756,164265874,164339001,164412137,164485282,164558436,164631599,164704771,164777952,164851142,164924350,164997567,165070793,165144028,165217272,165290525,165363787,165437058,165510338,165583645,165656961,165730286,165803620,165876963,165950315,166023676,166097046,166170452,166243867,166317291,166390724,166464166,166537617,166611077,166684582,166758096,166831619,166905151,166978692,167052242,167125846,167199459,167273081,167346712,167420352,167494055,167567767,167641488,167715218,167789020,167862831,167936651,168010552,168084462,168158471,168232489,168306516,168380552,168454597,168528651,168602714,168676786,168750867,168824957,168899065,168973182,169047308,169121443,169195587,169269740,169343902,169418073,169492253,169566460,169640676,169714901,169789135,169863378,169937630,170011891,170086161,170160467,170234782,170309106,170383439,170457781,170532132,170606492,170680897,170755311,170829734,170904166,170978607,171053057,171127561,171202074,171276596,171351127,171425667,171500270,171574882,171649503,171724133,171798835,171873546,171948266,172023067,172097877,172172777,172247785,172322802,172397828,172472863,172547907,172622960,172698022,172773093,172848173,172923280,172998396,173073521,173148655,173223798,173298950,173374111,173449281,173524487,173599702,173674926,173750159,173825401,173900652,173975912,174051217,174126531,174201854,174277186,174352527,174427877,174503281,174578694,174654116,174729547,174804987,174880490,174956002,175031523,175107053,175182655,175258266,175333886,175409587,175485297,175561097,175637104,175713120,175789145,175865179,175941222,176017274,176093335,176169405,176245511,176321626,176397750,176473883,176550025,176626176,176702336,176778541,176854755,176930978,177007210,177083451,177159701,177236005,177312318,177388640,177464971,177541311,177617714,177694126,177770547,177846977,177923479,177999990,178076510,178153111,178229721,178306421,178383427,178460442,178537466,178614499,178691541,178768592,178845652,178922757,178999871,179076994,179154126,179231267,179308417,179385621,179462834,179540056,179617287,179694527,179771830,179849142,179926463,180003793,180081195,180158606,180236026,180313527,180391037,180468637,180546642,180624656,180702679,180780711,180858752,180936802,181014906,181093019,181171141,181249272,181327412,181405615,181483827,181562048,181640278,181718580,181796891,181875211,181953612,182032022,182110522,182189526,182268539,182347561,182426592,182505632,182584735,182663847,182742968,182822098,182901300,182980511,183059731,183139032,183218342,183297742,183377781,183457829,183537886,183617952,183698027,183778111,183858204,183938333,184018471,184098618,184178774,184258939,184339113,184419296,184499488,184579707,184659935,184740172,184820418,184900673,184980937,185061210,185141492,185221783,185302092,185382410,185462737,185543073,185623418,185703772,185784135,185864507,185944888,186025278,186105686,186186103,186266529,186346964,186427408,186507861,186588323,186668794,186749274,186829781,186910297,186990822,187071356,187151899,187232451,187313012,187393582,187474188,187554803,187635427,187716060,187796702,187877353,187958013,188038718,188119432,188200155,188280887,188361628,188442378,188523182,188603995,188684817,188765648,188846488,188927391,189008303,189089224,189170154,189251183,189332221,189413268,189494324,189575389,189656463,189737546,189818638,189899757,189980885,190062022,190143168,190224323,190305487,190386660,190467842,190549033,190630242,190711460,190792687,190873923,190955168,191036422,191117685,191198957,191280238,191361528,191442836,191524153,191605479,191686814,191768158,191849511,191930873,192012244,192093624,192175031,192256447,192337872,192419306,192500749,192582201,192663662,192745132,192826638,192908153,192989677,193071210,193152752,193234303,193315863,193397468,193479082,193560705,193642337,193723978,193805628,193887332,193969045&#125;; int n; cin &gt;&gt; n; printf("%lld\n",ans[n]);&#125; E Expression 题目描述解题思路AC代码点击 12 F Fragmentation 题目描述解题思路AC代码点击 12 G Grave 题目描述给一个大长方形$A$，$A$里面有个小长方形$B$，再给一个长方形$C$，问$C$能否位于$A$内且位于$B$外。 解题思路枚举能不能放到四个角上即可。 AC代码点击 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int x[10],y[10],w,h;int main()&#123; int i; freopen("grave.in","r",stdin); freopen("grave.out","w",stdout); for(i=1;i&lt;=4;i++)scanf("%d%d",&amp;x[i],&amp;y[i]); scanf("%d%d",&amp;w,&amp;h); if(h&lt;=y[2]-y[1]&amp;&amp;w&lt;=x[2]-x[1]&amp;&amp;( x[1]+w&lt;=x[3]||y[2]-h&gt;=y[4]|| x[1]+w&lt;=x[3]||y[1]+h&lt;=y[3]|| x[2]-w&gt;=x[4]||y[1]+h&lt;=y[3]|| x[2]-w&gt;=x[4]||y[2]-h&gt;=y[4] ))printf("Yes"); else printf("No"); return 0;&#125; H Hiking in the Hills 题目描述有一些三角形组成一个曲面，在这个曲面上从$A$走到$B$的路径中，最小化最大高度，并输出路径。 解题思路显然，只经过点的路径是不劣的。于是连成一个图，二分一下最大高度判断连通性即可。最后输出方案广搜一下。 判断$x$是否在某个平面$ABC$内：$S_{ABC}=S_{ABx}+S_{BCx}+S_{ACx}$。叉积也可，但要判断全为正或负。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 32010int tot;struct Point&#123; int x,y,z; bool operator&lt;(const Point&amp;a)const&#123; if(x&lt;a.x)return 1; if(x&gt;a.x)return 0; if(y&lt;a.y)return 1; if(y&gt;a.y)return 0; return z&lt;a.z; &#125; void in()&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); &#125;&#125;p[N][3],a,b,aft[N&lt;&lt;2];Point operator-(Point &amp;a,const Point &amp;p)&#123; return (Point)&#123;(ll)a.x-p.x,(ll)a.y-p.y,(ll)a.z-p.z&#125;;&#125;map&lt;Point,int&gt;id;ll cha(Point a,Point b)&#123; return 1LL*a.x*b.y-1LL*a.y*b.x;&#125;struct Edge&#123; int e,n;&#125;e[N&lt;&lt;4];int hd[N&lt;&lt;2],cnt=1;void adde(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;void add(int a,int b)&#123; adde(a,b); adde(b,a);&#125;int jud(int i,Point x)&#123; if(cha(p[i][1]-p[i][0],x-p[i][0])&lt;0)&#123; if(cha(p[i][2]-p[i][1],x-p[i][1])&gt;0)return 0; if(cha(p[i][0]-p[i][2],x-p[i][2])&gt;0)return 0; return 1; &#125;else&#123; if(cha(p[i][2]-p[i][1],x-p[i][1])&lt;0)return 0; if(cha(p[i][0]-p[i][2],x-p[i][2])&lt;0)return 0; return 1; &#125;&#125;int vis[N&lt;&lt;2];int dfs(int mx,int now)&#123; int i; if(aft[now].z&gt;mx)return 0; vis[now]=1; if(now==id[b])return 1; for(i=hd[now];i;i=e[i].n)&#123; int ed=e[i].e; if(!vis[ed]&amp;&amp;dfs(mx,ed))return 1; &#125; return 0;&#125;int check(int mx)&#123; memset(vis,0,sizeof(vis)); return dfs(mx,id[a]);&#125;int last[N&lt;&lt;2];int sta[N&lt;&lt;2],top;#define mp make_pairvoid bfs(int ans)&#123; queue&lt;pair&lt;int,int&gt;&gt;Q; memset(vis,0,sizeof(vis)); memset(last,-1,sizeof(last)); while(!Q.empty())Q.pop(); Q.push(mp(id[a],1)); while(!Q.empty())&#123; int tp=Q.front().first,step=Q.front().second;Q.pop(); int i; for(i=hd[tp];i;i=e[i].n)&#123; int q=e[i].e; if(aft[q].z&lt;=ans&amp;&amp;last[q]==-1&amp;&amp;q!=tp)&#123; Q.push(mp(q,step+1)); last[q]=tp; if(q==id[b])&#123; int now=q; printf("%d\n",step+1); while(now!=id[a])&#123; sta[++top]=now; now=last[now]; &#125; sta[++top]=id[a]; for(i=top;i;i--)printf("%d %d %d\n",aft[sta[i]].x,aft[sta[i]].y,aft[sta[i]].z); return; &#125; &#125; &#125; &#125;&#125;int main()&#123; int i,j,n; freopen("hiking.in","r",stdin); freopen("hiking.out","w",stdout); scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;3;j++)&#123; p[i][j].in(); if(id[p[i][j]]); else id[p[i][j]]=++tot; &#125; &#125; for(i=1;i&lt;=n;i++)&#123; add(id[p[i][0]],id[p[i][2]]); add(id[p[i][1]],id[p[i][2]]); add(id[p[i][0]],id[p[i][1]]); &#125; a.in();b.in(); if(!id[a])id[a]=++tot,aft[tot]=a; if(!id[b])id[b]=++tot,aft[tot]=b; int Ain=0,Bin=0; for(i=1;i&lt;=n;i++)if(jud(i,a))Ain=i; for(i=1;i&lt;=n;i++)if(jud(i,b))Bin=i; for(i=0;i&lt;3;i++)&#123; add(id[a],id[p[Ain][i]]); add(id[b],id[p[Bin][i]]); &#125; for(i=1;i&lt;=n;i++)for(j=0;j&lt;3;j++)aft[id[p[i][j]]]=p[i][j]; int l=0,r=1000010,ans=1000000; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))ans=mid,r=mid-1; else l=mid+1; &#125; bfs(ans); return 0;&#125; I Instruction 题目描述没看。 解题思路不知道。 AC代码 - by Mogg点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;#include &lt;set&gt;using namespace std;const int ms = 100 + 10;struct Node&#123; int id, s; string name;&#125;;vector&lt;int&gt; g[ms];Node nd[ms];void dfs1(int x)&#123; if (!nd[x].name.empty()) &#123; return; &#125; dfs1(g[x][0]); if (g[x].size() &gt; 1) &#123; if (g[x][1] &lt; g[x][0]) &#123; nd[x].s = 1; &#125; dfs1(g[x][1]); &#125;&#125;pair&lt;int, int&gt; tms[50050]; int cnt;bool dfs(int x, int t, const string &amp;to)&#123; if (!nd[x].name.empty()) &#123; return nd[x].name == to; &#125; if (dfs(g[x][0], t + 1, to)) &#123; if (nd[x].s == 1) &#123; nd[x].s = 0; tms[cnt++] = &#123; t,x &#125;; &#125; return true; &#125; if (g[x].size() &gt; 1) &#123; if (dfs(g[x][1], t + 1, to)) &#123; if (nd[x].s == 0) &#123; nd[x].s = 1; tms[cnt++] = &#123; t,x &#125;; &#125; return true; &#125; &#125; return false;&#125;int main()&#123; freopen("instruction.in", "r", stdin); freopen("instruction.out", "w", stdout); ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin &gt;&gt; n; string s; int par; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s &gt;&gt; par; g[par].push_back(i); if (s == "s") &#123; nd[i] = &#123; i,0,"" &#125;; &#125; else &#123; cin &gt;&gt; s; nd[i] = &#123; i,0,s &#125;; &#125; &#125; dfs1(0); cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; int t; string to; cin &gt;&gt; t &gt;&gt; to; dfs(1, t + 1, to); &#125; sort(tms, tms + cnt); cout &lt;&lt; cnt &lt;&lt; "\n"; for (int i = 0; i &lt; cnt; ++i) &#123; cout &lt;&lt; tms[i].second &lt;&lt; " " &lt;&lt; tms[i].first &lt;&lt; "\n"; &#125;&#125; J Joy of flight 题目描述一段时间有一种风，给定飞机最大速度，问能否在第$k$秒到达终点。 解题思路开始读错题了，以为是找出最快到达的方案，枚举每一段风，解了一手一元二次方程，然后$WA$掉了。 WA代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;double sx,sy,fx,fy;double A,B,v;#define N 10010int n,k,t[N];double res,wix[N],wiy[N];int jud(double a,double b,double c)&#123; double delta=b*b-4*a*c; if(delta&gt;=0)&#123; double x1=(-b+sqrt(delta))/(2*a); double x2=(-b-sqrt(delta))/(2*a); if(fabs(a*x1*x1+b*x1+c)&lt;1e-9&amp;&amp;x1&gt;=0&amp;&amp;x1&lt;=1)&#123; res=x1; return 1; &#125; if(fabs(a*x2*x2+b*x2+c)&lt;1e-9&amp;&amp;x2&gt;=0&amp;&amp;x2&lt;=1)&#123; res=x2; return 1; &#125; return 0; &#125;else return 0;&#125;int main()&#123; int i,j; scanf("%lf%lf%lf%lf",&amp;sx,&amp;sy,&amp;fx,&amp;fy); A=fx-sx;B=fy-sy; scanf("%d%d%lf",&amp;n,&amp;k,&amp;v); double lstx=0,lsty=0; double st=0; for(i=1;i&lt;=n;i++)scanf("%d%lf%lf",&amp;t[i],&amp;wix[i],&amp;wiy[i]); t[i]=k; for(i=1;i&lt;=n+1;i++)&#123; double wx,wy; wx=lstx+wix[i]*(t[i+1]-t[i]); wy=lsty+wiy[i]*(t[i+1]-t[i]); double dT=t[i+1]-t[i]; if(jud((wx-lstx)*(wx-lstx)+(wy-lsty)*(wy-lsty)-v*v*dT*dT,2*(lsty-B)*(wy-lsty)+2*(lstx-A)*(wx-lstx)-2*st*v*v*dT,(lstx-A)*(lstx-A)+(lsty-B)*(lsty-B)-st*st*v*v))&#123; printf("Yes\n"); double tmpx=lstx+res*(wx-lstx),tmpy=lsty+res*(wy-lsty); double dis=sqrt((A-tmpx)*(A-tmpx)+(B-tmpy)*(B-tmpy)); double rd=v*(st+res*dT); double theta=atan2(B-tmpy,A-tmpx); double vx=v*cos(theta),vy=v*sin(theta); double nowx=0,nowy=0; int index=0; double time=st+t[i+1]*res; double Tx=time*(wix[i]+vx)+lstx; double Ty=time*(wiy[i]+vy)+lsty; for(j=1;j&lt;=time;j++)&#123; if(t[index+1]&gt;=j)index++; nowx+=wix[index]+vx; nowy+=wiy[index]+vy; printf("%.10f %.10f\n",sx+nowx,sy+nowy); &#125; return 0; &#125; st=t[i]; lstx=wx,lsty=wy; &#125; puts("No"); return 0;&#125; 后来搞懂题意之后，这不是签到题吗….直接算出来风的向量走了多少，飞机就冲着这个点到终点的线飞就行了… AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;double sx,sy,fx,fy;double A,B,v;#define N 10010int n,k,t[N];double res,wix[N],wiy[N];int main()&#123; int i; freopen("joy.in","r",stdin); freopen("joy.out","w",stdout); scanf("%lf%lf%lf%lf",&amp;sx,&amp;sy,&amp;fx,&amp;fy); A=fx-sx;B=fy-sy; scanf("%d%d%lf",&amp;n,&amp;k,&amp;v); double lstx=0,lsty=0; for(i=1;i&lt;=n;i++)scanf("%d%lf%lf",&amp;t[i],&amp;wix[i],&amp;wiy[i]); t[i]=k; for(i=1;i&lt;=n;i++)lstx+=wix[i]*(t[i+1]-t[i]),lsty+=wiy[i]*(t[i+1]-t[i]); double dis=sqrt((A-lstx)*(A-lstx)+(B-lsty)*(B-lsty)); if(dis&gt;k*v)return printf("No"),0; double theta=atan2(B-lsty,A-lstx); double tx=dis/k*cos(theta),ty=dis/k*sin(theta); int index=1; printf("Yes\n"); for(i=1;i&lt;=k;i++)&#123; if(t[index+1]&lt;i)index++; sx+=tx+wix[index]; sy+=ty+wiy[index]; printf("%.10f %.10f\n",sx,sy); &#125; return 0;&#125; K Kebab House 题目描述有$n$个连续的任务，每个任务一共有$t_i$时间，可以摸鱼，但是必须在这时间内至少有$q_i$的时间不摸鱼。还要求不能在连续的$t+1$秒内摸两次鱼，问方案总数。 解题思路设$f[i][j]$表示总时间到了$i$秒，当前任务下摸了$j$次鱼的方案数。于是转移方程为$f[i][j]=f[i-1][j]+f[i-t-1][j-1]$，等号右边的两个分别表示这次不摸鱼和这次摸鱼的方案数。 相邻的两个任务$I,I+1$，当$i$已经进入$I+1$个任务的时候，所有$I$任务中摸的鱼都可以被无视掉，也即进入第二个任务的时候，$f[i\in I][0]=\sum_{k=0}^{t[I]-q[I]}f[i\in I][k]$。 为了防止$MLE$，需重复利用数组。 AC代码点击 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll f[255][255],mod=1000000007;int q[1010],x[1010],w=255;int main()&#123; freopen("kebab.in","r",stdin); freopen("kebab.out","w",stdout); int i,j,k,mx=0,n,t; scanf("%d%d",&amp;n,&amp;t);t++; for(i=1;i&lt;=n;i++)scanf("%d%d",&amp;q[i],&amp;x[i]); f[0][0]=1; for(i=1;i&lt;=n;i++)&#123; mx+=q[i]; for(j=mx-q[i]+1;j&lt;=mx;j++)&#123; for(k=0;k&lt;=q[i]-x[i];k++)&#123; f[j%w][k]=0; if(j&gt;=1)(f[j%w][k]+=f[(j-1)%w][k])%=mod;//拿 if(k&gt;=1)(f[j%w][k]+=f[max(0,j-t)%w][k-1])%=mod;//不拿 &#125;for(;k&lt;w;k++)f[j%w][k]=0;//清空 &#125; for(j=max(0,mx-t);j&lt;=mx;j++)&#123;//压下去 for(k=1;k&lt;=q[i]-x[i];k++)&#123; (f[j%w][0]+=f[j%w][k])%=mod; f[j%w][k]=0; &#125; for(;k&lt;w;k++)f[j%w][k]=0; &#125; &#125; printf("%lld",f[mx%w][0]%mod); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沙雕错误以及小结论 TO-DO LIST]]></title>
    <url>%2F2019%2F08%2F19%2Fsandstatuewrongthing%2F</url>
    <content type="text"><![CDATA[最近沙雕错误太多，实在看不下去了，必须写个博客记录一下了 沙雕合集DP 区间$DP$，仔细考虑左右端点转移问题，可能不只从一个转过去（$CF1114D$） 数据结构 线段树区间乘$x$，更新某个节点以及$pushdown$时$data$应该更新$x^{len_p}$而不是$x$，懒标记是$x$。（$CF1114F$） 线段树多注意$1,l$之类的区分。（$CF1199D$） 图论 找环的时候，注意考虑萘形状的情况，不要只要访问过就不找。（$CF1206D$） 计算几何 判断$x$是否在某个平面$ABC$内：$S_{ABC}=S_{ABx}+S_{BCx}+S_{ACx}$。叉积判正负也可，但要判断全为正或负。（暑训第七场-H） 一定要注意正负号！！！（暑训第四场-F） 数论 $gcd(n,a)=1\Rightarrow gcd(n,n-a)=1$（$HDU 6434$） 其他 输入顺序（牛客第三场$J$） 未定义行为一定开$-Wall$查看（牛客第四场$C$） for(k=0;k&lt;n;k++)a[i]=... TO-DO LIST min-max​容斥 mobius​反演 min_25​筛 LCT 二次剩余 后缀自动机的使用 可持久化并查集 二分图的KM算法 扫描线 线性递推BM算法 wqs二分 整体二分，cdq分治]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Summer Training 8 题解]]></title>
    <url>%2F2019%2F08%2F19%2F2019summertraining-8%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K 8/11 O . O O . . O O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 题目来源：2013长沙区域赛 比赛链接 A Alice’s Print Service 题目描述分段收电费，求要买$s$度电最少花费是多少。 解题思路签到题，从后到前更新一下后面的最小值即可。 AC代码点击 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;int t,n;ll s[100010],p[100010],mn[100010];int main()&#123; int i,n,m; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)scanf("%lld%lld",&amp;s[i],&amp;p[i]),mn[i]=s[i]*p[i]; mn[n]=1e18; for(i=n-2;i&gt;=0;i--)mn[i]=min(mn[i],mn[i+1]); while(m--)&#123; int x; scanf("%d",&amp;x); int pos=upper_bound(s,s+n,x)-s-1; printf("%lld\n",min(1LL*p[pos]*x,mn[pos+1])); &#125; &#125; return 0;&#125; B Bob’s new toy 题目描述解题思路AC代码点击 12 C Collision 题目描述有个固定住的质量视作无限大的大硬币（半径$R_m$），有个小硬币（半径$r$）在$(x,y)$，沿着$(v_x,v_y)$方向移动，如果碰到大硬币就完全弹性碰撞弹回，问小硬币任何一块位于$x^2+y^2\leq R^2$的总时间。 解题思路解出与大小圆分别相切的坐标，分类讨论一下即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;double Rm,R,r,x,y,vx,vy;const double eps=1e-7;double getdis(double x1,double y1,double x2,double y2)&#123; return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));&#125;bool cross(double &amp;X1,double &amp;Y1,double &amp;X2,double &amp;Y2,double R)&#123; double A=(vx*vx+vy*vy),B=2*(x*vx+y*vy),C=x*x+y*y-(R+r)*(r+R); double delta=B*B-4*A*C; if(delta&lt;eps) return false; delta=sqrt(delta); double k=(-B+delta)/(2*A); if(k&lt;-eps)&#123; X1=X2=x;Y1=Y2=y; return false; &#125; else&#123; X2=k*vx+x,Y2=k*vy+y; &#125; k=(-B-delta)/(2*A); X1=k*vx+x,Y1=k*vy+y; //printf("%.3f %.3f %.3f\n",X1,Y1,k); return true;&#125;int main()&#123; while(cin&gt;&gt;Rm&gt;&gt;R&gt;&gt;r&gt;&gt;x&gt;&gt;y&gt;&gt;vx&gt;&gt;vy)&#123; double x1,y1,x2,y2; double ans=0; double v=sqrt(vx*vx+vy*vy); if(cross(x1,y1,x2,y2,Rm))&#123; //printf("%.3f %.3f %.3f %.3f ",x1,y1,x2,y2); double dis=min(getdis(x1,y1,x,y),getdis(x2,y2,x,y)); ans+=dis/sqrt(vx*vx+vy*vy); cross(x1,y1,x2,y2,R); double d=min(getdis(x1,y1,x,y),getdis(x2,y2,x,y)); ans+=(dis+d)/sqrt(vx*vx+vy*vy); if(getdis(x,y,0,0)&gt;R+r) ans-=(3*d)/sqrt(vx*vx+vy*vy); &#125; else if(cross(x1,y1,x2,y2,R))&#123; if(getdis(x,y,0,0)&gt;R+r)&#123; ans+=getdis(x1,y1,x2,y2)/v; &#125; else&#123; if((x1-x)*vx&gt;eps||(y1-y)*vy&gt;eps)&#123; ans+=getdis(x,y,x1,y1)/v; &#125; else if((x2-x)*vx&gt;eps||(y2-y)*vy&gt;eps) ans+=getdis(x,y,x2,y2)/v; &#125; &#125; printf("%.3f\n",ans); &#125;&#125; D Arnold 题目描述有一个$n\times n$的矩阵，$(i,j)$坐标处的值为$pair(i,j)$，每次操作将整个矩阵每个位置处的$pair(x,y)$改变为$pair((x+y)\ %n,(x+2y)\ %n)$，问改变多少次回到初始状态。 解题思路发现这就是斐波那契数列的相邻两项，只需要求出斐波那契数列的循环节$ans$，如果$ans$是$2$的整数倍那么答案显然为$\frac{ans}2$；否则答案为$ans$。 现在考虑怎么求出模$n$意义下的循环节。由于模质数意义下的循环节比较好求，考虑将$n$质因数分解。设$n=p_1^{k_1}p_2^{k_2}…p_l^{k_l}$。我们假设已经求出来模$p_i$意义下斐波那契数列的循环节为$cir_i$，那么模$p_i^{k_i}$意义下的循环节显然可以设置为$len_i=cir_i\times p_i^{k_i-1}$。于是模$n$意义下的循环节就是$lcm(len_i)$。 现在要考虑求模$p$意义下的循环节。很容易写出转移方程： 设$A=\left(\begin{aligned}1\space {1}\\ 1\space{0}\end{aligned}\right) $，有$A^n\left(\begin{aligned} f_2 \\ f_1\end{aligned}\right)=\left(\begin{aligned} f_{n+2} \\ f_{n+1}\end{aligned}\right)$ 设循环节为$n$，即求$A^n=E$的最小$n$。 将$A$相似对角化：$A=T^{-1}BT,B=\left(\begin{aligned}\lambda_1 \space {0}\\ 0\space{\lambda_2}\end{aligned}\right)$，其中特征值$\lambda_1=\frac{1+\sqrt 5}2$，$\lambda_2=\frac{1-\sqrt 5}2$。 于是显然有$B^n=E\Leftrightarrow A^n=E\Leftrightarrow (\lambda_1^n\equiv 1\space mod\space p \space and\space\lambda_2^n\equiv 1\space mod\space p)$。 分两种情况讨论： $5$是$p$的二次剩余。此时有$\lambda_1\equiv const_1,\lambda_2\equiv const_2$，$const_1,const_2\in integer$。故$\lambda_1^{p-1}\equiv\lambda_2^{p-1}\equiv 1\space mod\space p$。从小到大枚举$p-1$的因数求出最短循环节即可。 $5$不是$p$的二次剩余。这时候有$5^{\frac{p-1}2}\equiv -1\space mod\space p$即$(\sqrt5)^{p-1}\equiv -1\space mod\space p$，这种情况比较麻烦，我们将$\lambda^n$用二项式定理展开，以$\lambda_1^n$为例： $\lambda_1^n$ $=\frac1{2^n}(1+\sqrt5)^{n}$ $=\frac1{2^n}(1+n\sqrt5+\frac{n(n-1)}2\sqrt5^2+…+\frac{n(n-1)}2\sqrt5^{n-2}+n\sqrt5^{n-1}+\sqrt5^{n})$ 我们不妨取$n=p+1$，这时有 $\lambda_1^{p+1}$ $=\frac1{4\times 2^{p-1}}(1+(p+1)\sqrt5+\frac{p(p+1)}2\sqrt5^2+…+\frac{p(p+1)}2\sqrt5^{p-1}+(p+1)\sqrt5^{p}+\sqrt5^{p+1})$ $\equiv \frac14 (1+(p+1)\sqrt5 +(p+1)\sqrt5^p+\sqrt5^{p+1})\space mod\space p$ $\equiv \frac14 (1+(p+1)\sqrt5+(p+1)\sqrt5(-1)+5\times (-1))\space mod\space p$ $\equiv -1\space mod\space p$ 于是$\lambda_1^{2(p+1)}\equiv 1 \space mod\space p$ 枚举$2(p+1)$的因数即可。 当时直接贴上循环节和暴力程序比了一下发现只有$2$的情况需要保留循环节，其余情况都需要输出循环节的$\frac12$倍。这里的原理大概是，矩阵$A$的行列式为$-1$，只有模$2$意义下$-1\equiv1$，所以其余情况要想让$A^n=E$，$n$必然为偶数。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define M 2struct mt&#123;ll m[M][M];&#125;;mt E=&#123;&#123;&#123;1,0&#125;,&#123;0,1&#125;&#125;&#125;,A=&#123;&#123;&#123;1,1&#125;,&#123;1,0&#125;&#125;&#125;;ll qmul(ll a,ll b,ll mod)&#123; ll res=0; while(b)&#123; if(b&amp;1)res=(res+a)%mod; a=a*2%mod;b&gt;&gt;=1; &#125; return res;&#125;mt mul(mt a,mt b,ll mod)&#123; mt c; int i,j,k; for(i=0;i&lt;M;i++)&#123; for(j=0;j&lt;M;j++)&#123; c.m[i][j]=0; for(k=0;k&lt;M;k++)c.m[i][j]=(c.m[i][j]+(__int128)a.m[i][k]*b.m[k][j]%mod)%mod; &#125; &#125; return c;&#125;mt qpmt(mt a,ll k,ll mod)&#123; mt ans=E; for(;k;k&gt;&gt;=1,a=mul(a,a,mod))if(k&amp;1)ans=mul(ans,a,mod); return ans;&#125;#define N 70005int p[N],isnp[N],tot;//大小void sieve()&#123; int i,j;isnp[0]=isnp[1]=1; for(i=2;i&lt;N;i++)&#123; if(!isnp[i])p[tot++]=i; for(j=0;1LL*p[j]*i&lt;N&amp;&amp;j&lt;tot;j++)&#123; isnp[i*p[j]]=1; if(i%p[j]==0)break; &#125; &#125;&#125;ll qp(ll x,ll p,ll mod)&#123; ll ans=1;x%=mod; for(;p;p&gt;&gt;=1,x=(__int128)x*x%mod)if(p&amp;1)ans=(__int128)ans*x%mod; return ans;&#125;int isQuadratic(ll a,ll mod)&#123;//a是mod的二次剩余(a^&#123;(mod-1)/2&#125;=1) if(qp(a,(mod-1)/2,mod)==1)return 1; else return 0;&#125;ll num[N],pri[N];int splitPrime(ll n,ll pri[],ll num[])&#123;//分解质因数 int i,now=0; for(i=0;1LL*p[i]*p[i]&lt;=n;i++)&#123; if(n%p[i]==0)&#123; int cnt=0; while(n%p[i]==0)cnt++,n/=p[i]; num[now]=cnt; pri[now]=p[i]; now++; &#125; &#125; if(n&gt;1)&#123; pri[now]=n; num[now]=1; now++; &#125; return now;&#125;ll fac[N];int findFactor(ll n)&#123; int i,now=0; for(i=1;1LL*i*i&lt;=n;i++)&#123; if(n%i==0)&#123; fac[now++]=i; if(1LL*i*i!=n)fac[now++]=n/i; &#125; &#125; return now;&#125;ll findloop(ll n)&#123; int i,j,cnt=splitPrime(n,pri,num); ll ans=1;//lcm(len_i) for(i=0;i&lt;cnt;i++)&#123; ll now=1;//len_i if(pri[i]==2)now=3; else if(pri[i]==5)now=20; else&#123; int cntFac=0; if(isQuadratic(5,pri[i]))cntFac=findFactor(pri[i]-1); else cntFac=findFactor((pri[i]+1)*2); sort(fac,fac+cntFac); for(j=0;j&lt;cntFac;j++)&#123; mt a=qpmt(A,fac[j],pri[i]); if(a.m[0][0]==1&amp;&amp;a.m[1][1]==1&amp;&amp;!a.m[0][1]&amp;&amp;!a.m[1][0])&#123; now=fac[j]; break; &#125; &#125; &#125; //now:c_i for(j=1;j&lt;num[i];j++)now*=pri[i]; ans=ans/__gcd(ans,now)*now; &#125; return ans;&#125;int main()&#123; ll n; sieve(); while(~scanf("%lld",&amp;n))&#123; if(n==2)printf("3\n"); else printf("%lld\n",findloop(n)/2); &#125; return 0;&#125; E Easy Problem Once More 题目描述解题思路AC代码点击 12 F Winter’s Coming 题目描述解题思路AC代码点击 12 G Graph Reconstruction 题目描述给定度序列，还原简单图。如果有多解，输出两组解。 解题思路根据度序列排序，从大到小枚举度序列中的点，向后连边，即可求出一组解。过程中任意找一个最后两个度相等的节点，交换一下连边即可求出第二组解。 $SBspj$，再见 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;struct P&#123; int deg,i; bool operator&lt;(const P&amp;a)const&#123;return deg&gt;a.deg||(deg==a.deg&amp;&amp;i&gt;a.i);&#125;&#125;a[110],b[110];pair&lt;int,int&gt;E[10010],E2[10010];int tot,tot2;int n,sumdeg;int dfs(int now,int sumd)&#123; int i; if(now==n)&#123; for(i=0;i&lt;n;i++)if(a[i].deg)return 0; return 1; &#125; sumd-=a[now].deg*2; if(sumd&lt;0)return 0; for(i=now+1;i&lt;=now+a[now].deg;i++)&#123; E[tot++]=make_pair(a[now].i,a[i].i); a[i].deg--; if(a[i].deg&lt;0)return 0; &#125; a[now].deg=0; sort(a+now+1,a+n); return dfs(now+1,sumd);&#125;int dfs2(int now,int sumd,int flag)&#123;//flag:有没有改 int i; if(now==n)return flag;//一定有解 sumd-=a[now].deg*2; if(sumd&lt;0)return 0; for(i=now+1;i&lt;now+a[now].deg;i++)&#123; E2[tot2++]=make_pair(a[now].i,a[i].i); a[i].deg--; &#125; if(a[now].deg&gt;0)&#123; a[now].deg=0; if(!flag&amp;&amp;a[i].deg&amp;&amp;a[i].deg==a[i+1].deg)&#123; a[i+1].deg--; E2[tot2++]=make_pair(a[now].i,a[i+1].i); sort(a+now+1,a+n); return dfs2(now+1,sumd,1); &#125; E2[tot2++]=make_pair(a[now].i,a[i].i); a[i].deg--; sort(a+now+1,a+n); &#125; return dfs2(now+1,sumd,flag);&#125;int main()&#123; int i; //freopen("in.txt","r",stdin); while(~scanf("%d",&amp;n))&#123; tot=tot2=0; sumdeg=0; for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i].deg),a[i].i=i+1,b[i]=a[i],sumdeg+=a[i].deg; sort(a,a+n); if(!dfs(0,sumdeg))printf("IMPOSSIBLE\n"); else&#123; for(i=0;i&lt;n;i++)a[i]=b[i]; sort(a,a+n); if(!dfs2(0,sumdeg,0))&#123; printf("UNIQUE\n"); printf("%d %d\n",n,tot); if(tot)&#123; printf("%d",E[0].first); for(i=1;i&lt;tot;i++)printf(" %d",E[i].first); &#125; printf("\n"); if(tot)&#123; printf("%d",E[0].second); for(i=1;i&lt;tot;i++)printf(" %d",E[i].second); &#125; printf("\n"); //debug(0); &#125;else&#123; printf("MULTIPLE\n"); printf("%d %d\n",n,tot); if(tot)&#123; printf("%d",E[0].first); for(i=1;i&lt;tot;i++)printf(" %d",E[i].first); &#125; printf("\n"); if(tot)&#123; printf("%d",E[0].second); for(i=1;i&lt;tot;i++)printf(" %d",E[i].second); &#125; printf("\n"); printf("%d %d\n",n,tot2); if(tot2)&#123; printf("%d",E2[0].first); for(i=1;i&lt;tot2;i++)printf(" %d",E2[i].first); &#125; printf("\n"); if(tot2)&#123; printf("%d",E2[0].second); for(i=1;i&lt;tot2;i++)printf(" %d",E2[i].second); &#125; printf("\n"); //debug(1); &#125; &#125; &#125; return 0;&#125; H Skycity 题目描述用木板围住圆，要求木板长度均大于某个值，求最小消耗。 解题思路转化成正多边形计算即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include &lt;algorithm&gt;#include&lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int ms = 50000 + 10;typedef long long ll;int r, R, H, F, S;double h, s;const double pi = acos(-1.0);double cal(int f)&#123; double rr = 1.0 * (R - r) / F * f + r; double top = floor(pi / atan2(s, (2 * rr))); return 2 * rr * tan(pi / top) *top;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); while (cin &gt;&gt; R &gt;&gt; r &gt;&gt; H &gt;&gt; F &gt;&gt; S) &#123; h = 1.0 * H / F; s = S / h; double res = 0; for (int i = 0; i &lt; F; ++i) &#123; res += cal(i)*h; &#125; printf("%.3lf\n", res); &#125;&#125; I LIKE vs CANDLE 题目描述给一棵树，每个点有可正可负的权值，每次可以花费$x$翻转一个未被翻转过的节点的子树，或者花费$y$反转一个已被翻转过的节点的子树。翻转某棵子树的意思就是，把这个子树所有节点的权值乘$-1$。求最终所有权值和减去总花费的最大值。 解题思路树形$dp$记录下每个节点分别修改、不修改造成的影响即可。 AC代码 - by Mogg点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;algorithm&gt;#include&lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int ms = 50000 + 10;typedef long long ll;int n, X, Y;vector&lt;int&gt; g[ms];int flag[ms], dp[ms][2], power[ms];void dfs(int x, int s)&#123; if (flag[x]) s ^= 1; if (s) power[x] = -power[x]; dp[x][0] = power[x], dp[x][1] = -power[x]; for (int i : g[x]) &#123; dfs(i, s); dp[x][0] += max(dp[i][0], dp[i][1] - (flag[i] ? Y : X)); dp[x][1] += max(dp[i][1], dp[i][0] - (flag[i] ? Y : X)); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); while (cin &gt;&gt; n &gt;&gt; X &gt;&gt; Y) &#123; for (int i = 1; i &lt;= n; ++i) &#123; int par, l; cin &gt;&gt; power[i] &gt;&gt; par &gt;&gt; flag[i] &gt;&gt; l; if (l) power[i] = -power[i]; g[par].push_back(i); &#125; dfs(0, 0); if (dp[0][0] &lt; 0) cout &lt;&lt; "HAHAHAOMG\n"; else cout &lt;&lt; dp[0][0] &lt;&lt; "\n"; for (int i = 0; i &lt;= n; ++i) g[i].clear(); &#125;&#125; J Josephina and RPG 题目描述有$n$个人，$p_{ij}$表示$i$打败$j$的概率。初始时选择其中一个人$x$。有$m$个对手$a_1…a_m$依次出现，每次打赢$a_i$后可以选择把当前选手换成$a_i$或者不换。求打败所有对手的概率。 解题思路$dp[i][j]$表示打到第$i$场，当前出战的选手是$j$的获胜概率。转移显然。 AC代码 - by qxforever点击 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 133;double p[maxn][maxn];double dp[10002][maxn];int a[10002];int m,n;int main()&#123; while(~scanf("%d",&amp;m))&#123; n=m*(m-1)*(m-2)/6; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) scanf("%lf",&amp;p[i][j]); int N;cin &gt;&gt; N ; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=N;i++) scanf("%d",a+i); for(int i=0;i&lt;maxn;i++) dp[0][i]=1; for(int i=1;i&lt;=N;i++)&#123; int t=a[i]; dp[i][t]=dp[i-1][t]*0.5; for(int j=0;j&lt;n;j++)&#123; dp[i][j]=max(dp[i][j],dp[i-1][j]*p[j][t]); dp[i][t]=max(dp[i][t],dp[i][j]); &#125; &#125; double ans=0; for(int i=0;i&lt;n;i++) ans=max(ans,dp[N][i]); printf("%.7f\n",ans); &#125;&#125; K Pocket Cube 题目描述转$2\times 2$的魔方，问$n$次以内最多能拼好几个面。 解题思路巨麻烦的爆搜。 AC代码 - by Mogg点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;int color[24], n, ans;int check()&#123; int res = 0; res += (color[0] == color[1]) &amp;&amp; (color[1] == color[2]) &amp;&amp; (color[2] == color[3]); res += (color[4] == color[5]) &amp;&amp; (color[5] == color[10]) &amp;&amp; (color[10] == color[11]); res += (color[6] == color[7]) &amp;&amp; (color[7] == color[12]) &amp;&amp; (color[12] == color[13]); res += (color[8] == color[9]) &amp;&amp; (color[9] == color[14]) &amp;&amp; (color[14] == color[15]); res += (color[16] == color[17]) &amp;&amp; (color[17] == color[18]) &amp;&amp; (color[18] == color[19]); res += (color[20] == color[21]) &amp;&amp; (color[21] == color[22]) &amp;&amp; (color[22] == color[23]); return res;&#125;void rt1()&#123; int t1 = color[0], t2 = color[2]; color[0] = color[20], color[2] = color[22]; color[20] = color[16], color[22] = color[18]; color[16] = color[6], color[18] = color[12]; color[6] = t1, color[12] = t2; t1 = color[4]; color[4] = color[10], color[10] = color[11]; color[11] = color[5], color[5] = t1;&#125;void rt2()&#123; int t1 = color[0], t2 = color[2]; color[0] = color[6], color[2] = color[12]; color[6] = color[16], color[12] = color[18]; color[16] = color[20], color[18] = color[22]; color[20] = t1, color[22] = t2; t1 = color[4]; color[4] = color[5], color[5] = color[11]; color[11] = color[10], color[10] = t1;&#125;void rt3()&#123; int t1 = color[2], t2 = color[3]; color[2] = color[11], color[3] = color[5]; color[11] = color[17], color[5] = color[16]; color[17] = color[8], color[16] = color[14]; color[8] = t1, color[14] = t2; t1 = color[6]; color[6] = color[12], color[12] = color[13]; color[13] = color[7], color[7] = t1;&#125;void rt4()&#123; int t1 = color[2], t2 = color[3]; color[2] = color[8], color[3] = color[14]; color[8] = color[17], color[14] = color[16]; color[17] = color[11], color[16] = color[5]; color[11] = t1, color[5] = t2; t1 = color[6]; color[6] = color[7], color[7] = color[13]; color[13] = color[12], color[12] = t1;&#125;void rt5()&#123; int t1 = color[22], t2 = color[23]; color[22] = color[5], color[23] = color[4]; color[5] = color[7], color[4] = color[6]; color[7] = color[9], color[6] = color[8]; color[9] = t1, color[8] = t2; t1 = color[0]; color[0] = color[2], color[2] = color[3]; color[3] = color[1], color[1] = t1;&#125;void rt6()&#123; int t1 = color[22], t2 = color[23]; color[22] = color[9], color[23] = color[8]; color[9] = color[7], color[8] = color[6]; color[7] = color[5], color[6] = color[4]; color[5] = t1, color[4] = t2; t1 = color[0]; color[0] = color[1], color[1] = color[3]; color[3] = color[2], color[2] = t1;&#125;void dfs(int x, int o)&#123; ans = max(ans, check()); if (ans == 6 || x &gt; n) return; if (o != 2) &#123; rt1(); dfs(x + 1, 1); rt2(); &#125; if (o != 1) &#123; rt2(); dfs(x + 1, 2); rt1(); &#125; if (o != 4) &#123; rt3(); dfs(x + 1, 3); rt4(); &#125; if (o != 3) &#123; rt4(); dfs(x + 1, 4); rt3(); &#125; if (o != 6) &#123; rt5(); dfs(x + 1, 5); rt6(); &#125; if (o != 5) &#123; rt6(); dfs(x + 1, 6); rt5(); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); while (cin &gt;&gt; n) &#123; ans = 0; for (int i = 0; i &lt; 24; ++i) &#123; cin &gt;&gt; color[i]; &#125; dfs(1, 0); cout &lt;&lt; ans &lt;&lt; "\n"; &#125;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Summer Training 6 题解]]></title>
    <url>%2F2019%2F08%2F18%2F2019summertraining-6%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 8/10 Ø O . O O O Ø O . Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 题目来源：2019牛客暑期多校训练营第十场 比赛链接 A 题目描述有一个数列$a_i$，每次拿走一个元素$x_k$，不放回，当$\sum_k x_k&gt;b$时立刻输掉，当$\sum_k x_k&gt;a$时立刻获胜。问获胜的概率。 解题思路$f[i][j]$为共选了$i$个数，总和为$j$的概率。通过背包很容易从“选到第$k$个数，共选了$i$个数，总和为$j$的概率”优化掉一个维度算出。 枚举最后选到的数字，删掉其对$f[i][j]$的贡献，计算完了再加回去即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 520double f[N][N];int x[N];int n,a,b;int main()&#123; int i,j,k; scanf("%d%d%d",&amp;n,&amp;a,&amp;b); for(i=1;i&lt;=n;i++)scanf("%d",&amp;x[i]); f[0][0]=1; for(k=1;k&lt;=n;k++) for(i=k;i;i--) for(j=x[k];j&lt;=a;j++) f[i][j]+=f[i-1][j-x[k]]*i/(n-i); double fz=0,fm=0; for(k=1;k&lt;=n;k++)&#123; for(i=1;i&lt;=n;i++) for(j=x[k];j&lt;=a;j++) f[i][j]-=f[i-1][j-x[k]]*i/(n-i); for(i=0;i&lt;n;i++) for(j=max(0,a-x[k]+1);j&lt;=a;j++)&#123; fm+=f[i][j]; if(j+x[k]&lt;=b)fz+=f[i][j]; &#125; for(i=n;i;i--) for(j=x[k];j&lt;=a;j++) f[i][j]+=f[i-1][j-x[k]]*i/(n-i); &#125; printf("%.10f\n",fz/fm); return 0;&#125; B 题目描述斐波那契字符串，求第$n$到$n+10$个字符。 解题思路分别处理每一个字符，不停递归到下标为$1$或$2$的情况。 AC代码点击 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int t;char a[3][10]=&#123;"","COFFEE","CHICKEN"&#125;;ll f[1010]=&#123;0,6,7&#125;;void calc(ll res,int ind)&#123; if(ind&lt;3)&#123; printf("%c",a[ind][res-1]); return; &#125; if(res&gt;f[ind-2])calc(res-f[ind-2],ind-1); else calc(res,ind-2);&#125;int main()&#123; int i,j; scanf("%d",&amp;t); for(i=3;i&lt;=58;i++)f[i]=f[i-1]+f[i-2]; while(t--)&#123; int n;ll k; scanf("%d%lld",&amp;n,&amp;k); while(n&gt;58)n-=2; ll sum=n&gt;58?f[58]:f[n]; for(j=0;j&lt;10;j++)&#123; if(k&gt;sum)break; calc(k,n); k++; &#125; puts(""); &#125; return 0;&#125; C 题目描述解题思路AC代码点击 12 D 题目描述韩信点兵？ 解题思路$ExCRT$板子。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364def mul(a,b,mod): res = 0 while(b&gt;0): if(b%2==1): res = (res + a)%mod a = (a + a)%mod b //=2 return res gcd = 0def exgcd(a, b): global gcd if (b == 0): gcd = a return 1,0 x,y = exgcd(b,a%b) return y,x-a//b * y def excrt(a,b,n): global gcd M = b[0] ans = a[0] x = 0 for i in range(1,n): #print(M,b[i]) x,y=exgcd(M, b[i]) #print(x) B = b[i] c = (a[i] - ans % B + B) % B g = B // gcd x = mul(x, c // gcd, g) ans += x * M M *= g ans = (ans%M + M) % M #print(ans) return ans%M def check(x,n,a,b): for i in range(n): if (x%b[i] != a[i]): return False return True s = input().split()n = int(s[0])m = int(s[1])a = []b = []for i in range(n): s = input().split() a.append(int(s[1])) b.append(int(s[0])) now = excrt(a,b,n)#print(now)if (check(now,n,a,b)): if (now &lt; m): print(now) else: print("he was probably lying")else: print("he was definitely lying") E 题目描述希尔伯特排序。 解题思路按题意模拟编号即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;using namespace std; typedef long long ll;const int ms = 1e6 + 10;pair&lt;ll, ll&gt; pos[ms], val[ms];ll cal(ll x, ll y, int k)&#123; if (k == 1) &#123; if (x == 1 &amp;&amp; y == 1) return 1; if (x == 1 &amp;&amp; y == 2) return 4; if (x == 2 &amp;&amp; y == 1) return 2; if (x == 2 &amp;&amp; y == 2) return 3; &#125; ll p = 1 &lt;&lt; (k - 1); if (x &gt; p&amp;&amp;y &gt; p) &#123; return p * p * 2 + cal(x - p, y - p, k - 1); &#125; if (x &gt; p&amp;&amp;y &lt;= p) &#123; return p * p + cal(x - p, y, k - 1); &#125; if (x &lt;= p &amp;&amp; y &lt;= p) &#123; return p * p - cal(y, p - x + 1, k - 1) + 1; &#125; y -= p; return p * p * 4 - cal(p - y + 1, x, k - 1) + 1;&#125;int main()&#123; int n, k; ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; k; /*for (int i = 1; i &lt; 9; ++i) &#123; for (int j = 1; j &lt; 9; ++j) &#123; printf("%d %d %lld\n", i, j, cal(i, j, 3)); &#125; &#125;*/ for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; pos[i].first &gt;&gt; pos[i].second; val[i].second = i; val[i].first = cal(pos[i].first, pos[i].second, k); &#125; sort(val, val + n); for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; pos[val[i].second].first &lt;&lt; " " &lt;&lt; pos[val[i].second].second &lt;&lt; '\n'; &#125;&#125; F 题目描述解题思路AC代码点击 12 G 题目描述给$n$个点，求一条把所有点分成两块，一边$\frac n2$个点的直线，使得距离这个直线最近的点到这条直线的距离最远。 解题思路满足距离这个直线最近的点到这条直线的距离最远的直线，必定满足：它垂直于某两点连线，或者它平行于某两点连线。 很容易直观上理解，当直线两边各有一个点距离该直线相同时，能够最大化最小距离。假设某条直线两端最近的点$A,B$到直线的距离相等，且直线不为$AB$的垂直平分线，那么可以旋转这个直线使得最短距离增大。当然也有可能不能旋转，也即旋转会造成另一个点$C$到该直线的距离减小。于是$AC$平行或$BC$平行时，也可以最大化最小距离。 然后枚举斜率就完了。 AC代码点击 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 310int n;double x[N],y[N],ans,d[N],k;void calc(double k)&#123; int i; for(i=1;i&lt;=n;i++)d[i]=(k*x[i]-y[i])/sqrt(1+k*k); sort(d+1,d+1+n); ans=max(ans,(d[n/2+1]-d[n/2])/2);&#125;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lf%lf",&amp;x[i],&amp;y[i]); for(i=1;i&lt;=n;i++) for(j=i+1;j&lt;=n;j++) k=1.0*(y[j]-y[i])/(x[j]-x[i]),calc(k), k=-1/k,calc(k); printf("%.10f",ans); return 0;&#125; H 题目描述给一张图，判断是哪种六碳烷烃。 解题思路直接根据度，叶子个数判断即可。 AC代码 - by qxforever点击 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std; int g[12];int f[7][7];int cnt[9];int T,n,m,u,v; int check()&#123; memset(cnt,0,sizeof(cnt)); for(int i=1;i&lt;=6;i++) cnt[g[i]]++; if(cnt[1]==4&amp;&amp;cnt[2]==1&amp;&amp;cnt[4]==1)&#123; return 0*printf("2,2-dimethylbutane\n"); &#125; if(cnt[1]==4&amp;&amp;cnt[3]==2) return 0*printf("2,3-dimethylbutane\n"); if(cnt[1]==2&amp;&amp;cnt[2]==4) return 0*printf("n-hexane\n"); int now; for(int i=1;i&lt;=6;i++) if(g[i]==3) &#123;now=i;break;&#125; int c=0; for(int i=1;i&lt;=6;i++)&#123; if(f[now][i]==1) c+=g[i]; &#125; if(c==5) return 0*printf("3-methylpentane\n"); if(c==4) return 0*printf("2-methylpentane\n");&#125; int main()&#123; cin &gt;&gt; T; while(T--)&#123; memset(g,0,sizeof(g)); memset(f,0,sizeof(f)); for(int i=0;i&lt;5;i++)&#123; scanf("%d%d",&amp;u,&amp;v); g[u]++,g[v]++; f[u][v]=1,f[v][u]=1; &#125; check(); &#125;&#125; I 题目描述解题思路AC代码点击 12 J 题目描述把一堆木板切成$k$种高度，求切下来的最小面积。 解题思路设$f[i][j]$表示砍了$i$次，到第$j$个的最小花费。于是有：$f[i][j]=min_{k=1}^{j-1}(f[i-1][k]+SumS_j-SumS_k-h_{k+1}(SumW_j-SumW_k)$，这是一个有决策单调性的转移方程，可以斜率优化，也可以分治处理。 （听说也可$wqs$二分，不会） AC代码 - by qxforever点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define f dpusing namespace std;typedef long long ll;const int maxn = 5e3+23;ll dp[maxn][maxn],s[maxn],w[maxn];int n,k;struct T&#123; int w; int h; bool operator &lt;(const T &amp;a) &#123; if(h!=a.h) return h&lt;a.h; return w&lt;a.w; &#125;&#125;t[maxn]; inline ll cal(int i,int j,int k)&#123; return 1LL*dp[i-1][k]+(s[j]-s[k])-1LL*t[k+1].h*(w[j]-w[k]);&#125; void solve(int k,int l,int r,int ql,int qr)&#123; if(l&gt;r) return; int mid=(l+r)&gt;&gt;1,b=ql+1; for(int i=ql;i&lt;mid&amp;&amp;i&lt;=qr;i++) if(cal(k,mid,b)&gt;cal(k,mid,i)) b=i; f[k][mid]=cal(k,mid,b); solve(k,l,mid-1,ql,b); solve(k,mid+1,r,b,qr);&#125; int main()&#123; cin &gt;&gt; n &gt;&gt; k; for(int i=0;i&lt;n;i++) scanf("%d%d",&amp;t[i].w,&amp;t[i].h); sort(t,t+n); s[0]=1LL*t[0].h*t[0].w,w[0]=t[0].w; for(int i=1;i&lt;n;i++)&#123; s[i]=1LL*t[i].h*t[i].w+s[i-1]; w[i]=t[i].w+w[i-1]; &#125; for(int i=0;i&lt;n;i++) f[1][i]=s[i]-1LL*t[0].h*w[i]; for(int i=2;i&lt;=k;i++) solve(i,i-1,n-1,i-2,n-2); printf("%lld",f[k][n-1]);&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Summer Training 5 题解]]></title>
    <url>%2F2019%2F08%2F17%2F2019summertraining-5%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 7/10 Ø O . O O . . O Ø O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 题目来源：2019牛客暑期多校训练营第九场 比赛链接 A 题目描述设斐波那契数列为$f[i]$，求$\sum_{i=1}^{n}f[i]^m% 10^9$。 解题思路求出$\sum_{i=1}^{n}f[i]^m% 2^9,\sum_{i=1}^{n}f[i]^m% 5^9$的循环节，乘出来再中国剩余定理合并即可。 AC代码 - by qxforever点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 5e7;const int mod1 = pow(2,9);const int mod2 = pow(5,9);const int len1=768;const int len2=7812500;int f1[len1+3],f2[len2+3];int g1[len1+3],g2[len2+3];ll n,ans1,ans2;int m; int qpow(int a,int b,int mod)&#123; int ans=1; int base=a; while(b!=0)&#123; if(b&amp;1) ans=(1LL*ans*base)%mod; base=(1LL*base*base)%mod; b&gt;&gt;=1; &#125; return ans;&#125; void getf()&#123; #define f f1 f[0]=0,f[1]=1;g1[1]=1; for(int i=2;i&lt;=len1;i++)&#123; f[i]=f[i-1]+f[i-2];if(f[i]&gt;=mod1) f[i]-=mod1; g1[i]=qpow(f[i],m,mod1)+g1[i-1]; if(g1[i]&gt;=mod1) g1[i]-=mod1; &#125; #undef f #define f f2 f[0]=0,f[1]=1;g2[1]=1; for(int i=2;i&lt;=len2;i++)&#123; f[i]=f[i-1]+f[i-2];if(f[i]&gt;=mod2) f[i]-=mod2; g2[i]=g2[i-1]+qpow(f[i],m,mod2); if(g2[i]&gt;=mod2) g2[i]-=mod2; &#125; #undef f&#125; void calc(ll tmp1,ll tmp2)&#123; ll d; d=n/len1;ans1+=(d%mod1)*tmp1%mod1; d=n/len2;ans2+=(d%mod2)*tmp2%mod2; d=n%len1; //printf("%lld\n",ans1); ans1+=g1[d];if(ans1&gt;=mod1) ans1-=mod1; d=n%len2; ans2+=g2[d];if(ans2&gt;=mod2) ans2-=mod2;&#125;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0)&#123; x=1,y=0; return a; &#125; int gcd=exgcd(b,a%b,x,y); int t=x; x=y; y=t-a/b*y; return gcd;&#125; int china()&#123; int w[]=&#123;512,1953125&#125;,b[]=&#123;ans1,ans2&#125;,k=2; int x,y,a,m,n; a=0,n=1000000000; for(int i=0;i&lt;k;i++)&#123; m=n/w[i]; exgcd(w[i],m,x,y); a=(1LL*a+1LL*y*m*b[i])%n; &#125; return a&gt;0 ? a : a+n;&#125; int main()&#123; cin &gt;&gt; n &gt;&gt; m; getf(); int tmp1=0,tmp2=0; tmp1=g1[len1-1]; tmp2=g2[len2-1]; calc(tmp1,tmp2); //printf("%lld %lld\n",tmp1,tmp2); printf("%d\n",china());&#125; B 题目描述$(x+y)\space mod \space p=b$ $(x\times y)\space mod \space p=c$ 求$x,y$。 解题思路很容易化成一个二次剩余的式子。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;typedef long long ll;#define rg register#define il inline#define co consttemplate&lt;class T&gt;il T read()&#123; rg T data=0,w=1; rg char ch=getchar(); while(!isdigit(ch))&#123; if(ch=='-') w=-1; ch=getchar(); &#125; while(isdigit(ch)) data=data*10+ch-'0',ch=getchar(); return data*w;&#125;template&lt;class T&gt;il T read(rg T&amp;x)&#123; return x=read&lt;T&gt;();&#125;ll b,c,n,mod=1000000007;ll add(ll x,ll y)&#123; return (x+y)%mod;&#125;ll mul(ll x,ll y)&#123; return x*y%mod;&#125;ll pow(ll x,ll k)&#123; x%=mod,k%=(mod-1); ll re=1; for(;k;k&gt;&gt;=1,x=mul(x,x)) if(k&amp;1) re=mul(re,x); return re;&#125;ll omega;struct complex&#123;ll a,b;&#125;;complex operator*(co complex&amp;x,co complex&amp;y)&#123; return (complex)&#123;add(mul(x.a,y.a),mul(x.b,mul(y.b,omega))),add(mul(x.a,y.b),mul(x.b,y.a))&#125;;&#125;complex operator^(complex x,ll k)&#123; complex re=(complex)&#123;1,0&#125;; for(;k;k&gt;&gt;=1,x=x*x) if(k&amp;1) re=re*x; return re;&#125;ll sqrt(ll n)&#123; n%=mod; if(!n) return 0; ll a=rand()%mod; while(pow(add(mul(a,a),mod-n),(mod-1)/2)!=mod-1) a=rand()%mod; omega=add(mul(a,a),mod-n); return ((complex)&#123;a,1&#125;^(mod+1)/2).a;&#125;int main()&#123; int kase=read&lt;int&gt;(); while(kase--)&#123; read(b);read(c); n=(b*b-4*c%mod+mod)%mod; if(!n)&#123; ll tmp=b; if(b%2)b+=mod; printf("%lld %lld\n",b/2,b/2); continue; &#125; if(pow(n,(mod-1)/2)!=1)&#123;puts("-1 -1");continue;&#125; ll ans1=sqrt(n),ans2=mod-ans1; if(ans1&gt;ans2) std::swap(ans1,ans2); ll tmp=b+ans1; if(tmp%2)ans1+=mod; tmp=ans1+b; ll x=tmp/2%mod; ll y=(b-ans1)/2%mod; if(y&lt;0)y+=mod; if(x&gt;y)std::swap(x,y); printf("%lld %lld\n",x,y); &#125; return 0;&#125; C 题目描述解题思路AC代码点击 12 D 题目描述从$n$个元素中选，问能否组成$s$。 解题思路中途相遇法板子题。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll a[40],sum[(1&lt;&lt;18)+10];map&lt;ll,int&gt;mp;int main()&#123; int i,j,n; ll s; scanf("%d%lld",&amp;n,&amp;s); for(i=0;i&lt;n;i++)scanf("%lld",&amp;a[i]); for(i=0;i&lt;(1&lt;&lt;(n/2));i++)&#123; ll tmp=0; for(j=0;j&lt;n/2;j++)if(i&amp;(1&lt;&lt;j))tmp+=a[j]; mp[s-tmp]=i; &#125; ll left,right; for(i=0;i&lt;(1&lt;&lt;(n-n/2));i++)&#123; ll tmp=0; for(j=n/2;j&lt;n;j++)if(i&amp;(1&lt;&lt;(j-n/2)))tmp+=a[j]; if(mp.count(tmp)!=0)&#123; left=mp[tmp]; right=i; break; &#125; &#125; for(i=0;i&lt;n/2;i++)&#123; if(left&amp;(1&lt;&lt;i))printf("1"); else printf("0"); &#125; for(i=0;i&lt;(n-n/2);i++)&#123; if(right&amp;(1&lt;&lt;i))printf("1"); else printf("0"); &#125; return 0;&#125; E 题目描述问从$n$个人中选择$4$个互不认识的人的方法数，有$m$次操作每次添加一条边$u,v$，使得$u$的朋友和$v$的朋友互相认识。 解题思路并查集，分别维护两个人、四个人的种数即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;int T;const int maxn = 1e5+23;int f[maxn];ull sz[maxn];int n,m; int find(int x)&#123; return x==f[x] ? x : f[x]=find(f[x]);&#125; void init()&#123; for(int i=0;i&lt;=n;i++) f[i]=i; for(int i=1;i&lt;=n;i++) sz[i]=1;&#125; int main()&#123; cin &gt;&gt; n &gt;&gt; m ; init(); ull ans=0,last=0; ans=(ull)n*(n-1)/2*(n-2)/3*(n-3)/4; last=(ull)n*(n-1)/2; printf("%llu\n",ans); for(int i=0;i&lt;m;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); int x=find(u),y=find(v); if(x!=y)&#123; ull t=n-sz[x]-sz[y]; ans=ans-sz[x]*sz[y]*(last-sz[x]*sz[y]-sz[x]*t-sz[y]*t); last-=sz[x]*sz[y]; f[x]=y; sz[y]+=sz[x]; &#125; printf("%llu\n",ans); &#125;&#125; F 题目描述解题思路AC代码点击 12 G 题目描述解题思路AC代码点击 12 H 题目描述砍树，区间砍$y$次，问第$x$次砍到多高。 解题思路主席树 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long ll;const int N=800010;int a[N],b[N];int n,m,tot;int root[N],L[N&lt;&lt;3],R[N&lt;&lt;3];ll sum[N&lt;&lt;3],cnt[N&lt;&lt;3];int size;int build(int l,int r)&#123; int now=++tot; if(l&lt;r)&#123; L[now]=build(l,mid); R[now]=build(mid+1,r); &#125; return now;&#125;int update(int root,int l,int r,int x)&#123; int now=++tot; L[now]=L[root]; R[now]=R[root]; cnt[now]=cnt[root]+1; if(l&lt;r)&#123; if(x&lt;=mid)L[now]=update(L[root],l,mid,x); else R[now]=update(R[root],mid+1,r,x); sum[now]=sum[L[now]]+sum[R[now]]; cnt[now]=cnt[L[now]]+cnt[R[now]]; &#125;else&#123; sum[now]=sum[root]+b[l]; &#125; return now;&#125;double query(int lt,int rt,int l,int r,double x,double rightremain,double leftsum)&#123; if(l&gt;=r)&#123; rightremain+=cnt[rt]-cnt[lt]; return (x-leftsum)/rightremain; &#125; ll t=leftsum+rightremain*b[mid];//左区间最靠右的 t+=cnt[R[rt]]*b[mid]+sum[L[rt]]; t-=cnt[R[lt]]*b[mid]+sum[L[lt]]; if(t&gt;=x)return query(L[lt],L[rt],l,mid,x,rightremain+cnt[R[rt]]-cnt[R[lt]],leftsum); return query(R[lt],R[rt],mid+1,r,x,rightremain,leftsum+sum[L[rt]]-sum[L[lt]]);&#125;double solve(int l,int r,int x,int y)&#123; double s=sum[root[r]]-sum[root[l-1]]; double remain=s-s/y*x; double res=query(root[l-1],root[r],1,size,remain,0,0); return res;&#125;int main()&#123; int i,x,y,z; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),b[i]=a[i]; sort(b+1,b+1+n); size=unique(b+1,b+1+n)-b-1; root[0]=build(1,size); for(i=1;i&lt;=n;i++)root[i]=update(root[i-1],1,size,lower_bound(b+1,b+1+size,a[i])-b); while(m--)&#123; int l,r,x,y; scanf("%d%d%d%d",&amp;l,&amp;r,&amp;x,&amp;y); printf("%.8f\n",solve(l,r,x,y)); &#125; return 0;&#125; I 题目描述求$\sum_{k=1}^n(kM)\ &amp;M$。 解题思路对于$M$二进制的每一位$j$，对答案的贡献显然为$2^{\sum_{i=1}^{n}\frac {i\times M}{2^j}-\frac{i\times M}{2^{j+1}}\times 2}$，这可以用类欧几里得算法算出。 AC代码点击 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll mod=1000000007;__int128 f(__int128 a,__int128 b,__int128 c,__int128 n)&#123; __int128 m=(a*n+b)/c; if(!m||!a)return 0; if(a&gt;=c||b&gt;=c)return (n*(n+1)/2%mod*(a/c)%mod+(b/c)*(n+1)%mod+f(a%c,b%c,c,n))%mod; else return (m*n%mod-f(c,c-b-1,a,m-1)+mod)%mod;&#125;int main()&#123; int i; ll n,m,ans=0; scanf("%lld%lld",&amp;n,&amp;m); for(i=0;i&lt;60;i++) if((1LL&lt;&lt;i)&amp;m) (ans+=(((f(m,0,1ll&lt;&lt;i,n)-f(m,0,1ll&lt;&lt;(i+1),n)*2%mod+mod)%mod)&lt;&lt;i)%mod)%=mod; printf("%lld",ans); return 0;&#125; J 题目描述有一堆矩形，找到某条线，每个矩形贡献为关于这条线对称的面积，求最大答案。 解题思路就三种情况，离散化之后算一算就行。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 3e5+23; struct E&#123; unsigned int s; bool si;&#125;;E e[maxn*3];bool cmp(E a,E b)&#123; return a.s&lt;b.s;&#125;int n;int cnt=0;int main()&#123; cin &gt;&gt; n ; for(int i=0;i&lt;n;i++)&#123; scanf("%u%u",&amp;e[cnt].s,&amp;e[cnt+1].s); e[cnt].s*=2; e[cnt+1].s*=2; e[cnt+2].s=(e[cnt].s+e[cnt+1].s)/2; e[cnt].si=true,e[cnt+1].si=true,e[cnt+2].si=false; cnt+=3; &#125; sort(e,e+cnt,cmp); int now=0;ll ans=0,mx=0; if(e[0].si) now=1; for(int i=1;i&lt;cnt;i++)&#123; //printf("? %d %lld\n",now,ans); ans+=(1LL*now*(e[i].s-e[i-1].s)); mx=max(ans,mx); if(e[i].si) now+=1; else now-=2; &#125; cout &lt;&lt; mx ;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Summer Training 4 题解]]></title>
    <url>%2F2019%2F08%2F14%2F2019summertraining-4%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L 11/12 O Ø . O Ø Ø O O Ø O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 题目来源：Egyptian Collegiate Programming Contest 2017 (ACM ECPC 2017) 沙雕比赛，沙雕数据（手动再见 比赛链接 pdf A Assessments 题目描述$n$个人站一排，有$k$轮，每轮有$p$的概率交换某两个相邻的人，问经过这些轮之后，$x$和$y$两人互换位置的概率。 解题思路设$dp[i][j][k]$表示第$i$轮后，$x$的位置在$j$，$y$的位置在$k$的概率，转移显然。 口头AC，还没写代码，扔个队友的算了 AC代码 - by qxforever点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std; const int maxn = 52;const int maxk = 3e3+23;double dp[maxk][maxn][maxn];int n,x,y,k,T;double p;int main()&#123; freopen("assessment.in","r",stdin); scanf("%d",&amp;T);int cas=1; while(T--)&#123; printf("Case %d: ",cas++); memset(dp,0,sizeof(dp)); scanf("%d%lf%d%d%d",&amp;n,&amp;p,&amp;x,&amp;y,&amp;k); if(n==1) &#123;printf("1.00000\n");continue;&#125; dp[0][x][y]=1; if(x==y)&#123; for(int i=1;i&lt;=k;i++)&#123; for(int j=0;j&lt;n;j++)&#123; int cnt=0; if(j&gt;=1) dp[i][j][x]+=dp[i-1][j-1][x],cnt++; if(j&lt;n-1) dp[i][j][x]+=dp[i-1][j+1][x],cnt++; dp[i][j][x]+=dp[i-1][j][x]*(n-1-cnt); dp[i][j][x]=(dp[i][j][x]*p)/(n-1); dp[i][j][x]+=dp[i-1][j][x]*(1-p); &#125; &#125; printf("%.5lf\n",dp[k][x][x]); continue; &#125; dp[0][x][y]=1; for(int i=1;i&lt;=k;i++)&#123; for(int j=0;j&lt;n;j++)&#123; for(int k=0;k&lt;n;k++)&#123; if(j==k) continue; int cnt=0; if(abs(j-k)!=1)&#123; if(j&gt;=1) dp[i][j][k]+=dp[i-1][j-1][k],cnt++; if(j&lt;n-1) dp[i][j][k]+=dp[i-1][j+1][k],cnt++; if(k&gt;=1) dp[i][j][k]+=dp[i-1][j][k-1],cnt++; if(k&lt;n-1) dp[i][j][k]+=dp[i-1][j][k+1],cnt++; &#125; else&#123; if(j-k==1)&#123; dp[i][j][k]+=dp[i-1][k][j],cnt++; if(j&lt;n-1) dp[i][j][k]+=dp[i-1][j+1][k],cnt++; if(k&gt;=1) dp[i][j][k]+=dp[i-1][j][k-1],cnt++; &#125; else&#123; dp[i][j][k]+=dp[i-1][k][j],cnt++; if(k&lt;n-1) dp[i][j][k]+=dp[i-1][j][k+1],cnt++; if(j&gt;=1) dp[i][j][k]+=dp[i-1][j-1][k],cnt++; &#125; &#125; dp[i][j][k]+=(dp[i-1][j][k]*(n-cnt-1)); dp[i][j][k]=(dp[i][j][k]*p)/(n-1); dp[i][j][k]+=dp[i-1][j][k]*(1-p); //printf("%d %d %d\n",j,k,cnt); &#125; &#125; &#125; printf("%.5lf\n",dp[k][y][x]); &#125;&#125; B Breaking the Curse 题目描述给两个字符串，$q$次询问，每次询问$s$中一个区间$[l,r]$，问有多少个$[l,r]$的子区间$[l_i,r_i]$满足$s[l_i,r_i]\in t$。 解题思路我们假设$s$中以$s_i$结尾的串中，能够匹配的最长串的左端点为$left_i$，最长串的长度为$length_i$。很容易得出结论：$left_i$是单调不减的。（如果后面的比前面匹配的更靠前，那么显然前面也应当往前匹配） 考虑如何求$length_i$。对$t$建一个后缀自动机，根据后缀自动机的性质，从根节点任意沿着匹配边走的路径都是一个后缀的前缀，所以从根节点开始跑，每次如果有匹配边那就沿着匹配边走，匹配长度$+1$；否则沿着父亲边走，匹配长度更新为节点对应的最大长度$len[p]$。这样可以线性的求出$length_i$，$left_i$也可顺带求出。 处理询问的时候，一个区间中可以找到一个分界点$x$，在$x$左边的点都是最左端延伸到左端点之外的，而在$x$右边的点是可以把所有合法区间都加入答案贡献中的。于是每次二分一下$x$，两边分别用组合数和前缀和计算一下即可。 复杂度$O(T(n+q\log n))$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 200010#define P 27char s[N],t[N];ll sum[N],lef[N];struct SAM&#123; int tr[N&lt;&lt;1][P],fa[N&lt;&lt;1],len[N&lt;&lt;1],siz[N&lt;&lt;1]; int cnt,last; void init()&#123; cnt=last=1; memset(tr[1],0,sizeof(tr[1])); fa[1]=len[1]=0; &#125;//dont forget!!! void add(int c)&#123; int p=last,np=++cnt; memset(tr[cnt],0,sizeof(tr[cnt])); siz[np]=1; last=np; len[np]=len[p]+1; while(p&amp;&amp;!tr[p][c])tr[p][c]=np,p=fa[p]; if(!p)fa[np]=1; else&#123; int q=tr[p][c]; if(len[q]==len[p]+1)fa[np]=q; else&#123; int nq=++cnt; len[nq]=len[p]+1; memcpy(tr[nq],tr[q],sizeof(tr[q])); fa[nq]=fa[q]; fa[q]=fa[np]=nq; while(tr[p][c]==q)tr[p][c]=nq,p=fa[p]; &#125; &#125; &#125; void insert(char a[])&#123; int i; for(i=0;a[i];i++)add(a[i]-'a');//can be changed &#125; void process(char a[])&#123; int i,now=1,l=0; for(i=0;a[i];i++)&#123; while(now!=1&amp;&amp;!tr[now][a[i]-'a'])now=fa[now],l=len[now]; if(tr[now][a[i]-'a'])now=tr[now][a[i]-'a'],l++; lef[i+1]=i+2-l; sum[i+1]=sum[i]+l; &#125; &#125;&#125;sam;int main()&#123; int i,T,q,Cas; freopen("curse.in","r",stdin); scanf("%d",&amp;T); for(Cas=1;Cas&lt;=T;Cas++)&#123; sam.init(); printf("Case %d:\n",Cas); scanf("%s%s",s,t); sam.insert(t); sam.process(s); scanf("%d",&amp;q); while(q--)&#123; int l,r; scanf("%d%d",&amp;l,&amp;r); int L=l,R=r+1; while(L&lt;R)&#123; int mid=(L+R)&gt;&gt;1; if(lef[mid]&lt;l)L=mid+1; else R=mid; &#125; printf("%lld\n",sum[r]-sum[L-1]+1LL*(L-l+1)*(L-l)/2); &#125; &#125; return 0;&#125; C Cheering Parabolas 题目描述解题思路AC代码点击 12 D Dream Team 题目描述神秘原题 解题思路见上面链接的E题。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n,a[100010],f[100010],map[100010];int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;int main()&#123; int i,j,k,l,t,m; scanf("%d",&amp;t); while(t--)&#123; long long ans=0,max; int temp,p,q,u[2]=&#123;0&#125;,now=0,cnt=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); sort(a+1,a+n+1); max=a[n]; for(i=1;i&lt;n;i++)if(a[i]==a[i+1])ans+=a[i],cnt++; for(i=1;i&lt;=n;i++)map[a[i]]=i; for(i=1;i&lt;=n;i++)f[i]=i; for(i=max;i;i--)&#123; now=u[0]=u[1]=0; for(j=1;j*i&lt;=max;j++)&#123; if(map[j*i])&#123; u[now]=map[j*i]; if(u[now^1])&#123; p=find(u[now]); q=find(u[now^1]); if(p!=q)&#123; ans+=i; f[p]=q; cnt++; &#125; &#125; now^=1; &#125; &#125; if(cnt==n-1)break; &#125; printf("%lld\n",ans); memset(map,0,sizeof(map)); &#125; return 0;&#125; E Evaluations 题目描述给一棵有边权的树，定义两点$u,v$之间的一个函数$f(u,v)$为$u$到$v$路径权值的积，问有多少对$u,v$满足$f(u,v)$为两个不同质数的乘积。 解题思路可以考虑点分治，记录通过根节点的边权乘积分别为$1$、质数、两不同质数乘积的个数即可求出。但这个方法貌似是$O(Tn\log n)$的，会$T$掉。考虑线性做法。 对边做文章，把连续的边权为$1$的通过并查集并起来，记录$1$的数量$cnt$，方便查询。对于某个边权为$w$的边$(u,v)$，计算其对答案的贡献$x$。如果$w$为两个不同质数的乘积，答案即为$cnt_u\times cnt_v$；如果$w$为质数，答案即为前面统计过的$sz_u\times cnt_v+sz_v\times cnt_u$，其中$sz_i$表示已计算的$i$连出的边权乘积一个质数的个数。为了保证结果是两个不同的质数的乘积，用一个$map$去掉重复的即可。 没来得及写，扔一个队友的代码： AC代码 - by qxforever点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5+23;typedef pair&lt;int,int&gt; pii;int T,n;int f[maxn];int u[maxn],v[maxn],w[maxn],cnt[maxn];int pri[maxn],vis[maxn],tot=0;int sat[maxn],sz[maxn];map&lt;int,int&gt; m[maxn];void sieve()&#123; int N=1e5+3; vis[0]=vis[1]=1; for(int i=2;i&lt;=N;i++)&#123; if(!vis[i]) pri[tot++]=i; for(int j=0;j&lt;tot&amp;&amp;(pri[j]*i)&lt;=N;j++)&#123; vis[i*pri[j]]=1; if(i%pri[j]==0) break; &#125; &#125; for(int i=0;i&lt;tot;i++)&#123; for(int j=0;j&lt;tot&amp;&amp;(pri[i]*pri[j])&lt;=N;j++)&#123; if(j==i) continue; sat[pri[i]*pri[j]]=1; &#125; &#125;&#125; void init()&#123; for(int i=1;i&lt;=n;i++) f[i]=i; memset(sz,0,sizeof(sz));&#125; int find(int x)&#123; return x==f[x] ? x : f[x]=find(f[x]);&#125; void count()&#123; memset(cnt,0,sizeof(cnt)); for(int i=1;i&lt;=n;i++)&#123; cnt[find(i)]++; &#125;&#125; int main()&#123; freopen("evaluations.in","r",stdin); cin &gt;&gt; T ; int cas=1; sieve(); while(T--)&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) m[i].clear(); printf("Case %d: ",cas++); init(); for(int i=0;i&lt;n-1;i++)&#123; scanf("%d%d%d",u+i,v+i,w+i); if(w[i]==1)&#123; int x=find(u[i]),y=find(v[i]); f[x]=y; &#125; &#125; count(); ll ans=0; for(int i=0;i&lt;n-1;i++)&#123; int x=find(u[i]),y=find(v[i]); if(sat[w[i]])&#123; ans+=(1LL*cnt[x]*cnt[y]); &#125; if(!vis[w[i]])&#123; ans+=1LL*(sz[x]-m[x][w[i]])*cnt[y]; ans+=1LL*(sz[y]-m[y][w[i]])*cnt[x]; sz[x]+=cnt[y]; sz[y]+=cnt[x]; m[x][w[i]]+=cnt[y]; m[y][w[i]]+=cnt[x]; &#125; &#125; printf("%lld\n",ans); &#125;&#125; F Forgot the Flag! 题目描述给一个凸多边形，两个点，问其中一个点到凸多边形边界再到另一个点总路径最小值是多少。 解题思路没计算几何板子，就暴力对于每个边每个点求…求镜像点，求两直线交点… 细节有点多，不赘述了，肯定有套板子的好方法。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;double x[50010],y[50010];double dis(int ind,double X,double Y)&#123; return (X-x[ind])*(X-x[ind])+(Y-y[ind])*(Y-y[ind]);&#125;int main()&#123; int i,j,n,T,q; freopen("flags.in","r",stdin); scanf("%d",&amp;T); for(i=1;i&lt;=T;i++)&#123; printf("Case %d:\n",i); scanf("%d",&amp;n); for(j=0;j&lt;n;j++)scanf("%lf%lf",&amp;x[j],&amp;y[j]); x[n]=x[0],y[n]=y[0]; scanf("%d",&amp;q); while(q--)&#123; double A,B,C,D; scanf("%lf%lf%lf%lf",&amp;A,&amp;B,&amp;C,&amp;D); double ans=4e18,tx,ty; for(j=0;j&lt;n;j++)&#123; double dist=dis(j,A,B); double t=sqrt(dist)+dis(j,C,D); if(ans&gt;t)&#123; ans=t; tx=x[j]; ty=y[j]; &#125; double x1=x[j],y1=y[j],x2=x[j+1],y2=y[j+1]; double a,b,c; if(abs(x1-x2)&lt;1e-9)a=1,b=0,c=-x1; else&#123; double k=(y2-y1)/(x2-x1); double b2=y2-x2*k; a=k;b=-1;c=b2; &#125; double ds=abs(a*A+b*B+c)/sqrt(a*a+b*b),mx,my; if(abs(x1-x2)&lt;1e-9)&#123; mx=x1; my=B; &#125;else&#123; double k=(y2-y1)/(x2-x1); double dx=sqrt(dist-ds*ds)/sqrt(1+k*k); double dy=dx*k; if(dis(j,A,B)+(x[j]-x[j+1])*(x[j]-x[j+1])+(y[j]-y[j+1])*(y[j]-y[j+1])&lt;dis(j+1,A,B))&#123;//钝角 mx=x1-(x2&lt;x1?-dx:dx); my=y1-(x2&lt;x1?-dy:dy); &#125;else&#123; mx=x1+(x2&lt;x1?-dx:dx); my=y1+(x2&lt;x1?-dy:dy); &#125; &#125; double refx=2*mx-A,refy=2*my-B; double inx,iny; double a2,b2,c2; if(abs(refx-C)&lt;1e-9)a2=1,b2=0,c2=-x1; else&#123; double k=(D-refy)/(C-refx); double b3=D-C*k; a2=k;b2=-1;c2=b3; &#125; iny=(a2*c-a*c2)/(a*b2-a2*b); inx=(b2*c-b*c2)/(b*a2-b2*a); if((inx-x1)*(x2-x1)&lt;-1e-9)continue; t=sqrt((C-refx)*(C-refx)+(D-refy)*(D-refy)); if(ans&gt;t)&#123; ans=t; tx=inx; ty=iny; &#125; &#125; printf("%.7f %.7f %.7f\n",ans,tx,ty); &#125; &#125; return 0;&#125; G Glorious Stadium 题目描述圆和多边形互相套，求阴影部分面积。 解题思路推出式子等比数列求和即可。 AC代码 - by qxforever点击 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const double pi = acos(-1.0);int n,r,k,T; double qpow(double a,int b)&#123; double ans=1,base=a; while(b!=0)&#123; if(b&amp;1!=0) ans*=base; base*=base; b&gt;&gt;=1; &#125; return ans;&#125; int main()&#123; freopen("glorious.in","r",stdin); cin &gt;&gt; T; int cas=1; while(T--)&#123; scanf("%d%d%d",&amp;k,&amp;r,&amp;n); double the = pi*(n-2)/n; double a=(2*1.0*r)/tan(the/2); double phi=pi/n; double h=a/(2*tan(phi)); double s1=(a*h/2)*n-pi*r*r; double q=1/(tan(the/2)*sin(phi)); q=q*q; double S=s1*(1-qpow(q,k))/(1-q); printf("Case %d: %.5f\n",cas++,S); &#125;&#125; H Half Nice Years 题目描述给一个区间，问区间中存不存在一个数，这个数左右两部分不互质。 解题思路暴力从大到小枚举处理左端。 AC代码点击 1待补 I Important matches 题目描述$q$次询问某个问子矩阵中位数。 解题思路不会$cdq$分治，暴力三维树状数组卡常通过。 $cdq$分治留坑 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;algorithm&gt;typedef long long ll;int bit[202][202][2003],n,m,mx;#define lb(x) ((x)&amp;(-(x)))void upd(int px,int py,int pz)&#123; int i,j,k; for(i=px;i&lt;=n;i+=lb(i))for(j=py;j&lt;=m;j+=lb(j))for(k=pz;k&lt;=mx;k+=lb(k)) ++bit[i][j][k];&#125;void upd2(int px,int py,int pz)&#123; int i,j,k; for(i=px;i&lt;=n;i+=lb(i))for(j=py;j&lt;=m;j+=lb(j))for(k=pz;k&lt;=mx;k+=lb(k)) --bit[i][j][k];&#125;int que(int px,int py,int pz)&#123; int i,j,k,ans=0; for(i=px;i;i-=lb(i))for(j=py;j;j-=lb(j))for(k=pz;k;k-=lb(k)) ans+=bit[i][j][k]; return ans;&#125;int num(int a,int b,int c,int d,int mid)&#123; int q1=que(c,d,mid); int q2=que(a-1,d,mid); int q3=que(c,b-1,mid); int q4=que(a-1,b-1,mid); return q1-q2-q3+q4;&#125;inline int read() &#123; char ch=getchar();int x=0,f=1; while(ch&lt;'0'||ch&gt;'9')&#123; if(ch=='-')f=-1; ch=getchar(); &#125; while('0'&lt;=ch&amp;&amp;ch&lt;='9')&#123; x=x*10+ch-'0'; ch=getchar(); &#125; return x*f;&#125;char buf[100];void print(const int&amp; x) &#123; int tmp=x,s=0; while(tmp&gt;0)&#123; buf[s++]=tmp%10+'0'; tmp/=10; &#125; while(s&gt;0)putchar(buf[--s]);&#125;int mt[210][210];int main()&#123; int Cas,i,j,t,q,a,b,c,d; freopen("important.in","r",stdin); t=read(); for(Cas=1;Cas&lt;=t;Cas++)&#123; mx=1; printf("Case %d:\n",Cas); n=read();m=read();q=read(); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; mt[i][j]=read(); mx=std::max(mx,mt[i][j]+1); &#125; &#125; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; upd(i,j,mt[i][j]+1); &#125; &#125; while(q--)&#123; a=read();b=read();c=read();d=read(); int sz=(d-b+1)*(c-a+1); sz=(sz+2)/2; int l=1,mid,r=mx; while(l&lt;r)&#123; mid=(l+r)&gt;&gt;1; int nm=num(a,b,c,d,mid); if(nm&gt;=sz)r=mid; else if(nm&lt;sz)l=mid+1; &#125; print(l-1);puts(""); &#125; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++) upd2(i,j,mt[i][j]+1); &#125; return 0;&#125; J Jacked Tickets 题目描述给一个凸函数$f$，给定$n,p$，求把$n$分为$a_1,a_2…a_p$，满足$\sum_{i=1}^p a_i=n$且$a_i\geq 1$，最小化$\sum_{i=1}^pf(a_i)$。 解题思路显然尽量平均分就是满足条件的。 AC代码 - by Mogg点击 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include &lt;vector&gt;using namespace std;typedef long long ll; const int ms = 1e5 + 15; int n, tmp;ll p[ms]; int main()&#123; int t; freopen("jacking.in", "r", stdin); scanf("%d", &amp;t); int cas = 0; while (t--) &#123; cas++; printf("Case %d:\n", cas); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%lld", &amp;p[i]); &#125; int k, l, r; scanf("%d", &amp;k); for (int i = 0; i &lt; k; ++i) &#123; scanf("%d%d", &amp;l, &amp;r); if (l &lt; r) &#123; printf("impossible\n"); continue; &#125; tmp = l / r; printf("%lld\n", p[tmp + 1] * (l - tmp * r) + p[tmp] * ((tmp + 1)*r - l)); &#125; &#125;&#125; K Katryoshka 题目描述给几个原材料和配方，求最多能做物品的个数。 解题思路签到，贪心即可。 AC代码点击 1234567891011121314151617#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int main()&#123; int i,n,a,b,c; freopen("katryoshka.in","r",stdin); scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)&#123; int ans=0; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); ans+=min(a,min(b,c)); a-=ans,b-=ans,c-=ans; ans+=min(a/2,c); printf("Case %d: %d\n",i,ans); &#125; return 0;&#125; L Lazy ERCD 题目描述比赛规则是每场比赛淘汰失败的队伍，问一共要看多少场比赛。 解题思路签到，显然是$n-1$场。 AC代码点击 123456789101112#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int main()&#123; int i,n,T; freopen("lazy.in","r",stdin); scanf("%d",&amp;T); for(i=1;i&lt;=T;i++)&#123; scanf("%d",&amp;n); printf("Case %d: %d\n",i,n-1); &#125;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Summer Training 3 题解]]></title>
    <url>%2F2019%2F08%2F12%2F2019summertraining-3%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 7/10 Ø O O Ø Ø . O . . Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 题目来源：2019牛客暑期多校训练营第八场 比赛链接 A 题目描述问一个$01$矩阵中有多少个极大全$1$子矩形。 解题思路扫描先处理一遍，枚举每一行作为底边，对这条底边上任意一个点$i$，只要$[l_i,r_i]$不是被包含在$[l_{i+1},r_{i+1}]$里，就能构成一个极大的矩形。每行记录一下是否计算过左右端分别为$[l,r]$的矩形防止多次计算即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 3005char a[N];int l[N][N],r[N][N],u[N][N],mt[N][N];int vis[N][N];int main()&#123; int i,j,n,m,ans=0; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)&#123; scanf("%s",a); for(j=1;j&lt;=m;j++)mt[i][j]=a[j-1]-'0'; &#125; memset(r,0x3f,sizeof(r)); for(i=1;i&lt;=n;i++)&#123; int lm=0,rm=m+1; for(j=1;j&lt;=m;j++)&#123; if(mt[i][j])&#123; if(i==1)l[i][j]=lm+1; else l[i][j]=max(l[i-1][j],lm+1); u[i][j]=u[i-1][j]+1; &#125;else lm=j; &#125; for(j--;j;j--)&#123; if(mt[i][j])&#123; if(i==1)r[i][j]=rm-1; else r[i][j]=min(r[i-1][j],rm-1); &#125;else rm=j; &#125; &#125; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; if(!mt[i][j])continue; int L=l[i][j],R=r[i][j]; if(vis[L][R]==i)continue; vis[L][R]=i; if(i==n||!mt[i+1][j]||l[i+1][j]&gt;L||r[i+1][j]&lt;R)ans++; &#125; &#125; printf("%d",ans); return 0;&#125; B 题目描述给一个数列，求所有连续非零子序列的美丽值，其中一个序列的美丽值定义为其中不同元素的个数。 解题思路枚举每一位结尾的贡献，记录一下每个数最后出现的位置即可。 AC代码点击 1234567891011121314151617#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,a,last[100010];ll s,f[100010];int main()&#123; int i; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a); f[i]=f[i-1]+(i-last[a]); last[a]=i; s+=f[i]; &#125; printf("%d",s); return 0;&#125; C 题目描述求一个$m=2^k$维的、只由$1,-1$构成的$m$个互相垂直的向量。 解题思路$m=2$时，向量组可以写为$A_2=\left(\begin{aligned}1\space {1}\\ -1\space{1}\end{aligned}\right) $ $m=2^k$时，向量组可以写为$A_k=\left(\begin{aligned}A_{k-1}\space {A_{k-1}}\\ -A_{k-1}\space{A_{k-1}}\end{aligned}\right) $ 可行性显然。 AC代码点击 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n;int mt[2000][2000];int main()&#123; int i,j,k; mt[0][0]=mt[0][1]=mt[1][1]=1;mt[1][0]=-1; for(i=1;i&lt;10;i++)&#123; for(j=0;j&lt;(1&lt;&lt;i);j++)&#123; for(k=0;k&lt;(1&lt;&lt;i);k++)&#123; mt[(1&lt;&lt;i)+j][k]=mt[j][k]; mt[(1&lt;&lt;i)+j][(1&lt;&lt;i)+k]=mt[j][k]; mt[j][(1&lt;&lt;i)+k]=-mt[j][k]; &#125; &#125; &#125; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)printf("%d ",mt[i][j]); puts(""); &#125; return 0;&#125; D 题目描述$q$次操作，每次可能在$(x,y,z)$点插入一个标签，也可能问离$(x,y,z)$曼哈顿距离最近的标签离它有多远。 解题思路维护八个三维树状数组，表示坐标原点分别在限制范围长方体的八个顶点上的时候，对应的有标签的$x+y+z$的最大值，每次按照坐标原点对应移动暴力询问即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,m,h,q;int bit[10][500110];int id(int i,int j,int k)&#123;return i*m*h+j*h+k;&#125;int lb(int x)&#123;return x&amp;(-x);&#125;void upd(int px,int py,int pz,int ind,int x)&#123; int i,j,k; for(i=px;i&lt;=n;i+=lb(i))for(j=py;j&lt;=m;j+=lb(j))for(k=pz;k&lt;=h;k+=lb(k)) bit[ind][id(i,j,k)]=max(x,bit[ind][id(i,j,k)]);&#125;int que(int px,int py,int pz,int ind)&#123; int i,j,k,ans=-1e8; for(i=px;i;i-=lb(i))for(j=py;j;j-=lb(j))for(k=pz;k;k-=lb(k)) ans=max(ans,bit[ind][id(i,j,k)]); return ans;&#125;int main()&#123; int i,j; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;h,&amp;q); n++,m++,h++; for(i=0;i&lt;10;i++)for(j=0;j&lt;500110;j++)bit[i][j]=-1e8; while(q--)&#123; int opt,x,y,z,ans=1e8; scanf("%d%d%d%d",&amp;opt,&amp;x,&amp;y,&amp;z); if(opt==1)&#123; upd( x, y, z,1,x+y+z); upd(n-x, y, z,2,n-x+y+z); upd( x,m-y, z,3,x+m-y+z); upd(n-x,m-y, z,4,n-x+m-y+z); upd( x, y,h-z,5,x+y+h-z); upd(n-x, y,h-z,6,n-x+y+h-z); upd( x,m-y,h-z,7,x+m-y+h-z); upd(n-x,m-y,h-z,8,n-x+m-y+h-z); &#125;else&#123; ans=min(ans,-que( x, y, z,1)+x+y+z); ans=min(ans,-que(n-x, y, z,2)+(n-x)+y+z); ans=min(ans,-que( x,m-y, z,3)+x+(m-y)+z); ans=min(ans,-que(n-x,m-y, z,4)+(n-x)+(m-y)+z); ans=min(ans,-que( x, y,h-z,5)+x+y+(h-z)); ans=min(ans,-que(n-x, y,h-z,6)+(n-x)+y+(h-z)); ans=min(ans,-que( x,m-y,h-z,7)+x+(m-y)+(h-z)); ans=min(ans,-que(n-x,m-y,h-z,8)+(n-x)+(m-y)+(h-z)); printf("%d\n",ans); &#125; &#125; return 0;&#125; E 题目描述有一些边，每个边限制人的高度范围，问从$1$走到$n$，有多少种身高能够走过去。 解题思路线段树分治，把大小离散化后的区间当做“时间”，写一个可撤销并查集就可以了。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#include&lt;set&gt;#include&lt;unordered_map&gt;#include&lt;vector&gt;typedef long long ll;using namespace std;#define N 200010#define pii pair&lt;int,int&gt;#define fi first#define se second#define mp make_pair#define pb push_backint n,u[N],v[N],lo[N],ro[N],b[N&lt;&lt;1];int l[N],r[N];int L[N&lt;&lt;2],R[N&lt;&lt;2];vector&lt;pii&gt;P[N&lt;&lt;2];int f[N];void build(int p,int l,int r)&#123; L[p]=l;R[p]=r; if(l==r)return; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r);&#125;void modify(int p,int l,int r,pii pr)&#123; if(L[p]&gt;r||R[p]&lt;l)return; if(l&lt;=L[p]&amp;&amp;R[p]&lt;=r)&#123; P[p].pb(pr); return; &#125; modify(p&lt;&lt;1,l,r,pr); modify(p&lt;&lt;1|1,l,r,pr);&#125;pii sta[N];int top,rnk[N],drnk[N];int find(int x)&#123; return x==f[x]?f[x]:find(f[x]);&#125;void unite(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx==fy)&#123; sta[top++]=mp(0,0); return; &#125; if(rnk[fx]&lt;rnk[fy])f[fx]=fy,sta[top++]=mp(fx,fy); else&#123; f[fy]=fx; if(rnk[fy]==rnk[fx])&#123; rnk[fx]++; drnk[top]=1; &#125; sta[top++]=mp(fy,fx); &#125;&#125;void deunite()&#123; int son=sta[top-1].fi,fa=sta[top-1].se; if(drnk[top-1])rnk[fa]--; f[son]=son; top--;&#125;int ans;void dfs(int p)&#123; for(auto pr:P[p])unite(pr.first,pr.second); if(L[p]==R[p])&#123; if(find(1)==find(n))ans+=b[L[p]+1]-b[L[p]]; &#125;else dfs(p&lt;&lt;1),dfs(p&lt;&lt;1|1); for(auto pr:P[p])deunite();&#125;int main()&#123; int i,m,tot=0; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)f[i]=i,rnk[i]=0; for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d%d",&amp;u[i],&amp;v[i],&amp;lo[i],&amp;ro[i]); ro[i]++;//[l,r) b[tot++]=lo[i]; b[tot++]=ro[i]; &#125; sort(b+1,b+tot); tot=unique(b+1,b+tot)-b-1; build(1,1,tot); for(i=0;i&lt;m;i++)&#123;//b[l[i]]=lo[i] l[i]=lower_bound(b+1,b+tot,lo[i])-b; r[i]=lower_bound(b+1,b+tot,ro[i])-b; modify(1,l[i],r[i]-1,mp(u[i],v[i])); &#125; dfs(1); printf("%d",ans); return 0;&#125; F 题目描述解题思路AC代码点击 12 G 题目描述给一个串，每次可以去掉三个相同的相邻字母，问最多能去多少次。 解题思路签到。 AC代码点击 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char a[100010];int p[100010];int main()&#123; int i,now=0,ans=0; scanf("%s",a); for(i=0;a[i];i++)&#123; p[now]=a[i]; if(now&gt;=2&amp;&amp;p[now]==p[now-1]&amp;&amp;p[now-1]==p[now-2])&#123; ans++; now-=3; &#125; now++; &#125; printf("%d",ans); return 0;&#125; H 题目描述解题思路AC代码点击 12 I 题目描述解题思路AC代码点击 12 J 题目描述有一条长度为$l$的道路，从$0$走到$l-1$，每次走的步长为$\geq d$的任意正整数，有$m$次袭击，每次袭击有一个位置和时间，表示第$t_i$步不能到$p_i$这个位置，求从$0$ 走到$l-1$的总方案数。 解题思路首先可以很容易递推求出，从$x$到$x+i$不考虑袭击有多少种走法。我们假设这个走法为$f_i$。 考虑容斥。总方案数为$f_l$，减去至少走到某一次袭击的方案数之和，加上两次的，减去三次…… 把所有的袭击按时间或者坐标排一下序，显然可以得出，后面的袭击进行之后，前面的袭击不可能再遇到。有了这个性质就可以递推求解，设$g[i][0]$表示受到第$i$次袭击、总受袭击次数为偶数的方案数，$g[i][1]$表示总受袭击次数为奇数的方案数。递推即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 10000010#define M 3005const ll mod=998244353;ll f[N],g[N][2],inv[N],fac[N],l,d,m,ans,s;ll c(ll n,ll m)&#123; if(n&lt;m||m&lt;0)return 0; return fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;struct Event&#123; int t,p; bool operator&lt;(const Event&amp;q)const&#123;return t&lt;q.t;&#125;&#125;e[M];ll F(ll p,ll t)&#123;return c(p-t*d+t-1,t-1);&#125;int main()&#123; int i,j; fac[0]=fac[1]=inv[0]=inv[1]=f[0]=1; for(i=2;i&lt;N;i++)fac[i]=fac[i-1]*i%mod,inv[i]=inv[mod%i]*(mod-mod/i)%mod; for(i=2;i&lt;N;i++)inv[i]=inv[i]*inv[i-1]%mod; scanf("%lld%lld%lld",&amp;l,&amp;d,&amp;m); for(i=1;i&lt;=l;i++)&#123; if(i&gt;=d)(s+=f[i-d])%=mod; f[i]=s; &#125; for(i=1;i&lt;=m;i++)scanf("%d%d",&amp;e[i].t,&amp;e[i].p); sort(e+1,e+m+1); for(i=1;i&lt;=m;i++)&#123; if(l&lt;e[i].p)continue; g[i][1]=F(e[i].p,e[i].t); for(j=1;j&lt;i;j++)&#123; if(e[j].p&gt;=e[i].p)continue; (g[i][0]+=g[j][1]*F(e[i].p-e[j].p,e[i].t-e[j].t))%=mod; (g[i][1]+=g[j][0]*F(e[i].p-e[j].p,e[i].t-e[j].t))%=mod; &#125; (ans+=mod-g[i][1]*f[l-e[i].p]%mod+g[i][0]*f[l-e[i].p]%mod)%=mod; &#125; printf("%lld",(ans+f[l])%mod); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Summer Training 2 题解]]></title>
    <url>%2F2019%2F08%2F09%2F2019summertraining-2%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K 8/11 O O O O Ø . . Ø Ø O . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 题目来源：2019牛客暑期多校训练营第七场 比赛链接 A 题目描述给一个$01$串，求最少的分割使得每一段字符串都是把这段字符串循环一圈之中字典序最小的。 解题思路暴力$O(Tn^3)$居然可过…… AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char a[250];int cnt0[250],cnt1[250],top;int judge(int l,int r)&#123; char b[250]=&#123;0&#125;,c[250]=&#123;0&#125;; int i,j; for(i=l;i&lt;=r;i++)b[i-l]=a[i]; for(i=1;i&lt;=r-l;i++)&#123; for(j=0;j&lt;=r-l;j++)&#123; c[j]=b[(j+i)%(r-l+1)]; &#125; c[j]=0; if(strcmp(b,c)&gt;0)return 0; &#125; return 1;&#125;int main()&#123; int i,j,T; scanf("%d",&amp;T); while(T--)&#123; scanf("%s",a+1); int l=strlen(a+1),last=1; while(1)&#123; for(i=l;i;i--)&#123; if(judge(last,i))&#123; for(j=last;j&lt;=i;j++)printf("%c",a[j]); printf(" "); last=i+1; break; &#125; &#125; if(last&gt;l)break; &#125; puts(""); &#125; return 0;&#125; B 题目描述给一个多项式，判断能否拆成两个多项式相乘。 解题思路$n\geq 3$时，多项式必有实根或共轭复根。若有共轭复根$a+bi,a-bi$，则必然有因式$(x-a)^2-b^2$；若有实根$a$，则必然有因式$(x-a)$。于是不能拆的情况只有两种：一次多项式；$\Delta&lt;0$的二次多项式。 AC代码点击 123456789101112131415#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll a[25];int main()&#123; int i,t,n; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=1;i&lt;=n+1;i++)scanf("%lld",&amp;a[i]); if(n&lt;2||(n==2&amp;&amp;a[2]*a[2]-4*a[1]*a[3]&lt;0))printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125; C 题目描述有$n$种树，每种树有一个高度$H_i$，个数$P_i$，砍掉一棵的代价$C_i$。最终状态要求为，最高的树的个数之和严格大于总树数的一半，求最小代价。 解题思路从高到低枚举高度，每次查询需要删掉的个数$num$以及前$num$个的代价和，查询后删除。 也就是需要一种数据结构，支持单点修改区间求和，显然可以用树状数组。根据代价升序排列，建两个树状数组，一个维护个数，一个维护总代价。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010#define pb push_backstruct Tree&#123; int h,c,p; bool operator&lt;(const Tree&amp;t)const&#123;return c&lt;t.c;&#125;&#125;a[N];ll b1[N&lt;&lt;2],b2[N&lt;&lt;2];int n;void ins(ll a[],int p,ll x)&#123;while(p&lt;=n)a[p]+=x,p+=p&amp;(-p);&#125;ll query(ll a[],int p)&#123;ll ans=0;while(p)ans+=a[p],p-=p&amp;(-p);return ans;&#125;map&lt;int,vector&lt;int&gt;&gt;h;int main()&#123; int i; while(~scanf("%d",&amp;n))&#123; ll tot=0,ans=1e18,nowc=0; h.clear(); for(i=1;i&lt;=n;i++)scanf("%d%d%d",&amp;a[i].h,&amp;a[i].c,&amp;a[i].p),tot+=a[i].p; sort(a+1,a+n+1); for(i=1;i&lt;=n;i++)ins(b1,i,a[i].p),ins(b2,i,1LL*a[i].p*a[i].c),h[a[i].h].pb(i); for(auto it=h.rbegin();it!=h.rend();it++)&#123; ll sump=0,sumc=nowc; for(auto j:(*it).second)&#123; sump+=a[j].p; sumc+=1LL*a[j].p*a[j].c; ins(b1,j,-a[j].p);ins(b2,j,-1LL*a[j].p*a[j].c); &#125; int l=1,r=n,res=n,mid; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(query(b1,mid)&gt;tot-2*sump)r=mid-1,res=mid; else l=mid+1; &#125; ll x=max(tot-(sump*2-1)-query(b1,res-1),0LL); ans=min(ans,nowc+query(b2,res-1)+a[res].c*x); nowc=sumc; tot-=sump; &#125; printf("%lld\n",ans); &#125; return 0;&#125; D 题目描述求出有没有一个可以被质数$p$整除的$n$位整数。 解题思路后面加零就行了。 AC代码点击 1234567891011121314#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int main()&#123; int i,cnt=0,n,p; scanf("%d%d",&amp;n,&amp;p);int t=p; while(t)cnt++,t/=10; if(cnt&gt;n)printf("T_T"); else&#123; printf("%d",p); for(i=cnt;i&lt;n;i++)printf("0"); &#125; return 0;&#125; E 题目描述$n$次操作，每次向数列中加入$[L_i,R_i]$中所有数各一个，要求每次操作后输出中位数。 解题思路中位数显然可以用线段树查询求出，或者二分查找大小求出，需要离散化一下，每个节点代表$[L,R+1)$区间，所以离散化的时候也应当离散化$L$和$R+1$。线段树维护一下区间和就好了。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;unordered_map&lt;int,int&gt; id; int n;const int maxn=4e5+23;int f[maxn&lt;&lt;1];ll x1,x2,a,b,c,m;ll x[maxn&lt;&lt;1];int l[maxn],r[maxn];ll st[maxn&lt;&lt;3];int add[maxn&lt;&lt;3];int v[maxn&lt;&lt;3];int inde[maxn&lt;&lt;3]; void build(int o,int l,int r)&#123; if(l==r) v[o]=f[l]-f[l-1],inde[l]=o; else&#123; int m=(r+l)&gt;&gt;1; build(o&lt;&lt;1,l,m); build(o&lt;&lt;1|1,m+1,r); v[o]=v[o&lt;&lt;1]+v[o&lt;&lt;1|1]; &#125;&#125; void pushup(int o)&#123; st[o]=st[o&lt;&lt;1]+st[o&lt;&lt;1|1];&#125; void pushdown(int o)&#123; if(add[o])&#123; add[o&lt;&lt;1]+=add[o]; add[o&lt;&lt;1|1]+=add[o]; st[o&lt;&lt;1]+=(1LL*add[o]*v[o&lt;&lt;1]); st[o&lt;&lt;1|1]+=(1LL*add[o]*v[o&lt;&lt;1|1]); add[o]=0; &#125;&#125; void update1(int o,int l,int r,int ql,int qr,int addv)&#123; if(ql&lt;l&amp;&amp;qr&gt;=r)&#123; add[o]+=addv; st[o]+=(1LL*addv*v[o]); return ; &#125; if(ql&gt;=r||qr&lt;l)return; pushdown(o); int m=(l+r)&gt;&gt;1; update1(o&lt;&lt;1,l,m,ql,qr,addv); update1(o&lt;&lt;1|1,m+1,r,ql,qr,addv); pushup(o);&#125; ll query(int o,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;qr&gt;=r) return st[o]; if(ql&gt;r||qr&lt;l)return 0; pushdown(o); int m=(l+r)&gt;&gt;1; ll ans=0; ans+=query(o&lt;&lt;1,l,m,ql,qr)+query(o&lt;&lt;1|1,m+1,r,ql,qr); return ans;&#125;int y[maxn&lt;&lt;1];int main()&#123; int i; cin &gt;&gt; n; cin &gt;&gt; x1 &gt;&gt; x2 &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; m; x[1]=x1,x[2]=x2; for(i=3;i&lt;=n;i++)&#123; x[i]=(a*x[i-1]+b*x[i-2]+c)%m; &#125; cin &gt;&gt; x1 &gt;&gt; x2 &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; m; x[1+n]=x1,x[2+n]=x2; for(i=3;i&lt;=n;i++)x[n+i]=(a*x[n+i-1]+b*x[n+i-2]+c)%m; int cnt=1; for(i=1;i&lt;=n;i++)&#123; l[i]=min(x[i],x[n+i])+1; r[i]=max(x[i],x[n+i])+1; y[cnt++]=l[i]; y[cnt++]=r[i]+1; &#125; sort(1+y,1+y+2*n); cnt=unique(y+1,y+1+2*n)-y-1; for(i=1;i&lt;=cnt;++i)&#123; id[y[i]]=i; f[i]=y[i]; &#125; ll num=0; build(1,1,cnt); for(i=1;i&lt;=n;i++)&#123; num+=r[i]-l[i]+1; int bb=id[l[i]],bbb=id[r[i]+1]; update1(1,1,cnt,bb,bbb,1); int L=1,R=cnt,mid; ll ans=0,M=(num+1)/2; while(L&lt;R)&#123; mid=(L+R)&gt;&gt;1; ans=query(1,1,cnt,1,mid); if(ans&gt;=M) R=mid; else L=mid+1; &#125; ans=query(1,1,cnt,1,L); ll temp=ans-M; ll m=st[inde[L]]/v[inde[L]]; ll ret=f[L]-temp/m-1; printf("%d\n",ret); &#125;&#125; 然后又发现了一种神奇的树状数组做法： 考虑一个$x$，只要能够快速判断出$x$左边有多少个数就能快速判断中位数的位置了。 $x$左边的数有两种情况： 是一个完整的区间 是一个跨越$x$的区间 于是我们可以对跨越$x$的区间进行计数$cnt$，也就是区间$[L,R]$内部$cnt$都加一；完整的区间可以通过区间内$cnt2+=-L$，右端点$cnt2+=R-L$进行表示。 于是通过记录这两个值，可以看出，某一点$x$的前面（包括本身）数的总数便是它的$cnt2-cnt1\times (x+1)$，其中$cnt2$一部分贡献来自于$x$前面的完整区间，另一部分和$cnt1$的$x$倍共同组成跨越$x$区间的左半边，再加上$x$本身的$cnt1$。 这是一个区间修改单点查询的问题，通过对左右端点的修改用树状数组即可维护。最后二分答案即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 400010int n,x[N],y[N],l[N],r[N];ll a1,a2,b1,b2,c1,c2,m1,m2;int z[N&lt;&lt;1],cnt;ll B1[N&lt;&lt;2],B2[N&lt;&lt;2];void ins(ll a[],int p,int x)&#123; int i; for(i=p;i&lt;=cnt;i+=i&amp;(-i))a[i]+=x;&#125;ll query(ll a[],int p)&#123; int i;ll ans=0; for(i=p;i;i-=i&amp;(-i))ans+=a[i]; return ans;&#125;int main()&#123; int i;ll t=0; scanf("%d%d%d%lld%lld%lld%lld%d%d%lld%lld%lld%lld",&amp;n,&amp;x[1],&amp;x[2],&amp;a1,&amp;b1,&amp;c1,&amp;m1,&amp;y[1],&amp;y[2],&amp;a2,&amp;b2,&amp;c2,&amp;m2); for(i=1;i&lt;=n;i++)&#123; if(i&gt;2)x[i]=(a1*x[i-1]+b1*x[i-2]+c1)%m1; if(i&gt;2)y[i]=(a2*y[i-1]+b2*y[i-2]+c2)%m2; l[i]=min(x[i],y[i])+1; r[i]=max(x[i],y[i])+1; z[++cnt]=l[i];z[++cnt]=r[i]+1; &#125; sort(z+1,z+cnt+1); cnt=unique(z+1,z+cnt+1)-z-1; for(i=1;i&lt;=n;i++)&#123; t+=r[i]-l[i]+1; int L=lower_bound(z+1,z+cnt+1,l[i])-z,R=lower_bound(z+1,z+cnt+1,r[i]+1)-z; ins(B1,L,-l[i]);ins(B1,R,r[i]+1); ins(B2,L,1);ins(B2,R,-1); L=1,R=1e9; while(L&lt;R)&#123; int mid=(L+R)&gt;&gt;1,pos=upper_bound(z+1,z+cnt+1,mid)-z-1; ll tmp=query(B1,pos); tmp+=query(B2,pos)*(mid+1); if(tmp&lt;(t+1)/2)L=mid+1; else R=mid; &#125; printf("%d\n",L); &#125; return 0;&#125; F 题目描述解题思路AC代码点击 12 G 题目描述解题思路AC代码点击 12 H 题目描述给$1e9$以内的$a,b,c$，求满足$1\leq x\leq a,1\leq y\leq b$，且$(x\ &amp; y)&gt;c$或$(x\oplus y)&lt;c$的$(x,y)$个数。 解题思路找出$(x\ &amp; y)\leq c$且$(x\oplus y)\geq c$的$x,y$对数，用总数减去即可。 从高位到低位枚举$a,b$的每一二进制位，通过记录这两个条件是否已经满足（后面任选）、是否已经满足$x\leq a,y\leq b$、是否全是$0$（$1\leq x,y$）几种状态进行数位$dp$。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int staa[40],stab[40],stac[40],top,a,b,c;ll A,B,C,f[40][2][2][2][2][2][2];ll dfs(int st,int ad,int xo,int lima,int limb,int la,int lb)&#123; if(st&lt;0)return !la&amp;&amp;!lb; ll &amp;ans=f[st][ad][xo][lima][limb][la][lb]; if(~ans)return ans; ans=0; int i,j,mxa=lima?staa[st]:1,mxb=limb?stab[st]:1; for(i=0;i&lt;=mxa;i++) for(j=0;j&lt;=mxb;j++) if(ad&amp;&amp;(i&amp;j)&amp;&amp;!stac[st]||xo&amp;&amp;!(i^j)&amp;&amp;stac[st]); else ans+=dfs(st-1,ad&amp;((i&amp;j)==stac[st]),xo&amp;((i^j)==stac[st]),lima&amp;(i==mxa),limb&amp;(j==mxb),la&amp;!i,lb&amp;!j); return ans;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)&#123; memset(f,-1,sizeof(f)); memset(staa,0,sizeof(staa)); memset(stab,0,sizeof(stab)); memset(stac,0,sizeof(stac)); scanf("%d%d%d",&amp;a,&amp;b,&amp;c);A=a;B=b;C=c; while(a)staa[top++]=a&amp;1,a&gt;&gt;=1;top=0; while(b)stab[top++]=b&amp;1,b&gt;&gt;=1;top=0; while(c)stac[top++]=c&amp;1,c&gt;&gt;=1;top=0; printf("%lld\n",A*B-dfs(31,1,1,1,1,1,1)); &#125; return 0;&#125; I 题目描述给定两个数$n,m$，可以取任意大小的$k\times k$的正方形填数，填数的要求是： 任意$k$个行列都不同的点，点上数的总和相等 点上数的总和不超过$n$ 任意点上的数字不少于$m$ 问有多少种方法。 解题思路对于每一个$k$，显然可以先把$m$的限制去掉，限制$n$改为$n-mk$。 任意$k$个不同行列的点，其数的和都相等，代表这个矩阵$M$可以由第$i$行全为$1$，其他全为$0$的矩阵$A_i$和第$i$列全为$1$，其他全为$0$的矩阵$B_i$线性表示，即$M=\sum_{i=1}^k(a_iA_i+b_iB_i)$。假设总和为$x$，限制条件为$0\leq x\leq n-mk$，则有$\sum_{i=1}^k(a_i+b_i)=x,a_i\geq 0,b_i\geq 0$。把$x$看做$x$个$1$，插总共$2k-1$块板（$a_1,a_2…a_k,b_1..b_k$共$2k$个数，每个板子分开两个数），方案数为$C_{x+2k-1}^{2k-1}$。 然后发现如果只用这个公式，多算了一些情况：如果$a_i$全$\geq 1$，那么把$a_i$全都减一，$b_i$全都加一，会被重复统计。重复统计的个数即为$\sum_{i=1}^k(a_i+b_i)=x,a_i\geq 1,b_i\geq 0$，$C_{x+k-1}^{2k-1}$。 枚举$k,x$，得出答案。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 4020ll mod=998244353;ll inv[N],fac[N];ll qp(ll x,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,x=x*x%mod)if(p&amp;1)ans=ans*x%mod; return ans;&#125;ll c(int n,int m)&#123;return n&gt;=m?fac[n]*inv[m]%mod*inv[n-m]%mod:0;&#125;int main()&#123; int i,k,t,n,m; fac[0]=inv[0]=1; for(i=1;i&lt;N;i++)fac[i]=fac[i-1]*i%mod,inv[i]=qp(fac[i],mod-2); scanf("%d",&amp;t); while(t--)&#123; ll ans=0; scanf("%d%d",&amp;n,&amp;m); for(k=1;k*m&lt;=n;k++)&#123; for(i=0;i&lt;=n-m*k;i++)&#123; ans+=c(i+2*k-1,2*k-1); ans+=mod-c(i+k-1,2*k-1); ans%=mod; &#125; &#125; printf("%lld\n",ans); &#125; return 0;&#125; J 题目描述计算两个数倒过来的和，忽略掉首位$0$。 解题思路签到题。 AC代码点击 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char a[50],b[50],c[50];int main()&#123; int i,T; scanf("%d",&amp;T); while(T--)&#123; ll A=0,B=0; scanf("%s%s",a,b); for(i=strlen(a)-1;i&gt;=0;i--)A=A*10+a[i]-'0'; for(i=strlen(b)-1;i&gt;=0;i--)B=B*10+b[i]-'0'; memset(c,0,sizeof(c)); ll C=A+B; while(C&amp;&amp;C%10==0)C/=10; sprintf(c,"%lld",C); for(i=strlen(c)-1;i&gt;=0;i--)printf("%c",c[i]); puts(""); &#125; return 0;&#125; K 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Summer Training 1 题解]]></title>
    <url>%2F2019%2F08%2F07%2F2019summertraining-1%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 7/10 Ø . Ø O O Ø O . . O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 题目来源：2018HDU多校第二场 比赛链接 A HDU 6309 - Absolute 题目描述从原点出发，每次向$x$轴正向以等概率走$[l_i,r_i]$步（$-10^6\leq l_i\leq r_i\leq 10^6$），问最终离原点的距离期望。 解题思路离原点距离可以分为$\sum x_i\geq 0,\sum x_i&lt;0$两部分解决。 能到达的区间是$[\sum l_i,\sum r_i]$，显然如果这两个数同号则直接输出其平均值即可。 将每一次走法看做一个维度上的区间$x_i\in [0,r_i-l_i]$，设$a_i=r_i-l_i$，最终要求期望，可以先求概率，这个概率便是一个$n$维超体中经过一个$n-1$维超体的概率$P(n,x)$，其中$n-1$维超体方程为$x_1+x_2+…+x_n=x$。为方便求解，将问题全部转化为$n$维上的运算，即求一个$n-1$维超体上概率的前缀和$p(n,x)=\sum P(n,i)$。直观上理解这个前缀和，就是以原点为顶点的$n$维锥体。 好抽象，画个图理解。以二维为例：现在已知$0\leq x_1\leq a_1,0\leq x_2\leq a_2$，其中$x_1,x_2$为二维空间中的两个维度（平面直角坐标系中的$x,y$），显然这个区间代表的是一个矩形。那么$p(2,x)$代表的含义就是画一道$x_1+x_2=x$的直线，把这个矩形切下来的左下方的面积除以$a_1a_2$的大小。是不是很容易理解呀 这个面积显然可以用容斥求：我们假设$f(n,x)$为$n$维，$a_1=a_2=…=a_n=x$情况下的$p(n,x)$，对应二维也就是直角三角形面积比上正方形面积$\frac12$，三维就是三棱锥比上正方体体积$\frac16$，在$n$维情况下便是$\frac 1{n!}$，即$f(n,x)=\frac 1{n!}$。很容易在二维下面验证 $$s(2,x)=f(2,x)\cdot x^2-f(2,x-a_1)\cdot (x-a_1)^2-f(2,x-a_2)\cdot (x-a_2)^2+f(2,x-a_1-a_2)\cdot (x-a_1-a_2)^2$$ 我们设$g(n,x)=f(n,x)\cdot x^n$，有 $$s(n,x)=g(n,x)-\sum_{i=1}^{n}g(n,x-a_i)+\sum_{i=1}^n\sum_{j=i+1}^{n}g(n,x-a_i-a_j)-…$$ 于是，$p(n,x)=\frac{s(n,x)}{\prod a_i}$。 现在$p(n,x)$即为把原点移到$[-\sum l_i,0]$上后$[0,-\sum l_i]$上的概率前缀和（其实转化为了从$-\sum l_i$开始，每次走$[0,a_i]$长度后总共走的长度）。求一下这个$p$对应的期望：$E(n,x)=\int x\cdot p’(n,x)dx$，其中$p(n,x)$求导可以逐项进行，会转化成对$g(n,x)$求导。不妨将$p(n,x)$表示为$\sum g(n,x)=\sum\frac{x^n}{n!}$，则$E(n,x)=\int x\cdot \sum (\frac {x^n}{n!})’=\int \sum\frac{x^n}{(n-1)!}=\sum\frac{n\cdot x^{n+1}}{(n+1)!}$。转化成在原数轴上的期望，即为$xp(n,x)-E(n,x)=\sum\frac{x^{n+1}}{n!}-\frac{n\cdot x^{n+1}}{(n+1)!}=\sum \frac{x^{n+1}}{(n+1)!} $。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 20ll mod=998244353,inv[N];int l[N],r[N],len[N],n;ll qp(ll a,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,a=a*a%mod)if(p&amp;1)ans=ans*a%mod; return ans;&#125;ll ie(int now,int sign,int sum)&#123; if(sum&lt;=0)return 0; if(now&gt;n)return qp(sum,n+1)*inv[n+1]%mod*(sign==-1?mod-1:1)%mod; return (ie(now+1,sign,sum)+ie(now+1,-sign,sum-len[now]))%mod;&#125;int main()&#123; int i; ll prod=1,ls=0,rs=0; inv[0]=1; for(i=1;i&lt;N;i++)inv[i]=inv[i-1]*qp(i,mod-2)%mod; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;l[i],&amp;r[i]); len[i]=r[i]-l[i]; ls+=l[i];rs+=r[i]; if(len[i])prod=prod*len[i]%mod; &#125; if(ls&gt;=0||rs&lt;=0)printf("%lld",abs(ls+rs)*qp(2,mod-2)%mod); else printf("%lld",(((ie(1,1,-ls)+ie(1,1,rs))*qp(prod,mod-2)%mod)+mod)%mod); puts(""); return 0;&#125; B HDU 6310 - Counting Permutations 题目描述解题思路AC代码点击 12 C HDU 6311 - Cover 题目描述给一个非联通图，求用最少的笔数遍历所有边，每条边只能走一次。 解题思路把度为奇数的点连上虚边，从度为奇数的点开始跑一下欧拉路，遇到虚边则断开即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010struct Edge&#123; int e,n,del,sign,index;&#125;e[N&lt;&lt;4];int hd[N],cnt;int deg[N];void add(int a,int b,int index,int sign)&#123; e[++cnt].e=b;e[cnt].n=hd[a];e[cnt].del=0;e[cnt].sign=sign;e[cnt].index=index;hd[a]=cnt; e[++cnt].e=a;e[cnt].n=hd[b];e[cnt].del=0;e[cnt].sign=sign;e[cnt].index=-index;hd[b]=cnt;&#125;int vis[N],tot;#define pb push_backvector&lt;int&gt;ans[N];void dfs(int p)&#123; vis[p]=1; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(e[i].del)continue; e[i].del=e[i^1].del=1; dfs(q); if(e[i].sign)tot++; else ans[tot].pb(-e[i].index); &#125;&#125;int main()&#123; int i,j,n,m,u,v; while(~scanf("%d%d",&amp;n,&amp;m))&#123; memset(deg,0,sizeof(int)*(n+1)); memset(vis,0,sizeof(int)*(n+1)); memset(hd,0,sizeof(int)*(n+1));cnt=1; for(i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); deg[u]++;deg[v]++; add(u,v,i,0); &#125; int last=0; for(i=1;i&lt;=n;i++)&#123; if(deg[i]&amp;1)&#123; if(last)add(last,i,0,1),last=0; else last=i; &#125; &#125; tot=0; for(i=1;i&lt;=n;i++)if(!vis[i]&amp;&amp;(deg[i]&amp;1))tot++,dfs(i); for(i=1;i&lt;=n;i++)if(!vis[i])tot++,dfs(i); int res=tot; for(i=1;i&lt;=tot;i++)if(ans[i].size()==0)res--; printf("%d\n",res); for(i=1;i&lt;=tot;i++)&#123; int sz=ans[i].size(); if(!sz)continue; printf("%d ",sz); for(j=0;j&lt;sz;j++)printf("%d ",ans[i][j]); ans[i].clear(); puts(""); &#125; &#125; return 0;&#125; D HDU 6312 - Game 题目描述一个游戏，每人选一个数，这个数的约数之后不能再被选，问谁能赢。 解题思路若先手不选$1$必输，则选$1$后必胜；否则必胜。故永远先手必胜。 AC代码点击 12345678#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int main()&#123; int n; while(~scanf("%d",&amp;n))printf("Yes\n"); return 0;&#125; E HDU 6313 - Hack It 题目描述构造一个$2000\times 2000$的$01$矩阵，要求不存在一个四个角都为$1$的子矩阵，且$1$的个数$\geq 85000$。 解题思路考虑一个$25\times 25$的矩阵： $10000\space 10000\space 10000\space 10000\space 10000$ $10000\space 01000\space 00100\space 00010\space 00001$ $10000\space 00100\space 00001\space 01000\space 00010$ $10000\space 00010\space 01000\space 00001\space 00100$ $10000\space 00001\space 00010\space 00100\space 01000$ $01000\space 01000\space 01000\space 01000\space 01000$ $01000\space 00100\space 00010\space 00001\space 10000$ $01000\space 00010\space 10000\space 00100\space 00001$ $01000\space 00001\space 00100\space 10000\space 00010$ $01000\space 10000\space 00001\space 00010\space 00100$ …… 分成$5\times 5$个格子，每个格子里填一个数字，通过同行不同构、每隔五行整体平移的方法保证不存在四个顶点都是$1$的矩形存在。 AC代码点击 1234567891011121314#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int a[2500][2500];int main()&#123; int i,j,k,x=47; for(i=0;i&lt;x;i++)for(j=0;j&lt;x;j++)for(k=0;k&lt;x;k++)a[i*x+j][k*x+(i+k*j)%x]=1; printf("2000\n"); for(i=0;i&lt;2000;i++)&#123; for(j=0;j&lt;2000;j++)printf("%d",a[i][j]); puts(""); &#125; return 0;&#125; F HDU 6314 - Matrix 题目描述给一个$n\times m$的网格图，每一个格子可以涂为黑色或白色，$n$行中要求至少有$a$行全涂为黑色，$m$列中要求至少有$b$列全涂为黑色，问有多少种本质不同的涂色方案。 解题思路设$g(x)$为恰好涂$x$行黑色，$m$列至少涂$b$列黑色的方案数，答案显然为$\sum_{i=a}^{n}g(i)$。 $g(x)=f(n-x,b)\cdot C_n^x-\sum_{i=x+1}^{n}g(i)\cdot C_i^x$，其中$f(x,i)$表示在$x$行的时候，$m$列至少涂$i$列的方案数。这个式子的意义是，在涂了$x$行黑色后，剩下的$x-i$列中任意涂的方案数中包括了总共涂多于$x$列黑色的情况。假设多算了恰好涂$y$列的情况，那么有$C_y^x$种重复的方案（选择涂$x$列的时候选择$y$列中的$x$列）。 再考虑求$f(x,i)$。设$h(n,i)$表示有$n$行的时候，$m$列恰好涂$i$列的方案数，显然$f(n,i)=\sum_{j=i}^mh(n,j)$。而$h(n,i)=C_m^i\cdot (2^{i}-1)^{m-i}$，即选择$i$列全部填满，剩下$m-i$列不能全部填满的种类数。 全都预处理出来之后，时间复杂度是$O(Tnm)$的，但会卡常…… AC代码点击 1234567891011121314151617181920212223242526272829303132#pragma GCC optimize(2)#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 3005const ll mod=998244353;ll f[N],g[N];int c[N][N];int main()&#123; int i,j,n,m,a,b; for(i=0;i&lt;N;i++)c[i][0]=1; for(i=1;i&lt;N;i++)for(j=1;j&lt;N;j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod; while(~scanf("%d%d%d%d",&amp;n,&amp;m,&amp;a,&amp;b))&#123; ll ans=1,x=0; for(i=1;i&lt;=n-a;i++)&#123; f[i]=0; x=(x*2+1)%mod;ll now=1; for(j=m;j&gt;=b;j--)&#123; (f[i]+=c[m][j]*now)%=mod; now=now*x%mod; &#125; &#125; g[n]=1; for(i=n-1;i&gt;=a;i--)&#123; g[i]=f[n-i]*c[n][i]%mod; for(j=i+1;j&lt;=n;j++)(g[i]-=g[j]*c[j][i])%=mod; ans+=g[i]; &#125; printf("%lld\n",(ans%mod+mod)%mod); &#125; return 0;&#125; G HDU 6315 - Naive Operations 题目描述有两个数组$a,b$，$a$初始都为$0$，$b$初始为一个$1-n$的排列。有$q$次区间询问，每次有两种操作：区间所有$a_i$加$1$；求出区间$\lfloor\frac {a_i}{b_i}\rfloor$的和。 解题思路建一棵维护区间和的线段树，再维护一棵维护每个数$b_i-a_i$的线段树，表示再加几次就能够向第一棵线段树中加一了。 第二棵线段树需要维护一个区间最小值，每次更新的时候把所有区间最小值小于等于零的进行更新即可。最多更新$n\log n$次叶子节点，每次更新复杂度为$O(\log n)$，时间复杂度$O(n\log ^2n)$。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 400010struct SegTree&#123; int lazy,data;&#125;tr[N],res[N];int b[N],n,q;void pushdown(int p)&#123;//res int t=res[p].lazy; if(!t)return; res[p&lt;&lt;1].lazy+=t; res[p&lt;&lt;1].data-=t; res[p&lt;&lt;1|1].lazy+=t; res[p&lt;&lt;1|1].data-=t; res[p].lazy=0;&#125;void build(int p,int l,int r)&#123;//build res,tr tr[p].lazy=tr[p].data=res[p].lazy=res[p].data=0; if(l==r)&#123; res[p].data=b[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(p&lt;&lt;1,l,mid); build(p&lt;&lt;1|1,mid+1,r); res[p].data=min(res[p&lt;&lt;1].data,res[p&lt;&lt;1|1].data);&#125;void add(int p,int l,int r,int L,int R)&#123;//add a_i pushdown(p); if(l&lt;=L&amp;&amp;R&lt;=r)&#123; res[p].lazy++; res[p].data--; return; &#125; if(R&lt;l||L&gt;r)return; add(p&lt;&lt;1,l,r,L,(L+R)&gt;&gt;1); add(p&lt;&lt;1|1,l,r,((L+R)&gt;&gt;1)+1,R); res[p].data=min(res[p&lt;&lt;1].data,res[p&lt;&lt;1|1].data);&#125;void modify(int p,int l,int L,int R,int x)&#123;//tr tr[p].data+=x; if(L&gt;=R)return; int mid=(L+R)&gt;&gt;1; if(mid&gt;=l)modify(p&lt;&lt;1,l,L,mid,x); else modify(p&lt;&lt;1|1,l,mid+1,R,x);&#125;void update(int p,int l,int r,int L,int R)&#123;//res-- pushdown(p); if(L==R)&#123; int x=-res[p].data/b[L]+1; modify(1,L,1,n,x); res[p].data+=x*b[L]; return; &#125; if(res[p].data&gt;0)return; if(res[p&lt;&lt;1].data&lt;=0)update(p&lt;&lt;1,l,r,L,(L+R)&gt;&gt;1); if(res[p&lt;&lt;1|1].data&lt;=0)update(p&lt;&lt;1|1,l,r,((L+R)&gt;&gt;1)+1,R); res[p].data=min(res[p&lt;&lt;1].data,res[p&lt;&lt;1|1].data);&#125;int query(int p,int l,int r,int L,int R)&#123; if(L&gt;=l&amp;&amp;R&lt;=r)return tr[p].data; if(r&lt;L||l&gt;R)return 0; return query(p&lt;&lt;1,l,r,L,(L+R)&gt;&gt;1)+query(p&lt;&lt;1|1,l,r,((L+R)&gt;&gt;1)+1,R);&#125;void print()&#123; int i; for(i=1;i&lt;10;i++)&#123; printf("%d:%d %d ;%d %d\n",i,tr[i].lazy,tr[i].data,res[i].lazy,res[i].data); &#125; puts("");&#125;int main()&#123; int i; while(~scanf("%d%d",&amp;n,&amp;q))&#123; for(i=1;i&lt;=n;i++)scanf("%d",&amp;b[i]); build(1,1,n); while(q--)&#123; char a[10]=&#123;0&#125;; int l,r; //print(); scanf("%s%d%d",a,&amp;l,&amp;r); if(a[0]=='a')add(1,l,r,1,n); else&#123; update(1,l,r,1,n); printf("%d\n",query(1,l,r,1,n)); &#125; &#125; &#125; return 0;&#125; H HDU 6316 - Odd Shops 题目描述解题思路AC代码点击 12 I HDU 6317 - Segment 题目描述解题思路AC代码点击 12 J HDU 6318 - Swaps and Inversions 题目描述给一个序列，序列中一对逆序对需要花费$x$，移动相邻两个元素位置花费$y$，问最小花费。 解题思路最优选择下，移动相邻两个元素必然能使一个且只能使一个逆序对消失（显然），故答案为逆序对数乘$min(x,y)$。 $WA$一发原因：归并排序的时候忘记把右边段可能剩下的部分加上…（$19$行） AC代码点击 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,x,y,a[100010],tmp[100010];ll calc(int l,int r)&#123; int i,j,mid=(l+r)&gt;&gt;1; if(l&gt;=r)return 0; ll res=calc(l,mid)+calc(mid+1,r); i=l,j=mid+1; int cnt=0; for(i=l;i&lt;=mid;i++)&#123; while(j&lt;=r&amp;&amp;a[i]&gt;a[j])&#123; tmp[cnt++]=a[j]; j++; &#125; res+=j-mid-1; tmp[cnt++]=a[i]; &#125; while(j&lt;=r)tmp[cnt++]=a[j],j++; for(i=l;i&lt;=r;i++)a[i]=tmp[i-l]; return res;&#125;int main()&#123; int i; while(~scanf("%d%d%d",&amp;n,&amp;x,&amp;y))&#123; for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); ll num=calc(1,n); if(x&gt;y)printf("%lld\n",num*y); else printf("%lld\n",num*x); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营第六场 题解]]></title>
    <url>%2F2019%2F08%2F03%2F2019nowcodersummercontest-6%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 7/10 O O Ø O O . Ø . . O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述垃圾分类。 解题思路签到题，模拟即可。 AC代码点击 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char a[2010],b[30];int main()&#123; int i,j,n; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf("%s%s",a,b); printf("Case #%d: ",i); int l=strlen(a),h=0,d=0,w=0; for(j=0;j&lt;l;j++)&#123; if(b[a[j]-'a']=='h')h++; else if(b[a[j]-'a']=='w')w++; else d++; &#125; if(4*h&gt;=l)printf("Harmful"); else if(10*h&lt;=l)printf("Recyclable"); else if(d&gt;=2*w)printf("Dry"); else printf("Wet"); puts(""); &#125; return 0;&#125; B 题目描述给一个长度为$128$的$01$串，按照规定缩小串长度并输出。 解题思路模拟，注意处理各个位置缩小的幅度。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char a[200];int num[200],hexa[200],ipv[200];void print(int x)&#123; int i,tmp=x; while(!hexa[x]&amp;&amp;x&lt;tmp+4)x++; if(x==tmp+4)printf("0"); for(i=x;i&lt;tmp+4;i++)&#123; printf("%x",hexa[i]); &#125;&#125;int main()&#123; int i,T,Cas=0; scanf("%d",&amp;T); while(T--)&#123; scanf("%s",a); printf("Case #%d: ",++Cas); for(i=0;a[i];i++)num[i]=a[i]-'0'; for(i=0;i&lt;32;i++)&#123; int j=i*4; hexa[i]=num[j]*8+num[j+1]*4+num[j+2]*2+num[j+3]; &#125; for(i=0;i&lt;8;i++)&#123; int j=i*4; ipv[i]=(hexa[j]||hexa[j+1]||hexa[j+2]||hexa[j+3]); &#125; int zero=0,mx=0,temp=0; for(i=0;i&lt;8;i++)&#123; if(ipv[i]==0)&#123; zero++; if(zero&gt;mx||(zero==mx&amp;&amp;(i!=7||temp-zero&lt;0)))&#123; mx=zero; temp=i; &#125; &#125;else zero=0; &#125; zero=mx; if(zero&lt;2)&#123; print(0); for(i=1;i&lt;8;i++)printf(":"),print(i*4); &#125;else&#123; if(temp-zero&gt;=0)print(0); for(i=1;i&lt;=temp-zero;i++)printf(":"),print(i*4); printf("::"); if(temp+1&lt;8)print((temp+1)*4); for(i=temp+2;i&lt;8;i++)printf(":"),print(i*4); &#125; puts(""); &#125; return 0;&#125; C 题目描述给一个串$s$，其所有连续子回文串构成集合$S$。问从$S$中能取多少对$(a,b)$，$a$是$b$的真子串。 解题思路建立一棵回文树，每一个节点当做$b$串时，对答案的贡献为所有它的回文子串。注意到回文树$fail$指针的作用是其最长回文后缀，对答案产生的贡献即为其回文树上的前驱节点的贡献集合与沿$fail$指针不停向上跳路上经过的节点集合的并集。这里考虑用$dfs$计算贡献，$vis$数组记录所有前驱走过的$fail$边上的点的集合去重即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define P 26#define N 200010ll ans;struct PT&#123; int tr[N][P],fail[N],len[N]; int tot,s[N],n,last,i; int newnode(int l)&#123; for(i=0;i&lt;P;i++)tr[tot][i]=0; len[tot]=l; return tot++; &#125; void init()&#123; n=last=tot=0; newnode(0);newnode(-1); s[0]=-1; fail[0]=1; &#125; int getfail(int p)&#123; while(s[n-len[p]-1]!=s[n])p=fail[p]; return p; &#125; void add(int p)&#123; s[++n]=p; int cur=getfail(last); if(!tr[cur][p])&#123; int now=newnode(len[cur]+2); int getf=getfail(fail[cur]); fail[now]=tr[getf][p]; tr[cur][p]=now; &#125; last=tr[cur][p]; &#125; void insert(char a[])&#123; int i; for(i=0;a[i];i++)add(a[i]-'a'); &#125;&#125;p;char a[N];queue&lt;int&gt;Q;int vis[N];void dfs(int x,int num)&#123; int i,t=x; int sta[10]=&#123;0&#125;,top=0; while(t&amp;&amp;!vis[t])&#123; vis[t]=1; sta[++top]=t; num++; t=p.fail[t]; &#125; if(x&gt;=2)ans+=num-1; for(i=0;i&lt;P;i++)if(p.tr[x][i])dfs(p.tr[x][i],num); while(top)vis[sta[top--]]=0;&#125;ll solve()&#123; ans=0; memset(vis,0,sizeof(vis)); vis[0]=vis[1]=1; dfs(0,0);dfs(1,0); return ans;&#125;int main()&#123; int T,Cas=0; scanf("%d",&amp;T); while(T--)&#123; scanf("%s",a); p.init(); p.insert(a); printf("Case #%d: %lld\n",++Cas,solve()); &#125; return 0;&#125; D 题目描述有$n$个物品，$k$个箱子，每个物品有其重量，按照每次向箱子里放最大可以放的物品的规则，问箱子最小要多大才能够保证所有物品能够放入。 解题思路开始以为是个二分答案，然后全场都在$WA$，莫名其妙，看来二分是假了。然后每次二分枚举一下下界调调参就过了 虚假的AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,k,a[1010],vis[1010];int check(int x)&#123; int i,tot=0; memset(vis,0,sizeof(vis)); for(i=0;i&lt;k;i++)&#123; int rest=x; while(1)&#123; int index=upper_bound(a+1,a+n+1,rest)-a-1; while(index&amp;&amp;vis[index])index--; if(!index)break; rest-=a[index]; vis[index]=1; tot++; &#125; &#125; return tot==n;&#125;int main()&#123; int i,t,Cas=0; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); a[n+1]=1e9; sort(a+1,a+n+1); int l=0,r=1000000,ans=1000000; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))ans=mid,r=mid-1; else&#123; int flag=0; for(i=mid-1;i&gt;=mid-40&amp;&amp;i&gt;0;i--)if(check(i))&#123; ans=i; r=i-1; flag=1; &#125; if(!flag)l=mid+1; &#125; &#125; printf("Case #%d: %d\n",++Cas,ans); &#125; return 0;&#125; 正解：答案没有单调性，上界下界之差的复杂度可以保证，于是从下界暴力枚举即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,k,a[1010],vis[1010];int check(int x)&#123; int i,tot=0; memset(vis,0,sizeof(vis)); for(i=0;i&lt;k;i++)&#123; int rest=x; while(1)&#123; int index=upper_bound(a+1,a+n+1,rest)-a-1; while(index&amp;&amp;vis[index])index--; if(!index)break; rest-=a[index]; vis[index]=1; tot++; &#125; &#125; return tot==n;&#125;int main()&#123; int i,t,Cas=0; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;k); int s=0; for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),s+=a[i]; sort(a+1,a+n+1); for(i=max(s/k,a[n]);;i++)if(check(i))break; printf("Case #%d: %d\n",++Cas,i); &#125; return 0;&#125; E 题目描述求构造一个补图和原图同构的图。 解题思路玄学构造，待补。 AC代码点击 12 F 题目描述解题思路AC代码点击 12 G 题目描述给一堆字母表示的日期，按字典序求出字母代表的数字使得日期合法且均为星期五。 解题思路暴力枚举剪枝，去个重即可$AC$。 蔡勒公式看来需要收藏一下。 $random_shuffle$一下直接从$4000ms$跑到$3400ms$，牛 WA代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010struct Str&#123; char a[20]; bool operator&lt;(const Str s)const&#123; return strcmp(a,s.a)&lt;0; &#125; bool operator==(const Str s)const&#123; return strcmp(a,s.a)==0; &#125;&#125;a[N];int n,y[N][10],m[N][10],d[N][10];int vis[15];int ans[15];int day[15]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int run(int Y)&#123; if(Y%400==0)return 1; if(Y%100==0)return 0; if(Y%4==0)return 1; return 0;&#125;int friday(int y,int m,int d)&#123; if(m&lt;3)m+=12,y--; int c=y/100;y%=100; return (c/4-2*c+y+y/4+13*(m+1)/5+d-1-5)%7==0;&#125;int check(int Y,int M,int D)&#123; if(run(Y))day[2]=29; else day[2]=28; if(Y&gt;=1600&amp;&amp;Y&lt;=9999&amp;&amp;M&gt;=1&amp;&amp;M&lt;=12&amp;&amp;D&lt;=day[M]&amp;&amp;D&gt;=1); else return 0; if(friday(Y,M,D))return 1; return 0;&#125;int dfs(int x)&#123; int i,j; for(i=0;i&lt;n;i++)&#123; int Y=ans[y[i][0]]*1000+ans[y[i][1]]*100+ans[y[i][2]]*10+ans[y[i][3]]; int M=ans[m[i][0]]*10+ans[m[i][1]]; int D=ans[d[i][0]]*10+ans[d[i][1]]; if(ans[m[i][0]]&gt;1||M&gt;12)return 0; if(ans[d[i][0]]&gt;3)return 0; if(ans[y[i][0]]!=-1&amp;&amp;ans[y[i][1]]!=-1&amp;&amp;ans[y[i][0]]*10+ans[y[i][1]]&lt;16)return 0; if(ans[d[i][0]]==-1||ans[d[i][1]]==-1)continue; if(ans[m[i][0]]==-1||ans[m[i][1]]==-1)continue; if(ans[y[i][0]]==-1||ans[y[i][1]]==-1||ans[y[i][2]]==-1||ans[y[i][3]]==-1)continue; if(!check(Y,M,D))return 0; &#125; if(x==10)&#123; for(i=0;i&lt;10;i++)&#123; if(ans[i]==-1)&#123; for(j=0;j&lt;10;j++)&#123; if(!vis[j])&#123; vis[j]=1; ans[i]=j; break; &#125; &#125; &#125; printf("%d",ans[i]); &#125; return 1; &#125; for(i=0;i&lt;10;i++)&#123; if(!vis[i])&#123; vis[i]=1; ans[x]=i; if(dfs(x+1))return 1; vis[i]=0; ans[x]=-1; &#125; &#125; return 0;&#125;int main()&#123; int i,j,T,Cas=0; scanf("%d",&amp;T); while(T--)&#123; memset(vis,0,sizeof(vis)); memset(ans,-1,sizeof(ans)); scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%s",a[i].a); sort(a,a+n); n=unique(a,a+n)-a; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;4;j++)y[i][j]=a[i].a[j]-'A'; for(j=5;j&lt;7;j++)m[i][j-5]=a[i].a[j]-'A'; for(j=8;j&lt;10;j++)d[i][j-8]=a[i].a[j]-'A'; &#125; printf("Case #%d: ",++Cas); if(!dfs(0))printf("Impossible"); puts(""); &#125; return 0;&#125; H 题目描述解题思路AC代码点击 12 I 题目描述解题思路AC代码点击 12 J 题目描述有$n$个科技，$m$个等级，第$i$个科技升级到$j$的花费是$c_{ij}$，所有科技都升级到$i$的花费是$d_i$，求最大化收益。 解题思路枚举所有科技共同升到多少级，其他科技处理成最小值，并记录位置，如果全都在枚举的等级之上，则强制删掉一个最大的（负值），更新答案即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1010int n;ll d[N],a[N][N];int mn[N][N];int main()&#123; int i,j,n,m,T,Cas=0; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; scanf("%lld",&amp;a[i][j]); a[i][j]+=a[i][j-1]; &#125; mn[i][m]=m; for(j=m-1;j;j--)&#123; if(a[i][j]&lt;a[i][mn[i][j+1]])mn[i][j]=j; else mn[i][j]=mn[i][j+1]; &#125; &#125; ll ans=0; for(i=1;i&lt;=m;i++)scanf("%lld",&amp;d[i]),d[i]+=d[i-1]; printf("Case #%d: ",++Cas); for(j=0;j&lt;=m;j++)&#123; ll sum=d[j],mx=0; int rightend=1e9; for(i=1;i&lt;=n;i++)sum-=a[i][j]; for(i=1;i&lt;=n;i++)&#123; ll pay=a[i][mn[i][j]]-a[i][j]; sum-=pay; mx=max(mx,pay); rightend=min(rightend,mn[i][j]); &#125; if(rightend!=j)sum+=mx; ans=max(ans,sum); &#125; printf("%lld\n",ans); &#125; return 0;&#125; isha]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM-ICPC 2017 现场赛(西安) 题解]]></title>
    <url>%2F2019%2F08%2F02%2F2017icpcxian%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K 6/11 O O . . . O O O . O . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A - XOR 题目描述给一个序列$a_i$和一个正整数$k$，$Q$次询问，每次询问一个区间$l,r$，求该区间中任取元素集合的异或和$v$与$k$取或（$v|k$）的最大值。 解题思路先不考虑$k$，考虑求区间异或和最大值，显然用线段树合并线性基即可求解。 考虑$k$的每一位，如果为$1$，则这一位在最终结果必然为$1$，故线性基中可以不考虑这一位，把所有的数这一位都置为$0$。其他位对线性基没有影响，照常取最大值即可。 我们发现这是一个对$k$取反变成$k’$，再把每个数与$k’$取与的操作。 线段树+线性基合并即可。复杂度$O(Pn+QP^3)$，$P=27$。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 40010#define P 28#define mid ((l+r)&gt;&gt;1)struct linebase&#123; int bas[2+P]; void clear()&#123;memset(bas,0,sizeof(bas));&#125; void insert(int x)&#123; int i; for(i=P;i&gt;=0;i--)&#123; if(!(x&amp;(1&lt;&lt;i)))continue; if(!bas[i])&#123; bas[i]=x; return; &#125; x^=bas[i]; &#125; &#125;&#125;empty,t[N];int L[N],R[N];linebase merge(linebase a,linebase b)&#123; int i; for(i=P;i&gt;=0;i--)if(a.bas[i])b.insert(a.bas[i]); return b;&#125;int a[N];void build(int p,int l,int r)&#123; L[p]=l;R[p]=r; t[p].clear(); if(l==r)&#123; t[p].insert(a[l]); return; &#125; build(p&lt;&lt;1,l,mid); build(p&lt;&lt;1|1,mid+1,r); t[p]=merge(t[p&lt;&lt;1],t[p&lt;&lt;1|1]);&#125;linebase query(int p,int l,int r)&#123; if(L[p]&gt;=l&amp;&amp;R[p]&lt;=r)return t[p]; if(!L[p]||L[p]&gt;r||R[p]&lt;l)return empty; return merge(query(p&lt;&lt;1,l,r),query(p&lt;&lt;1|1,l,r));&#125;int main()&#123; int i,T; scanf("%d",&amp;T); empty.clear(); while(T--)&#123; int n,q,k; memset(L,0,sizeof(L)); memset(R,0,sizeof(R)); scanf("%d%d%d",&amp;n,&amp;q,&amp;k); k=~k; for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); a[i]&amp;=k; &#125; k=~k; build(1,1,n); while(q--)&#123; int l,r,ans=k; scanf("%d%d",&amp;l,&amp;r); linebase cur=query(1,l,r); for(i=P;i&gt;=0;i--)ans=max(ans,ans^cur.bas[i]); printf("%d\n",ans); &#125; &#125; return 0;&#125; B - Lovers 题目描述有两个数列$a_i,b_i$，$a_i+b_j\geq k$则$i,j$可匹配。每个$i$最多只能配对一个$j$，反之亦然，问最多能够匹配多少对。 解题思路问题转化成$a_i \geq c_j=(k-b_j)$，排序双指针模拟即可。 AC代码点击 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 200010int n,k,a[N],b[N];int main()&#123; int i,t; scanf("%d",&amp;t); while(t--)&#123; int ans=0; scanf("%d%d",&amp;n,&amp;k); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)scanf("%d",&amp;b[i]),b[i]=k-b[i]; sort(a,a+n);sort(b,b+n); int r=0,l=0; while(l&lt;n&amp;&amp;r&lt;n)&#123; if(a[l]&gt;=b[r])ans++,l++,r++; else l++; &#125; printf("%d\n",ans); &#125; return 0;&#125; C - Naomi with Array 题目描述解题思路AC代码点击 12 D - Islands 题目描述解题思路AC代码点击 12 E - Naomi with Graph 题目描述解题思路AC代码点击 12 F - God of Gamblers 题目描述有一个赌博游戏，你有$n$个$RMB$，对方有$m$个$RMB$，从$1$个$RMB$开始赌起，每次每个人胜利的概率均为$50%$，如果某个人在赌注为$i$的时候输了，这$i$个$RMB$都归对方，两方都会拿出$2i$的$RMB$继续下一轮赌博。当某个人没有$RMB$时，对方获胜。问你获胜的概率是多少。 解题思路不会做，但感觉是个很公平的游戏，输出$\frac {n}{n+m}$即可。 AC代码点击 12345678#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int main()&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))printf("%.5f\n",1.0*n/(n+m)); return 0;&#125; G - Sum of xor sum 题目描述给一个数列，每次询问一个区间$[l,r]$中的所有连续子区间异或和的和是多少。 解题思路考虑拆位。 对于每一位，相当于询问在$[l,r]$区间内有多少个不同的连续子区间，其总$1$的个数为奇数（或者说：异或和为$1$）。 考虑用线段树维护这个数据。要进行合并操作，还需要维护区间的异或和、前缀后缀各有多少个异或和为$0/1$的子区间。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010#define mid ((l+r)&gt;&gt;1)int mod=1000000007;struct Data&#123; ll sub[2],pre[2],suf[2],sum; friend Data operator+(const Data &amp;a,const Data&amp;b)&#123; Data tmp; tmp.sum=a.sum^b.sum; tmp.sub[0]=a.sub[0]+b.sub[0]+a.suf[0]*b.pre[0]+a.suf[1]*b.pre[1]; tmp.sub[1]=a.sub[1]+b.sub[1]+a.suf[0]*b.pre[1]+a.suf[1]*b.pre[0]; tmp.pre[0]=a.pre[0]; tmp.pre[1]=a.pre[1]; if(!a.sum)tmp.pre[0]+=b.pre[0],tmp.pre[1]+=b.pre[1]; else tmp.pre[0]+=b.pre[1],tmp.pre[1]+=b.pre[0]; tmp.suf[0]=b.suf[0]; tmp.suf[1]=b.suf[1]; if(!b.sum)tmp.suf[0]+=a.suf[0],tmp.suf[1]+=a.suf[1]; else tmp.suf[0]+=a.suf[1],tmp.suf[1]+=a.suf[0]; for(int i=0;i&lt;2;i++)tmp.sub[i]%=mod,tmp.pre[i]%=mod,tmp.suf[i]%=mod; return tmp; &#125;&#125;emp,tr[21][N&lt;&lt;2];int L[N],R[N],a[N];void build(int p,int l,int r,int x)&#123; L[p]=l;R[p]=r; if(l==r)&#123; int y=(a[l]&gt;&gt;x)&amp;1; if(y)tr[x][p]=(Data)&#123;&#123;0,1&#125;,&#123;0,1&#125;,&#123;0,1&#125;,1&#125;; else tr[x][p]=(Data)&#123;&#123;1,0&#125;,&#123;1,0&#125;,&#123;1,0&#125;,0&#125;; return; &#125; build(p&lt;&lt;1,l,mid,x); build(p&lt;&lt;1|1,mid+1,r,x); tr[x][p]=tr[x][p&lt;&lt;1]+tr[x][p&lt;&lt;1|1];&#125;Data query(int p,int l,int r,int x)&#123; if(l&gt;=L[p]&amp;&amp;r&lt;=R[p])return tr[x][p]; if(l&gt;R[p]||r&lt;L[p])return emp; return query(p&lt;&lt;1,l,r,x)+query(p&lt;&lt;1|1,l,r,x);&#125;int main()&#123; int i,T,n,q; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;q); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;20;i++)build(1,1,n,i); while(q--)&#123; ll ans=0; int l,r; scanf("%d%d",&amp;l,&amp;r); for(i=0;i&lt;20;i++) (ans+=(1LL&lt;&lt;i)*query(1,l,r,i).sub[1]%mod)%=mod; printf("%lld\n",ans); &#125; &#125; return 0;&#125; H - Arrangement for Contests 题目描述给定每个难度的题的个数，问最多能出多少套题。难度连续的$k$个题可以出成套题。 解题思路贪心，每次找到区间最小值删除并更新答案，用线段树维护即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 400010#define mid ((l+r)&gt;&gt;1)int tr[N],L[N],R[N],mn[N],lazy[N],a[N];void pushdown(int x)&#123; if(!lazy[x])return; int t=lazy[x]; if(L[x&lt;&lt;1])lazy[x&lt;&lt;1]+=t,mn[x&lt;&lt;1]-=t; if(L[x&lt;&lt;1|1])lazy[x&lt;&lt;1|1]+=t,mn[x&lt;&lt;1|1]-=t; lazy[x]=0;&#125;void build(int l,int r,int p)&#123; L[p]=l;R[p]=r; lazy[p]=mn[p]=0; if(l==r)&#123; mn[p]=a[l]; return; &#125; build(l,mid,p&lt;&lt;1); build(mid+1,r,p&lt;&lt;1|1); mn[p]=min(mn[p&lt;&lt;1],mn[p&lt;&lt;1|1]);&#125;int query(int l,int r,int p)&#123; if(l&lt;=L[p]&amp;&amp;R[p]&lt;=r)return mn[p]; if(R[p]&lt;l||L[p]&gt;r)return 1e9; pushdown(p); return min(query(l,r,p&lt;&lt;1),query(l,r,p&lt;&lt;1|1));&#125;void modify(int l,int r,int p,int x)&#123; pushdown(p); if(L[p]&gt;=l&amp;&amp;R[p]&lt;=r)&#123; lazy[p]+=x; mn[p]-=x; return; &#125; int m=(L[p]+R[p])&gt;&gt;1; if(m&gt;=l)modify(l,r,p&lt;&lt;1,x); if(m+1&lt;=r)modify(l,r,p&lt;&lt;1|1,x); mn[p]=min(mn[p&lt;&lt;1],mn[p&lt;&lt;1|1]);&#125;int main()&#123; int i,t,n,k; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); int l=1,r=k,ans=0; build(1,n,1); while(1)&#123; int mn; while(r&lt;=n&amp;&amp;(mn=query(l,r,1))&lt;=0)l++,r++; if(r&gt;n)break; ans+=mn; modify(l,r,1,mn); &#125; printf("%d\n",ans); &#125; return 0;&#125; I - Acedia 题目描述解题思路AC代码点击 12 J - LOL 题目描述一共$100$个英雄，我方五人，敌方五人，每人可以选择一个英雄、禁掉一个英雄，这$20$个英雄互不相同。已知敌方什么英雄都能选，而我方英雄只能从给定输入里的$1$中挑选。问有多少种方案。 解题思路枚举我方前四个人的选法，第五个人的选法可以由此确定下来，设总方案数为$p$。我方英雄选好后，敌方可以有顺序选$5$个英雄，我方和敌方可无顺序选$5$个英雄禁掉。故答案为$p\times A_{95}^5\times C_{90}^5\times C_{85}^5$。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char a[5][110];int vis[110];int mod=1000000007,ans;void dfs(int x,int s)&#123; int i,tmp; if(x==4)&#123; (ans+=s)%=mod; return; &#125; for(i=0;i&lt;100;i++)if(a[x][i]=='1'&amp;&amp;!vis[i])&#123; tmp=s; vis[i]=1; if(a[4][i]=='1')tmp--; dfs(x+1,tmp); vis[i]=0; &#125;&#125;int fac[110]=&#123;1&#125;,inv[110]=&#123;1&#125;;int c(int n,int m)&#123; return 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;int A(int n,int m)&#123; return 1LL*fac[n]*inv[n-m]%mod;&#125;int qp(ll x,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,x=x*x%mod)if(p&amp;1)ans=ans*x%mod; return ans;&#125;int main()&#123; int i,s=0; for(i=1;i&lt;100;i++)&#123; fac[i]=1LL*fac[i-1]*i%mod; inv[i]=qp(fac[i],mod-2); &#125; while(~scanf("%s%s%s%s%s",a[0],a[1],a[2],a[3],a[4]))&#123; s=0;ans=0; for(i=0;i&lt;100;i++)if(a[4][i]=='1')s++; dfs(0,s); printf("%d\n",1LL*ans*A(95,5)%mod*c(90,5)%mod*c(85,5)%mod); &#125; return 0;&#125; K LOVER II 题目描述解题思路AC代码点击 12 L 题目描述解题思路AC代码点击 12 M 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营第五场 题解]]></title>
    <url>%2F2019%2F08%2F01%2F2019nowcodersummercontest-5%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 8/10 O O Ø . Ø O O O Ø . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给一个不超过$100$的正数$n$，求一个不超过$10^4$位的数$x$满足：$num(x)%n=0,x%n=0$ ，$num(x)$表示$x$的数位和。 解题思路输出$n$个$n$即可。 AC代码点击 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t,n; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)printf("%d",&amp;n); puts(""); &#125;&#125; B 题目描述给$x_0,x_1,a,b$，求出满足$x_i=ax_{i-1}+bx_{i-2}$的$x_n$，$1\leq n\leq 10^{10^6}$。 解题思路用十进制进行快速幂，复杂度$O(10\log n)$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;int mod = 1e9+7;typedef long long ll;const int maxn = 1e6+23;char s[maxn];ll x0,x1;int a,b,n;struct matrix&#123; ll a,b,c,d; void init()&#123; a=1,b=0,c=0,d=1; &#125;&#125;;matrix pow(matrix A,matrix B)&#123; matrix C; C.a=(A.a*B.a)+(A.b*B.c);C.a%=mod; C.b=(A.a*B.b)+(A.b*B.d);C.b%=mod; C.c=(A.c*B.a)+(A.d*B.c);C.c%=mod; C.d=(A.c*B.b)+(A.d*B.d);C.d%=mod; return C;&#125;int main()&#123; cin &gt;&gt; x0 &gt;&gt; x1 &gt;&gt; a &gt;&gt; b ; scanf("%s",s);cin &gt;&gt; mod ; n=strlen(s); matrix A;A.a=a,A.b=b,A.c=1,A.d=0; matrix ans;ans.init(); for(int i=n-1;i&gt;=0;i--)&#123; int t=s[i]-'0';matrix B=A; if(t==0) B.init(); for(int j=1;j&lt;t;j++) B=pow(B,A); ans=pow(ans,B); for(int j=t;j&lt;10;j++) B=pow(B,A); A=B; &#125; ll t=0; t=ans.c*x1+ans.d*x0;t%=mod; cout &lt;&lt; t;&#125; C 题目描述给一个数列：$x_i=(ax_{i-1}+b)mod\space p$，$0\leq i&lt;n$。给定$n,a,b,p$，有$q$次询问，每次询问$v$是否在数列中，如果是，输出下标，否则输出$-1$。 $1\leq n\leq 10^{18},0\leq x_p,a,b&lt;p\leq 10^9+9,q\leq 1000,0\leq v&lt;p$。 解题思路一眼没看出来有式子可推，高中数学白学了 推式子：待定系数法化为等比数列，$x_i+\frac b{a-1}=a(x_{i-1}+\frac b{a-1})$，就可以$BSGS$了 高代学疯了看着是个矩阵，$\left(\begin{aligned}a\space {0}\\b\space{1}\end{aligned}\right)^p \left(\begin{aligned}x_0\\1\end{aligned}\right)=\left(\begin{aligned}v\\1\end{aligned}\right)$ 于是设$p=i\times m-j$，式子转化为$\left(\begin{aligned}a\space {0}\\b\space{1}\end{aligned}\right)^{i\times m} \left(\begin{aligned}x_0\\1\end{aligned}\right)=\left(\begin{aligned}v\\1\end{aligned}\right)\left(\begin{aligned}a\space {0}\\b\space{1}\end{aligned}\right)^j $，这里特判一下不能转化为这个式子的情况（矩阵没有逆）。 正常套路$BSGS$，先预处理出矩阵的$i\times m$次幂$i\in [1,\lceil \frac pm\rceil]$，每次枚举$j\in [0,m]$即可。由于不是预处理$j$然后$i$从小枚举即可保证是最佳答案，所以不能找到解$im+j$就退出，找到$j$后需要与以前找过的答案做大小比较，复杂度可能会高一些。 由于有$q$次询问，平均复杂度为$O(T(\lceil \frac pm \rceil+qm))$，故取$m=\lceil \frac pq \rceil$来降低询问时的复杂度。 设矩阵为$A$，我们发现$A$的$k$次幂的形式都为$\left(\begin{aligned}k_1\space {0}\\k_2\space{1}\end{aligned}\right)$，故只保存两个数值即可减少一些常数。 时限剧毒，放一下卡常记录（$WA$那次是因为特判的时候$0$和$1$先后顺序反了） AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;unordered_map&lt;ll,int&gt;mp;int mod;struct Matrix&#123; ll a,b; Matrix operator*(Matrix t)&#123;return (Matrix)&#123;a*t.a%mod,(t.a*b+t.b)%mod&#125;;&#125;&#125;E;int main()&#123; int i,T; E.a=1;E.b=0; scanf("%d",&amp;T); while(T--)&#123; ll n,x0,a,b,p,q,v; scanf("%lld%lld%lld%lld%lld%lld",&amp;n,&amp;x0,&amp;a,&amp;b,&amp;p,&amp;q); if(!a)&#123;//不存在逆矩阵 while(q--)&#123; scanf("%lld",&amp;v); if(v==x0)printf("0\n"); else if(v==b)printf("1\n"); else printf("-1\n"); &#125; continue; &#125; mp.clear(); mod=p; Matrix A=(Matrix)&#123;a,b&#125;; ll m=ceil(sqrt(1.0*p/q)),M=ceil(1.0*p/m); Matrix now=A; for(i=1;i&lt;m;i++)now=now*A;//A^m Matrix __im=E; ll ans=1; for(i=1;i&lt;=M&amp;&amp;i*m-m&lt;n;i++)&#123;//A^&#123;im&#125; __im=__im*now,ans=(__im.a*x0+__im.b)%mod; if(!mp.count(ans))mp[ans]=i; else break;//循环 &#125; while(q--)&#123; int v; scanf("%d",&amp;v); ll res=2e18,ans=1; Matrix now=E; for(i=0;i&lt;=m;i++)&#123; if(i)now=now*A; ans=(now.a*v+now.b)%mod; if(mp.count(ans))res=min(res,mp[ans]*m-i); &#125; if(res&gt;=n)res=-1; printf("%lld\n",res); &#125; &#125; return 0;&#125; D 题目描述解题思路AC代码点击 12 E 题目描述给一张点最多有$26$个的图，求所有子图的独立集大小之和。 解题思路设某个子图为$s$状态，$f[s]$表示该状态独立集的大小。假设$x$为$s$的最低为$1$的位，有$f[s]$为去掉$x$的大小和去掉$x$连边大小$+1$的最大值，即$f[s]=max(f[s-(1&lt;&lt;x)],1+f[s&amp;(\text ~state[x])])$，其中$state[i]$表示和$i$连边或$i$本身的状态。 AC代码点击 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int state[30];int ans;char dp[(1&lt;&lt;26)+10];int main()&#123; int i,n,m,u,v,mb=-1; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)state[i]|=1&lt;&lt;i; for(i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); state[u]|=1&lt;&lt;v; state[v]|=1&lt;&lt;u; &#125; for(i=1;i&lt;(1&lt;&lt;n);i++)&#123; mb+=(i&amp;(-i))==i; dp[i]=max(dp[i-(1&lt;&lt;mb)],(char)(dp[i&amp;(~state[mb])]+1)); ans+=dp[i]; &#125; printf("%d",ans); return 0;&#125; F 题目描述有$n$个不同的数，求最大的子集，保证子集中任意两个数的二进制表示都至少有两个不同的位。 解题思路两个恰有一位不同的数不在同一集合，也就是如果满足这个条件就连一条边，问题转化为二分图的最大独立集。先染色，再求一个最大匹配，再对所有左图没有对应右图中的点的点进行增广，在这些次增广没有被访问到的左图中的点和访问到的右图中的点为一个最小点覆盖，剩下的点就是最大独立集。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 5010int n,a[N];struct Edge&#123; int e,n,l;&#125;e[N*N/2];int vis[N],hd[N],ct=1,mt[N];void add(int a,int b,int l)&#123; e[++ct].e=b;e[ct].n=hd[a];hd[a]=ct;e[ct].l=l; assert(ct&lt;N*N/2);&#125;int col[N];vector&lt;int&gt;G[5];void dfs(int x,int c)&#123; col[x]=c; G[c].push_back(x); int i; for(i=hd[x];i;i=e[i].n)&#123; int q=e[i].e; if(!col[q])dfs(q,c^1); &#125;&#125;int L[N],R[N],S[N],T[N];int dfs2(int p)&#123;//p:左半边编号 int i; S[p]=1; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(!T[q])&#123; T[q]=1; if(L[q]==-1||dfs2(L[q]))&#123; L[q]=p; R[p]=q; return 1; &#125; &#125; &#125; return 0;&#125;int outs[N];void solve()&#123; int i,ans=0; memset(L,-1,sizeof(L)); memset(R,-1,sizeof(R)); for(auto i:G[2])&#123; memset(S,0,sizeof(S)); memset(T,0,sizeof(T)); if(dfs2(i))ans++; &#125; printf("%d\n",n-ans); memset(S,0,sizeof(S)); memset(T,0,sizeof(T)); for(auto i:G[2])if(R[i]==-1)dfs2(i); for(auto i:G[2])if(!S[i])outs[i]=1; for(auto i:G[3])if(T[i])outs[i]=1; for(i=1;i&lt;=n;i++)if(!outs[i])printf("%d ",a[i]);&#125;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++) for(j=i+1;j&lt;=n;j++) if(__builtin_popcount(a[i]^a[j])&lt;2) add(i,j,1),add(j,i,1); for(i=1;i&lt;=n;i++)&#123; if(!col[i])dfs(i,2); &#125; solve(); return 0;&#125; G 题目描述求$s$有多少个合法子串$x$满足十进制下$x&gt;t$。 解题思路长度大于$m$的可以排列组合算出，求出有多少个长度为$m$的大于$t$的$s$的子串即可。 $f[i][j][0]$表示到$s$的第$i$个数字，与$t$前$j$位相等的种数；$f[i][j][1]$表示到$s$的第$i$个数字，比$t$前$j$位大的种数。转移非常显然。特判一下前导$0$即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 3002int f[N][N][2],m,n;char a[N],b[N];int fac[N]=&#123;1&#125;,inv[N],mod=998244353;int qp(int x,int p)&#123; int ans=1; for(;p;p&gt;&gt;=1,x=1LL*x*x%mod)if(p&amp;1)ans=1LL*ans*x%mod; return ans;&#125;int c(int n,int m)&#123; if(n&lt;m)return 0; return 1LL*fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;int main()&#123; int i,j,t; scanf("%d",&amp;t); for(i=1;i&lt;N;i++)fac[i]=fac[i-1]*1LL*i%mod; for(i=0;i&lt;N;i++)inv[i]=qp(fac[i],mod-2); while(t--)&#123; scanf("%d%d%s%s",&amp;n,&amp;m,a+1,b+1); ll ans=0; f[0][0][0]=1; for(i=1;i&lt;=n;i++)&#123; f[i][0][0]=1; if(a[i]!='0')for(j=m;j&lt;=n-i;j++)(ans+=c(n-i,j))%=mod; for(j=1;j&lt;=m&amp;&amp;j&lt;=i;j++)&#123; (f[i][j][0]=f[i-1][j][0]+(a[i]==b[j]?f[i-1][j-1][0]:0))%=mod; (f[i][j][1]=(f[i-1][j][1]+f[i-1][j-1][1])%mod+(a[i]&gt;b[j]?f[i-1][j-1][0]:0))%=mod; &#125; &#125; printf("%lld\n",(ans+f[n][m][1])%mod); &#125; return 0;&#125; H 题目描述求构造一个串满足给定$hidden$字母的顺序。 解题思路特判空串、各个字符个数，编完号建图拓扑序跑一遍即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010char a[N],s[10];char ch[N];struct Edge&#123; int e,n;&#125;e[1000000];int hd[N],ind[N],cnt;void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt; ind[b]++;&#125;vector&lt;int&gt;id[30];int tot,vis[30];queue&lt;int&gt;Q;vector&lt;char&gt;ans;int main()&#123; int i,j,n,m; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;m*(m-1)/2;i++)&#123; int l; scanf("%s%d",s,&amp;l); if(l)scanf("%s",a); else a[0]='\0'; int t0=id[s[0]-'a'].size(),t1=id[s[1]-'a'].size(); if(vis[s[0]-'a'])&#123; for(j=0;j&lt;l;j++)if(a[j]==s[0])t0--; if(t0)return printf("-1"),0; &#125; if(vis[s[1]-'a'])&#123; for(j=0;j&lt;l;j++)if(a[j]==s[1])t1--; if(t1)return printf("-1"),0; &#125; for(j=0;j&lt;l;j++)&#123; if(!vis[a[j]-'a'])&#123; id[a[j]-'a'].push_back(++tot); ch[tot]=a[j]; &#125; &#125; vis[s[0]-'a']=vis[s[1]-'a']=1; if(!l)continue; int L=0,R=0,last=id[a[0]-'a'][0]; if(s[0]==a[0])L++;else R++; for(j=1;j&lt;l;j++)&#123; int now; if(a[j]==s[0])now=id[a[j]-'a'][L],L++; else now=id[a[j]-'a'][R],R++; add(last,now); last=now; &#125; &#125; for(i=1;i&lt;=tot;i++)if(!ind[i])Q.push(i); while(!Q.empty())&#123; int idt=Q.front();Q.pop(); ans.push_back(ch[idt]); for(i=hd[idt];i;i=e[i].n)&#123; int x=e[i].e; if(!--ind[x])Q.push(x); &#125; &#125; if(ans.size()!=n||tot!=n)printf("-1"); else for(auto it:ans)printf("%c",it); return 0;&#125; I 题目描述求一个$x\in [0,w],y\in [0,h]$的三个点，满足距离分别为$a,b,c$。 解题思路暴力枚举连在原点上的两条边，检查即可。有精度问题。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;int T;double w,h,a,b,c;double dis[3];int a1,a2,a3,a4,a5;double x[3],y[3];double getdis(int i,int j)&#123; return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));&#125;int main()&#123; cin &gt;&gt; T; while(T--)&#123; scanf("%d%d%d%d%d",&amp;a1,&amp;a2,&amp;a3,&amp;a4,&amp;a5); int W=a1,H=a2,flag=0; w=a1,h=a2,a=a3,b=a4,c=a5; dis[0]=a,dis[1]=b,dis[2]=c; bool change=false; if(w&lt;h) &#123;swap(w,h);change=true;&#125; x[0]=y[0]=0; double the; for(int i=0;i&lt;3;i++)&#123; for(int j=0;j&lt;3;j++)&#123; if(i==j)continue; if(dis[i]&lt;=w) x[2]=dis[i],y[2]=0,the=1; else&#123; x[2]=w,y[2]=sqrt(dis[i]*dis[i]-w*w); the=w/dis[i]; &#125; int k=3-i-j; double cosi=(dis[i]*dis[i]+dis[j]*dis[j]-dis[k]*dis[k])/(2*dis[i]*dis[j]); double phi=acos(cosi);the=acos(the); x[1]=dis[j]*cos(phi+the);y[1]=dis[j]*sin(phi+the); if(change)for(int l=0;l&lt;3;l++)swap(x[l],y[l]); for(int l=0;l&lt;3;l++)&#123; if(x[l]&lt;1e-7)x[l]+=1e-7; if(y[l]&lt;1e-7)y[l]+=1e-7; if(x[l]&gt;W-1e-7)x[l]-=1e-7; if(y[l]&gt;H-1e-7)y[l]-=1e-7; &#125; if(x[0]&gt;=0&amp;&amp;x[0]&lt;=W);else continue; if(x[1]&gt;=0&amp;&amp;x[1]&lt;=W);else continue; if(x[2]&gt;=0&amp;&amp;x[2]&lt;=W);else continue; if(y[0]&gt;=0&amp;&amp;y[0]&lt;=H);else continue; if(y[1]&gt;=0&amp;&amp;y[1]&lt;=H);else continue; if(y[2]&gt;=0&amp;&amp;y[2]&lt;=H);else continue; for(int p=0;p&lt;3;p++)&#123; for(int q=0;q&lt;3;q++)&#123; if(q==p)continue; int r=3-p-q; if(!(abs(getdis(p,q)-a)&lt;1e-6))continue; if(abs(getdis(p,r)-b)&lt;1e-6&amp;&amp;abs(getdis(q,r)-c)&lt;1e-6)&#123; printf("%.10f %.10f %.10f %.10f %.10f %.10f\n",x[p],y[p],x[q],y[q],x[r],y[r]); flag=1; goto A; &#125; &#125; &#125; &#125; &#125; A:; assert(flag); &#125;&#125; J 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营第四场 题解]]></title>
    <url>%2F2019%2F07%2F28%2F2019nowcodersummercontest-4%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K 7/11 O Ø O O . . . . Ø O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给一个点数为$n$的树，树上有$k$个人在不同的节点上，他们每秒能走一条边，问他们集会（走到相同位置）最短需要多少时间。 解题思路先把树转化成叶子节点均为人的新树，在新树上求直径即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010int n,k,a,b;vector&lt;int&gt;G[N],G2[N];int inG2[N];int dfs(int x,int f)&#123; int i; for(i=0;i&lt;G[x].size();i++)&#123; int y=G[x][i]; if(y!=f&amp;&amp;dfs(y,x))&#123; inG2[x]++; G2[x].push_back(y); G2[y].push_back(x); &#125; &#125; return inG2[x];&#125;int ans=0,d[N],vis[N];void dp(int x)&#123; int i; vis[x]=1; for(i=0;i&lt;G2[x].size();i++)&#123; int y=G2[x][i]; if(!vis[y])&#123; dp(y); ans=max(ans,d[x]+d[y]+1); d[x]=max(d[x],d[y]+1); &#125; &#125;&#125;int main()&#123; int i; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;n;i++)&#123; scanf("%d%d",&amp;a,&amp;b); G[a].push_back(b); G[b].push_back(a); &#125; for(i=0;i&lt;k;i++) scanf("%d",&amp;a),inG2[a]++; int rt=1;while(!inG2[rt])rt++; dfs(rt,-1); dp(rt); printf("%d",(ans+1)/2); return 0;&#125; B 题目描述$n$个集合，$m$次询问，每次询问一个区间$[l,r]$，问是否任意区间中的集合都能用异或表示$x$。 $1\leq n,m\leq 50000,0\leq x&lt;2^{32}$。 解题思路线性基+线段树。 线性基求交的思想很有意思，本质就是线性空间的两组基求交，比如两平面求交。 假设现在我们要对$a,b$两组基求交。从低到高枚举$b$的基$b_i$，如果它能够被$a$和以前枚举出的$b$（$b_1…b_{i-1}$）线性表示，假设$b_i=a_{k_1}\oplus a_{k_2}\oplus…\oplus a_{k_p}\oplus b_{l_1}\oplus b_{l_2}\oplus…\oplus b_{l_q}$，则$a_{k_1}\oplus a_{k_2}\oplus…\oplus a_{k_p}$为交集的一个基。故维护一个$tot$代表$a$和以前的$b$组成的基，维护一个到达$tot_j$所需要的$a_{k_1}\oplus a_{k_2}\oplus…\oplus a_{k_p}$的值，每次插入$b_i$时分别异或插入即可。 每次合并复杂度$O(32^2)$，建立线段树复杂度$O(32^2n\log n)$，每次询问$O(32\log n)$，总时间复杂度$O(32^2n\log n+32m\log n)$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 50010#define M 35struct Base&#123; int a[33];&#125;t[N&lt;&lt;2];int n,m;int insert(Base *bas,int x,int flag)&#123;//flag:是否真插入 int i; for(i=31;i&gt;=0;i--)&#123; if((1&lt;&lt;i)&amp;x)&#123; if((*bas).a[i])x^=(*bas).a[i]; else&#123; if(flag)(*bas).a[i]=x; return 1; &#125; &#125; if(!x)return 0; &#125; return printf("err"),0;&#125;void merge(Base *e,Base a,Base b)&#123; Base tot; int i,j; for(i=0;i&lt;32;i++)tot.a[i]=a.a[i],(*e).a[i]=0; for(i=0;i&lt;32;i++)&#123; if(b.a[i])&#123; int cur=b.a[i],add=0; for(j=i;j&gt;=0;j--)&#123; if((1&lt;&lt;j)&amp;cur)&#123; if(tot.a[j])&#123; cur^=tot.a[j]; add^=a.a[j]; if(!cur)&#123; (*e).a[i]=add; break; &#125; &#125;else&#123; tot.a[j]=cur; a.a[j]=add; break; &#125; &#125; &#125; &#125; &#125;&#125;int siz[N],v[N][M];void build(int p,int l,int r)&#123; if(l==r)&#123; int i; for(i=0;i&lt;siz[l];i++)insert(&amp;t[p],v[l][i],1); return; &#125; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); merge(&amp;t[p],t[p&lt;&lt;1],t[p&lt;&lt;1|1]);&#125;int query(int p,int l,int r,int ql,int qr,int x)&#123; if(ql&lt;=l&amp;&amp;qr&gt;=r)return !insert(&amp;t[p],x,0); if(ql&lt;=(l+r)&gt;&gt;1&amp;&amp;!query(p&lt;&lt;1,l,(l+r)&gt;&gt;1,ql,qr,x))return 0; if(qr&gt;((l+r)&gt;&gt;1)&amp;&amp;!query(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r,ql,qr,x))return 0; return 1;&#125;int main()&#123; int i,j; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;siz[i]); for(j=0;j&lt;siz[i];j++)scanf("%d",&amp;v[i][j]); &#125; build(1,1,n); for(i=0;i&lt;m;i++)&#123; int l,r,x; scanf("%d%d%d",&amp;l,&amp;r,&amp;x); printf("%s\n",query(1,1,n,l,r,x)?"YES":"NO"); &#125; return 0;&#125; C 题目描述给两个数列$a_i,b_i$，求$max(min(a_{l…r})\times sum(b_{l…r}))$。 解题思路分治，对每一个$[l,r]$对最小值分治，找到向左右延伸的$b$前缀和最大最小值更新答案即可。 首先，我用$ST$表，获得了$MLE$ 。 MLE代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 3000010int n;ll a[N],b[N];int rmq[22][N];int rmin[22][N],rmax[22][N];int lg[N];ll ans=-1e18;void init(int rmq[][N],ll *a,int flag)&#123; int i,j; for(i=0;i&lt;=n;i++)rmq[0][i]=i; for(j=1;(1&lt;&lt;j)&lt;=n;j++)&#123; for(i=0;i+(1&lt;&lt;(j-1))-1&lt;=n;i++)&#123; if(flag==1)&#123;//max if(a[rmq[j-1][i]]&lt;a[rmq[j-1][i+(1&lt;&lt;(j-1))]]) rmq[j][i]=rmq[j-1][i+(1&lt;&lt;(j-1))]; else rmq[j][i]=rmq[j-1][i]; &#125;else&#123;//min if(a[rmq[j-1][i]]&gt;a[rmq[j-1][i+(1&lt;&lt;(j-1))]]) rmq[j][i]=rmq[j-1][i+(1&lt;&lt;(j-1))]; else rmq[j][i]=rmq[j-1][i]; &#125; &#125; &#125;&#125;int query(int rmq[][N],ll *a,int l,int r,int flag)&#123; int f=lg[r-l+1]; if(flag)&#123; if(a[rmq[f][l]]&lt;a[rmq[f][r+1-(1&lt;&lt;f)]])return rmq[f][r+1-(1&lt;&lt;f)]; else return rmq[f][l]; &#125;else&#123; if(a[rmq[f][l]]&gt;a[rmq[f][r+1-(1&lt;&lt;f)]])return rmq[f][r+1-(1&lt;&lt;f)]; else return rmq[f][l]; &#125;&#125;void dc(int l,int r)&#123; if(l&gt;r)return; if(l==r)&#123; ans=max(ans,a[l]*(b[l]-b[l-1])); return; &#125; int pos=query(rmq,a,l,r,0); if(a[pos]&lt;0)&#123; ans=max(ans,a[pos]*(b[query(rmin,b,pos,r,0)]-b[query(rmax,b,l-1,pos,1)])); &#125;else&#123; ans=max(ans,a[pos]*(b[query(rmax,b,pos,r,1)]-b[query(rmin,b,l-1,pos,0)])); &#125; dc(l,pos-1); dc(pos+1,r);&#125;int main()&#123; int i; scanf("%d",&amp;n); for(i=2;i&lt;N;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;b[i]),b[i]+=b[i-1]; init(rmq,a,0); init(rmin,b,0); init(rmax,b,1); dc(1,n); printf("%lld",ans); return 0;&#125; 有点自闭，把$ST$表换成笛卡尔树试了试。 获得了$TLE$ 。 TLE代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 3000010int n;ll a[N],b[N];/*int rmq[24][N];int rmin[24][N],rmax[24][N];int lg[N];*/int rt1,rtmin,rtmax;int ls[3][N],rs[3][N],fa[3][N];ll ans=-1e18;/*void init(int rmq[][N],ll *a,int flag)&#123; int i,j; for(i=0;i&lt;=n;i++)rmq[0][i]=i; for(j=1;(1&lt;&lt;j)&lt;=n;j++)&#123; for(i=0;i+(1&lt;&lt;(j-1))-1&lt;=n;i++)&#123; if(flag==1)&#123;//max if(a[rmq[j-1][i]]&lt;a[rmq[j-1][i+(1&lt;&lt;(j-1))]]) rmq[j][i]=rmq[j-1][i+(1&lt;&lt;(j-1))]; else rmq[j][i]=rmq[j-1][i]; &#125;else&#123;//min if(a[rmq[j-1][i]]&gt;a[rmq[j-1][i+(1&lt;&lt;(j-1))]]) rmq[j][i]=rmq[j-1][i+(1&lt;&lt;(j-1))]; else rmq[j][i]=rmq[j-1][i]; &#125; &#125; &#125;&#125;*/int init(int *ls,int *rs,int *fa,ll *a,int flag)&#123; stack&lt;int&gt; st; //存放节点的key值 int rt,last; for(int i=0;i&lt;=n;++i)&#123; last=-1; while(!st.empty())&#123; if(a[st.top()]&lt;a[i]&amp;&amp;!flag||flag&amp;&amp;a[st.top()]&gt;a[i])&#123; rt=st.top(); if(rs[rt])&#123; fa[rs[rt]]=i; ls[i]=rs[rt]; &#125; rs[rt]=i; fa[i]=rt; break; &#125; last=st.top(); st.pop(); &#125; if(st.empty()&amp;&amp;last)&#123; fa[last]=i; ls[i]=last; &#125; st.push(i); &#125; while(!st.empty())rt=st.top(), st.pop(); return rt;&#125;int query(int *ls,int *rs,int root,int l,int r)&#123; while(root&lt;l||root&gt;r)root=root&lt;l?rs[root]:ls[root]; return root;&#125;/*int query(int rmq[][N],ll *a,int l,int r,int flag)&#123; int f=lg[r-l+1]; if(flag)&#123; if(a[rmq[f][l]]&lt;a[rmq[f][r+1-(1&lt;&lt;f)]])return rmq[f][r+1-(1&lt;&lt;f)]; else return rmq[f][l]; &#125;else&#123; if(a[rmq[f][l]]&gt;a[rmq[f][r+1-(1&lt;&lt;f)]])return rmq[f][r+1-(1&lt;&lt;f)]; else return rmq[f][l]; &#125;&#125;*/void dc(int l,int r)&#123; if(l&gt;r)return; if(l==r)&#123; ans=max(ans,a[l]*(b[l]-b[l-1])); return; &#125; int pos=query(ls[0],rs[0],rt1,l,r); //int pos=query(rmq,a,l,r,0); /*if(a[pos]&lt;0)&#123; ans=max(ans,a[pos]*(b[query(rmin,b,pos,r,0)]-b[query(rmax,b,l-1,pos,1)])); &#125;else&#123; ans=max(ans,a[pos]*(b[query(rmax,b,pos,r,1)]-b[query(rmin,b,l-1,pos,0)])); &#125;*/ if(a[pos]&lt;0)&#123; ans=max(ans,a[pos]*(b[query(ls[1],rs[1],rtmin,pos,r)]-b[query(ls[2],rs[2],rtmax,l-1,pos)])); &#125;else&#123; ans=max(ans,a[pos]*(b[query(ls[2],rs[2],rtmax,pos,r)]-b[query(ls[1],rs[1],rtmin,l-1,pos)])); &#125; dc(l,pos-1); dc(pos+1,r);&#125;int main()&#123; int i; scanf("%d",&amp;n); //for(i=2;i&lt;N;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;b[i]),b[i]+=b[i-1]; rt1=init(ls[0],rs[0],fa[0],a,0); rtmin=init(ls[1],rs[1],fa[1],b,0); rtmax=init(ls[2],rs[2],fa[2],b,1); dc(1,n); printf("%lld",ans); return 0;&#125; 学习了一发单调栈求最小值影响范围的，把最初的代码改了一下优化成两个$ST$表，恰好卡住$510M$，但莫名其妙$WA$了，对着标程各种数据拍了好久没找出问题，留坑准备拿到数据后再查一下。 WA代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 3000010int n;int a[N];ll b[N];int rmin[23][N],rmax[23][N];int lg[N];ll ans=-1e18;void init(int rmq[][N],ll *a,int flag)&#123; int i,j; for(i=0;i&lt;=n;i++)rmq[0][i]=i; for(j=1;(1&lt;&lt;j)&lt;=n;j++)&#123; for(i=0;i+(1&lt;&lt;(j-1))-1&lt;=n;i++)&#123; if(flag==1)&#123;//max if(a[rmq[j-1][i]]&lt;a[rmq[j-1][i+(1&lt;&lt;(j-1))]]) rmq[j][i]=rmq[j-1][i+(1&lt;&lt;(j-1))]; else rmq[j][i]=rmq[j-1][i]; &#125;else&#123;//min if(a[rmq[j-1][i]]&gt;a[rmq[j-1][i+(1&lt;&lt;(j-1))]]) rmq[j][i]=rmq[j-1][i+(1&lt;&lt;(j-1))]; else rmq[j][i]=rmq[j-1][i]; &#125; &#125; &#125;&#125;int query(int rmq[][N],ll *a,int l,int r,int flag)&#123; int f=lg[r-l+1]; if(flag)&#123; if(a[rmq[f][l]]&lt;a[rmq[f][r+1-(1&lt;&lt;f)]])return rmq[f][r+1-(1&lt;&lt;f)]; else return rmq[f][l]; &#125;else&#123; if(a[rmq[f][l]]&gt;a[rmq[f][r+1-(1&lt;&lt;f)]])return rmq[f][r+1-(1&lt;&lt;f)]; else return rmq[f][l]; &#125;&#125;int sta[N],top=1,c[N][2];void dc(int pos,int l,int r)&#123; int L=c[pos][0],R=c[pos][1]; if(!pos||l&gt;r)return; if(a[pos]&lt;0)&#123; ans=max(ans,a[pos]*(b[query(rmin,b,pos,r,0)]-b[query(rmax,b,l-1,pos-1,1)])); &#125;else if(a[pos]&gt;0)&#123; ans=max(ans,a[pos]*(b[query(rmax,b,pos,r,1)]-b[query(rmin,b,l-1,pos-1,0)])); &#125;else ans=max(ans,0LL); if(L)dc(L,l,pos-1); if(R)dc(R,pos+1,r);&#125;int main()&#123; int i; //freopen("data.in","r",stdin); scanf("%d",&amp;n); for(i=2;i&lt;N;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;b[i]),b[i]+=b[i-1]; sta[1]=1; for(i=2;i&lt;=n;i++)&#123; while(top&amp;&amp;a[i]&lt;a[sta[top]])&#123; c[sta[top]][1]=c[i][0]; c[i][0]=sta[top]; top--; &#125; sta[++top]=i; &#125; while(top&gt;1)c[sta[top-1]][1]=sta[top--]; init(rmin,b,0); init(rmax,b,1); dc(sta[1],1,n); printf("%lld",ans); return 0;&#125; 好耶，这是不想让我过了。那考虑一下标程的思路，每次在分治的过程中处理好左右端的最大最小值，感觉十分巧妙。 $upd$： 注释部分…是一个故事，算了不讲了 然后把上面$WA$的代码注释部分改一遍就变成了$MLE$…… AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 3000010int sta[N],top,a[N],tree[N][2];ll b[N],ans=-1e18;struct Datamax&#123; ll pre,suf,sum; friend Datamax operator +(const Datamax &amp;l,const Datamax &amp;r)&#123; ll sf=max(l.suf+r.sum,r.suf); ll s=l.sum+r.sum; ll p=max(l.sum+r.pre,l.pre); return (Datamax)&#123;p,sf,s&#125;; &#125;&#125;mx[N];Datamax fmx(ll x)&#123; ll p=max(x,0LL); ll sf=max(x,0LL); ll s=x; return (Datamax)&#123;p,sf,s&#125;;&#125;struct Datamin&#123; ll pre,suf,sum; friend Datamin operator +(const Datamin &amp;l,const Datamin &amp;r)&#123; ll sf=min(l.suf+r.sum,r.suf); ll s=l.sum+r.sum; ll p=min(l.sum+r.pre,l.pre); return (Datamin)&#123;p,sf,s&#125;; &#125;&#125;mn[N];Datamin fmn(ll x)&#123; ll p=min(x,0LL); ll sf=min(x,0LL); ll s=x; return (Datamin)&#123;p,sf,s&#125;;&#125;void dc(int x)&#123; int l=tree[x][0],r=tree[x][1]; if(l)dc(l); if(r)dc(r); ans=max(ans,a[x]*(mx[l].suf+b[x]+mx[r].pre)); ans=max(ans,a[x]*(mn[l].suf+b[x]+mn[r].pre)); mx[x]=mx[l]+fmx(b[x])+mx[r]; mn[x]=mn[l]+fmn(b[x])+mn[r];&#125;int main()&#123; int i,n; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;b[i]); sta[1]=top=1; for(i=2;i&lt;=n;i++)&#123; while(top&amp;&amp;a[i]&lt;a[sta[top]])&#123; tree[sta[top]][1]=tree[i][0]; tree[i][0]=sta[top]; top--; &#125; sta[++top]=i; &#125; while(top&gt;1)tree[sta[top-1]][1]=sta[top],top--;//...... dc(sta[1]); printf("%lld",ans); return 0;&#125; D 题目描述给一个$n$，求$3$的倍数数列$x_i$使得$|_ix_i=n$（或和为$n$），并最小化数列长度。 解题思路如果$n$为$3$的倍数，直接输出$n$ 否则通过观察，二进制对$3$的余数满足$12121212…$，故$n$的二进制必然为三个或以上个$1$。 分类讨论：当$n%3=1$时，如果有两个余数为$1$的位$p,q$，则答案可以为$n-p,n-q$；如果只有一个$p$，那必然有一个余数为$2$的位$q$，答案可以为$n-p,p+q$；如果没有，那至少有三个余数为$2$的位$p,q,r$，答案可以为$n-p-q,p+q+r$。$n%3=2$时与之类似。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int T;ll n,x,y;vector&lt;ll&gt;a[2];int main()&#123; int i; scanf("%d",&amp;T); while(T--)&#123; scanf("%lld",&amp;n); a[0].clear(); a[1].clear(); if(n%3==0)&#123;printf("1 %lld\n",n);continue;&#125; for(i=0;i&lt;62;i++)if((1LL&lt;&lt;i)&amp;n)a[i&amp;1].push_back(1LL&lt;&lt;i); if(n%3==1)&#123; if(a[0].size()&gt;=2)&#123; x=n-a[0][0]; y=n-a[0][1]; &#125;else if(a[0].size()==1)&#123; x=n-a[0][0]; y=a[0][0]+a[1][0]; &#125;else&#123; x=n-a[1][0]-a[1][1]; y=a[1][0]+a[1][1]+a[1][2]; &#125; &#125;else&#123; if(a[1].size()&gt;=2)&#123; x=n-a[1][0]; y=n-a[1][1]; &#125;else if(a[1].size()==1)&#123; x=n-a[1][0]; y=a[0][0]+a[1][0]; &#125;else&#123; x=n-a[0][0]-a[0][1]; y=a[0][0]+a[0][1]+a[0][2]; &#125; &#125; printf("2 %lld %lld\n",x,y); assert((x|y)==n); assert(x%3==0); assert(y%3==0); &#125;&#125; E 题目描述解题思路AC代码点击 12 F 题目描述解题思路AC代码点击 12 G 题目描述解题思路AC代码点击 12 H 题目描述解题思路AC代码点击 12 I 题目描述问一个字符串中能找到最大的子串集的大小，其中满足集合中任意两个子串，其正序倒序均不相等。 解题思路相当于将原串翻转，这样正序倒序都会出现两次，求出本质不同子串个数除以二即为答案，但回文串会被少统计，于是再加上本质不同的回文串数量。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define P 27#define N 400010struct PT&#123; int tr[N][P],fail[N],cnt[N]/*,num[N]*/,len[N]; int tot,s[N],n,last,i; int newnode(int l)&#123; for(i=0;i&lt;P;i++)tr[tot][i]=0; cnt[tot]=0; len[tot]=l; //num[tot]=l; return tot++; &#125; void init()&#123; n=last=tot=0; newnode(0);newnode(-1); s[0]=-1; fail[0]=1; &#125; int getfail(int p)&#123; while(s[n-len[p]-1]!=s[n])p=fail[p]; return p; &#125; void add(int p)&#123; s[++n]=p; int cur=getfail(last); if(!tr[cur][p])&#123; int now=newnode(len[cur]+2); fail[now]=tr[getfail(fail[cur])][p]; tr[cur][p]=now; //num[now]=num[fail[now]]+1; &#125; last=tr[cur][p]; cnt[last]++; &#125; void insert(char a[])&#123; int i; for(i=0;a[i];i++)add(a[i]-'a'); &#125; void count()&#123; for(i=tot-1;i&gt;=0;i--)cnt[fail[i]]+=cnt[i]; &#125;&#125;p;struct SAM&#123; ll ans; int len[N&lt;&lt;1],fa[N&lt;&lt;1],tr[N&lt;&lt;1][P]; int siz,last; void init()&#123; last=siz=1; fa[1]=ans=len[1]=0; memset(tr[1],0,sizeof(tr[1])); &#125; int newnode()&#123; ++siz; memset(tr[siz],0,sizeof(tr[siz])); fa[siz]=len[siz]=0; return siz; &#125; void add(char c)&#123; int s=c-'a',p=last,np=newnode(); last=np; len[np]=len[p]+1; while(p&amp;&amp;!tr[p][s])tr[p][s]=np,p=fa[p]; if(!p)fa[np]=1; else&#123; int q=tr[p][s]; if(len[p]+1==len[q])fa[np]=q; else&#123; int nq=newnode(); len[nq]=len[p]+1; memcpy(tr[nq],tr[q],sizeof(tr[q])); fa[nq]=fa[q]; fa[q]=fa[np]=nq; while(tr[p][s]==q)tr[p][s]=nq,p=fa[p]; &#125; &#125; ans+=len[last]-len[fa[last]]; &#125; void insert(char a[])&#123; int i; for(i=0;a[i];i++)add(a[i]); &#125;&#125;s;char a[N];int main()&#123; int i,l; scanf("%s",a); l=strlen(a); p.init();p.insert(a); a[l]='a'+26;for(i=1;i&lt;=l;i++)a[l+i]=a[l-i]; s.init();s.insert(a); printf("%lld",(s.ans-(l+1LL)*(l+1)+(p.tot-2))/2); return 0;&#125; J 题目描述在一个图里求$S$到$T$的最短路，其中可以把任意$k$条边的边权置零。 解题思路上来一看，这不一眼题，直接$dis[i][j]$表示用了$i$次置零，到$j$的最短路径长度，$dijkstra/spfa$转移时候多带一维即可。 $WAWAWA$ 期间重构了无数次代码，最后一次莫名其妙$A$的也不知道怎么$A$的。 好，回头补题，检查了一下， $nmdwsm$ 那就把赛时重构了两遍的代码全发出来吧…改了$kst$之后它们全都过了……白白废了比赛时的一个小时…… AC代码-1——dijkstra+前向星点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,m,k,s,t;#define N 1010struct Edge&#123; int e,n,l;&#125;e[N&lt;&lt;1];int hd[N],cnt;void add(int a,int b,int l)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt; e[cnt].l=l;&#125;int dis[N][N];struct node&#123; int step,nod,dis; bool operator&lt;(const node&amp;a)const&#123; return dis&gt;a.dis; &#125;&#125;;priority_queue&lt;node&gt;Q;void dijkstra()&#123; int i; memset(dis,0x3f,sizeof(dis)); Q.push(&#123;0,s,0&#125;); dis[0][s]=0; while(!Q.empty())&#123; int t=Q.top().nod,ds=Q.top().dis,st=Q.top().step; Q.pop(); for(i=hd[t];i;i=e[i].n)&#123; int q=e[i].e; if(ds+e[i].l&lt;dis[st][q])&#123; dis[st][q]=dis[st][t]+e[i].l; Q.push(&#123;st,q,dis[st][q]&#125;); &#125; if(st+1&lt;=k&amp;&amp;ds&lt;dis[st+1][q])&#123; dis[st+1][q]=dis[st][t]; Q.push(&#123;st+1,q,dis[st+1][q]&#125;); &#125; &#125; &#125;&#125;int main()&#123; int i; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t,&amp;k); while(m--)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); add(u,v,w);add(v,u,w); &#125; dijkstra(); int ans=1e9; for(i=0;i&lt;=k;i++)ans=min(ans,dis[i][t]); printf("%d",ans); return 0;&#125; AC代码-2——SPFA+前向星点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,m,K,S,T;#define N 1010struct Edge&#123; int e,n;ll l;&#125;e[N&lt;&lt;5];int hd[N],cnt;void add(int a,int b,ll l)&#123; e[++cnt].e=b; e[cnt].n=hd[a]; e[cnt].l=l; hd[a]=cnt;&#125;ll dis[N][N];queue&lt;pair&lt;int,int&gt;&gt;Q;#define mp make_pairint vis[N][N];int main()&#123; int i; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;S,&amp;T,&amp;K); while(m--)&#123; int u,v;ll w; scanf("%d%d%lld",&amp;u,&amp;v,&amp;w); add(u,v,w);add(v,u,w); &#125; memset(dis,0x3f,sizeof(dis)); while(!Q.empty())Q.pop(); Q.push(mp(S,0)); dis[S][0]=0; while(!Q.empty())&#123; int u=Q.front().first,k=Q.front().second; Q.pop(); vis[u][k]=0; for(i=hd[u];i;i=e[i].n)&#123; int v=e[i].e;ll w=e[i].l; if(dis[u][k]+w&lt;dis[v][k])&#123; dis[v][k]=dis[u][k]+w; if(!vis[v][k])vis[v][k]=1,Q.push(mp(v,k)); &#125; if(k&lt;K&amp;&amp;dis[u][k]&lt;dis[v][k+1])&#123; dis[v][k+1]=dis[u][k]; if(!vis[v][k+1])vis[v][k+1]=1,Q.push(mp(v,k+1)); &#125; &#125; &#125; ll ans=1e15; for(i=0;i&lt;=K;i++)ans=min(ans,dis[T][i]); printf("%lld\n",ans); return 0;&#125; AC代码-3——SPFA+vector点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,m,K,S,T;#define N 1010vector&lt;int&gt;G[N];vector&lt;ll&gt;W[N];#define pb push_backvoid add(int a,int b,ll l)&#123; G[a].pb(b);W[a].pb(l);&#125;ll dis[N][N];queue&lt;pair&lt;int,int&gt;&gt;Q;#define mp make_pairint vis[N][N];int main()&#123; int i; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;S,&amp;T,&amp;K); while(m--)&#123; int u,v;ll w; scanf("%d%d%lld",&amp;u,&amp;v,&amp;w); add(u,v,w);add(v,u,w); &#125; memset(dis,0x3f,sizeof(dis)); while(!Q.empty())Q.pop(); Q.push(mp(S,0)); dis[S][0]=0; while(!Q.empty())&#123; int u=Q.front().first,k=Q.front().second; Q.pop(); vis[u][k]=0; for(i=0;i&lt;(int)G[u].size();i++)&#123; int v=G[u][i];ll w=W[u][i]; if(dis[u][k]+w&lt;dis[v][k])&#123; dis[v][k]=dis[u][k]+w; if(!vis[v][k])vis[v][k]=1,Q.push(mp(v,k)); &#125; if(k&lt;K&amp;&amp;dis[u][k]&lt;dis[v][k+1])&#123; dis[v][k+1]=dis[u][k]; if(!vis[v][k+1])vis[v][k+1]=1,Q.push(mp(v,k+1)); &#125; &#125; &#125; ll ans=1e15; for(i=0;i&lt;=K;i++)ans=min(ans,dis[T][i]); printf("%lld\n",ans); return 0;&#125; K 题目描述给一个大数，求其中连续子串对应数字能被$300$整除的种类数。 解题思路考虑记录到第$i$个数字的时候，结尾为$i$的被$3$除余$0,1,2$的个数，它们与后面的两个零组成一种答案。然后再特殊处理一下未记录的单个$0$和两个$0$的情况即可。 AC代码点击 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010char a[N];int num[3][N];ll ans;int main()&#123; int i,j; scanf("%s",a+1); for(i=1;a[i];i++)&#123; int now=a[i]-'0'; for(j=0;j&lt;3;j++)&#123; num[((j*10)+now)%3][i]=num[j][i-1]; &#125; num[now%3][i]++; if(a[i+1]=='0'&amp;&amp;a[i+2]=='0')ans+=num[0][i]; if(a[i]=='0')ans++; if(a[i]=='0'&amp;&amp;a[i+1]=='0')ans++; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营第三场 题解]]></title>
    <url>%2F2019%2F07%2F25%2F2019nowcodersummercontest-3%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 6/10 . O . Ø . Ø Ø O . Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述解题思路AC代码点击 12 B 题目描述给一个$01$串，分别求出$01$个数相同的最长子序列和最长连续子序列的长度。 解题思路最长子序列直接$min(num_0,num_1)$，最长连续子序列转化成$\pm 1$，求前缀和记录即可。 AC代码点击 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010int n,pos[N&lt;&lt;1],t[N],ans;char a[N];int main()&#123; int i,offset=N; int n1=0,n2=0; scanf("%d",&amp;n); scanf("%s",a+1); for(i=1;i&lt;=n;i++)&#123; if(a[i]=='0')t[i]=-1,n1++; else t[i]=1,n2++; &#125; int s=offset; for(i=0;i&lt;N&lt;&lt;1;i++)pos[i]=-1; pos[s]=0; for(i=1;i&lt;=n;i++)&#123; s+=t[i]; if(pos[s]==-1)pos[s]=i; else ans=max(ans,i-pos[s]); &#125; printf("%d %d",ans,min(n1,n2)*2); return 0;&#125; C 题目描述解题思路AC代码点击 12 D 题目描述问有多少对$(i,j)$满足$A(i^j)%p=0$，其中$1\leq i\leq n,1\leq j\leq m;p,n,m\leq 10^9$，$p$为素数，$A(x)=111…1$，共$x$个$1$。 解题思路等价变形为：$10^{i^j}%9p=1$ 先求$10^n%9p$的循环节$d$。显然有$n=2,n=5$时该式子不可能为$1$；其他时候可枚举$\phi(9p)$的因子。（提前推出了$p=3$的结论：循环节为$3$，所以也可以特判$3$然后枚举$\phi(p)$的因子） $O(\log p\log\log p )$暴力求出$d$后，考虑有多少对$(i,j)$满足$d|i^j$。 对于每一个$j$，对$d$质因数分解成$p_1^{k_1}p_2^{k_2}…p_t^{k_t}$后，满足条件的$i$必然为$g=p_1^{\lceil \frac{k_1}j\rceil}p_2^{\lceil \frac{k_2}j\rceil}…p_t^{\lceil \frac{k_t}j\rceil}$的整数倍（否则凑不成$d$的倍数），故这个$j$对答案的贡献为$\frac ng$。显然，在$j\geq max(k_p)$的时候贡献是相同的，于是枚举$j$到$min(30,m)$进行计算即可（因为显然$max(k_p)\leq 30$）。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll mod,n,m,ans;ll qp(ll a,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,a=a*a%mod)if(p&amp;1)ans=ans*a%mod; return ans;&#125;ll solve()&#123; int i,j,d=mod+1,x=mod-1; for(i=1;i*i&lt;=x;i++)&#123; if(x%i==0)&#123; if(qp(10,i)==1)&#123;d=i;break;&#125; if(i*i!=x&amp;&amp;qp(10,x/i)==1)d=x/i; &#125; &#125; if(d&gt;mod)return 0; int p[110]=&#123;0&#125;,k[110]=&#123;0&#125;,tot=0; for(i=2;i*i&lt;=d;i++)&#123; if(d%i==0)&#123; p[++tot]=i;k[tot]=0; while(!(d%i))d/=i,++k[tot]; &#125; &#125; if(d!=1)p[++tot]=d,k[tot]=1; ll ret=0; for(j=1;j&lt;=m;j++)&#123; ll g=1; for(i=1;i&lt;=tot;i++)g*=qp(p[i],(k[i]+j-1)/j); ret+=n/g; if(j&gt;=30)ret+=n/g*(m-j),j=m+1; &#125; return ret;&#125;int main()&#123; int i,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%lld%lld%lld",&amp;mod,&amp;n,&amp;m); if(mod==3)ans=n/3*m; else if(mod==2||mod==5)ans=0; else ans=solve(); printf("%lld\n",ans); &#125; return 0;&#125; E 题目描述解题思路AC代码点击 12 F 题目描述给一个矩阵，求最大矩形的面积，保证矩形内元素的最大最小值之差小于给定值。 解题思路枚举上下界，再枚举矩形右端点，左端点显然可以保证单调性，于是到此时复杂度为$O(n^3)$。考虑左端点每次移动代价为$O(1)$，用两个单调栈分别保存最小值和最大值即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 521int n,m;int a[N][N],mn[N],mx[N];int qmn[N],hmn,tmn,qmx[N],hmx,tmx;int main()&#123; int T,i,j,k; scanf("%d",&amp;T); while(T--)&#123; int ans=0; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)for(j=0;j&lt;n;j++)scanf("%d",&amp;a[i][j]); for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;n;j++)mn[j]=mx[j]=a[i][j]; for(j=i;j&lt;n;j++)&#123; for(k=0;k&lt;n;k++)mn[k]=min(mn[k],a[j][k]),mx[k]=max(mx[k],a[j][k]); hmn=hmx=1;tmn=tmx=0; if(n*(j-i+1)&lt;ans)continue; int l=0,r; for(r=0;r&lt;n;r++)&#123; while(hmn&lt;=tmn&amp;&amp;mn[qmn[tmn]]&gt;=mn[r])tmn--; qmn[++tmn]=r; while(hmx&lt;=tmx&amp;&amp;mx[qmx[tmx]]&lt;=mx[r])tmx--; qmx[++tmx]=r; while(l&lt;=r&amp;&amp;mx[qmx[hmx]]&gt;m+mn[qmn[hmn]])&#123; l++; if(hmn&lt;=tmn&amp;&amp;qmn[hmn]&lt;l)hmn++; if(hmx&lt;=tmx&amp;&amp;qmx[hmx]&lt;l)hmx++; &#125; if((j-i+1)*(n-l+1)&lt;ans)break; if(ans&lt;(j-i+1)*(r-l+1))ans=(j-i+1)*(r-l+1); &#125; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; G 题目描述有一个游戏，规则是给定多堆石子，石子总个数为偶数，每次从不同的两堆石子中各取一个，能够取完则获得胜利，有残余则失败。 给定一个数列，求该数列中有多少种能够取胜的连续子列。如果连续子列总个数为奇数，则弃掉石子个数最小的那一堆中的一个石子。 解题思路题意很容易转化为：给定一个数列，求出有多少个区间满足区间中的最大值比区间中的其他所有值的和严格大。 分治，每次$rmq$找到最大值，跑出这个最大值对应的贡献，再分别处理两边不包含这个最大值的贡献。计算最大值对应的贡献时，考虑一端枚举另一端二分，为保证复杂度，在数少的一端枚举，另一端二分。 复杂度$O(n\log^2 n)$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 300010int a[N],n;ll s[N],ans;int rmq[20][N],pos[20][N],lg[N];void init()&#123; int i,j; for(i=1;i&lt;=n;i++)rmq[0][i]=a[i],pos[0][i]=i; for(j=1;(1&lt;&lt;j)&lt;=n;j++)&#123; for(i=1;i+(1&lt;&lt;j-1)-1&lt;=n;i++)&#123; if(rmq[j-1][i]&lt;rmq[j-1][i+(1&lt;&lt;(j-1))])&#123; pos[j][i]=pos[j-1][i+(1&lt;&lt;(j-1))]; rmq[j][i]=rmq[j-1][i+(1&lt;&lt;(j-1))]; &#125;else&#123; pos[j][i]=pos[j-1][i]; rmq[j][i]=rmq[j-1][i]; &#125; &#125; &#125;&#125;int query(int l,int r)&#123; int f=lg[r-l+1]; if(rmq[f][l]&lt;rmq[f][r+1-(1&lt;&lt;f)])return pos[f][r+1-(1&lt;&lt;f)]; else return pos[f][l];&#125;void dc(int l,int r,int pos)&#123; int i; if(l&gt;r)return; if((l+r)/2&gt;pos) for(i=pos;i&gt;=l;i--)&#123; ll now=s[pos-1]-s[i-1],remain=a[pos]-now; if(remain&lt;=0)break; int rm=lower_bound(s+pos,s+r+1,remain+s[pos])-s-1; ans+=rm-pos+1; &#125; else for(i=pos;i&lt;=r;i++)&#123; ll now=s[i]-s[pos],remain=a[pos]-now; if(remain&lt;=0)break; int lm=upper_bound(s+l-1,s+pos,-remain+s[pos-1])-s+1; ans+=pos-lm+1; &#125; ans--; int tmp=pos-1; if(a[pos]==a[tmp])while(tmp&amp;&amp;a[tmp-1]==a[pos])tmp--;//卡常 dc(l,tmp,query(l,tmp)); tmp=pos+1; if(a[tmp]==a[pos])while(tmp&lt;n&amp;&amp;a[tmp+1]==a[pos])tmp++;//卡常 dc(tmp,r,query(tmp,r));&#125;int main()&#123; int i,t; scanf("%d",&amp;t); for(i=2;i&lt;N;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); while(t--)&#123; scanf("%d",&amp;n); int mx=0,pos=0; ans=0; for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); s[i]=s[i-1]+a[i]; &#125; init(); dc(1,n,query(1,n)); printf("%lld\n",1LL*n*(n-1)/2-ans); &#125; return 0;&#125; H 题目描述给平面上$n$个不同的点，求一条不经过任何这些点的直线把他们分割成点数完全相等的两部分。输出这条直线经过的两个不同整数点。 解题思路把所有点按照先$x$后$y$的方法排好序，找到中间两个点，画一条斜率超级大的倾斜直线即可。 AC代码点击 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;#define N 1010struct P&#123; int x,y; bool operator&lt;(const P&amp;a)const&#123;return x&lt;a.x||(x==a.x&amp;&amp;y&lt;a.y);&#125;&#125;p[N];int main()&#123; int t,n,i; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d%d",&amp;p[i].x,&amp;p[i].y); sort(p,p+n); int mid=p[n/2-1].x; int temp=999000000; printf("%d %d %d %d\n",mid-1,temp+1+p[n/2-1].y,mid+1,-temp+p[n/2-1].y); &#125; return 0;&#125; I 题目描述解题思路AC代码点击 12 J 题目描述要求实现一个队列，有两种操作，一种是找到某个字符串，如果找到则把它移到最后面，没找到就加进去，超过容量则删掉第一个；另一种是找到它前驱后继。 解题思路$trie$存一下位置，链表维护一下就行了… AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 5000010int tr[10][N],tot,ed[N];int l[N],r[N],dat[N],s,t,sz;int ins(char s[])&#123; int i,now=0; for(i=0;s[i];i++)&#123; int x=s[i]-'0'; if(!tr[x][now])tr[x][now]=++tot; now=tr[x][now]; &#125; ed[now]=1; return now;&#125;int find(char s[])&#123; int i,now=0; for(i=0;s[i];i++)&#123; int x=s[i]-'0'; now=tr[x][now]; if(!now)return 0; &#125; if(!ed[now])return 0; return now;&#125;void del(int x)&#123; sz--; l[r[x]]=l[x]; r[l[x]]=r[x]; if(x==s)s=r[x]; if(x==t)t=l[x]; l[x]=r[x]=dat[x]=0;&#125;void add(int x,int v)&#123; sz++; dat[x]=v; if(sz==1)s=t=x; else r[t]=x,l[x]=t,t=x;&#125;char a[N];int main()&#123; int i,j,t,n,m,opt,v; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)&#123; scanf("%d%s%d",&amp;opt,a,&amp;v); int p=find(a); if(!opt)&#123; if(p)&#123; v=dat[p]; del(p);//node add(p,v); &#125;else&#123; if(sz==m)ed[s]=0,del(s); add(ins(a),v); &#125; printf("%d\n",v); &#125;else&#123; if(!p)puts("Invalid"); else&#123; if(v==-1)p=l[p]; else if(v==1)p=r[p]; if(!p)puts("Invalid"); else printf("%d\n",dat[p]); &#125; &#125; &#125; for(i=0;i&lt;=tot;i++)&#123; for(j=0;j&lt;10;j++)tr[j][i]=0; ed[i]=0; &#125; while(s)del(s); tot=sz=0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营第二场 题解]]></title>
    <url>%2F2019%2F07%2F22%2F2019nowcodersummercontest-2%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 6/10 Ø Ø . Ø . O . O . Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述有一个长为$n$的环，从$0$开始每次等概率向左向右移动一格。当所有格子被访问过至少一次后，结束移动，问停留在$m$的概率是多少。 解题思路边界情况：$m=0$时：$n\neq 1$时概率为$0$，否则概率为$1$。 一般情况：打表可以知道，任何一点的概率均为$\frac{1}{n-1}$。 AC代码点击 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int mod=1000000007;int qp(int x,int p)&#123; int ans=1; for(;p;p&gt;&gt;=1,x=1LL*x*x%mod)if(p&amp;1)ans=1LL*ans*x%mod; return ans;&#125;int main()&#123; int i,T,n,m; scanf("%d",&amp;T); ll ans=1; while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); if(n==1&amp;&amp;!m)printf("%lld\n",ans); else if(m)printf("%lld\n",ans=ans*qp(n-1,mod-2)%mod); else printf("%lld\n",ans=0); &#125; return 0;&#125; B 题目描述从$0$开始沿着数轴向前走，每次等概率走$[1,2…k]$步，问经过$n$的概率。如果$n=-1$，求出$n$趋向正无穷时经过$n$的概率。 解题思路递推一下可以发现，$p_0=1,p_i=\frac{p_{i-1}+p_{i-2}+…+p_{i-k}}{k}$，这是一个很明显的线性递推，套上板子就行了。 $n$趋向正无穷时概率相同，故在讨论无穷下的概率时可认为经过任意点的概率相同。由于走$1…k$步概率相同，我们可以假设走了$t$次$1$步，$t$次$2$步…$t$次$k$步，那么最后到达的位置是$\frac{tk(k+1)}2$，而走过的点数是$tk$，故经过某点的概率为$\frac{tk}{\frac{tk(k+1)}2}=\frac2{k+1}$。也可打表找规律。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;bits/stdc++.h&gt;typedef long long ll;#define int long longusing namespace std;#define M 5000struct comp&#123; double x,y; comp():x(0),y(0)&#123;&#125; comp(const double &amp;_x,const double &amp;_y):x(_x),y(_y)&#123;&#125;&#125;;comp operator+(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x+b.x,a.y+b.y);&#125;comp operator-(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x-b.x,a.y-b.y);&#125;comp operator*(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;comp conj(const comp &amp;a)&#123;return comp(a.x,-a.y);&#125;double PI=acos(-1);comp w[M+5];int rev[M+5];int lim,mx,mod;void fft(comp *a,int n)&#123; int i,j,k,lyc; for(i=0;i&lt;n;i++)if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(i=2,lyc=n&gt;&gt;1;i&lt;=n;i&lt;&lt;=1,lyc&gt;&gt;=1) for(j=0;j&lt;n;j+=i)&#123; comp *l=a+j,*r=a+j+(i&gt;&gt;1),*p=w; for(k=0;k&lt;(i&gt;&gt;1);k++)&#123; comp tmp=*r**p; *r=*l-tmp,*l=*l+tmp; ++l,++r,p+=lyc; &#125; &#125;&#125;void fft_prepare()&#123; int i; for(i=0;i&lt;lim;i++)rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(mx-1)); for(i=0;i&lt;lim;i++)w[i]=comp(cos(2*PI*i/lim),sin(2*PI*i/lim));&#125;void conv(int *x,int *y,int *z,int n,int m,int mod)&#123; int i,j; static comp ta[M+5],tb[M+5],a[M+5],b[M+5]; static int X[M+5],Y[M+5]; for(i=0;i&lt;n;i++)X[i]=(x[i]+mod)%mod; for(;i&lt;lim;i++)X[i]=0; for(i=0;i&lt;m;i++)Y[i]=(y[i]+mod)%mod; for(;i&lt;lim;i++)Y[i]=0; for(i=0;i&lt;lim;i++)&#123; ta[i]=comp(X[i]&amp;32767,X[i]&gt;&gt;15); tb[i]=comp(Y[i]&amp;32767,Y[i]&gt;&gt;15); &#125; fft(ta,lim);fft(tb,lim); for(i=0;i&lt;lim;i++)&#123; j=(lim-i)%lim; comp da,db,dc,dd; da=(ta[i]+conj(ta[j]))*comp(0.5,0); db=(ta[i]-conj(ta[j]))*comp(0,-0.5); dc=(tb[i]+conj(tb[j]))*comp(0.5,0); dd=(tb[i]-conj(tb[j]))*comp(0,-0.5); a[j]=da*dc+da*dd*comp(0,1); b[j]=db*dc+db*dd*comp(0,1); &#125; fft(a,lim);fft(b,lim); for(i=0;i&lt;lim;i++)&#123; ll da,db,dc,dd; da=(ll)(a[i].x/lim+0.5)%mod; db=(ll)(a[i].y/lim+0.5)%mod; dc=(ll)(b[i].x/lim+0.5)%mod; dd=(ll)(b[i].y/lim+0.5)%mod; z[i]=(((da+((db+dc)&lt;&lt;15)+(dd&lt;&lt;30))%mod)+mod)%mod; &#125;&#125;int qpow(ll x,int p)&#123; int ans=1; for(;p;p&gt;&gt;=1,x=x*x%mod)if(p&amp;1)ans=ans*x%mod; return ans;&#125;void polyinv(int *A,int *ans,int n)&#123; static int B[2][M+5]; int bas,cur,i; memset(B,0,sizeof(B)); B[0][0]=qpow(A[0],mod-2); for(mx=2,bas=1,lim=4,cur=1;bas&lt;n*2;mx++,lim&lt;&lt;=1,cur^=1,bas&lt;&lt;=1)&#123; fft_prepare(); memset(B[cur],0,sizeof(B[cur])); for(i=0;i&lt;bas;i++)B[cur][i]=(ll)B[cur^1][i]*2%mod; conv(B[cur^1],B[cur^1],B[cur^1],bas,bas,mod); conv(B[cur^1],A,B[cur^1],bas,bas,mod); for(i=0;i&lt;bas;i++)B[cur][i]=((ll)B[cur][i]-B[cur^1][i]+mod)%mod; &#125; for(i=0;i&lt;n;i++)ans[i]=(B[cur^1][i]+mod)%mod;&#125;int flag;void polydiv(int *a,int *b,int *H,int *R,int n,int m)&#123; int i; static int rF[M+5],rG[M+5],t1[M+5]; memset(t1,0,sizeof(int)*n); for(i=0;i&lt;=n;i++)rF[n-i]=a[i]; if(!flag)&#123; flag=1; for(i=0;i&lt;=m;i++)rG[m-i]=b[i]; polyinv(rG,rG,n-m+1); &#125; mx=0,lim=1;while(lim&lt;n&lt;&lt;1)lim&lt;&lt;=1,mx++; fft_prepare(); conv(rF,rG,H,n,n,mod); reverse(H,H+n-m+1); for(i=n-m+1;i&lt;=n;i++)H[i]=0; mx=0,lim=1;while(lim&lt;n+m)lim&lt;&lt;=1,mx++; fft_prepare(); conv(b,H,t1,m,n,mod); for(i=0;i&lt;m;i++)R[i]=((ll)a[i]-t1[i]+mod)%mod; for(;i&lt;=n;i++)R[i]=0;&#125;int a[M+5],g[M+5];int D[M+5];int res[M+5],bas[M+5],k;ll n;void mtmul(int *a,int *b)&#123; mx=0,lim=1; while(lim&lt;k*2)lim&lt;&lt;=1,mx++; fft_prepare(); conv(a,b,a,k,k,mod); polydiv(a,g,D,a,k*2-2,k);&#125;void qpow(ll x)&#123; res[0]=bas[1]=1; for(;x;x&gt;&gt;=1,mtmul(bas,bas)) if(x&amp;1)mtmul(res,bas);&#125;signed main()&#123; int i,j,T; ll x; mod=1000000007; scanf("%lld",&amp;T); while(T--)&#123; flag=0; scanf("%lld%lld",&amp;k,&amp;n); if(k==1)&#123; printf("1\n"); continue; &#125; if(n==-1)&#123; printf("%lld\n",2*qpow(k+1,mod-2)%mod); continue; &#125; ll invk=qpow(k,mod-2); memset(a,0,sizeof(a)); memset(g,0,sizeof(g)); g[k]=mod-1; for(i=1;i&lt;=k;i++)g[k-i]=invk; a[0]=1; for(i=1;i&lt;k;i++)&#123; for(j=0;j&lt;i;j++)(a[i]+=a[j])%=mod; a[i]=a[i]*invk%mod; &#125; if(n&lt;k)&#123; printf("%lld\n",a[n]); continue; &#125; memset(res,0,sizeof(res)); memset(bas,0,sizeof(bas)); qpow(n); ll ans=0; for(i=0;i&lt;k;i++)(ans+=(ll)a[i]*res[i])%=mod; printf("%lld\n",ans); &#125; return 0;&#125; C 题目描述解题思路AC代码点击 12 D 题目描述给一个图，找到第$k$小团。 解题思路先对权值排序，建立堆，每次的操作有两种，在最后插入新元素，或者将最后的元素替换掉。枚举状态即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 105#define M 1000005#define plii pair&lt;pair&lt;ll,int&gt;,int&gt;#define mp make_pair#define f first#define s secondchar a[N];int n,k,tot;pair&lt;ll,int&gt;p[N];bitset&lt;N&gt;g[N],ith[M];//ith[id]:removing last, what can be addedstruct tp&#123; ll w;int id,last; bool operator&lt;(const tp&amp;a)const&#123;return w&gt;a.w;&#125;&#125;;priority_queue&lt;tp&gt;Q;int main()&#123; int i,j; scanf("%d%d",&amp;n,&amp;k); for(i=0;i&lt;n;i++)scanf("%d",&amp;p[i].f),p[i].s=i; for(i=0;i&lt;n;i++)&#123; scanf("%s",a); for(j=0;j&lt;n;j++)if(a[j]=='1')g[i][j]=1;else g[i][j]=0; &#125; sort(p,p+n); if(!k--)return printf("0"),0;//empty set Q.push((tp)&#123;p[0].f,0,0&#125;); for(i=0;i&lt;n;i++)ith[0][i]=1; while(!Q.empty())&#123; tp t=Q.top();Q.pop(); ll val=t.w;int id=t.id,last=t.last; if(!--k)return printf("%lld",val),0; for(i=last+1;i&lt;n;i++)&#123;//add i, del last, id remain if(ith[id][p[i].s])&#123; Q.push((tp)&#123;val+p[i].f-p[last].f,id,i&#125;); break; &#125; &#125; ith[++tot]=ith[id]&amp;g[p[last].s];//find what can be added for(i=last+1;i&lt;n;i++)&#123;//add i if(ith[tot][p[i].s])&#123; Q.push((tp)&#123;val+p[i].f,tot,i&#125;); break; &#125; &#125; &#125; puts("-1"); return 0;&#125; E 题目描述解题思路AC代码点击 12 F 题目描述给定$2n$个人，要求分成两组，使得权值最大。权值的大小为任意不属于同一组的$i,j$，其$v_{ij}$之和。 解题思路$n$大小在$14$，可以暴力$O(C_{28}^{14}\cdot 14^2)$搜出。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 30int n,v[N][N];ll ans,s[N],sum;int seq[N];void dfs(int mn,int dep)&#123; int i,j; if(dep==n)&#123; if(ans&lt;sum)ans=sum; return; &#125; for(i=mn;i&lt;=n+1+dep;i++)&#123; seq[dep]=i; ll tmp=0; for(j=0;j&lt;dep;j++)tmp-=2*v[i][seq[j]]; tmp+=s[i]; sum+=tmp; dfs(i+1,dep+1); sum-=tmp; &#125;&#125;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=1;i&lt;=n*2;i++) for(j=1;j&lt;=n*2;j++)&#123; scanf("%d",&amp;v[i][j]); if(i^j)s[i]+=v[i][j]; &#125; dfs(1,0); printf("%lld",ans); return 0;&#125; G 题目描述解题思路AC代码点击 12 H 题目描述给一个$01$矩阵，求出全由$1$构成的第二大矩阵。 解题思路求最大矩阵是扫描线板子题，求第二大稍微改一下即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;#define N 1010int n,m,mt[N][N];int u[N][N],l[N][N],r[N][N],lm,rm;char a[N];int max(int a,int b)&#123;return a&gt;b?a:b;&#125;int min(int a,int b)&#123;return a&gt;b?b:a;&#125;int main()&#123; int i,j,ans=0,subans=0; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)&#123; scanf("%s",a+1); for(j=1;j&lt;=m;j++)mt[i][j]=a[j]-'0'; &#125; memset(r,0x3f,sizeof(r)); int ansl=0,ansr=0,ansi=0; for(i=1;i&lt;=n;i++)&#123; lm=0;rm=m+1; for(j=1;j&lt;=m;j++)&#123; if(mt[i][j])&#123; if(i==1)l[i][j]=lm+1; else l[i][j]=max(l[i-1][j],lm+1); u[i][j]=u[i-1][j]+1; &#125;else lm=j; &#125; for(j--;j;j--)&#123; if(mt[i][j])&#123; if(i==1)r[i][j]=rm-1; else r[i][j]=min(r[i-1][j],rm-1); &#125; else rm=j; int h=u[i][j],w=(r[i][j]-l[i][j]+1),sq=h*w; if(ans&gt;sq)subans=max(subans,sq); else&#123; if(ans&lt;sq)subans=max(subans,ans); else if(l[i][j]!=ansl||r[i][j]!=ansr||i!=ansi)subans=max(subans,ans); &#125; if(ans&lt;sq)&#123; ansl=l[i][j],ansr=r[i][j],ansi=i; ans=sq; &#125; subans=max(subans,max((u[i][j]-1)*(r[i][j]-l[i][j]+1),u[i][j]*(r[i][j]-l[i][j]))); &#125; &#125; printf("%d",subans); return 0;&#125; I 题目描述解题思路AC代码点击 12 J 题目描述有一个长为$1e9$的只含有$1,-1$的数列，其中$1$区间个数$n\leq 10^6$，$1$的个数$num\leq 10^7$，问有多少个区间$[l,r]$满足$\sum_{i=l}^ra[i]&gt;0$。 解题思路考虑把问题转化为：对于某一点$x$，有多少个$y$满足$y&lt;x$且$sum[y]&lt;sum[x]$，其中$sum[i]=\sum_{j=0}^ia[j]$。 由于区域很大，暴力求前缀和是不可取的，所以只需把$1e9$划分为多个对答案有贡献的区间，可以把这些区间连成一起求前缀和，这并不影响答案。 所以求出对答案有贡献的区间$[L_i,R_i]$，记录下前面有多少比当前前缀和小的前缀和，记录下前缀和为$k$的有多少个即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1000010#define M 40000010int l[N],r[N],n;int L[N],R[N];int num[M];int main()&#123; int i,j; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d%d",&amp;l[i],&amp;r[i]); l[0]=r[0]=L[0]=R[0]=-1,l[n+1]=r[n+1]=1e9; int len=0; for(i=1;i&lt;=n;i++)&#123; len+=r[i]-l[i]+1; R[i]=min(r[i]+len,l[i+1]-1); len-=l[i+1]-r[i]-1; if(len&lt;0)len=0; &#125; len=0; for(i=n;i;i--)&#123; len+=r[i]-l[i]+1; L[i]=max(l[i]-len,r[i-1]+1); len-=l[i]-r[i-1]-1; if(len&lt;0)len=0; &#125; int now=20000001; ll sum=0,ans=0; num[now]=1;//change for(i=1;i&lt;=n;i++)&#123; for(j=max(L[i],R[i-1]+1);j&lt;=R[i];j++)&#123; if(j&gt;=l[i]&amp;&amp;j&lt;=r[i])&#123; sum+=num[now]; num[++now]++; &#125;else&#123; sum-=num[--now]; num[now]++; &#125; ans+=sum; &#125; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019牛客暑期多校训练营第一场 题解]]></title>
    <url>%2F2019%2F07%2F21%2F2019nowcodersummercontest-1%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 8/10 O O Ø . Ø O . Ø Ø O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A Equivalent Prefixes 题目描述定义两个数组$u,v$等价当且仅当任意$l,r$，有$RMQ(u,l,r)=RMQ(v,l,r)$，其中$RMQ(u,l,r)$表示数组$u$中下标为$[l,r]$中最小元素的位置。 给两个只包含不同元素的数组，求出两数组最长等价前缀长度。 解题思路之前做过一个类似的笛卡尔树的题（HDU 6305，这里的B题），感觉还是比较容易的。 首先二分区间进行$check$，每次$check$的时候，找出$[l,r]$区间中最小值位置$pos$，因为这个最小值不影响$[l,pos-1]$和$[pos+1,r]$的检查，故可以分治解决。预处理出$ST$表，总复杂度$O(n\log n)$。 （代码里为了找$pos$好写就离散化了一下，其实可以直接在构造$ST$表的时候存储最小位置，懒得改了） AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010int a[N],b[N],n;int aa[N],bb[N];int lg[N],p[17][N],q[17][N];int pa[N],pb[N];void init()&#123; int i,j; for(i=0;i&lt;n;i++)p[0][i]=a[i],q[0][i]=b[i]; for(i=1;(1&lt;&lt;i)&lt;=n;i++)&#123; for(j=0;j+(1&lt;&lt;(i-1))&lt;n;j++)&#123; p[i][j]=min(p[i-1][j],p[i-1][j+(1&lt;&lt;(i-1))]); q[i][j]=min(q[i-1][j],q[i-1][j+(1&lt;&lt;(i-1))]); &#125; for(;j&lt;n;j++)p[i][j]=q[i][j]=2e9; &#125;&#125;int solve(int l,int r)&#123; if(l&gt;=r)return 1; int len=r-l+1,x=lg[len],pos; if(p[x][l]&gt;p[x][r-(1&lt;&lt;x)+1])&#123; pos=pa[p[x][r-(1&lt;&lt;x)+1]]; if(pos!=pb[q[x][r-(1&lt;&lt;x)+1]]||q[x][l]&lt;q[x][r-(1&lt;&lt;x)+1])return 0; if(solve(l,pos-1)==0)return 0; return solve(pos+1,r); &#125;else&#123; pos=pa[p[x][l]]; if(pos!=pb[q[x][l]]||q[x][l]&gt;q[x][r-(1&lt;&lt;x)+1])return 0; if(solve(l,pos-1)==0)return 0; return solve(pos+1,r); &#125;&#125;int check(int x)&#123;return solve(0,x-1);&#125;int main()&#123; int i; for(i=2;i&lt;=100000;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); while(~scanf("%d",&amp;n))&#123; for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]),aa[i]=a[i]; for(i=0;i&lt;n;i++)scanf("%d",&amp;b[i]),bb[i]=b[i]; sort(aa,aa+n);sort(bb,bb+n); map&lt;int,int&gt;mpa,mpb; mpa.clear();mpb.clear(); for(i=0;i&lt;n;i++)&#123; mpa[aa[i]]=i; mpb[bb[i]]=i; &#125; for(i=0;i&lt;n;i++)a[i]=mpa[a[i]],b[i]=mpb[b[i]]; for(i=0;i&lt;n;i++)pa[a[i]]=i,pb[b[i]]=i; init(); int l=0,r=n,ans=0; while(l&lt;=r)&#123; int mid=(l+r)/2; if(check(mid))l=mid+1,ans=mid; else r=mid-1; &#125; printf("%d\n",ans); &#125; return 0;&#125; B Integration 题目描述给定数组$a_i$，计算$\frac1{\pi}\int_{0}^{\inf}\frac{1}{\prod_{i=1}^{n}(a_i^2+x^2)}\text{d}x$。 解题思路被积函数是一堆很好积分的东西的乘积，我们发现每一项$\frac{1}{a_i^2+x^2}$的$x$系数都为$1$，容易想到将乘积转化成和的形式逐项积分。 $\frac{1}{\prod_{i=1}^{n}(a_i^2+x^2)}$$=\frac{c_1}{(a_1^2+x^2)}+\frac{c_2}{(a_2^2+x^2)}+…+\frac{c_n}{(a_n^2+x^2)}$ 两边同乘$\prod_{i=1}^{n}(a_i^2+x^2)$，得$1=c_i\prod_{j\neq i}(a_j^2+x^2)+\sum_{j\neq i}\frac{c_j\prod(a_k^2+x^2)}{a_j^2+x^2}$ 为了求出$c_i$，我们不妨令$x=a_i\cdot i$，则$x^2=-a_i^2$。于是$1=c_i\prod_{j\neq i}(a_j^2-a_i^2)$，$c_i=\frac1{\prod_{j\neq i}(a_j^2-a_i^2)}$。 逐项求积分即可。 AC代码点击 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n;ll a[1010];ll mod=1000000007;ll qp(ll x,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,x=x*x%mod)if(p&amp;1)ans=ans*x%mod; return ans;&#125;int main()&#123; int i,j; while(~scanf("%d",&amp;n))&#123; for(i=0;i&lt;n;i++)scanf("%lld",&amp;a[i]); ll ans=0; for(i=0;i&lt;n;i++)&#123; ll now=a[i]; for(j=0;j&lt;n;j++)&#123; if(i==j)continue; now=(a[j]*a[j]-a[i]*a[i])%mod*now%mod; &#125; if(now&lt;0)now+=mod; (ans+=qp(now,mod-2))%=mod; &#125; ans=ans*qp(2,mod-2)%mod; printf("%lld\n",(ans+mod)%mod); &#125; return 0;&#125; C Euclidean Distance 题目描述给定一个$n$维的点$A$，求一个$n$维点$P(p_1,p_2,…,p_n)$满足$\sum p_i=1,p_i\geq 0(1\leq i\leq n)$，使得$|AP|$最短。 解题思路考虑$A$点在平面$x+y+z+…=1$的超平面上的投影$B$，设$b_i=a_i-dis$，则$\sum a_i-n\cdot dis=1$，$dis=\frac{\sum a_i-1}{n}$，$b_i=a_i-\frac{\sum a_i-1}n$。 若$\forall i, b_i\geq 0$，则$B$即为$P$点。否则设$b_k&lt;0$，则要使得距离最短，必然有$p_k=0$，即该维的坐标为$0$，故问题转化为少一维度的情况（注意$b_i$计算的时候$n$会发生变化），重复运算一直到$\forall i,b_i\geq 0$。 于是我们可以对$a_i$排序，找到首个$b_i\geq 0$的点，则往后的所有维度都满足这个条件，所以前面的$p_k=0$，后面的$p_k=b_k$，分别求和即可。 AC代码点击 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 10010int n,m;ll a[N],s2[N];int main()&#123; int i,j; while(~scanf("%d%d",&amp;n,&amp;m))&#123; ll s=0; for(i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]),s+=a[i]; sort(a+1,a+1+n); for(i=1;i&lt;=n;i++)s2[i]=s2[i-1]+a[i]*a[i]; for(i=1;i&lt;=n;i++)&#123; if(a[i]*(n-i+1)-s+m&gt;=0)break; s-=a[i]; &#125; ll fz=s2[i-1]*(n-i+1)+(s-m)*(s-m),fm=1LL*m*m*(n-i+1); ll g=__gcd(fz,fm); fz/=g;fm/=g; if(fm==1)printf("%lld\n",fz); else printf("%lld/%lld\n",fz,fm); &#125; return 0;&#125; D Parity of Tuples 题目描述解题思路AC代码点击 12 E ABBA 题目描述构造一个长度为$2(n+m)$的$AB$字符串，其中能够拆分出$n$个$AB$，$m$个$BA$，问有多少种构造方法。 解题思路考虑从第一位开始填字符，类似$catalan$数的求法，建立一个坐标轴，$x$轴表示$A$的数量，$y$轴表示$B$的数量。从原点走起，每一次填写$A$则$x++$，否则$y++$，最后走到$(n+m,n+m)$点。 任意前缀的$B-A$最大值即为这个串中$AB$个数的最小值，所以如果有某个前缀$B-A&gt;n$，那么$B$要组成大于$n$个$AB$，$BA$的个数就不会到达$m$，所以任意前缀有$B\leq A+n$。同理可得：$A\leq B+m$。 黑体字部分证明如下：设$A-B$在某个前缀$[1,l]$取得最大值$p$，则$[l+1,2(n+m)]$区间中$B-A=p$。尽量使得后面区间中的$B$组成$BA$而非$AB$，则可以$BABABA….BA,BBB..B$进行排列，最终有$p$个$B$必须同前面的$A$进行匹配，故$AB$的最小可能值为$p$。 通过类似$catalan$数对称处理的方法可以得出答案。 AC代码点击 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 4010ll fac[N],inv[N],mod=1000000007;ll qp(ll x,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,x=x*x%mod)if(p&amp;1)ans=ans*x%mod; return ans;&#125;ll c(int n,int m)&#123; if(n&lt;m||m&lt;0)return 0; return fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;int main()&#123; int i,n,m; inv[0]=fac[0]=1; for(i=1;i&lt;N;i++) fac[i]=fac[i-1]*i%mod, inv[i]=qp(fac[i],mod-2); while(~scanf("%d%d",&amp;n,&amp;m)) printf("%lld\n",((c((n+m)&lt;&lt;1,n+m)-c((n+m)&lt;&lt;1,n-1)-c((n+m)&lt;&lt;1,m-1))%mod+mod)%mod); return 0;&#125; F Random Point in Triangle 题目描述给定三角形，求任意三角形内一点与顶点分别形成的三个三角形面积最大值的期望。 解题思路先猜结论是常数倍的三角形面积，然后用等边三角形特例求出常数。 详细证明 AC代码点击 123456789101112#include &lt;bits/stdc++.h&gt;typedef long long ll;#define y1 Yint x1,y1,x2,x3,y2,y3;int main()&#123; while(~scanf("%d%d%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;x3,&amp;y3))&#123; ll S=(1LL*x1*y2+1LL*x2*y3+1LL*x3*y1-1LL*x1*y3-1LL*x2*y1-1LL*x3*y2); ll t=S*11; if(t&lt;0)t=-t; printf("%lld\n",t); &#125;&#125; G Substrings 2 题目描述解题思路AC代码点击 12 H XOR 题目描述求一个数列中，所有异或和为$0$的子集大小之和。 解题思路等价于求每一个元素在多少个子集中再求一下和。 对于每一个元素$i$，可以考虑对其他所有元素建一个线性基，假设线性基中包含了$k$个元素。如果这个元素不能插入这个线性基，就表示这个元素可以被线性基中的$k$个元素线性表示，也就是另外的$n-k-1$个元素中任意选择都能找到对应的线性基中元素使得异或和为$0$，对答案的贡献为$2^{n-k-1}$。 但这样复杂度太高，是$O(n^2\log n)$的，显然会$T$掉。 考虑对所有数先建立一个线性基$lb$。假设$lb$的大小为$k$，则同理对于剩下的$n-k$个元素中的每一个元素$i$，任意再取$lb$外的元素，都能找到$lb$中的元素对应使得异或和为$0$，故每个$lb$外元素都在$2^{n-k-1}$个子集中。 再对$lb$外的元素建立一个线性基$res$，对于所有$lb$中的元素建立的包含其他$n-1$个元素的线性基，可以从$res$中插入不多于$\log n$次建立，于是总时间复杂度变为$O(n\log n+\log ^3 n)$。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define P 64#define N 100010struct LinearBase&#123; ll bas[P];int cnt=0; int insert(ll x)&#123; int i; for(i=P-1;i&gt;=0;i--)&#123; if((x&gt;&gt;i)&amp;1)&#123; if(bas[i])x^=bas[i]; else&#123; bas[i]=x; cnt++; return 1; &#125; &#125; &#125; return 0; &#125; void clear()&#123; cnt=0; memset(bas,0,sizeof(bas)); &#125;&#125;lb,res,tmp;ll a[N],pw[N],mod=1000000007;ll b[N],tot,c[N],tot2;int main()&#123; int i,j,n; pw[0]=1; for(i=1;i&lt;N;i++)pw[i]=pw[i-1]*2%mod; while(~scanf("%d",&amp;n))&#123; lb.clear();res.clear();tot=tot2=0; for(i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); if(!lb.insert(a[i]))b[tot++]=a[i]; else c[tot2++]=a[i]; &#125; ll ans=pw[n-lb.cnt-1]*(n-lb.cnt)%mod; for(i=0;i&lt;tot;i++)res.insert(b[i]); for(i=0;i&lt;tot2;i++)&#123; tmp=res; for(j=0;j&lt;tot2;j++)&#123; if(i==j)continue; tmp.insert(c[j]); &#125; if(!tmp.insert(c[i]))(ans+=pw[n-tmp.cnt-1])%=mod; &#125; printf("%lld\n",ans); &#125; return 0;&#125; I Points Division 题目描述有$n$个点，每个点有一个坐标$(x_i,y_i)$，有两个属性$a_i,b_i$。把这$n$个点分成两个集合$A,B$，保证不存在$A$中的点位于$B$中的点的右下方，最大化$\sum_{i\in A}a_i+\sum_{j\in B}b_j$。 解题思路可以转化为，有一条折线把$A,B$两个集合分开。规定位于折线上的点归属于$B$，设$f[i]$表示$i$位于折线上时原式的最大值，每次加入一个新点$i$的时候，有$f[j]=f[j]+ai;$$f[j]=f[j]+bi;$ $f[i]=b[i]+max(f[j]),j&lt;i$。 所以每次需要支持的操作为：单点修改，区间查询最大值，区间修改。 对于$y$坐标离散化，建一棵线段树维护一下在每一个$y$上的最大值即可。 注意初始状态有$f[0]=0$，即考虑$y=0$的情况，也即所有点都进入$A$集合。 还需要注意的是，对点进行排序的时候，$x$坐标升序，而为了防止多加，$y$坐标应当为降序。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 400010ll lazy[N&lt;&lt;2],mx[N&lt;&lt;2];int L[N&lt;&lt;2],R[N&lt;&lt;2];struct Poi&#123; int a,b; int x,y; bool operator&lt;(const Poi&amp;p)const&#123;return x==p.x?y&gt;p.y:x&lt;p.x;&#125;&#125;a[N];int b[N];void pushup(int p)&#123; mx[p]=max(mx[p&lt;&lt;1],mx[p&lt;&lt;1|1]);&#125;void pushdown(int p)&#123; ll t=lazy[p]; if(!t)return; if(L[p&lt;&lt;1])lazy[p&lt;&lt;1]+=t,mx[p&lt;&lt;1]+=t; if(L[p&lt;&lt;1|1])lazy[p&lt;&lt;1|1]+=t,mx[p&lt;&lt;1|1]+=t; lazy[p]=0;&#125;void build(int p,int l,int r)&#123; L[p]=l,R[p]=r; int mid=(l+r)&gt;&gt;1; lazy[p]=0;mx[p]=-1e18; if(l==r)return; build(p&lt;&lt;1,l,mid); build(p&lt;&lt;1|1,mid+1,r);&#125;void upd(int p,int pos,ll x)&#123; pushdown(p); if(L[p]&gt;pos||R[p]&lt;pos)return; if(L[p]==pos&amp;&amp;pos==R[p])&#123;mx[p]=max(mx[p],x);return;&#125; upd(p&lt;&lt;1,pos,x); upd(p&lt;&lt;1|1,pos,x); pushup(p);&#125;void modify(int p,int l,int r,ll x)&#123; if(l&lt;=L[p]&amp;&amp;r&gt;=R[p])&#123; lazy[p]+=x; mx[p]+=x; return; &#125; if(l&gt;R[p]||r&lt;L[p])return; modify(p&lt;&lt;1,l,r,x); modify(p&lt;&lt;1|1,l,r,x); pushup(p);&#125;ll querymax(int p,int l,int r)&#123; pushdown(p); if(l&lt;=L[p]&amp;&amp;r&gt;=R[p])return mx[p]; if(l&gt;R[p]||r&lt;L[p])return -1e18; return max(querymax(p&lt;&lt;1,l,r),querymax(p&lt;&lt;1|1,l,r));&#125;int main()&#123; int i,n; while(~scanf("%d",&amp;n))&#123; for(i=0;i&lt;=(n&lt;&lt;2);i++)lazy[i]=0,mx[i]=0,L[i]=R[i]=0; for(i=1;i&lt;=n;i++)scanf("%d%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].a,&amp;a[i].b),b[i]=a[i].y; sort(b+1,b+1+n); int cnt=unique(b+1,b+1+n)-b; for(i=1;i&lt;=n;i++)a[i].y=lower_bound(b+1,b+cnt,a[i].y)-b+1; sort(a+1,a+1+n); build(1,1,cnt); upd(1,1,0); for(i=1;i&lt;=n;i++)&#123; upd(1,a[i].y,querymax(1,1,a[i].y)+a[i].b); modify(1,1,a[i].y-1,a[i].a); modify(1,a[i].y+1,cnt,a[i].b); &#125; printf("%lld\n",mx[1]); &#125; return 0;&#125; J Fraction Comparision 题目描述给两个分数$\frac xa, \frac yb$，比较大小。（$0\leq x,y\leq 10^{18},1\leq a,b\leq 10^9$） 解题思路可以化成假分数比较，可以用$JAVA$，可以写高精度，也可以$__int128$。 AC代码点击 12345678910111213#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int main()&#123; ll a,b,c,d; while(~scanf("%lld%lld%lld%lld",&amp;a,&amp;b,&amp;c,&amp;d))&#123; __int128 A=a,B=b,C=c,D=d; if(A*D==B*C)puts("="); else if(A*D&lt;B*C)puts("&lt;"); else puts("&gt;"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 16 题解]]></title>
    <url>%2F2019%2F07%2F08%2F2019springtraining-16%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M 13/13 O O O O O O Ø O O Ø O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A Gym 102021A - Attack on Alpha-Zet 题目描述给一个迷宫，迷宫中所有点互相连通且有且仅有一条道路。给$m$个点，求从$1$号点依次经过这些点到$m$号点的总距离。 解题思路可以看成一棵树，不停求$LCA$即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 1100010struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int hd[N],cnt;void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;int fa[25][N],d[N],lg[N];void dfs(int now,int f)&#123; d[now]=d[f]+1; fa[0][now]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++) fa[i][now]=fa[i-1][fa[i-1][now]]; for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=f)dfs(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y]) x=fa[lg[d[x]-d[y]]][x]; if(x==y)return x; for(i=lg[d[x]];~i;i--) if(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y]; return fa[0][x];&#125;string g[2200];int n,m,k;ll res;int dir[]=&#123;1,0,-1,0&#125;;int id(int x,int y)&#123;return(x-1)*m+y;&#125;void Add(int x,int y)&#123; int i; for(i=0;i&lt;4;++i)&#123; int nx=x+dir[i],ny=y+dir[3-i]; if(nx&gt;0&amp;&amp;nx&lt;=n&amp;&amp;ny&gt;0&amp;&amp;ny&lt;=m)&#123; if(nx==x-1&amp;&amp;g[nx][ny*2-1]=='_') continue; if(nx==x+1&amp;&amp;g[x][ny*2-1]=='_') continue; if(ny==y-1&amp;&amp;g[nx][ny*2]=='|') continue; if(ny==y+1&amp;&amp;g[nx][ny*2-2]=='|') continue; add(id(x,y),id(nx,ny)); &#125; &#125;&#125;int main()&#123; int i,j; scanf("%d%d",&amp;n,&amp;m); getchar(); for(i=0;i&lt;=n;++i)getline(cin,g[i]); for(i=1;i&lt;=n;i++)for(j=1;j&lt;=m;j++)Add(i,j); for(i=2;i&lt;N;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); dfs(id(1,1),0); scanf("%d",&amp;k); int x,y; scanf("%d%d",&amp;x,&amp;y); for(i=1;i&lt;k;++i)&#123; int a,b,i1=id(x,y),i2; scanf("%d%d",&amp;a,&amp;b); i2=id(a,b); res+=d[i1]+d[i2]-2*d[lca(i1,i2)]; x=a;y=b; &#125; printf("%lld",res); return 0;&#125; B Gym 102021B - Battle Royale 题目描述给两个点，两个点通过的一个圆，求两点间不进入这个圆的最短路径。 解题思路两切线长加弧长即可。 AC代码点击 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;double x1,x2,y,y2,x3,y3,r;double dis(double a,double b,double c,double d)&#123; return sqrt((c-a)*(c-a)+(d-b)*(d-b));&#125;int main()&#123; scanf("%lf%lf",&amp;x1,&amp;y); scanf("%lf%lf",&amp;x2,&amp;y2); scanf("%lf%lf%lf",&amp;x3,&amp;y3,&amp;r); scanf("%lf%lf%lf",&amp;x3,&amp;y3,&amp;r); double d1=dis(x1,y,x3,y3); double d2=dis(x2,y2,x3,y3); double d3=dis(x1,y,x2,y2); double c1=sqrt(d1*d1-r*r); double c2=sqrt(d2*d2-r*r); double j1=acos(r/d1); double j2=acos(r/d2); double j3=acos((-d3*d3+d1*d1+d2*d2)/(2*d1*d2))-j2-j1; printf("%.10f",c1+c2+r*j3);&#125; C Gym 102021C - Coolest Ski Route 题目描述给一个有向无环图，边权为正，求任意能够到达的两点距离的最大值。 解题思路按拓扑序递推即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;#define N 10010int n,m,k,vis[N];int dis[N];struct Edge&#123; int e,n,l;&#125;e[N&lt;&lt;1];int hd[N],ind[N],cnt;void add(int a,int b,int l)&#123; e[++cnt].e=b;e[cnt].n=hd[a];e[cnt].l=l;hd[a]=cnt++;&#125;queue&lt;int&gt;Q;int main()&#123; int i,f,g,w; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d",&amp;f,&amp;g,&amp;w); add(f,g,w); ind[g]++; &#125; for(i=1;i&lt;=n;i++)if(!ind[i])Q.push(i); while(!Q.empty())&#123; int top=Q.front();Q.pop(); for(i=hd[top];i;i=e[i].n)&#123; int q=e[i].e; if(dis[q]&lt;dis[top]+e[i].l)dis[q]=dis[top]+e[i].l; if(!--ind[e[i].e])Q.push(e[i].e); &#125; &#125; int ans=0; for(i=1;i&lt;=n;i++)ans=max(ans,dis[i]); printf("%d",ans); return 0;&#125; D Gym 102021D - Down the Pyramid 题目描述给定一个数组$B$，求数组$A$，使得$A_i+A_{i+1}=B_i$。问有多少种方法。 解题思路从前往后找上下界限制，求出上下界最窄的有多少种情况即可。 AC代码点击 123456789101112131415161718#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1000010int n,a[N],up[N],low[N];int main()&#123; int i,ans=1e9; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]);a[n]=1e9; up[0]=a[0]; for(i=1;i&lt;=n;i++)&#123; up[i]=min(a[i-1]-low[i-1],a[i]); low[i]=max(0,a[i-1]-up[i-1]); ans=min(ans,up[i]-low[i]+1); &#125; printf("%d",ans&lt;0?0:ans); return 0;&#125; E Gym 102021E - Expired License 题目描述求一个小数能否转化成两个质数的比，并输出。 解题思路特判$1$！特判$1$！特判$1$！ AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int p[1000000],A[10000002],tot;int main()&#123; int i,j,n; A[0]=A[1]=1; for(i=2;i&lt;10000000;i++)&#123; if(!A[i])p[++tot]=i; for(j=1;p[j]*i&lt;10000000&amp;&amp;j&lt;=tot;j++)&#123; A[p[j]*i]=1; if(i%p[j]==0)break; &#125; &#125; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; double a,b; int x,y; scanf("%lf%lf",&amp;a,&amp;b); a*=100000;b*=100000; a+=1e-9,b+=1e-9; x=(int)a,y=(int)b; if(x==y)&#123; printf("2 2\n"); continue; &#125; int g=__gcd(x,y); x/=g,y/=g; if(!A[x]&amp;&amp;!A[y])printf("%d %d\n",x,y); else printf("impossible\n"); &#125; return 0;&#125; F Gym 102021F - Fighting Monsters 题目描述问一个自然数数组里存在不存在两个数能够互相减，减到$(0,1)$。 解题思路找斐波那契数列中的相邻两项。 AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int f[50]=&#123;1,1&#125;;struct P&#123; int d,i; bool operator&lt;(const P&amp;a)const&#123;return d&lt;a.d;&#125;&#125;a[1000010];int m[1000010];int main()&#123; int i,n; for(i=2;;i++)&#123; f[i]=f[i-1]+f[i-2]; if(f[i]&gt;1000000)break; m[f[i]]=i; &#125;m[1]=1; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i].d); a[i].i=i; &#125; int flag=0; sort(a+1,a+1+n); if(a[1].d==1&amp;&amp;a[2].d==1)return printf("%d %d\n",a[1].i,a[2].i),0; for(i=1;i&lt;=n;i++)&#123; if(m[a[i].d])&#123; if(!flag||m[a[flag].d]!=m[a[i].d]-1)flag=i; else return printf("%d %d\n",a[flag].i,a[i].i),0; &#125; while(a[i].d==a[i+1].d)i++; &#125; printf("impossible"); return 0;&#125; G Gym 102021G - GPS 题目描述给定地球上某一点，给定某个严格圆轨道卫星的轨道描述（两个旋转角度、半径）和轨道上一点经过的角度，求能否到达地球上那一点，如果可以求出时间。 解题思路根据$x,\phi,\psi$求出卫星上该点坐标，地球上一点用球坐标求出，判断角（地球球心—地球上的点—卫星上该点）是否为锐角，求出距离即可。 注意$\sin$不要打成$\cos$！ AC代码点击 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;double x,y,z,r=6371,pi=acos(-1),lo,la;double X,Y,Z,R,dis;int main()&#123; int n; scanf("%d",&amp;n); scanf("%lf%lf",&amp;lo,&amp;la);lo*=pi/180,la*=pi/180; double theta=lo,phi=pi/2-la; x=r*sin(phi)*cos(theta),y=r*sin(phi)*sin(theta),z=r*cos(phi); while(n--)&#123; double a,b,f; scanf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;R,&amp;f);a*=pi/180,b*=pi/180; theta=f*2*pi; double tx=cos(theta),ty=sin(theta)*cos(b); X=tx*cos(a)-ty*sin(a),Y=tx*sin(a)+ty*cos(a);Z=sin(theta)*sin(b); X*=R,Y*=R,Z*=R; dis=sqrt((x-X)*(x-X)+(y-Y)*(y-Y)+(z-Z)*(z-Z)); if(dis*dis+r*r&lt;=R*R)printf("%.10f\n",dis/299792.458); else printf("no signal\n"); &#125; return 0;&#125; H Gym 102021H - Hyper Illuminati 题目描述求一个$&lt;1e16$的正整数能否被分解成$\sum_{i=0}^{n}x^i$，若能，求出$x,n$。 解题思路暴力即可。 AC代码点击 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int main()&#123; ll i,j,k,n; scanf("%lld",&amp;n); for(i=3;i&lt;=55;i++)&#123; ll ans=0; for(j=1;j&lt;=n;j++)&#123; ll temp=1; for(k=1;k&lt;i;k++)&#123;//j^i if((double)temp*j-n&gt;0)&#123;temp=n+1;break;&#125; temp*=j; &#125; if((ans+=temp)&gt;n)break; if(n==ans)return printf("%lld %lld",i,j),0; &#125; &#125; printf("impossible"); return 0;&#125; I Gym 102021I - It’s Time for a Montage 题目描述给定$a,b$两个数组，$a$数组可以在$t$时间后每个元素的值$+1$，问至少多少时间后$a$的字典序$\geq b$的字典序。 解题思路题意倒是很简单，读题真是头疼。 AC代码点击 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,a[1010],b[1010];int jud(int x)&#123; int i; for(i=0;i&lt;n;i++)&#123; if(a[i]+x&gt;b[i])return 1; else if(a[i]+x&lt;b[i])return 0; &#125; return 1;&#125;int main()&#123; int i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)scanf("%d",&amp;b[i]); for(i=0;;i++)if(jud(i))return printf("%d",i),0; return 0;&#125; J Gym 102021J - Jigsaw Puzzle 题目描述给一些拼图，求输出按照给定的接口拼起来的方案。 解题思路每个接口都只有两个，直接记录搜索即可。 神秘操作，忘记$vector$和数组不一样会超出限制，$RE$了好久没看出来为什么…… AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 300010struct P&#123;int x,y;&#125;;//x,0123vector&lt;P&gt;ans[N];P p[N&lt;&lt;2][2];int num[N&lt;&lt;2],a[N][4],w,h,n;int find(int a1,int a2,int x)&#123; int i; for(i=0;i&lt;4;i++)if(a[x][i]==a1&amp;&amp;a[x][(i+1)%4]==a2)return i; return -1;&#125;int vis[N];int solve()&#123; vis[0]=1; int i,j,right,down,last; //find left&amp;up int start=0,startnum; for(i=1;i&lt;=n;i++)&#123; if((startnum=find(0,0,i))!=-1)&#123; start=i; break; &#125; &#125; if(!start)return 0; vis[start]=1; w=1; //first row right=a[start][(startnum+2)%4],last=start; ans[0].push_back(&#123;start,startnum&#125;); while(right)&#123; P x=(p[right][0].x==last?p[right][1]:p[right][0]); if(vis[x.x])return 0; vis[x.x]=1; if(a[x.x][(x.y+1)%4]!=0)return 0; right=a[x.x][(x.y+2)%4]; last=x.x; w++; ans[0].push_back(x); &#125; if(n%w)return 0; //row by row h=n/w; int nowh=1; while(nowh&lt;h)&#123; int noww=1; P upper=ans[nowh-1][0]; down=a[upper.x][(upper.y+3)%4],last=upper.x; if(!down)return 0; P x=(p[down][0].x==last?p[down][1]:p[down][0]); if(vis[x.x])return 0; vis[x.x]=1; ans[nowh].push_back(&#123;x.x,(x.y+3)%4&#125;); right=a[x.x][(x.y+1)%4],last=x.x; while(right)&#123; if(noww&gt;=w)return 0; x=(p[right][0].x==last?p[right][1]:p[right][0]); if(vis[x.x])return 0; vis[x.x]=1; upper=ans[nowh-1][noww]; if(a[x.x][(x.y+1)%4]!=a[upper.x][(upper.y+3)%4])return 0; right=a[x.x][(x.y+2)%4]; last=x.x; noww++; ans[nowh].push_back(x); &#125; if(noww!=w)return 0; nowh++; &#125; //check last for(i=0;i&lt;w;i++)if(a[ans[h-1][i].x][(ans[h-1][i].y+3)%4])return 0; //print printf("%d %d\n",w,h); for(i=0;i&lt;w;i++)&#123; for(j=0;j&lt;h;j++)printf("%d ",ans[j][i].x); puts(""); &#125; return 1;&#125;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;4;j++)&#123; scanf("%d",&amp;a[i][j]); int x=a[i][j]; if(x&amp;&amp;num[x]&gt;=2)return printf("impossible"),0; if(x)p[x][num[x]++]=(P)&#123;i,j&#125;; &#125; &#125; if(!solve())printf("impossible"); return 0;&#125; K Gym 102021K - Kitchen Cable Chaos 题目描述有一个长为$dis$的缝隙和$n$段杆，要求在这段缝隙中加入某些杆，杆与杆之间可以重叠不超过$5$，使得重叠最小的最大，并求出这个重叠长度。 解题思路$dp[i][j][k]$表示递推到前$i$个，用了$j$个，能否拼出长度为$k$的杆，循环判断即可。可以优化掉一维，不过没必要。 AC代码点击 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int d[62],dp[62][62][1295+5];double ans=-1;int main()&#123; int i,j,k,n,dis,mx=0; scanf("%d%d",&amp;n,&amp;dis); for(i=1;i&lt;=n;i++)scanf("%d",&amp;d[i]),mx+=d[i]; dp[0][0][0]=1; for(i=1;i&lt;=n;i++) for(j=0;j&lt;=i;j++) for(k=0;k&lt;=mx&amp;&amp;k&lt;=1295;k++) if(k&gt;=d[i]&amp;&amp;j)dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-1][k-d[i]]); else dp[i][j][k]=dp[i-1][j][k]; for(i=1;i&lt;=n;i++) for(k=dis-10;k&lt;=dis+5*(i-1);k++) if(dp[n][i][k]) ans=max(ans,(k+10-dis)*1.0/(i+1)); if(ans&gt;=0)printf("%.10f",ans); else printf("impossible"); return 0;&#125; L Gym 102021L - Logic Puzzle 题目描述扫雷，给定一个雷数矩阵（包含自己的九格雷数），最外圈没有雷，求最终雷的位置并判断合法性。 解题思路从$(2,2)$开始找，每一次找它左上的雷数，如果是$1$那么有雷，$0$那么无雷，否则不合法。再判断最右一列的合法性即可。 AC代码点击 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int num[200][200];char res[200][200];void setz(int i,int j)&#123; num[i][j]--;num[i][j+1]--;num[i][j-1]--; num[i+1][j+1]--;num[i+1][j]--;num[i+1][j-1]--; num[i-1][j+1]--;num[i-1][j]--;num[i-1][j-1]--;&#125;int main()&#123; int i,j,h,w; scanf("%d%d",&amp;h,&amp;w); for(i=0;i&lt;=h+1;i++)for(j=0;j&lt;=w+1;j++)scanf("%d",&amp;num[i][j]); for(i=0;i&lt;=h;i++)&#123; for(j=0;j&lt;=w;j++)&#123; if(num[i][j]==1)res[i+1][j+1]='X',setz(i+1,j+1); else if(num[i][j]==0)res[i+1][j+1]='.'; else return printf("impossible"),0; &#125; if(num[i][w+1])return printf("impossible"),0; &#125; for(j=0;j&lt;=w+1;j++)if(num[h+1][j]!=0)return printf("impossible"),0; for(i=1;i&lt;=h;i++)&#123; res[i][w+1]='\0'; printf("%s\n",res[i]+1); &#125; return 0;&#125; M Gym 102021M - Mountaineers 题目描述给一个矩阵，求给定两点间的路径中最大元素最小值。 解题思路考虑$LCA$，其实这个思想和$A$题基本重合。建图的过程为：开始时，所有的点都不联通；按高度从小到大枚举每个点，每个点向它周围四个方向寻找已经访问过的（高度小于等于它的）且与不在同一连通块中的点，将它们联通，用并查集维护连通块，用树存储连边关系。注意加边和修改父亲的顺序。最后求$LCA$的深度即可。注意排完序的顺序是改变了的，搞清楚哪里维护的是初始状态，哪里维护的是排序后的状态。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,m,q;#define N 260000int id(int x,int y)&#123;return (x-1)*m+y;&#125;struct Point&#123; int x,y,h,id; bool operator&lt;(const Point &amp;p)const&#123;return h&lt;p.h;&#125;&#125;p[N];#define M 510int tot,f[N],a[M][M],vis[N],H[N];int find(int x)&#123; return x==f[x]?f[x]:(f[x]=find(f[x]));&#125;struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int hd[N],cnt;void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;int dx[4]=&#123;0,0,1,-1&#125;;int dy[4]=&#123;1,-1,0,0&#125;;int fa[23][N],d[N],lg[N];void dfs(int now,int f)&#123; d[now]=d[f]+1; fa[0][now]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++) fa[i][now]=fa[i-1][fa[i-1][now]]; for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=f)dfs(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y]) x=fa[lg[d[x]-d[y]]][x]; if(x==y)return x; for(i=lg[d[x]];~i;i--) if(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y]; return fa[0][x];&#125;int in(int x,int y)&#123; return x&gt;=1&amp;&amp;y&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&lt;=m;&#125;int pos[N];int main()&#123; int i,j; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; scanf("%d",&amp;a[i][j]); p[++tot]=(Point)&#123;i,j,a[i][j],id(i,j)&#125;; f[tot]=tot; H[tot]=a[i][j]; &#125; &#125; for(i=1;i&lt;=tot;i++)pos[p[i].id]=i; sort(p+1,p+1+tot); for(i=1;i&lt;=tot;i++)&#123; int x=p[i].x,y=p[i].y,idnow=p[i].id; for(j=0;j&lt;4;j++)&#123; int tx=x+dx[j],ty=y+dy[j],idt=id(tx,ty); if(in(tx,ty)&amp;&amp;vis[idt]&amp;&amp;find(idt)!=find(idnow))&#123; add(f[idnow],f[find(idt)]); f[find(idt)]=f[idnow]; &#125; &#125; vis[idnow]=1; &#125; dfs(p[tot].id,0); for(i=2;i&lt;N;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); for(i=0;i&lt;q;i++)&#123; int X1,X2,Y1,Y2; scanf("%d%d%d%d",&amp;X1,&amp;Y1,&amp;X2,&amp;Y2); int id1=pos[id(X1,Y1)],id2=pos[id(X2,Y2)]; printf("%d\n",H[lca(id1,id2)]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 15 题解]]></title>
    <url>%2F2019%2F07%2F06%2F2019springtraining-15%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L 6/12 . . . . O . O O O O . O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A HDU 6426 - Alkane 题目描述解题思路AC代码点击 12 B HDU 6427 - Beads 题目描述解题思路AC代码点击 12 C HDU 6428 - Calculate 题目描述解题思路AC代码点击 12 D HDU 6429 - Permutation 题目描述解题思路AC代码点击 12 E HDU 6430 - TeaTree 题目描述给一棵树，每个节点有一个权值，某点的答案为该点任意两棵子树上的任意两点的$gcd$的最大值。求这个答案。 解题思路观察到权值最大在$100000$以内，故将每一个点上建立一个权值的集合，$dfs$的过程不断合并即可。$set$的常数太大，用$vector$存，二路归并的思想合并同时计算答案即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+23;const int N=1e5+2;int n,m;int v[maxn],ans[maxn],cnt[maxn],f[maxn];int exi[maxn];vector&lt;int&gt;fac[maxn],thi[maxn],g[maxn];void uni(int a,int b)&#123; int i,j; vector&lt;int&gt;p; for(i=0,j=0;i&lt;thi[a].size()&amp;&amp;j&lt;thi[b].size();)&#123; int x1=thi[a][i],x2=thi[b][j]; if(x1&lt;x2)p.push_back(x1),i++; else if(x1&gt;x2)p.push_back(x2),j++; else p.push_back(x1),i++,j++,ans[a]=max(ans[a],x1); &#125; while(i&lt;thi[a].size())p.push_back(thi[a][i]),i++; while(j&lt;thi[b].size())p.push_back(thi[b][j]),j++; thi[a]=p;&#125;void dfs(int x)&#123; int i; for(i=0;i&lt;g[x].size();i++)&#123; int q=g[x][i]; dfs(q); uni(x,q); &#125;&#125;int main()&#123; int n,i,j; scanf("%d",&amp;n); for(i=2;i&lt;=n;i++)&#123; scanf("%d",&amp;m); cnt[m]++;f[i]=m; g[f[i]].push_back(i); &#125; for(i=1;i&lt;=n;i++)scanf("%d",v+i); for(i=1;i&lt;maxn;i++)for(j=i;j&lt;maxn;j+=i)fac[j].push_back(i); for(i=1;i&lt;=n;i++)thi[i]=fac[v[i]]; memset(ans,-1,sizeof(ans)); dfs(1); for(i=1;i&lt;=n;i++)printf("%d\n",ans[i]);&#125; F HDU 6431 - NewNippori 题目描述解题思路AC代码点击 12 G HDU 6432 - Cyclic 题目描述求长度为$n$的环排列$(0,1,…,n-1)$中，不包含$(a_i+1-a_{(i+1)%n})%n=0$（下面称这个为相邻递增）的个数。 解题思路环排列一共有$(n-1)!$种。 至少有两个相邻递增的种类数为$C_n^1(n-2)!$，即$n$种两个相邻递增中选择一个，合并在一起后进行$n-1$个元素的环排列。 因为剩下元素是任意的环排列，所以这包含了一些重复的情况，容斥处理掉即可。 AC代码点击 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int mod=998244353;ll fac[100010]=&#123;1,1&#125;,inv[100010]=&#123;1,1&#125;;ll c(int n,int m)&#123;return fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;ll qp(ll a,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,a=a*a%mod)if(p&amp;1)ans=ans*a%mod; return ans;&#125;int main()&#123; int i,j,t,n; for(i=2;i&lt;100010;i++)fac[i]=fac[i-1]*i%mod,inv[i]=qp(fac[i],mod-2); scanf("%d",&amp;t); for(i=0;i&lt;t;i++)&#123; scanf("%d",&amp;n); ll ans=0,now=-1; for(j=0;j&lt;n;j++)&#123; now=now*-1; (ans+=now*c(n,j)*fac[n-1-j])%=mod; &#125; (ans+=now*-1+mod)%=mod; printf("%lld\n",(ans%mod+mod)%mod); &#125; return 0;&#125; H HDU 6433 - Pow 题目描述从$3^0,3^1,…,3^n-1$中任选子集加成一个新数，问有多少种可能，$n\leq 1000$。 解题思路输出$2^n$即可，用$JAVA$可过。 AC代码点击 1234567891011121314import java.math.BigDecimal;import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner s=new Scanner(System.in); int t=s.nextInt(); while(t&gt;0)&#123; t--; int n=s.nextInt(); BigDecimal res=new BigDecimal(2); System.out.println(res.pow(n)); &#125; &#125;&#125; I HDU 6434 - Count 题目描述$n\leq 2e7$，$T\leq 1e5$组数据，求$\sum_{i=1}^n\sum_{j=1}^{i-1}[gcd(i+j,i-j)==1]$。 解题思路$\sum_{i=1}^n\sum_{j=1}^{i-1}[gcd(i+j,i-j)==1]$ $=\sum_{i=1}^n\sum_{j=1}^{i-1}[gcd(i+j,2j)==1]$ $=\sum_{i=1}^n\sum_{j=1}^{i-1}[gcd(i+j,j)==1\space and\space (i+j) \ &amp;1]$ $=\sum_{i=1}^n\sum_{j=1}^{i-1}[gcd(i,j)==1\space and\space (i+j)\ &amp;1]$ 分类讨论，$i$为偶数时，所有偶数$j$都有$gcd(i,j)!=1$，故贡献为$\phi(i)$；$i$为奇数时，假设$gcd(i,j)==1$，则$gcd(i,i-j)==1$，$i$与$i-j$奇偶性相反，故贡献为$\frac{\phi(i)}2$。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 20000000int prime[N],a[N+10]=&#123;1,1&#125;,cnt;ll phi[N+10];void sieve()&#123; int i,j; for(i=2;i&lt;N;i++)&#123; if(!a[i])prime[++cnt]=i,phi[i]=i-1; for(j=1;j&lt;=cnt&amp;&amp;prime[j]*i&lt;N;j++)&#123; a[prime[j]*i]=1; if(i%prime[j]==0)&#123; phi[i*prime[j]]=phi[i]*prime[j]; break; &#125;else phi[i*prime[j]]=phi[i]*(prime[j]-1); &#125; &#125; for(i=1;i&lt;N;++i)&#123; if(i&amp;1)phi[i]&gt;&gt;=1; phi[i]+=phi[i-1]; &#125;&#125;int main()&#123; int t,i,n; sieve(); scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); printf("%lld\n",phi[n]); &#125; return 0;&#125; J HDU 6435 - CSGO 题目描述武器$i$有两类属性，$S_i$和${a_{ij}}(1\leq j\leq k)$。有两种武器，要从每一种武器中各选出一个$A,B$配合使用，威力为$S_A+S_B+\sum_{i=1}^{k}|x_{Ai}-x_{Bi}|$，最大化威力。$k\leq 5$。 解题思路直接去绝对值号，正负用$0/1$表示，观察到$k\leq 5$，直接状态压缩即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010#define K 7ll s[N],x[N][K],s2[N],x2[N][K];ll sit[1&lt;&lt;K];int main()&#123; int i,t,n,m,k,j,l; scanf("%d",&amp;t); while(t--)&#123; ll ans=0; memset(sit,0,sizeof(sit)); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); int S=1&lt;&lt;k; for(i=0;i&lt;n;i++)&#123; scanf("%lld",&amp;s[i]); for(j=0;j&lt;k;j++)scanf("%lld",&amp;x[i][j]); for(j=0;j&lt;S;j++)&#123; ll now=s[i]; for(l=0;l&lt;k;l++)&#123; if(j&amp;(1&lt;&lt;l))now+=x[i][l]; else now-=x[i][l]; &#125; sit[j]=max(sit[j],now); &#125; &#125; for(i=0;i&lt;m;i++)&#123; scanf("%lld",&amp;s2[i]); for(j=0;j&lt;k;j++)scanf("%lld",&amp;x2[i][j]); for(j=0;j&lt;S;j++)&#123; ll now=s2[i]; for(l=0;l&lt;k;l++)&#123; if(j&amp;(1&lt;&lt;l))now-=x2[i][l]; else now+=x2[i][l]; &#125; ans=max(ans,now+sit[j]); &#125; &#125; printf("%lld\n",ans); &#125; return 0;&#125; K HDU 6436 - Pow2 题目描述解题思路AC代码点击 12 L HDU 6437 - Videos 题目描述电影有$AB$两种类型，现在给出$m$个电影的起止时间、观看获得的收益$w$，类型$op(0/1)$，有$k$个人，每个电影只能被一个人看，一个人在上一个电影结束时刻之前不能看别的电影，电影必须完整看完。如果一个人相邻两次看电影是相同类型的，那么他额外损失$W(W\leq w)$。求这些人能获得的最大收益。 解题思路显然，人数越多越优。于是问题变成了以人数为流量、负收益为费用的最小费用最大流。 建图： $S\rightarrow temp$，流量$k$，费用$0$$temp\rightarrow i$，流量$1$，费用$0$$i\rightarrow i+m$，流量$1$，费用$-w_i$$i+m\rightarrow j$，流量$1$，费用$W$（$i.T\leq j.S$）$i+m\rightarrow T$，流量$1$，费用$0$ AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 10010struct Edge&#123; int e,l,c,n;&#125;e[N&lt;&lt;5];int maxflow,mincost;int hd[N],dis[N],flow[N],vis[N],cnt=1,s,t;struct Pre&#123; int pre,e;&#125;pre[N];void add(int a,int b,int l,int c)&#123; e[++cnt].e=b;e[cnt].c=c;e[cnt].l=l;e[cnt].n=hd[a];hd[a]=cnt; e[++cnt].e=a;e[cnt].c=-c;e[cnt].l=0;e[cnt].n=hd[b];hd[b]=cnt;&#125;queue&lt;int&gt;Q;int spfa()&#123; memset(dis,0x7f,sizeof(dis)); memset(flow,0x7f,sizeof(flow)); memset(vis,0,sizeof(vis)); while(!Q.empty())Q.pop(); int i,top,q; Q.push(s);vis[s]=1;dis[s]=0;pre[t].pre=0; while(!Q.empty())&#123; top=Q.front();Q.pop(); vis[top]=0; for(i=hd[top];i;i=e[i].n)&#123; q=e[i].e; if(e[i].l&amp;&amp;dis[q]&gt;dis[top]+e[i].c)&#123; dis[q]=dis[top]+e[i].c; pre[q].pre=top; pre[q].e=i; flow[q]=min(flow[top],e[i].l); if(!vis[q])&#123; vis[q]=1; Q.push(q); &#125; &#125; &#125; &#125; return pre[t].pre;&#125;void ek()&#123; int i; while(spfa())&#123; maxflow+=flow[t]; mincost+=flow[t]*dis[t]; for(i=t;i!=s;i=pre[i].pre)&#123; e[pre[i].e].l-=flow[t]; e[pre[i].e^1].l+=flow[t]; &#125; &#125;&#125;struct VIDEO&#123; int S,T,W,op;&#125;v[N];int main()&#123; int i,j,n,m,T,k,w; scanf("%d",&amp;T); while(T--)&#123; memset(hd,0,sizeof(hd));cnt=1;mincost=maxflow=0; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;w); for(i=0;i&lt;m;i++)scanf("%d%d%d%d",&amp;v[i].S,&amp;v[i].T,&amp;v[i].W,&amp;v[i].op); s=2*m;t=s+1;int tmp=t+1; add(s,tmp,k,0); for(i=0;i&lt;m;i++) add(tmp,i,1,0),add(i,i+m,1,-v[i].W),add(i+m,t,1,0); for(i=0;i&lt;m;i++)&#123; for(j=0;j&lt;m;j++)&#123; if(i==j)continue; if(v[i].T&lt;=v[j].S)add(i+m,j,1,v[i].op==v[j].op?w:0); &#125; &#125; ek(); printf("%d\n",-mincost); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 14 题解]]></title>
    <url>%2F2019%2F07%2F05%2F2019springtraining-14%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K 8/11 O . O Ø O . O . O Ø O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A Gym 101790A - Pizza Universe 题目描述有一些人，分别吃了不同价值的饭，付了不同价值的钱。问如何相互给钱使得总消费为自己吃的饭的价钱。 解题思路可以先排个序，双指针每次保证一个人的账单被清空即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int a[1000010];struct A&#123; int i,d; bool operator&lt;(const struct A&amp;P)const&#123; return d&lt;P.d; &#125;&#125;e[100010];int main()&#123; int b,i,n; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;b),a[i]-=b; e[i].i=i;e[i].d=a[i]; &#125; sort(e+1,e+1+n); int l=1,r=n; while(!e[r].d&amp;&amp;r&gt;=0)r--; while(!e[l].d&amp;&amp;l&lt;=n+1)l++; while(l&lt;=r)&#123; if(e[r].d+e[l].d&gt;0)printf("%d %d %d",e[r].i,e[l].i,-e[l].d),e[r].d+=e[l].d,l++; else if(e[r].d+e[l].d&lt;0)printf("%d %d %d",e[r].i,e[l].i,e[r].d),e[l].d+=e[r].d,r--; else printf("%d %d %d",e[r].i,e[l].i,e[r].d),l++,r--; while(!e[r].d&amp;&amp;r&gt;=0)r--; while(!e[l].d&amp;&amp;l&lt;=n+1)l++; puts(""); &#125; return 0;&#125; B Gym 101790B - Forest protection 题目描述解题思路AC代码点击 12 C Gym 101790C - Keys assignment 题目描述有$n$个$key$，$k$个槽，每次只能在一个槽里放一个数。对于第$i$个$key$，如果这个$key$的数字没有出现在槽，那需要使一个槽里的数字改变成这个$key$的数字，否则继续下一个$key$。问最多需要改变多少次槽里的数字（初始状态槽里没有放任何数字）。 解题思路贪心，每次需要分配的时候取出下一个这个数出现最晚的那个数，可以用堆维护。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010int pos[N],a[N],nxt[N];int key[N],in[N];struct P&#123; int data,i; bool operator&lt;(const struct P&amp;a)const&#123;return data&lt;a.data;&#125;&#125;;priority_queue&lt;P&gt;Q;int main()&#123; int i,n,m; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); memset(pos,0x3f,sizeof(pos)); for(i=n-1;i&gt;=0;i--)&#123; nxt[i]=pos[a[i]]; pos[a[i]]=i; &#125; int ans=0; for(i=0;i&lt;n;i++)&#123; if(in[a[i]])&#123; Q.push(&#123;nxt[i],i&#125;); continue; &#125; if(ans&lt;m)in[a[i]]=1,Q.push(&#123;nxt[i],i&#125;),ans++; else&#123; int top=Q.top().data,topi=Q.top().i; while(top&lt;=i&amp;&amp;!Q.empty())Q.pop(),top=Q.top().data,topi=Q.top().i; in[a[topi]]=0; Q.pop(); Q.push(&#123;nxt[i],i&#125;); in[a[i]]=1; ans++; &#125; &#125; printf("%d",ans); return 0;&#125; D Gym 101790D - Scotland Yard’s fail 题目描述初始时有一个人际关系图（原图），图里有且只有一个凶手。有$T$次杀戮，每一次杀戮时凶手与被害者互相认识（即有连边），每次杀戮后所有认识被害者的人都会互相认识。 问在第几次杀戮后，能够唯一确定凶手，并输出凶手是谁。 解题思路首先很容易想出的是，第一次杀戮的时候，受害者的朋友们成为嫌疑犯集合。在第一次杀戮之后的每次杀戮之后，嫌疑犯集合需要取所有认识受害者的人和嫌疑犯集合的交集。 分两类讨论： 如果受害者$p$没有当过前面的受害者的朋友，那么这个受害者在每一次杀戮之后都没有认识新的人，所以受害者在原图中的的朋友集合$P$与嫌疑犯集合取交集，成为新的嫌疑犯集合。 如果受害者$p$当过前面的受害者的朋友，那么这个受害者认识某一次杀戮之后的受害者的所有朋友，记为集合$S$，而这个集合已经与嫌疑犯集合$sus$取过并集，也就是$sus$是$S$的子集，故$p$所有认识的人与$sus$的交集仍为$sus$。 所以维护两个集合，一个代表嫌疑犯集合$suspect$，一个代表通过杀戮后受害者朋友的集合$irrelevant$即可。 注意，不手写$union$和$inetersection$会$T$掉。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010struct Edge&#123;int e,n;&#125;e[N&lt;&lt;2];int hd[N],cnt;void add(int a,int b)&#123;e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;set&lt;int&gt;suspect,irrelevant,temp;void uni(set&lt;int&gt;*a,set&lt;int&gt;*b)&#123; set&lt;int&gt;t; for(auto it=(*b).begin();it!=(*b).end();)if(!(*a).count(*it))(*a).insert(*it++);else it++;&#125;void cro(set&lt;int&gt;*a,set&lt;int&gt;*b)&#123; for(auto it=(*a).begin();it!=(*a).end();)if(!(*b).count(*it))(*a).erase(it++);else it++;&#125;int main()&#123; int i,j,n,m,u,v,num; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;m;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v),add(v,u); scanf("%d",&amp;num); for(i=0;i&lt;num;i++)&#123; scanf("%d",&amp;u); temp.clear(); for(j=hd[u];j;j=e[j].n)temp.insert(e[j].e); if(irrelevant.count(u))&#123; if(suspect.count(u))suspect.erase(u); irrelevant.erase(u); &#125;else&#123; if(i)cro(&amp;suspect,&amp;temp); else uni(&amp;suspect,&amp;temp); &#125; uni(&amp;irrelevant,&amp;temp); if(suspect.size()==1)return printf("%d %d",i+1,*suspect.begin()),0; &#125; printf("-1"); return 0;&#125; E Gym 101790E - Test variants 题目描述向长度为$n$的数列中填充整数，要求相邻两个数不相同且相隔$k$整数倍的数两两不同，输出最大值最小的方案。 解题思路首先特判能够由$12121212…$构造出来的情况。 然后填充前$k$项，根据需求用$21313….$或$23131…$填充；求出最大值为$max(3,\lceil\frac{n}{k}\rceil)$之后循环填充即可获得$WA$。 WA代码点击 123456789101112131415161718#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int ans[200010];int main()&#123; int i,j,n,k,mx; scanf("%d%d",&amp;n,&amp;k); if(n&lt;=k||(n&lt;=k*2&amp;&amp;k%2))for(i=0;i&lt;n;i++)ans[i]=i%2; else&#123; ans[0]=1; mx=(n+k-1)/k; if(k%2)for(i=1;i&lt;k;)ans[i++]=2,ans[i++]=0; else for(i=1;i&lt;k;)ans[i++]=0,ans[i++]=2; for(i=k;i&lt;n;i++)ans[i]=(ans[i-k]+1)%mx; &#125; for(i=0;i&lt;n;i++)printf("%d ",++ans[i]); return 0;&#125; 然后改成$131313242424$填充就过了？？？ 这是什么神秘$bug$，，，，如有高人看出其中问题请务必指点 AC代码点击 12345678910111213141516#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int ans[200010];int main()&#123; int i,j,n,k,mx; scanf("%d%d",&amp;n,&amp;k); if(n&lt;=k||(n&lt;=k*2&amp;&amp;k%2))for(i=0;i&lt;n;i++)ans[i]=i%2; else&#123; mx=max((n+k-1)/k,3); for(i=0;i&lt;k;)ans[i++]=0,ans[i++]=2; for(i=k;i&lt;n;i++)ans[i]=(ans[i-k]+1)%mx; &#125; for(i=0;i&lt;n;i++)printf("%d ",++ans[i]); return 0;&#125; F Gym 101790F - MK Ultra 题目描述解题思路AC代码点击 12 G Gym 101790G - Task distributor 题目描述每一秒有一个任务，能被$k$整除的时间点产生长度为$2T$的任务，其余时间点产生长度为$T$的任务。一台机器相同时刻只能处理一个任务，为了能够持续进行生产，至少需要多少机器？ 解题思路先考虑长度全都是$T$的情况，那么需要$T$台机器。再考虑长度为$2T$的，可以看成每隔时间$k$就多出来一个长度为$T$的任务，于是答案为$T+\frac Tk+(T%k!=0)$。 AC代码点击 123456789#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll t,k;int main()&#123; scanf("%lld%lld",&amp;t,&amp;k); printf("%lld",t+t/k+!!(t%k)); return 0;&#125; H Gym 101790H - Time difference 题目描述解题思路AC代码点击 12 I Gym 101790I - Key brute forcing 题目描述问手势密码经过某些边一共有多少种方法。 解题思路暴力$dfs$判正确性，注意$0$的特判。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int a[15][15]=&#123;&#123;1,2,3,4,5,6,7,8,9&#125;,&#123;2,4,5,6,8&#125;,&#123;1,3,4,5,6,7,9&#125;,&#123;2,4,5,6,8&#125;,&#123;1,2,3,5,7,8,9&#125;,&#123;1,2,3,4,6,7,8,9&#125;,&#123;1,2,3,5,7,8,9&#125;,&#123;2,4,5,6,8&#125;,&#123;1,3,4,5,6,7,9&#125;,&#123;2,4,5,6,8&#125;&#125;;int vis[15];int ans;int mt[15][15],mt2[15][15];int satisfy()&#123; int i,j; for(i=0;i&lt;15;i++)for(j=0;j&lt;15;j++)if(mt[i][j]&amp;&amp;!mt2[i][j])return 0; return 1;&#125;void dfs(int x)&#123; int i; if(satisfy())ans++; for(i=0;i&lt;10;i++)if(a[x][i]&amp;&amp;!vis[a[x][i]])&#123; vis[a[x][i]]=1; mt2[x][a[x][i]]=mt2[a[x][i]][x]=1; dfs(a[x][i]); vis[a[x][i]]=0; mt2[x][a[x][i]]=mt2[a[x][i]][x]=0; &#125;&#125;int main()&#123; int i,n; scanf("%d",&amp;n); if(!n)dfs(0),printf("%d",ans-10); else&#123; int u,v; for(i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;u,&amp;v); mt[u][v]=mt[v][u]=1; &#125; dfs(0); printf("%d",ans); &#125; return 0;&#125; J Gym 101790J - Distress signal 题目描述有两棵树，每棵树上有一个人随机在任意一个点上。他们同时向最靠近自己的叶节点走，每一秒走一条边，当一个人到达叶节点时游戏结束，问游戏结束的时间期望。 解题思路$dfs$找出到叶节点的距离，分别计算方案数即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int hd[N],cnt;void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;queue&lt;int&gt;Q;int dis[N],num[N],deg[N],vis[N],num2[N];ll s1[N],s2[N];int main()&#123; int i,n,m,u,v; scanf("%d",&amp;n); for(i=1;i&lt;n;i++)&#123; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); deg[u]++,deg[v]++; &#125; for(i=1;i&lt;=n;i++)if(deg[i]==1)vis[i]=1,dis[i]=0,Q.push(i); while(!Q.empty())&#123; int now=Q.front();Q.pop(); for(i=hd[now];i;i=e[i].n)&#123; int q=e[i].e; if(!vis[q])vis[q]=1,dis[q]=dis[now]+1,Q.push(q); &#125; &#125; for(i=1;i&lt;=n;i++)num[dis[i]]++; memset(hd,0,sizeof(hd));cnt=0; memset(deg,0,sizeof(deg));memset(vis,0,sizeof(vis)); scanf("%d",&amp;m); for(i=1;i&lt;m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); deg[u]++,deg[v]++; &#125; for(i=1;i&lt;=m;i++)if(deg[i]==1)vis[i]=1,dis[i]=0,Q.push(i); while(!Q.empty())&#123; int now=Q.front();Q.pop(); for(i=hd[now];i;i=e[i].n)&#123; int q=e[i].e; if(!vis[q])vis[q]=1,dis[q]=dis[now]+1,Q.push(q); &#125; &#125; for(i=1;i&lt;=m;i++)num2[dis[i]]++; for(i=max(n,m);i&gt;=0;i--)s1[i]=s1[i+1]+num[i],s2[i]=s2[i+1]+num2[i]; ll ans=0; for(i=1;i&lt;=n;i++)ans+=(num[i]*s2[i+1]+num2[i]*s1[i+1]+num[i]*num2[i])*i; printf("%.12f",ans*1.0/n/m); return 0;&#125; K Gym 101790K - Forbidden messenger 题目描述有$X$个小时，每个邮件写需要时间$A$，发需要时间$B$，每次在路上的邮件只能有一封，问能接受到几封邮件。 解题思路分类即可。 AC代码点击 12345678#include&lt;bits/stdc++.h&gt;int main()&#123; int x,a,b; scanf("%d%d%d",&amp;x,&amp;a,&amp;b);x*=60; if(a&gt;b)printf("%d",(x-b)/a); else printf("%d",(x-a)/b); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 13 题解]]></title>
    <url>%2F2019%2F07%2F04%2F2019springtraining-13%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J 10/10 O O O Ø Ø Ø O Ø O Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A Kattis - As Easy as CAB 题目描述给定一系列按照某种字典序排好的字符串，求字典序。 解题思路那就按照从小到大连边，找出这个图集的拓扑序，如果有环则拓扑序长度与给定长度不等，输出IMPOSSIBLE；否则一定能够找到一种方法，如果刚开始的入度为零的点为一是一条链那么就输出拓扑序，否则输出AMBIGUOUS。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char c[5],a[1010][1010];struct E&#123; int e,n;&#125;e[10010];int hd[30],cnt;void add(int a,int b)&#123;e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;int ind[30],oud[30];queue&lt;int&gt;Q;char seq[30];int top;int main()&#123; int i,n; scanf("%s%d",c,&amp;n); for(i=0;i&lt;n;i++)scanf("%s",a[i]); for(i=0;i&lt;n-1;i++)&#123; int j=0; while(a[i][j]&amp;&amp;a[i][j]==a[i+1][j])j++; if(a[i][j])&#123; int s=a[i][j]-'a',t=a[i+1][j]-'a'; add(s,t); ind[t]++;oud[s]++; &#125; &#125; int tot=0; for(i=0;i&lt;=c[0]-'a';i++)if(!ind[i])Q.push(i),tot++; while(!Q.empty())&#123; int t=Q.front();Q.pop(); seq[++top]=t+'a'; for(i=hd[t];i;i=e[i].n)&#123; int q=e[i].e; if(!--ind[q])Q.push(q); &#125; &#125; if(top!=c[0]-'a'+1)printf("IMPOSSIBLE"); else if(tot&gt;1)printf("AMBIGUOUS"); else if(tot==1)printf("%s",seq+1); return 0;&#125; B Kattis - Falling Apples 题目描述模拟重力掉落苹果。 解题思路暴力模拟就行了。 AC代码点击 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char a[50010][12];int main()&#123; int i,n,m,j; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)scanf("%s",a[i]); for(i=0;i&lt;m;i++)&#123; int now=n-1; for(j=n-1;j&gt;=0;j--)&#123; if(a[j][i]=='a')&#123; a[now][i]='a'; if(now!=j)a[j][i]='.'; now--; &#125;else if(a[j][i]=='#')now=j-1; &#125; &#125; for(i=0;i&lt;n;i++)printf("%s\n",a[i]); return 0;&#125; C Kattis - Square Deal 题目描述给三个矩形，问能不能够把他们无缝拼成一个正方形。 解题思路首先必然有，三个矩形中最长的边的长度为正方形长度。 求出面积和即可求出边长，进而分两类讨论剩下两个如何拼即可。 AC代码点击 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define x first#define y secondpair&lt;int,int&gt;p[5];int solve()&#123; int i,sq=0; for(i=0;i&lt;3;i++)scanf("%d%d",&amp;p[i].x,&amp;p[i].y),sq+=p[i].x*p[i].y; sort(p,p+3); int l=sqrt(sq),now=l-p[2].y; if(l*l!=sq||l!=p[2].x)return 0; if(p[0].x==l&amp;&amp;p[1].x==l)return 1; if(p[0].x==now)&#123;if(p[1].x==now||p[1].y==now)return 1;&#125; else if(p[1].x==now||p[1].y==now)return 1; return 0;&#125;int main()&#123; printf("%s",solve()?"YES":"NO"); return 0;&#125; D Kattis - Buggy Robot 题目描述给一张有障碍的图，上面有起点和终点。给定一段走路方向序列，要求用最少次数修改这个序列使得能够从起点走到终点。修改的方法有两种：删除一个、插入一个。走到终点后的所有序列会自动忽略。 解题思路$dp[i][x][y]$表示用序列前$i$项、走到$(x,y)$所需要最少修改次数。存状态宽搜即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int dp[102][51][51],ti,tj;char a[52][52],s[52];int dx[]=&#123;0,0,-1,1&#125;;int dy[]=&#123;-1,1,0,0&#125;;int f[260],n,m;struct P&#123;int i,x,y;&#125;;queue&lt;P&gt;Q;int in(int x,int y)&#123;return x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&lt;m&amp;&amp;a[x][y]!='#';&#125;void bfs()&#123; while(!Q.empty())&#123; int i,x,y; P top=Q.front();Q.pop(); for(i=0;i&lt;4;i++)&#123;//add x=top.x+dx[i],y=top.y+dy[i]; if(in(x,y)&amp;&amp;dp[top.i][x][y]&gt;dp[top.i][top.x][top.y]+1) dp[top.i][x][y]=dp[top.i][top.x][top.y]+1,Q.push(&#123;top.i,x,y&#125;); &#125; if(s[top.i])&#123; if(dp[top.i+1][top.x][top.y]&gt;dp[top.i][top.x][top.y]+1)//del dp[top.i+1][top.x][top.y]=dp[top.i][top.x][top.y]+1,Q.push(&#123;top.i+1,top.x,top.y&#125;); x=top.x+dx[f[s[top.i]]],y=top.y+dy[f[s[top.i]]]; if(in(x,y))&#123;//keep if(dp[top.i+1][x][y]&gt;dp[top.i][top.x][top.y]) dp[top.i+1][x][y]=dp[top.i][top.x][top.y],Q.push(&#123;top.i+1,x,y&#125;); &#125;else&#123; if(dp[top.i+1][top.x][top.y]&gt;dp[top.i][top.x][top.y]) dp[top.i+1][top.x][top.y]=dp[top.i][top.x][top.y],Q.push(&#123;top.i+1,top.x,top.y&#125;); &#125; &#125; &#125;&#125;int main()&#123; int i,j,ans=1e9; f['L']=0;f['R']=1;f['U']=2;f['D']=3; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)scanf("%s",a[i]); memset(dp,0x3f,sizeof(dp)); for(i=0;i&lt;n;i++)for(j=0;j&lt;m;j++) if(a[i][j]=='S')dp[0][i][j]=0,Q.push(&#123;0,i,j&#125;); else if(a[i][j]=='G')ti=i,tj=j; scanf("%s",s); bfs(); for(i=0;i&lt;=strlen(s);i++)ans=min(ans,dp[i][ti][tj]); printf("%d",ans); return 0;&#125; E Kattis - Construction Toy 题目描述给小于$9$个线段，要拼成一堆边邻三角形，其中一条边为基线，问离这条线最远的点有多远。 解题思路暴力枚举，每次枚举到哪条边上加边，保存边的使用与否，可以获得$TLE(10/15)$。 TLE代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,l[10];struct Seg&#123; double a1,b1,a2,b2; int l;&#125;a[10];int tot;double ans=0,pi=acos(-1);int proper(int a,int b,int c)&#123;return a+b&gt;c&amp;&amp;a+c&gt;b&amp;&amp;b+c&gt;a;&#125;void deal(int flag,Seg pre,int b,int c)&#123; int l=pre.l; double a1=pre.a1,a2=pre.a2,b1=pre.b1,b2=pre.b2; double theta=atan2(b2-b1,a2-a1)+acos((b*b+l*l-c*c)/(2.0*b*l))*(flag==1?-1:1); double tx=cos(theta)*b+a1,ty=sin(theta)*b+b1; a[tot++]=&#123;a1,b1,tx,ty,b&#125;; a[tot++]=&#123;a2,b2,tx,ty,c&#125;;&#125;int vis[10];void dfs()&#123; int i,k,j; for(i=0;i&lt;tot;i++)ans=max(ans,max(a[i].a1,a[i].a2)); if(tot&gt;=n-1)return; for(k=0;k&lt;tot;k++)&#123; if(vis[k])continue; i=tot,j=tot+1; if(proper(a[k].l,l[i],l[j]))&#123; vis[k]=1; deal(1,a[k],l[i],l[j]); if(a[tot-1].a1&gt;=0&amp;&amp;a[tot-2].a2&gt;=0)dfs(); tot-=2; if(tot==1)&#123; vis[k]=0; continue; &#125; deal(2,a[k],l[i],l[j]); if(a[tot-1].a1&gt;=0&amp;&amp;a[tot-2].a2&gt;=0)dfs(); tot-=2; vis[k]=0; &#125; &#125;&#125;int main()&#123; int i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;l[i]); sort(l,l+n); do&#123; a[0]=&#123;0,0,0,l[0],l[0]&#125;;tot=1; dfs(); &#125;while(next_permutation(l,l+n)); printf("%.10f",ans); return 0;&#125; 其实这样会引起很多重复，我们只需要每次在新扩展出的边上进行$DFS$即可，可以获得$AC$。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n,l[10];double ans=0,pi=acos(-1);int proper(double a,double b,double c)&#123;return a+b&gt;c&amp;&amp;a+c&gt;b&amp;&amp;b+c&gt;a;&#125;int vis[10];void dfs(double a1,double b1,double a2,double b2,int dep)&#123; int i; if(dep&gt;n-1)return; double a=sqrt((a1-a2)*(a1-a2)+(b1-b2)*(b1-b2)),b=l[dep],c=l[dep+1]; if(!proper(a,b,c))return; for(i=0;i&lt;2;i++)&#123; double theta=atan2(b2-b1,a2-a1)+acos((b*b+a*a-c*c)/(2.0*b*a))*(i?1:-1); double tx=cos(theta)*b+a1,ty=sin(theta)*b+b1; if(tx&lt;0)continue; dfs(a1,b1,tx,ty,dep+2); dfs(a2,b2,tx,ty,dep+2); ans=max(ans,tx); if(dep==1)break; &#125;&#125;int main()&#123; int i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;l[i]); sort(l,l+n); do&#123; dfs(0,0,0,l[0],1); &#125;while(next_permutation(l,l+n)); printf("%.10f",ans); return 0;&#125; F Kattis - Around and Around We Go 题目描述按照节拍对齐两个声部并输出。 解题思路分拍模拟即可，但不知道为什么会WA。 迫 真 码 农 题 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int n;char p[21][80][80],c;int t[21][80],num[21];#define N 1610char inin[N];void read(int x)&#123; fgets(inin,1600,stdin); int i; for(i=0;i&lt;strlen(inin);i++)&#123; int charnow=0; while(inin[i]==' ')i++; c=inin[i]; while(c&amp;&amp;c!=' '&amp;&amp;c!='\n'&amp;&amp;c!='\r')&#123; p[x][num[x]][charnow++]=c; c=inin[++i]; &#125; num[x]++; &#125; fgets(inin,1600,stdin); int number=0; for(i=0;i&lt;strlen(inin);i++)&#123; int num=0; while(inin[i]==' ')i++; c=inin[i]; while(c&gt;='0'&amp;&amp;c&lt;='9')num=num*10+c-'0',c=inin[++i]; t[x][number++]=num; &#125;&#125;pair&lt;int,pair&lt;int,int&gt; &gt;pai[16620],pai2[16620];int tot,cnt[N];char ans[N][N],ans2[N][N];int main()&#123; int i,j,d; scanf("%d%d",&amp;n,&amp;d); fgets(inin,1600,stdin); for(i=0;i&lt;n;i++)read(i); for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;num[i];j++)&#123; pai[tot]=make_pair(1,make_pair(i,j)); tot+=t[i][j]; &#125; &#125; for(i=0;i&lt;d;i++)pai2[i]=make_pair(0,make_pair(0,0)); for(i=0;i&lt;=tot;i++)pai2[d+i]=pai[i]; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;num[i];j++)cnt[i]+=t[i][j]; cnt[i]+=i?cnt[i-1]:0; &#125; int bt=0; for(i=0;i&lt;n;i++)&#123; int pre=-1; while(bt&lt;cnt[i])&#123; if(pai[bt].first&amp;&amp;pai2[bt].first)&#123; pre=max(strlen(ans[i]),strlen(ans2[i])); for(j=0;j&lt;pre;j++)&#123; if(!ans[i][j])ans[i][j]='_'; if(!ans2[i][j])ans2[i][j]='_'; &#125; strcat(ans[i],p[pai[bt].second.first][pai[bt].second.second]); strcat(ans[i],"_"); strcat(ans2[i],p[pai2[bt].second.first][pai2[bt].second.second]); strcat(ans2[i],"_"); &#125;else if(pai[bt].first)&#123; pre=strlen(ans[i]); for(j=strlen(ans2[i]);j&lt;=strlen(ans[i]);j++)ans2[i][j]='_'; strcat(ans[i],p[pai[bt].second.first][pai[bt].second.second]); strcat(ans[i],"_"); &#125;else if(pai2[bt].first)&#123; pre=strlen(ans2[i]); for(j=strlen(ans[i]);j&lt;=strlen(ans2[i]);j++)ans[i][j]='_'; strcat(ans2[i],p[pai2[bt].second.first][pai2[bt].second.second]); strcat(ans2[i],"_"); &#125; bt++; &#125; while(ans[i][strlen(ans[i])-1]=='_')ans[i][strlen(ans[i])-1]=0; while(ans2[i][strlen(ans2[i])-1]=='_')ans2[i][strlen(ans2[i])-1]=0; printf("%s\n%s\n",ans[i],ans2[i][0]?ans2[i]:"/"); &#125; return 0;&#125; G Kattis - The Calculus of Ada 题目描述给一个数组，问多少次差分之后能把它们全变为相同的数，并预测数列的下一项。 解题思路搞个矩阵模拟一下就好了。 AC代码点击 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll a[15];ll temp[15][15];int main()&#123; int i,j,n; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%lld",&amp;a[i]),temp[0][i]=a[i]; int now=n-1; for(i=1;;i++)&#123; int flag=0; for(j=0;j&lt;now;j++)temp[i][j]=temp[i-1][j+1]-temp[i-1][j]; for(j=0;j&lt;now;j++)if(temp[i][j]!=temp[i][1])&#123; flag=1; break; &#125; if(!flag)break; now--; &#125; temp[i][n-i]=temp[i][0]; int ans=i; for(i--;i&gt;=0;i--)temp[i][n-i]=temp[i][n-i-1]+temp[i+1][n-i-1]; printf("%d %lld",ans,temp[0][n]); return 0;&#125; H Kattis - Ghostbusters 2 题目描述平面上有一些放着武器的点，武器可以水平或竖直放置，武器的攻击范围为两侧对称的一定长度，问不互相打到最大的攻击范围是多少。 解题思路二分答案，一个武器水平或竖直放置是一个$0/1$问题，用$2-sat$解决。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#define N 8004#define cl(a) memset(a,0,sizeof(a))int n;struct P&#123; int x,y;&#125;a[N];struct Edge&#123; int e,n;&#125;e[N*N];int hd[N],count;void add(int a,int b)&#123;e[++count].e=b;e[count].n=hd[a];hd[a]=count;&#125;int col[N],sta[N],dfn[N],low[N],cnt,tot,top,vis[N];void tarjan(int p)&#123; int i,q; dfn[p]=low[p]=++cnt; sta[++top]=p;vis[p]=1; for(i=hd[p];i;i=e[i].n)&#123; q=e[i].e; if(!dfn[q])tarjan(q),low[p]=std::min(low[p],low[q]); else if(vis[q])low[p]=std::min(low[p],dfn[q]); &#125; if(low[p]==dfn[p])&#123; tot++; do&#123; q=sta[top--]; col[q]=tot; vis[q]=0; &#125;while(q!=p); &#125;&#125;int jud(int x)&#123;//horizontal 1;vertical 0(+n) cl(dfn);cl(col);cl(hd);cl(vis);cl(low);count=top=tot=cnt=0; int i,j; for(i=0;i&lt;n;i++)&#123; for(j=i+1;j&lt;n;j++)&#123; if(a[i].x==a[j].x&amp;&amp;(fabs(a[i].y-a[j].y)-1)/2&lt;x)add(i,j+n),add(j,i+n); if(a[i].y==a[j].y&amp;&amp;(fabs(a[i].x-a[j].x)-1)/2&lt;x)add(i+n,j),add(j+n,i); &#125; &#125; for(i=0;i&lt;n&lt;&lt;1;i++)if(!dfn[i])tarjan(i); for(i=0;i&lt;n;i++)if(col[i]==col[i+n])return 0; return 1;&#125;int main()&#123; int i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d%d",&amp;a[i].x,&amp;a[i].y); int ans=0,l=0,r=1000010; if(jud(r))return printf("UNLIMITED"),0; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(jud(mid))ans=mid,l=mid+1; else r=mid-1; &#125; printf("%d",ans); return 0;&#125; I Kattis - Postal Delivery 题目描述一个邮递员要从原点向数轴上某些点投一定量的邮件，每次装车件数有限制。求最短总路程。 解题思路贪心就行了，分正负两部分解决即可。 AC代码点击 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int a[1010],b[1010],n,k;int main()&#123; int i; scanf("%d%d",&amp;n,&amp;k); for(i=0;i&lt;n;i++)scanf("%d%d",&amp;a[i],&amp;b[i]); ll ans=0; int pos=n; for(i=0;i&lt;n;i++)if(a[i]&gt;0)&#123;pos=i;break;&#125; int now=0; for(i=0;i&lt;pos;i++)&#123; while(now&lt;b[i])ans+=-a[i]*2,b[i]-=now,now=k; now-=b[i]; &#125; now=0; for(i=n-1;i&gt;=pos;i--)&#123; while(now&lt;b[i])ans+=a[i]*2,b[i]-=now,now=k; now-=b[i]; &#125; printf("%lld",ans);&#125; J Kattis - Windy Path 题目描述给定平面上的一些点，找出一个不自交的路径序列保证符合给定的转弯顺序。保证没有三点共线。 解题思路先找到左下角的点（保证在边界），当下一个要转向右时，找到相对最左的那个点（与上一个形成的线段之间的夹角最小），否则找最右那个点。这个构造方法保证了每一次能够使得下一次无论选择哪个点都是正确的转向，同时选择斜率最大保证了不自交。 AC代码点击 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;struct P&#123; int x,y,i,flag; bool operator&lt;(const P&amp;a)const&#123;return x&lt;a.x||x==a.x&amp;&amp;y&lt;a.y;&#125; P operator-(const P&amp;a)const&#123;return &#123;x-a.x,y-a.y&#125;;&#125;&#125;a[52];char dir[52];int seq[52];int cross(P a,P b)&#123; return a.x*b.y-a.y*b.x;&#125;int main()&#123; int i,j,n; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d%d",&amp;a[i].x,&amp;a[i].y),a[i].i=i; scanf("%s",dir); sort(a+1,a+n+1); for(i=2;i&lt;n;i++)&#123; int flag=dir[i-2]=='L'?-1:1; int nxt=i; for(j=i+1;j&lt;=n;j++) if(cross(a[nxt]-a[i-1],a[j]-a[i-1])*flag&gt;0) nxt=j; swap(a[nxt],a[i]); &#125; for(i=1;i&lt;=n;i++)printf("%d ",a[i].i); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 11 题解]]></title>
    <url>%2F2019%2F06%2F08%2F2019springtraining-11%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F 6/6 O O O Ø Ø O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A CF1175E - Minimal Segment Cover 题目描述给定一组区间，每次询问某一个区间最少能由给定区间的多少个完全覆盖。 区间个数$q\leq n\leq 2e5$，给定区间以及询问区间均保证$0\leq l,r\leq 5e5$。 解题思路记录每一个点向右走$k$个区间能走到的最右端，用倍增存储。 每次查询从大到小搞一搞区间即可。 AC代码点击 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1000000#define M 23int n,m;int dis[M][N+5];int sol(int l,int r)&#123; int i,ans=0; for(i=M-1;i&gt;=0;i--)if(dis[i][l]&lt;r)l=dis[i][l],ans+=(1&lt;&lt;i); if(dis[0][l]&lt;r)return -1; return ans+1;&#125;int main()&#123; int i,j,l,r,mr=0; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;l,&amp;r); dis[0][l]=max(dis[0][l],r); mr=max(mr,r); &#125; for(i=1;i&lt;=mr;i++)dis[0][i]=max(dis[0][i],i); for(i=1;i&lt;=mr;i++)dis[0][i]=max(dis[0][i],dis[0][i-1]); for(i=1;i&lt;M;i++)for(j=0;j&lt;=mr;j++)dis[i][j]=dis[i-1][dis[i-1][j]]; for(i=0;i&lt;m;i++)scanf("%d%d",&amp;l,&amp;r),printf("%d\n",sol(l,r)); return 0;&#125; B CF1175D - Array Splitting 题目描述给一个整数数列，要把它分成$k$段，从左到右分别赋权值$1,2,…,k$（即：在第$j$个区间内的点$i$对应权值为$a_i=j$），求$\sum_{i=1}^na_ix_i$的最大值。 解题思路画一个图很显然可得知，答案为$k\times sum$减去$k-1$个互不相同的前缀和。排个序即可。 AC代码点击 1234567891011121314#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 300010ll ans,a[N];int main()&#123; int i,n,k; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;=n;i++)scanf("%I64d",&amp;a[i]),ans+=a[i]*k,a[i]+=a[i-1]; sort(a+1,a+n); for(i=1;i&lt;k;i++)ans-=a[i]; printf("%I64d\n",ans); return 0;&#125; C CF1175C - Electrification 题目描述给定一个递增序列$1\leq a_i\leq 10^9,1\leq n\leq 2\times 10^5$，以及$0\leq k&lt;n$，让你任意打乱$a_i$的顺序，构造数列$d_i=|a_i-x|$使得$d_{k+1}$最小，求出$x$。 解题思路暴力找出差距最小的长度为$k$的区间，求其中点即可。 AC代码点击 1234567891011121314151617#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 200010int n,k,t,a[N];int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;k); int mx=2e9,temp=1; for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i+k&lt;=n;i++)if(mx&gt;a[i+k]-a[i])mx=a[i+k]-a[i],temp=i; printf("%d\n",(a[temp]+a[temp+k])/2); &#125; return 0;&#125; D/E 1172C1/C2 - Nauuo and Pictures (easy/hard version) 题目描述有$n$个陈列品，每一个有一个正整数权值。$nauuo$喜欢其中某一些陈列品，有$m$次参观，每次每个陈列品按照权值对应的概率出现，如果是他喜欢的那么该陈列品的权值加一，否则减一。求出$m$次参观后每一个陈列品权值的期望。 解题思路设$f[i][j][w]$表示参观了$i+j$次，其中$i$次是他喜欢的，$j$次是他不喜欢的，之后初始权值为$w$的喜欢的陈列品最终权值期望，设初始喜欢的权值和为$gv$，不喜欢的权值和为$bv$，则当前分别为$gv+i,bv-j$。从后向前递推： $f[i][j][w]=\frac{w}{gv+bv+i-j}f[i+1][j][w+1]+\frac{gv-w}{gv+bv+i-j}f[i+1][j][w]+\frac{bv}{gv+bv+i-j}f[i][j+1][w]$。 给一个结论：$f[i][j][w]=f[i][j][1]\times w$，很容易证明。 所以$f[i][j][w]=\frac{w(w+1)}{gv+bv+i-j}f[i+1][j][1]+\frac{(gv-w)w}{gv+bv+i-j}f[i+1][j][1]+\frac{bv\times w}{gv+bv+i-j}f[i][j+1][1]$ $=\frac{w(gv+1)}{gv+bv+i-j}f[i+1][j][1]+\frac{bv\times w}{gv+bv+i-j}f[i][j+1][1]$ 同理处理出不喜欢的陈列品权值期望。预处理出逆元即可保证复杂度。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int mod=998244353;int qp(int x,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,x=(ll)x*x%mod)if(p&amp;1)ans=ans*x%mod; return ans;&#125;#define M 3005#define N 200010ll f[M][M],g[M][M];int n,m,a[N],inv[M&lt;&lt;1];ll gv,bv,w[N];int main()&#123; int i,v,j,k; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++)&#123; scanf("%I64d",&amp;w[i]); if(a[i])gv+=w[i];else bv+=w[i]; &#125; for(i=0;i&lt;=m&lt;&lt;1;i++)inv[i]=qp(bv+gv+i-m,mod-2); for(i=m;i&gt;=0;--i)&#123; f[i][m-i]=g[i][m-i]=1; for(j=min(m-i-1LL,bv);j&gt;=0;--j)&#123; int qpow=inv[i-j+m]; f[i][j]=((bv-j)*f[i][j+1]+(gv+i+1)*f[i+1][j])%mod*qpow%mod; g[i][j]=((bv-j-1)*g[i][j+1]+(gv+i)*g[i+1][j])%mod*qpow%mod; &#125; &#125; for(i=1;i&lt;=n;i++)&#123; if(a[i])printf("%d\n",w[i]*f[0][0]%mod); else printf("%d\n",w[i]*g[0][0]%mod); &#125; return 0;&#125; F CF1175F - The Number of Subpermutations 题目描述给定一个数列，称某个区间为好序列当且仅当其中所有数构成一个排列，求出其好序列个数。 解题思路先求出每一个点$i$的$maxright_i$，保证$[i,maxright_i]$中没有相同的数字。这很容易通过从后向前递推实现。求出这个后，我们发现，$[i,j]$合法当且仅当$j&lt;=maxright_i$且$max[i,j]=j-i+1$。 然后以每一个点为左端点，枚举合法的右端点，每次$RMQ$添加答案或者跳到这段区间对应最大值所对应长度的位置即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 300010int pos[N],a[N],mr[N],mx[20][N],lg[N];int query(int l,int r)&#123; int p=lg[r-l+1]; return max(mx[p][l],mx[p][r+1-(1&lt;&lt;p)]);&#125;int main()&#123; int i,j,l,r,n,ans=0; scanf("%d",&amp;n); for(i=2;i&lt;N;i++)lg[i]=lg[i-1]+!(i&amp;(i-1)); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),mx[0][i]=a[i];mr[i]=n; for(i=n;i;i--)&#123; if(pos[a[i]])mr[i]=min(mr[i+1],pos[a[i]]-1); else mr[i]=mr[i+1]; pos[a[i]]=i; &#125; for(i=1;i&lt;20;i++) for(j=1;j+(1&lt;&lt;i-1)&lt;=n;j++) mx[i][j]=max(mx[i-1][j],mx[i-1][j+(1&lt;&lt;i-1)]); for(l=1;l&lt;=n;l++)&#123; r=l; while(r&lt;=mr[l])&#123; int d=query(l,r); if(d==r-l+1)ans++,r++; else r=l+d-1; &#125; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 10 题解]]></title>
    <url>%2F2019%2F06%2F02%2F2019springtraining-10%2F</url>
    <content type="text"><![CDATA[Solved A B C D E 5/5 Ø O Ø O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A CF434E - Furukawa Nagisa’s Tree 题目描述给一棵树，每个点有给定权值$val_i$。定义一个长度为$l$的简单路径$[u,v]$是好的当且仅当$(\sum_{i=0}^{l-1}val_ik^i)%y=x$。问有多少条路径$[u,v]$满足$[u,p][p,v][u,v]$三条路径同好坏，其中$p$为$[u,v]$上一点。 解题思路太神了这题orz 首先我们观察任意三点构成的带方向和好坏的三角形，共有八种，有两种是答案所求，这两种需要满足三条边同好坏，不是很好求得。所以我们考虑，任意一个不符合答案要求的三角形必然满足有两个点连接两条不同好坏的边，这就可以与第三边脱离关系了，可以用点分治求解。 我们假设一个点$i$作为好边终点有$in[1][i]$种，作为坏边终点有$in[0][i]$种，作为好边起点有$out[1][i]$种，作为坏边起点有$out[0][i]$种。 下面引用洛谷题解中的一张图：（转侵删） 通过对上述六种三角形的计数，与某个点$i$有关的（注意，不是上述链接中题解中所说产生的）坏三角形个数即为$\frac12(4in[1][i]in[0][i]+4out[1][i]out[0][i]+2in[1][i]out[0][i]+2out[1][i]in[0][i])$，而一个三角形里有两个这样的点，所以答案即为$n^3$减去这些数的一半。 这个式子感觉很迷惑，让我们扔掉这个很抽象的图不管，用更形象的方式去理解。 考虑一个三角形$[u,p][p,v][u,v]$，根据题目描述中的定义，显然这三个点互不等价。任意一个点$m$都必为这个三元组中的任意一个，故可以假设$m$为$u,p,v$中的某一点，则$m$的贡献（有关的坏三角形数）即为$m$分别为这三个点的贡献之和。当$m$为$u$点时，贡献为$out[1]out[0]+out[0]out[1]$（考虑$u\rightarrow p,u\rightarrow v$两条边的不同）；当$m$为$v$点时，贡献为$in[1]out[0]+in[0]out[1]$；当$m$为$u$点时，贡献为$in[1]in[0]+in[0]in[1]$。加起来即为刚才的式子。 我们回过头理解这个三角形的图，其实是对于一个点，它与另一个顶点同时产生一个坏三角形。而这个图中计数是对每一个三角形中两个顶点计数分别计了一次，故需要除以二。这里很绕，可以理解为一个顶点对应的两份”答案“其实是不能同时满足的，但是是必然满足某一个的。 而对于最后的答案，因为是枚举每一个顶点，所以一个坏三角形会被计数两次，所以需要再除以二。 说了一大串，下面进入正题。 我们要统计的是经过给定树根的路径的起点与终点的$in,out$值。 首先，在$calc$里通过$dfs$可以很容易地得出每一个子树中的节点$p$到根的$up[p]$和$down[p]$值（从该节点向根走，从根走到该节点）。一条通过$rt$的路径$[p,q]$是好的当且仅当$(up[p]-val[rt]+down[q]\times k^{depth[p]})%y=x$。化一下式子，把$p,q$分离开，有$(buc1(p)=(-up[p]+val[rt]+x)\times k^{-depth[p]}%y)=(buc2(q)=down[q]%y)$。 于是，找到所有通过$rt$的路径的$buc1,buc2$以及其对应起止点，排一下序，即可双指针线性找出每一个起止点对应的$in,out$值增量。我们发现这里重复统计了在相同子树里的不合法路径，故需要把这些东西容斥掉。 时间复杂度$O(\log n(n+n\log n))=O(n\log^2n)$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010int n,y,k,x;ll ans;struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int hd[N],cnt;void add(int a,int b)&#123;e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;int siz[N],mxt[N],vis[N];int sum,rt;int val[N],kpow[N]=&#123;1&#125;,inv[N]=&#123;1&#125;;void getrt(int p,int f)&#123; int i,q; siz[p]=1;mxt[p]=0; for(i=hd[p];i;i=e[i].n)&#123; q=e[i].e; if(q==f||vis[q])continue; getrt(q,p); siz[p]+=siz[q]; mxt[p]=max(mxt[p],siz[q]); &#125; mxt[p]=max(mxt[p],sum-mxt[p]); if(mxt[p]&lt;mxt[rt])rt=p;&#125;int in[2][N],out[2][N];pair&lt;int,int&gt;buc1[N],buc2[N];int tot;void getv(int p,int f,int dep,int up,int down)&#123; int i,q; up=((ll)up*k+val[p])%y; down=(down+(ll)val[p]*kpow[dep])%y; buc1[++tot]=make_pair((((ll)x-up+y)*inv[dep]+val[rt])%y,p); buc2[tot]=make_pair(down,p); for(i=hd[p];i;i=e[i].n)&#123; q=e[i].e; if(q==f||vis[q])continue; getv(q,p,dep+1,up,down); &#125;&#125;void calc(int p,int flag,int up,int down)&#123;//flag=1 -&gt; depth=1 &amp;&amp; (*-1)容斥 int i,q; tot=0; up=((ll)up*k+val[p])%y; down=((ll)val[p]*kpow[flag]+down)%y; buc1[++tot]=make_pair((((ll)x-up+y)*inv[flag]+val[rt])%y,p); buc2[tot]=make_pair(down,p); for(i=hd[p];i;i=e[i].n)&#123; q=e[i].e; if(!vis[q])getv(q,p,1+flag,up,down); &#125; sort(buc1+1,buc1+tot+1); sort(buc2+1,buc2+tot+1); buc1[tot+1]=make_pair(-1,-1); buc2[tot+1]=make_pair(-1,-1); int pa=1,pb=1,num=1; for(i=1;i&lt;=tot;i++)&#123; while(pb&lt;=tot&amp;&amp;buc1[i].first&gt;buc2[pb].first)pb++; if(buc1[i].first!=buc2[pb].first)continue; while(pb&lt;tot&amp;&amp;buc2[pb].first==buc2[pb+1].first)num++,pb++; out[1][buc1[i].second]+=(flag?-1:1)*num; if(i==tot||buc1[i].first!=buc1[i+1].first)num=1; &#125; for(i=1;i&lt;=tot;i++)&#123; while(pa&lt;=tot&amp;&amp;buc1[pa].first&lt;buc2[i].first)pa++; if(buc1[pa].first!=buc2[i].first)continue; while(pa&lt;tot&amp;&amp;buc1[pa].first==buc1[pa+1].first)num++,pa++; in[1][buc2[i].second]+=(flag?-1:1)*num; if(i==tot||buc2[i].first!=buc2[i+1].first)num=1; &#125;&#125;void solve(int p)&#123; vis[p]=1; int i,q; calc(p,0,0,0); for(i=hd[p];i;i=e[i].n)&#123; q=e[i].e; if(!vis[q])calc(q,1,val[rt],val[rt]); &#125; for(i=hd[p];i;i=e[i].n)&#123; q=e[i].e; if(vis[q])continue; sum=siz[q]; mxt[rt=0]=n+1; getrt(q,0); solve(rt); &#125;&#125;int qp(int a,int b)&#123; int ans=1; for(;b;b&gt;&gt;=1,a=(ll)a*a%y)if(b&amp;1)ans=(ll)ans*a%y; return ans;&#125;int main()&#123; int i,X,Y; int kinv=qp(k,y-2); scanf("%d%d%d%d",&amp;n,&amp;y,&amp;k,&amp;x); for(i=1;i&lt;N;i++)kpow[i]=(ll)kpow[i-1]*k%y,inv[i]=(ll)inv[i-1]*kinv%y; for(i=1;i&lt;=n;i++)scanf("%d",&amp;val[i]); for(i=1;i&lt;n;i++)scanf("%d%d",&amp;X,&amp;Y),add(Y,X),add(X,Y); sum=n;mxt[rt=0]=n+1; getrt(1,0); solve(rt); ans=(ll)n*n*n*2; for(i=1;i&lt;=n;i++)&#123; in[0][i]=n-in[1][i]; out[0][i]=n-out[1][i]; ans-=2LL*in[0][i]*in[1][i]+2LL*out[0][i]*out[1][i]+(ll)in[0][i]*out[1][i]+(ll)in[1][i]*out[0][i]; &#125; printf("%I64d\n",ans/2); return 0;&#125; B CF746G - New Roads 题目描述构造一棵$n$节点的树，使得除了根节点外，深度为$i$的点有$a_i$个，且恰好有$k$个叶子节点。 解题思路先把所有都看成连到主根上，然后对于每一个节点枚举应不应该把它扔到另一个节点上使得叶子数量减少即可。 AC代码点击 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 200005int n,k,mxnum[N]=&#123;1&#125;,f[N],now[N]=&#123;2&#125;;int main()&#123; int i,mx,j; scanf("%d%d%d",&amp;n,&amp;mx,&amp;k); for(i=1;i&lt;=mx;i++)scanf("%d",&amp;mxnum[i]),mxnum[i]+=mxnum[i-1],now[i]=mxnum[i-1]+2; if(n-mx&lt;k||mxnum[mx]-mxnum[mx-1]&gt;k)return printf("-1"),0; int left=n-mx-k; f[2]=1; for(i=1;i&lt;mx;i++)f[mxnum[i]+1]=mxnum[i-1]+1; for(i=1;i&lt;=mx;i++)&#123; for(j=mxnum[i-1]+2;j&lt;=mxnum[i];j++)&#123; if(left&amp;&amp;now[i-1]&lt;=mxnum[i-1])f[j]=now[i-1]++,left--; else f[j]=f[j-1]; &#125; &#125; if(left)return printf("-1"),0; printf("%d\n",n); for(i=2;i&lt;=n;i++)printf("%d %d\n",i,f[i]); return 0;&#125; C CF665F - Four Divisors 题目描述求出所有小于等于$n\leq 10^{11}$的、只有四个因数的正整数的个数。 解题思路令$S(n,p)$为埃氏筛完第$p$个素数后，前$n$项里没被筛掉的数之和，这些数或者是质数，或者是最小质因数大于$p$的整数。 则$S(n,p)=S(n,p-1)-\sum_{2\leq k\leq n}[k的最小质因数为prime[p]]$$=S(n,p-1)-\sum_{2\leq t\leq \lfloor \frac n{prime[p]}\rfloor}[t的最小质因数\geq prime[p]]$$=S(n,p-1)-(S(\lfloor \frac n{prime[p]}\rfloor ,min(p-1,\sqrt{\frac n{prime[p]}})-(p-1))$ 求出每一个数对应小于等于它的最大质数下标，小数据记忆化搜索，大数据暴力递归即可得出结果。 时间复杂度$O(不会算)=O(能过)$。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1000002int f[N][110];int prime[N],a[N]=&#123;1,1&#125;,cnt,mxp[N];void initprime()&#123; int i,j; for(i=2;i&lt;N;i++)&#123; if(!a[i])prime[++cnt]=i; for(j=1;j&lt;=cnt&amp;&amp;i*prime[j]&lt;N;j++)&#123; a[prime[j]*i]=1; if(prime[j]%i==0)break; &#125; &#125; for(i=1;i&lt;N;i++)mxp[i]=mxp[i-1]+!a[i];&#125;ll s(ll n,int p)&#123; if(n&lt;N&amp;&amp;p&lt;110&amp;&amp;f[n][p])return f[n][p]; ll ans; if(p&lt;=0)ans=n-1; else ans=s(n,mxp[prime[p]-1])-s(n/prime[p],min(p-1,mxp[(int)sqrt(n/prime[p])]))+p-1; if(n&lt;N&amp;&amp;p&lt;110)f[n][p]=ans; return ans;&#125;int main()&#123; int i;ll n,ans=0; initprime(); scanf("%I64d",&amp;n); for(i=2;(ll)i*i*i&lt;=n;i++)if(!a[i])ans++; for(i=1;i&lt;=cnt;i++)&#123; if(((ll)prime[i]*prime[i]&gt;=n))break; ans+=s(n/prime[i],mxp[(int)sqrt(n/prime[i])])-i; &#125; printf("%I64d",ans); return 0;&#125; D HDU3032 - Nim or not Nim? 题目描述可以分裂的$Nim$ 解题思路爆搜一边$SG$发现有规律，直接解决即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int f(int x)&#123; if(x%4==1||x%4==2)return x; if(x%4==3)return x+1; return x-1;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int ans=0,a,n,i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a),ans^=f(a); printf("%s\n",ans?"Alice":"Bob"); &#125;&#125;/*#define N 1000int sg[N],vis[N];int main()&#123; int i,j; sg[0]=0;sg[1]=1; for(i=2;i&lt;N;i++)&#123; memset(vis,0,sizeof(vis)); for(j=0;j&lt;i;j++)vis[sg[j]]=vis[sg[j]^sg[i-j]]=1; for(j=0;j&lt;N;j++)if(!vis[j])break; sg[i]=j; &#125; for(i=0;i&lt;N;i++)printf("%d ",sg[i]); return 0;&#125;*/ E ZJOI2014 - 诸神眷顾的幻想乡 题目描述一棵树的每个节点有一个颜色$c$，且这棵树的叶子结点不超过$20$个，求这棵树两点之间颜色构成的路径不同序列个数。 解题思路广义后缀自动机，对每一个叶子爆搜即可。对于每一个等价类$p$，其对应的不同子串个数为$maxlen(p)-minlen(p)+1$，其中$maxlen(p)$为$len_p$，$minlen(p)$为$len_{fa_p}+1$。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 4000010#define P 11struct Edge&#123;int e,n;&#125;e[N&lt;&lt;1];int hd[N],cnt,deg[N];void add(int a,int b)&#123;e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;struct ExtendedSAM&#123; int len[N],fa[N],tr[N][P]; int siz; void init()&#123; int i; siz=1;len[0]=-1; for(i=0;i&lt;P;i++)tr[0][i]=1; &#125; int insert(int s,int p)&#123; int np=++siz; len[np]=len[p]+1; while(!tr[p][s])tr[p][s]=np,p=fa[p]; int q=tr[p][s]; if(len[p]+1==len[q])fa[np]=q; else&#123; int nq=++siz; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(tr[nq],tr[q],sizeof(tr[q])); while(tr[p][s]==q)tr[p][s]=nq,p=fa[p]; &#125; return np; &#125;&#125;sam;int a[N],n,c;void dfs(int now,int f,int pos)&#123; int i,nxt=sam.insert(a[now],pos); for(i=hd[now];i;i=e[i].n)&#123; int q=e[i].e; if(q!=f)dfs(q,now,nxt); &#125;&#125;int main()&#123; int i,u,v; sam.init(); scanf("%d%d",&amp;n,&amp;c); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;n;i++) scanf("%d%d",&amp;u,&amp;v), add(u,v),add(v,u), deg[u]++,deg[v]++; for(i=1;i&lt;=n;i++)if(deg[i]==1)dfs(i,0,1); ll ans=0; for(i=2;i&lt;=sam.siz;i++)ans+=sam.len[i]-sam.len[sam.fa[i]]; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 9 题解]]></title>
    <url>%2F2019%2F06%2F01%2F2019springtraining-9%2F</url>
    <content type="text"><![CDATA[Solved A B C D E 5/5 O O Ø Ø O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A CF520B - Two Buttons 题目描述签到$1$ 解题思路一看数据范围直接爆搜，不过似乎也可以用反向推导直接得到。 AC代码点击 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1000020int vis[N],n,m;queue&lt;int&gt;Q;int main()&#123; int i; memset(vis,0x3f,sizeof(vis)); scanf("%d%d",&amp;n,&amp;m); Q.push(n);vis[n]=0; int flag=0; while(!Q.empty()&amp;&amp;!flag)&#123; int x=Q.front();Q.pop(); if(x*2&lt;N&amp;&amp;vis[x*2]&gt;1e9)Q.push(x*2),vis[x*2]=vis[x]+1; if(x-1&gt;0&amp;&amp;vis[x-1]&gt;1e9)Q.push(x-1),vis[x-1]=vis[x]+1; if(x==m)flag=1; &#125; printf("%d",vis[m]); return 0;&#125; B CF521A - DNA Alignment 题目描述签到$2$ 解题思路首先找到出现次数最多的字母，那么整个串都为这个字母是最优选择之一。 然后找到有多少个出现次数为最多次数的字母，假设有$cnt$个。出现次数相同代表在$T$串中任意取这些字母得到的串都是最优选择，于是每一个空位有$cnt$种选择，于是答案为$cnt^n$。 AC代码点击 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char s[100005];int a[10];ll qp(int a,int p)&#123; ll ans=1,w=1000000007; for(;p;p&gt;&gt;=1,a=1LL*a*a%w)if(p&amp;1)ans=ans*a%w; return ans;&#125;int main()&#123; int i,n; scanf("%d%s",&amp;n,s); for(i=0;s[i];i++)&#123; if(s[i]=='A')a[0]++; if(s[i]=='T')a[1]++; if(s[i]=='G')a[2]++; if(s[i]=='C')a[3]++; &#125; int ans=0,cnt=0; for(i=0;i&lt;4;i++)ans=max(ans,a[i]); for(i=0;i&lt;4;i++)if(ans==a[i])cnt++; printf("%lld",qp(cnt,n)); return 0;&#125; C CF521B - Cubes 题目描述在保证稳定的情况下交替拿取最大值和最小值。 解题思路一开始想用平衡树，后来才发现居然能用$set+map$（$C$党的悲哀.jpg） 注意每次找答案的时候自身也要判断就是了。（也就是说可能会从$set$中取出来） AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100005#define w 1000000009map&lt;pair&lt;int,int&gt;,int&gt;mp;set&lt;int&gt;s;int x[N],y[N];int exist(int x,int y)&#123;return mp.count(make_pair(x,y));&#125;int up(int x,int y)&#123;return exist(x-1,y-1)+exist(x,y-1)+exist(x+1,y-1)&lt;2;&#125;int jud(int p)&#123; if(exist(x[p]-1,y[p]+1))&amp;&amp;up(x[p]-1,y[p]+1))return 0; if(exist(x[p],y[p]+1))&amp;&amp;up(x[p],y[p]+1))return 0; if(exist(x[p]+1,y[p]+1))&amp;&amp;up(x[p]+1,y[p]+1))return 0; return 1;&#125;void ins(int p)&#123; int temp; if(exist(x[p]-1,y[p]-1)&amp;&amp;jud(temp=mp[make_pair(x[p]-1,y[p]-1)]))s.insert(temp); if(exist(x[p],y[p]-1)&amp;&amp;jud(temp=mp[make_pair(x[p],y[p]-1)]))s.insert(temp); if(exist(x[p]+1,y[p]-1))&amp;&amp;jud(temp=mp[make_pair(x[p]+1,y[p]-1)]))s.insert(temp);&#125;int main()&#123; int i,n; ll ans=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;x[i],&amp;y[i]); mp[make_pair(x[i],y[i])]=i; &#125; for(i=0;i&lt;n;i++)if(jud(i))s.insert(i); for(i=0;i&lt;n;i++)&#123; while(!s.empty())&#123; int now=(i&amp;1)?(*s.begin()):(*s.rbegin()); if(jud(now))&#123; ans=(ans*n+now)%w; s.erase(now); mp.erase(make_pair(x[now],y[now])); ins(now); break; &#125; s.erase(now); &#125; &#125; printf("%I64d",ans); return 0;&#125; D CF521C - Pluses everywhere 题目描述给一个大整数串$a_i$，求在里面加$k$个加号的所有计算结果之和。 解题思路推出式子预处理。 假设每一位对答案的贡献为$ans_i$，则答案为$\sum_{i=0}^{n-1}ans_i$。 考虑计算从头开始的第$i$位对答案的贡献。 这一位数字可以放在个位、十位、百位……一直到串的末端。考虑分两类讨论： 直接延伸到串的末端，贡献为$a_i\times 10^{n-1-i}\times C_i^k$（在前$i$个空里面选择$k$个加号） 不延伸到末端，设$i$到加号右端数字的长度为$len$，则贡献为$a_i\times 10^{len-1}\times C_{n-len-1}^{k-1}$（本来有$n-1$个空，这一段都不能放置加号，一段结束放置了一个加号，故还剩$n-1-(len-1)-1=n-len-1$个空，放置$k$个加号） 故$ans_i=\sum_{len=1}^{n-1-i}a_i\times 10^{len-1}\times C_{n-len-1}^{k-1}+a_i\times 10^{n-1-i}\times C_i^k$ 发现可以预处理出来这一个求和号，线性解决。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010int n,k;char a[N];ll p[N]=&#123;1&#125;,w=1000000007,fac[N]=&#123;1&#125;,inv[N]=&#123;1&#125;,s[N];ll qp(ll x,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,x=x*x%w)if(p&amp;1)ans=ans*x%w; return ans;&#125;ll c(int n,int m)&#123; if(m&lt;0||m&gt;n)return 0; return fac[n]*inv[m]%w*inv[n-m]%w;&#125;int main()&#123; int i; scanf("%d%d",&amp;n,&amp;k); scanf("%s",a); for(i=1;i&lt;=n;i++)&#123; p[i]=p[i-1]*10%w; fac[i]=fac[i-1]*i%w; inv[i]=qp(fac[i],w-2); &#125; for(i=1;i&lt;=n;i++)s[i]=(s[i-1]+c(n-i-1,k-1)*p[i-1])%w; ll ans=0; for(i=0;i&lt;n;i++)ans=(ans+(a[i]-'0')*(s[n-1-i]+p[n-i-1]*c(i,k)))%w; printf("%lld\n",ans); return 0;&#125; E CF521D - Shop 题目描述给一个数组$a_i$，有三种操作：$a_i$变成给定数，$a_i$加上给定数，$a_i$乘上给定数。所有有关量均为正整数。 按顺序至多采取其中$m$个操作， 问最终结果（$\prod_{i=1}^na_i$）最大时的操作顺序。 解题思路贪心。 显然可证，乘法放到最后是最优的，操作一对于每一个数只能最多进行一次（且变到最大），且放到最前面是最优的。 于是先处理操作一，对于每一个数存储一下最大的改变量，于是转化成了操作二。 现在仅处理操作二的先后顺序。设在某一个时刻，操作二$a_i$优于$a_j$，假设操作$i$对应的数组下标是$pos_i$，改变量为$delta_i$（加或乘），当前数组（不是初始数组！）为$x_i$，则需要满足 $\prod_{p=1}^k x_p\times \frac{x_{pos_i}+delta_i}{x_{pos_i}}&gt;\prod_{p=1}^k x_p\times \frac{x_{pos_j}+delta_j}{x_{pos_j}}$，即$\frac{delta_i}{x_{pos_i}}&gt;\frac{delta_j}{x_{pos_j}}$。 现在考虑操作二和操作三的处理顺序。假设某一个操作二$a_i$优于操作三$a_j$，有 $\prod_{p=1}^k x_p\times \frac{x_{pos_i}+delta_i}{x_{pos_i}}&gt;\prod_{p=1}^k x_p\times delta_j$，即$\frac{delta_i}{x_{pos_i}}&gt;delta_j-1$。 于是对于每一个操作，记录一下$x,d$。在这里，我们对于每一个操作二以及转化过来的操作一，$x$为$x_{pos_i}$，$d$为$delta_i$，对于每一个操作三，$x$为$1$，$d$为$delta_j-1$，便可以进行排序。 排完序得到的结果中，前$ans$个中，所有的操作一与操作三必然被执行，但操作二的$x$会被操作一改变（注意上面的黑字说明的，$x$是执行这一个操作的时候的当前数组），故需要对所有的操作二进行修改。再次排序，则后面的操作一和操作三可能会上来顶替某些操作二，而这些上来的操作一又对与之对应的操作二产生了影响。重复这个过程，很快就可以到达平衡，得到答案。 非常神秘，比赛的时候我$A$掉了这个题，但是$CF$上却没有这个记录，而且再拿这个代码提交的时候会$WA$掉第$149$个点。 $upd1$：想出来原因了，等着改改。 WA-test149代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define N 1000005struct Add&#123; int x,d,i; int sign,pos; bool operator&lt;(const Add&amp;p)const&#123;return 1LL*d*p.x&gt;1LL*p.d*x;&#125;&#125;a[N];int cnt,d[N],x[N],p[N];int main()&#123; int i,k,n,m; scanf("%d%d%d",&amp;k,&amp;n,&amp;m); for(i=1;i&lt;=k;i++)scanf("%d",&amp;x[i]); for(i=1;i&lt;=n;i++)&#123; int opt,pos,ch; scanf("%d%d%d",&amp;opt,&amp;pos,&amp;ch); if(opt==1)&#123;if(d[pos]&lt;ch-x[pos])d[pos]=ch-x[pos],p[pos]=i;&#125; else if(opt==2)a[cnt++]=(Add)&#123;x[pos],ch,i,2,pos&#125;; else a[cnt++]=(Add)&#123;1,ch-1,i,3,pos&#125;; &#125; for(i=1;i&lt;=k;i++)if(d[i])a[cnt++]=(Add)&#123;x[i],d[i],p[i],1,i&#125;; std::sort(a,a+cnt); int ans=std::min(cnt,m); printf("%d\n",ans); int flag=1; while(flag)&#123; flag=0; for(i=0;i&lt;ans;i++)if(a[i].sign==1) x[a[i].pos]+=a[i].d,a[i].sign=0,flag=1; for(i=0;i&lt;cnt;i++)if(a[i].sign==2&amp;&amp;a[i].x!=x[a[i].pos]) a[i].x=x[a[i].pos]; std::sort(a,a+cnt); &#125; for(i=0;i&lt;ans;i++)if(a[i].sign&lt;2)printf("%d ",a[i].i); for(i=0;i&lt;ans;i++)if(a[i].sign==2)printf("%d ",a[i].i); for(i=0;i&lt;ans;i++)if(a[i].sign==3)printf("%d ",a[i].i); return 0;&#125; $upd2$：错误原因在于没有考虑到操作二也可以影响操作顺序。我们很容易证明，对于某个位置，最优的一个一操作和所以二操作可以完全混合在一起进行排序。于是记录每一次进行后的$x$值进行排序即可。这样是不需要考虑爆$ll$的。 AC代码1-108ms点击 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100005struct Add&#123; ll x,d;int i; bool operator&lt;(const Add&amp;p)const&#123;return d*p.x&gt;p.d*x;&#125;&#125;a[N];int cnt,d[N],p[N],sig[N];ll x[N];vector&lt;pair&lt;int,int&gt;&gt;chain[N];int main()&#123; int i,k,n,m; scanf("%d%d%d",&amp;k,&amp;n,&amp;m); for(i=1;i&lt;=k;i++)scanf("%I64d",&amp;x[i]); for(i=1;i&lt;=n;i++)&#123; int opt,pos,ch; scanf("%d%d%d",&amp;opt,&amp;pos,&amp;ch);sig[i]=opt; if(opt==1)&#123;if(d[pos]&lt;ch-x[pos])d[pos]=ch-x[pos],p[pos]=i;&#125; else if(opt==2)chain[pos].push_back(make_pair(ch,i)); else a[cnt++]=(Add)&#123;1,ch-1,i&#125;; &#125; for(i=1;i&lt;=k;i++)&#123; if(d[i])chain[i].push_back(make_pair(d[i],p[i])); sort(chain[i].rbegin(),chain[i].rend()); for(auto e:chain[i])&#123; a[cnt++]=(Add)&#123;x[i],e.first,e.second&#125;; x[i]+=e.first; &#125; &#125; std::sort(a,a+cnt); int ans=std::min(cnt,m); printf("%d\n",ans); for(i=0;i&lt;ans;i++)if(sig[a[i].i]==1)printf("%d ",a[i].i); for(i=0;i&lt;ans;i++)if(sig[a[i].i]==2)printf("%d ",a[i].i); for(i=0;i&lt;ans;i++)if(sig[a[i].i]==3)printf("%d ",a[i].i); return 0;&#125; 然后其实也可以变成乘法去搞一搞。但是这样搞的话居然爆$ll$……必须转化成$double$才可以进行比较…… AC代码2-108ms点击 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;typedef long long ll;#define N 100005struct Add&#123; ll d,x; int i; bool operator&lt;(const Add&amp;p)const&#123;return 1.0*d*p.x&gt;1.0*p.d*x;&#125;&#125;a[N];int cnt,d[N],p[N],sig[N],x[N];std::vector&lt;std::pair&lt;int,int&gt;&gt;chain[N];int main()&#123; int i,k,n,m; scanf("%d%d%d",&amp;k,&amp;n,&amp;m); for(i=1;i&lt;=k;i++)scanf("%d",&amp;x[i]); for(i=1;i&lt;=n;i++)&#123; int opt,pos,ch; scanf("%d%d%d",&amp;opt,&amp;pos,&amp;ch); sig[i]=opt; if(opt==1)&#123;if(d[pos]&lt;ch-x[pos])d[pos]=ch-x[pos],p[pos]=i;&#125; else if(opt==2)chain[pos].push_back(std::make_pair(ch,i)); else a[cnt++]=(Add)&#123;ch,1,i&#125;; &#125; for(i=1;i&lt;=k;i++)&#123; if(d[i])chain[i].push_back(std::make_pair(d[i],p[i])); std::sort(chain[i].rbegin(),chain[i].rend()); ll pre=x[i],now; for(auto e:chain[i])&#123; now=pre+e.first; a[cnt++]=(Add)&#123;now,pre,e.second&#125;; pre=now; &#125; &#125; std::sort(a,a+cnt); int ans=std::min(cnt,m); printf("%d\n",ans); for(i=0;i&lt;ans;i++)if(sig[a[i].i]==1)printf("%d ",a[i].i); for(i=0;i&lt;ans;i++)if(sig[a[i].i]==2)printf("%d ",a[i].i); for(i=0;i&lt;ans;i++)if(sig[a[i].i]==3)printf("%d ",a[i].i); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 8 题解]]></title>
    <url>%2F2019%2F05%2F29%2F2019springtraining-8%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F 6/6 Ø Ø Ø Ø Ø Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A HDU 4609 - 3-idiots 题目描述给定一堆长度，任选三个问构成三角形的概率。 解题思路建桶，求自身卷积，得到的便是每一个长度由原数组组合出来的方案数。去除自身选择自身、两个相互选择后得到不重复的方案数。 对初始数组排序，从小到大取，每次取该边为最长边，即需要满足剩下两个边都在$i$之前出现且其和大于$a_i$。于是先求和再去重（两个都在$i$后面，一个在前一个在后，一个是$i$另一个任取）即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;typedef long long ll;struct complex&#123; double x,y; complex(double xx=0,double yy=0)&#123;x=xx;y=yy;&#125; complex operator+(const complex a)const&#123;return &#123;x+a.x,y+a.y&#125;;&#125; complex operator-(const complex a)const&#123;return &#123;x-a.x,y-a.y&#125;;&#125; complex operator*(const complex a)const&#123;return &#123;x*a.x-y*a.y,x*a.y+y*a.x&#125;;&#125;&#125;;#define N 463010complex a[N],wn1,wnk,t;int m,n,mx,limit;int r[N];void fft(complex *F,int sign)&#123; int i,j,len; for(i=0;i&lt;limit;i++) if(i&lt;r[i])std::swap(F[r[i]],F[i]); for(len=1;len&lt;limit;len&lt;&lt;=1)&#123; wn1=complex(cos(acos(-1)/len),sign*sin(acos(-1)/len)); for(j=0;j&lt;limit;j+=(len&lt;&lt;1))&#123; wnk=complex(1,0); for(i=j;i&lt;j+len;i++)&#123; t=F[i+len]*wnk; F[i+len]=F[i]-t; F[i]=F[i]+t; wnk=wnk*wn1; &#125; &#125; &#125; if(sign==-1)for(i=0;i&lt;limit;i++)F[i].x/=limit;&#125;ll b[N],s[N],p[N];int main()&#123; int i,n,T,x; scanf("%d",&amp;T); while(T--)&#123; int mx=0; scanf("%d",&amp;n); memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x),b[x]++; p[i]=x;if(x&gt;mx)mx=x; &#125; mx&lt;&lt;=1;limit=1; while(limit&lt;=mx)limit&lt;&lt;=1; for(i=0;i&lt;=limit;i++)a[i].x=b[i]; for(i=0;i&lt;=limit;i++)r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?limit&gt;&gt;1:0); fft(a,1); for(i=0;i&lt;=limit;i++)a[i]=a[i]*a[i]; fft(a,-1); for(i=0;i&lt;=limit;i++)s[i]=round(a[i].x); s[0]=0; for(i=0;i&lt;n;i++)s[p[i]&lt;&lt;1]--; for(i=0;i&lt;=limit;i++)s[i]&gt;&gt;=1; for(i=1;i&lt;=limit;i++)s[i]+=s[i-1]; ll ans=0; std::sort(p,p+n); for(i=0;i&lt;n;i++)&#123; ans+=s[limit]-s[p[i]]; ans-=1LL*i*(n-i-1); ans-=n-1; ans-=1LL*(n-i-1)*(n-i-2)/2; &#125; printf("%.7f\n",ans*1.0/(1LL*n*(n-1)*(n-2)/6)); &#125; return 0;&#125; B HDU 4914 - Linear recursive sequence 题目描述$f[i]=0,i\leq 0$ $f[i]=a\times f[i-p]+b\times f[i-q],i&gt;0$ 给定$n,a,b,p,q(1≤n≤10^9,0≤a,b≤10^9,1≤p&lt;q≤10^4)$，求$f[n]$。多组数据。 解题思路一开始以为是线性递推，学了一下午打了个板子上去$T$掉了。 原理就是$k$阶矩阵$M$的任意幂次都能用$M$小于$k$次的幂次来线性表示，故可以通过特征多项式构造这个系数数列，利用快速幂+$FFT$解决。 TLE代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define M 65536struct comp&#123; double x,y; comp():x(0),y(0)&#123;&#125; comp(const double &amp;_x,const double &amp;_y):x(_x),y(_y)&#123;&#125;&#125;;comp operator+(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x+b.x,a.y+b.y);&#125;comp operator-(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x-b.x,a.y-b.y);&#125;comp operator*(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;comp conj(const comp &amp;a)&#123;return comp(a.x,-a.y);&#125;double PI=acos(-1);comp w[M+5];int rev[M+5];int lim,mx,mod;void fft(comp *a,int n)&#123; int i,j,k,lyc; for(i=0;i&lt;n;i++)if(i&lt;rev[i]) swap(a[i],a[rev[i]]); for(i=2,lyc=n&gt;&gt;1;i&lt;=n;i&lt;&lt;=1,lyc&gt;&gt;=1) for(j=0;j&lt;n;j+=i)&#123; comp *l=a+j,*r=a+j+(i&gt;&gt;1),*p=w; for(k=0;k&lt;(i&gt;&gt;1);k++)&#123; comp tmp=*r**p; *r=*l-tmp,*l=*l+tmp; ++l,++r,p+=lyc; &#125; &#125;&#125;void fft_prepare()&#123; int i; for(i=0;i&lt;lim;i++)rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(mx-1)); for(i=0;i&lt;lim;i++)w[i]=comp(cos(2*PI*i/lim),sin(2*PI*i/lim));&#125;void conv(int *x,int *y,int *z,int n,int m,int mod)&#123; int i,j; static comp ta[M+5],tb[M+5],a[M+5],b[M+5]; static int X[M+5],Y[M+5]; for(i=0;i&lt;n;i++)X[i]=(x[i]+mod)%mod; for(;i&lt;lim;i++)X[i]=0; for(i=0;i&lt;m;i++)Y[i]=(y[i]+mod)%mod; for(;i&lt;lim;i++)Y[i]=0; for(i=0;i&lt;lim;i++)&#123; ta[i]=comp(X[i]&amp;32767,X[i]&gt;&gt;15); tb[i]=comp(Y[i]&amp;32767,Y[i]&gt;&gt;15); &#125; fft(ta,lim);fft(tb,lim); for(i=0;i&lt;lim;i++)&#123; j=(lim-i)%lim;//0的特判 comp da,db,dc,dd; da=(ta[i]+conj(ta[j]))*comp(0.5,0); db=(ta[i]-conj(ta[j]))*comp(0,-0.5); dc=(tb[i]+conj(tb[j]))*comp(0.5,0); dd=(tb[i]-conj(tb[j]))*comp(0,-0.5); a[j]=da*dc+da*dd*comp(0,1); b[j]=db*dc+db*dd*comp(0,1); &#125; fft(a,lim);fft(b,lim); for(i=0;i&lt;lim;i++)&#123; ll da,db,dc,dd; da=(ll)(a[i].x/lim+0.5)%mod; db=(ll)(a[i].y/lim+0.5)%mod; dc=(ll)(b[i].x/lim+0.5)%mod; dd=(ll)(b[i].y/lim+0.5)%mod; z[i]=(((da+((db+dc)&lt;&lt;15)+(dd&lt;&lt;30))%mod)+mod)%mod; &#125;&#125;int qpow(ll x,int p)&#123; int ans=1; for(;p;p&gt;&gt;=1,x=x*x%mod)if(p&amp;1)ans=ans*x%mod; return ans;&#125;void polyinv(int *A,int *ans,int n)&#123; static int B[2][M+5]; int bas,cur,i; memset(B,0,sizeof(B)); B[0][0]=qpow(A[0],mod-2); for(mx=2,bas=1,lim=4,cur=1;bas&lt;n*2;mx++,lim&lt;&lt;=1,cur^=1,bas&lt;&lt;=1)&#123; fft_prepare(); memset(B[cur],0,sizeof(B[cur])); for(i=0;i&lt;bas;i++)B[cur][i]=(ll)B[cur^1][i]*2%mod; conv(B[cur^1],B[cur^1],B[cur^1],bas,bas,mod); conv(B[cur^1],A,B[cur^1],bas,bas,mod); for(i=0;i&lt;bas;i++)B[cur][i]=((ll)B[cur][i]-B[cur^1][i]+mod)%mod; &#125; for(i=0;i&lt;n;i++)ans[i]=(B[cur^1][i]+mod)%mod;&#125;int flag;void polydiv(int *a,int *b,int *H,int *R,int n,int m)&#123; int i; static int rF[M+5],rG[M+5],t1[M+5]; memset(t1,0,sizeof(int)*n); for(i=0;i&lt;=n;i++)rF[n-i]=a[i]; if(!flag)&#123; flag=1; for(i=0;i&lt;=m;i++)rG[m-i]=b[i]; polyinv(rG,rG,n-m+1); &#125; mx=0,lim=1;while(lim&lt;n&lt;&lt;1)lim&lt;&lt;=1,mx++; fft_prepare(); conv(rF,rG,H,n,n,mod); reverse(H,H+n-m+1); for(i=n-m+1;i&lt;=n;i++)H[i]=0; mx=0,lim=1;while(lim&lt;n+m)lim&lt;&lt;=1,mx++; fft_prepare(); conv(b,H,t1,m,n,mod); for(i=0;i&lt;m;i++)R[i]=((ll)a[i]-t1[i]+mod)%mod; for(;i&lt;=n;i++)R[i]=0;&#125;int a[M+5],g[M+5];int D[M+5];int res[M+5],bas[M+5],n,k;void mtmul(int *a,int *b)&#123; mx=0,lim=1; while(lim&lt;k*2)lim&lt;&lt;=1,mx++; fft_prepare(); conv(a,b,a,k,k,mod); polydiv(a,g,D,a,k*2-2,k);&#125;void qpow(int x)&#123; res[0]=bas[1]=1; for(;x;x&gt;&gt;=1,mtmul(bas,bas)) if(x&amp;1)mtmul(res,bas);&#125;int main()&#123; int i,aa,bb,p,q; mod=119; while(~scanf("%d%d%d%d%d",&amp;n,&amp;aa,&amp;bb,&amp;p,&amp;q))&#123; memset(res,0,sizeof(res)); memset(bas,0,sizeof(bas)); memset(g,0,sizeof(g)); memset(a,0,sizeof(a)); flag=0; k=q+1;n+=q; g[k]=118; g[k-p]=aa%mod;g[k-q]=bb%mod; for(i=0;i&lt;k;i++)a[i]=1; qpow(n); ll ans=0; for(i=0;i&lt;k;i++)(ans+=(ll)a[i]*res[i])%=mod; printf("%lld\n",ans); &#125; return 0;&#125; 过后，不久，就发现没理解透这个板子，其实这个矩阵第一行就两个数…… 然后就可以暴力了 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define M 65536struct comp&#123; double x,y; comp():x(0),y(0)&#123;&#125; comp(const double &amp;_x,const double &amp;_y):x(_x),y(_y)&#123;&#125;&#125;;comp operator+(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x+b.x,a.y+b.y);&#125;comp operator-(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x-b.x,a.y-b.y);&#125;comp operator*(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;int rev[M+5];int lim,mx,mod;void fft(comp *F,int sign)&#123; int i,j,len; for(i=0;i&lt;lim;i++)if(i&lt;rev[i])swap(F[rev[i]],F[i]); for(len=1;len&lt;lim;len&lt;&lt;=1)&#123; comp wn1=comp(cos(acos(-1)/len),sign*sin(acos(-1)/len)); for(j=0;j&lt;lim;j+=(len&lt;&lt;1))&#123; comp wnk=comp(1,0); for(i=j;i&lt;j+len;i++)&#123; comp t=F[i+len]*wnk; F[i+len]=F[i]-t; F[i]=F[i]+t; wnk=wnk*wn1; &#125; &#125; &#125; if(sign==-1)for(i=0;i&lt;lim;i++)F[i].x/=lim;&#125;void fft_prepare()&#123; int i; for(i=0;i&lt;lim;i++)rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(mx-1));&#125;int a[M+5],g[M+5];int res[M+5],bas[M+5],n,k,p,q,aa,bb;void mtmul(int *a,int *b)&#123; int i; static comp a1[M+5],a2[M+5]; memset(a1,0,sizeof(a1)); memset(a2,0,sizeof(a2)); for(i=0;i&lt;q;i++)a1[i].x=a[i],a2[i].x=b[i]; fft(a1,1);fft(a2,1); for(i=0;i&lt;lim;i++)a1[i]=a1[i]*a2[i]; fft(a1,-1); for(i=0;i&lt;lim;i++)a[i]=(int)((ll)(a1[i].x+0.5)%mod); for(i=2*q-2;i&gt;=q;i--)if(a[i])&#123; (a[i-q]+=a[i]*bb)%=mod; (a[i-p]+=a[i]*aa)%=mod; &#125;&#125;void qpow(int x)&#123; res[0]=bas[1]=1; for(;x;x&gt;&gt;=1,mtmul(bas,bas)) if(x&amp;1)mtmul(res,bas);&#125;int main()&#123; int i; mod=119; while(~scanf("%d%d%d%d%d",&amp;n,&amp;aa,&amp;bb,&amp;p,&amp;q))&#123;aa%=mod,bb%=mod; memset(res,0,sizeof(res)); memset(bas,0,sizeof(bas)); a[0]=1; for(i=1;i&lt;q;i++)a[i]=(i-p&gt;=0?(a[i-p]*aa+bb):aa+bb)%mod; if(n&lt;q)&#123; printf("%d\n",a[n]); continue; &#125; lim=1;mx=0;while(lim&lt;=(q-1)&lt;&lt;1)lim&lt;&lt;=1,mx++; fft_prepare(); qpow(n); int ans=0; for(i=0;i&lt;q;i++)ans=(ans+res[i]*a[i])%mod; printf("%d\n",ans); &#125; return 0;&#125; C HDU 5322 - Hope 题目描述定义一个排列$a_n$的价值如下：$a_i$向右边第一个大于它的数连边，所有连通分量的大小相乘后平方。定义 $f(n)$为$n$的全排列的价值之和，多次询问求 $f(n)$。 解题思路先根据当前最大值的位置推出来$DP$式子：$dp[n]=\sum_{i=1}^ndp[n-i]i^2\frac{(n-1)!}{(n-i)!}=(n-1)!\sum_{i=0}^{n-1}i^2\frac{dp[i]}{i!}$。 然后就可以快乐分治$FFT$求解了。对于每一个区间$[l,r]$，先计算出左半边，后计算出左半边对于右半边$dp$的贡献（可用卷积表示），再分治解决右半边即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define M 524290struct comp&#123; double x,y; comp():x(0),y(0)&#123;&#125; comp(const double &amp;_x,const double &amp;_y):x(_x),y(_y)&#123;&#125;&#125;;comp operator+(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x+b.x,a.y+b.y);&#125;comp operator-(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x-b.x,a.y-b.y);&#125;comp operator*(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;comp conj(const comp &amp;a)&#123;return comp(a.x,-a.y);&#125;double PI=acos(-1);comp w[M+5];int rev[M+5];int lim,mx,mod;void fft(comp *a,int n)&#123; int i,j,k,lyc; for(i=0;i&lt;n;i++)if(i&lt;rev[i])swap(a[i],a[rev[i]]); for(i=2,lyc=n&gt;&gt;1;i&lt;=n;i&lt;&lt;=1,lyc&gt;&gt;=1) for(j=0;j&lt;n;j+=i)&#123; comp *l=a+j,*r=a+j+(i&gt;&gt;1),*p=w; for(k=0;k&lt;(i&gt;&gt;1);k++)&#123; comp tmp=*r**p; *r=*l-tmp,*l=*l+tmp; ++l,++r,p+=lyc; &#125; &#125;&#125;void fft_prepare()&#123; int i; for(i=0;i&lt;lim;i++)rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(mx-1)); for(i=0;i&lt;lim;i++)w[i]=comp(cos(2*PI*i/lim),sin(2*PI*i/lim));&#125;void conv(int *x,int *y,int *z,int n,int m,int mod)&#123; int i,j; mx=0;lim=1;while(lim&lt;n+m+1)lim&lt;&lt;=1,mx++; fft_prepare(); static comp ta[M+5],tb[M+5],a[M+5],b[M+5]; static int X[M+5],Y[M+5]; for(i=0;i&lt;n;i++)X[i]=(x[i]+mod)%mod; for(;i&lt;lim;i++)X[i]=0; for(i=0;i&lt;m;i++)Y[i]=(y[i]+mod)%mod; for(;i&lt;lim;i++)Y[i]=0; for(i=0;i&lt;lim;i++)&#123; ta[i]=comp(X[i]&amp;32767,X[i]&gt;&gt;15); tb[i]=comp(Y[i]&amp;32767,Y[i]&gt;&gt;15); &#125; fft(ta,lim);fft(tb,lim); for(i=0;i&lt;lim;i++)&#123; j=(lim-i)%lim; comp da,db,dc,dd; da=(ta[i]+conj(ta[j]))*comp(0.5,0); db=(ta[i]-conj(ta[j]))*comp(0,-0.5); dc=(tb[i]+conj(tb[j]))*comp(0.5,0); dd=(tb[i]-conj(tb[j]))*comp(0,-0.5); a[j]=da*dc+da*dd*comp(0,1); b[j]=db*dc+db*dd*comp(0,1); &#125; fft(a,lim);fft(b,lim); for(i=0;i&lt;lim;i++)&#123; ll da,db,dc,dd; da=(ll)(a[i].x/lim+0.5)%mod; db=(ll)(a[i].y/lim+0.5)%mod; dc=(ll)(b[i].x/lim+0.5)%mod; dd=(ll)(b[i].y/lim+0.5)%mod; z[i]=(((da+((db+dc)&lt;&lt;15)+(dd&lt;&lt;30))%mod)+mod)%mod; &#125;&#125;int dp[M+5]=&#123;1&#125;,fac[M+5]=&#123;1&#125;,inv[M+5]=&#123;1&#125;;ll qp(ll a,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,a=a*a%mod)if(p&amp;1)ans=ans*a%mod; return ans;&#125;int a[M+5],b[M+5];void solve(int l,int r)&#123; if(l==r)return; int i,mid=(l+r)&gt;&gt;1; solve(l,mid); for(i=0;i&lt;=mid-l;i++)a[i]=(ll)dp[i+l]*inv[i+l]%mod; conv(a,b,a,mid-l+1,r-l+1,mod); for(i=mid+1;i&lt;=r;i++)dp[i]=(dp[i]+(ll)a[i-l]*fac[i-1])%mod; solve(mid+1,r);&#125;int main()&#123; int i,n; mod=998244353; for(i=1;i&lt;M;i++) fac[i]=(ll)fac[i-1]*i%mod,inv[i]=qp(fac[i],mod-2), b[i]=(ll)i*i%mod; solve(0,100000); while(~scanf("%d",&amp;n))printf("%d\n",dp[n]); return 0;&#125; D HDU 4656 - Evaluation 题目描述$x_k=b\times c^{2k}+d $$F(x)=a_0x_0+a_1x_1+a_2 x_2+…+a_{n-1 }x_{n-1} $ 给定$n,a_i,b,c,d$，求序列$F(x_i)$。 解题思路神仙题$orzzzzzzz$ $FFT$——从入门到放弃.jpg 整整连学带调写了一天半，终于过了 我们先来化一下式子： $F(x_k)=\sum_{i=0}^{n-1}a_ix_k^i$ $=\sum_{i=0}^{n-1}a_i\sum_{j=0}^{i}b^jc^{2kj}d^{i-j}C_j^i$ $=\sum_{j=0}^{n-1}\frac{b^jc^{2kj}}{j!}\sum_{i=j}^{n-1}a_ii!\frac{d^{i-j}}{(i-j)!}$ 设$A(i)=a_ii!,B(i)=\frac{d^i}{i!},p(j)=\sum_{i=j}^{n-1}A(i)B(i-j)$ 显然可将$A$翻转：$A’(i)=A(n-i)$ 则$p(n-j)=\sum_{i=1}^{n-j}A’(i)B(n-i-j)$，设$p’(i)=p(n-i)$，则$p’(j)=\sum_{i=1}^{j}B(j-i)$，可以用卷积求出。 $F(x_k)=\sum_{j=0}^{n-1}\frac{b^jc^{2kj}}{j!}p(j)$ $=\sum_{j=0}^{n-1}\frac{b^jc^{k^2+j^2-(k-j)^2}}{j!}p(j)$ $=c^{k^2}\sum_{j=0}^{n-1}\frac{q(j)}{c^{(k-j)^2}}$，其中$q(j)=p(j)\frac{b^jc^{j^2}}{j!}$。 于是设$g(i)=\frac1{i^2}$，$\frac{F(x_k)}{c^{k^2}}=\sum_{j=0}^{n-1}q(j)g(k-j)$，为了避免负数情况，将$g(i)$移动$n$（参考$ZJOI2014$力），即$g’(i)=g(i-n)$，最后$[n,2n-1]$区间即为所求卷积。 其中需要对给定质数求模，故用拆系数$FFT$进行运算，再用共轭优化$DFT$次数… 详情参考毛啸2016集训队论文《再探快速傅里叶变换》。 来说几个坑点吧：拆系数的时候注意正负号，注意零的特判，$c$的$i^2$次幂求的时候用$qp(c,i^2%(mod-1))$，以及这题卡空间…… MLE代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 524290#define M Nstruct comp&#123; double x,y; comp():x(0),y(0)&#123;&#125; comp(const double &amp;_x,const double &amp;_y):x(_x),y(_y)&#123;&#125;&#125;;comp operator+(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x+b.x,a.y+b.y);&#125;comp operator-(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x-b.x,a.y-b.y);&#125;comp operator*(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;comp conj(const comp &amp;a)&#123;return comp(a.x,-a.y);&#125;double PI=acos(-1);comp w[M];int rev[M];int A[M],B[M],C[M],lim,mx,mod=1000003;void fft(comp *a,int n)&#123; int i,j,k,lyc; for(i=0;i&lt;n;i++)if(i&lt;rev[i])swap(a[i],a[rev[i]]); for(i=2,lyc=n&gt;&gt;1;i&lt;=n;i&lt;&lt;=1,lyc&gt;&gt;=1) for(j=0;j&lt;n;j+=i)&#123; comp *l=a+j,*r=a+j+(i&gt;&gt;1),*p=w; for(k=0;k&lt;(i&gt;&gt;1);k++)&#123; comp tmp=*r**p; *r=*l-tmp,*l=*l+tmp; ++l,++r,p+=lyc; &#125; &#125;&#125;void fft_prepare()&#123; int i; for(i=0;i&lt;lim;i++)rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(mx-1)); for(i=0;i&lt;lim;i++)w[i]=comp(cos(2*PI*i/lim),sin(2*PI*i/lim));&#125;comp a[M+5],b[M+5],dfta[M+5],dftb[M+5],dftc[M+5],dftd[M+5];void conv(int *x,int *y,int *z)&#123; int i,j; for(i=0;i&lt;lim;i++)(x[i]+=mod)%=mod,(y[i]+=mod)%=mod; for(i=0;i&lt;lim;i++)&#123; a[i]=comp(x[i]&amp;32767,x[i]&gt;&gt;15); b[i]=comp(y[i]&amp;32767,y[i]&gt;&gt;15); &#125; fft(a,lim);fft(b,lim); for(i=0;i&lt;lim;i++)&#123; j=(lim-i)%lim;//0的特判 comp da,db,dc,dd; da=(a[i]+conj(a[j]))*comp(0.5,0); db=(a[i]-conj(a[j]))*comp(0,-0.5); dc=(b[i]+conj(b[j]))*comp(0.5,0); dd=(b[i]-conj(b[j]))*comp(0,-0.5); dfta[j]=da*dc; dftb[j]=da*dd; dftc[j]=db*dc; dftd[j]=db*dd; &#125; for(i=0;i&lt;lim;i++)&#123; a[i]=dfta[i]+dftb[i]*comp(0,1); b[i]=dftc[i]+dftd[i]*comp(0,1); &#125; fft(a,lim);fft(b,lim); for(i=0;i&lt;lim;i++)&#123; ll da,db,dc,dd; da=(ll)(a[i].x/lim+0.5)%mod; db=(ll)(a[i].y/lim+0.5)%mod; dc=(ll)(b[i].x/lim+0.5)%mod; dd=(ll)(b[i].y/lim+0.5)%mod; z[i]=(da+((db+dc)&lt;&lt;15)+(dd&lt;&lt;30))%mod; &#125;&#125;int arr[N],fac[N]=&#123;1&#125;,inv[N]=&#123;1&#125;,bpow[N]=&#123;1&#125;,dpow[N]=&#123;1&#125;;int qp(int x,int p)&#123; int ans=1; for(;p;p&gt;&gt;=1,x=(ll)x*x%mod)if(p&amp;1)ans=(ll)ans*x%mod; return ans;&#125;int Ai[N],Bi[N],P[N],p[N],ans[N],m[N],cpow[N]=&#123;1&#125;;int main()&#123; int i,n,b,c,d; scanf("%d%d%d%d",&amp;n,&amp;b,&amp;c,&amp;d); while((1&lt;&lt;mx)&lt;4*n)mx++; lim=1&lt;&lt;mx; fft_prepare(); for(i=1;i&lt;n;i++)fac[i]=(ll)fac[i-1]*i%mod,inv[i]=qp(fac[i],mod-2); for(i=1;i&lt;n;i++)dpow[i]=(ll)dpow[i-1]*d%mod,bpow[i]=(ll)bpow[i-1]*b%mod,cpow[i]=qp(c,(ll)i*i%(mod-1)); for(i=0;i&lt;n;i++)scanf("%d",&amp;arr[i]); for(i=0;i&lt;=n;i++)Ai[i]=(ll)arr[n-i]*fac[n-i]%mod,Bi[i]=(ll)dpow[i]*inv[i]%mod; conv(Ai,Bi,P); for(i=0;i&lt;n;i++)p[i]=(ll)P[n-i]*bpow[i]%mod*inv[i]%mod*cpow[i]%mod; for(i=0;i&lt;n+n;i++)m[i]=qp(i-n&gt;=0?cpow[i-n]:cpow[n-i],mod-2); conv(m,p,ans); for(i=0;i&lt;n;i++)&#123; ans[i+n]=(ll)ans[i+n]*cpow[i]%mod; printf("%d\n",(ans[i+n]+mod)%mod); &#125; return 0;&#125; 疯狂删减数组，勉强卡过$65536kb$内存限制。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 524290#define M Nstruct comp&#123; double x,y; comp():x(0),y(0)&#123;&#125; comp(const double &amp;_x,const double &amp;_y):x(_x),y(_y)&#123;&#125;&#125;;comp operator+(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x+b.x,a.y+b.y);&#125;comp operator-(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x-b.x,a.y-b.y);&#125;comp operator*(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;comp conj(const comp &amp;a)&#123;return comp(a.x,-a.y);&#125;double PI=acos(-1);comp w[M];int rev[M];int lim,mx,mod=1000003;void fft(comp *a,int n)&#123; int i,j,k,lyc; for(i=0;i&lt;n;i++)if(i&lt;rev[i])swap(a[i],a[rev[i]]); for(i=2,lyc=n&gt;&gt;1;i&lt;=n;i&lt;&lt;=1,lyc&gt;&gt;=1) for(j=0;j&lt;n;j+=i)&#123; comp *l=a+j,*r=a+j+(i&gt;&gt;1),*p=w; for(k=0;k&lt;(i&gt;&gt;1);k++)&#123; comp tmp=*r**p; *r=*l-tmp,*l=*l+tmp; ++l,++r,p+=lyc; &#125; &#125;&#125;void fft_prepare()&#123; int i; for(i=0;i&lt;lim;i++)rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(mx-1)); for(i=0;i&lt;lim;i++)w[i]=comp(cos(2*PI*i/lim),sin(2*PI*i/lim));&#125;comp a[M],b[M],ta[M],tb[M];void conv(int *x,int *y,int *z)&#123; int i,j; for(i=0;i&lt;lim;i++)(x[i]+=mod)%=mod,(y[i]+=mod)%=mod; for(i=0;i&lt;lim;i++)&#123; ta[i]=comp(x[i]&amp;32767,x[i]&gt;&gt;15); tb[i]=comp(y[i]&amp;32767,y[i]&gt;&gt;15); &#125; fft(ta,lim);fft(tb,lim); for(i=0;i&lt;lim;i++)&#123; j=(lim-i)%lim;//0的特判 comp da,db,dc,dd; da=(ta[i]+conj(ta[j]))*comp(0.5,0); db=(ta[i]-conj(ta[j]))*comp(0,-0.5); dc=(tb[i]+conj(tb[j]))*comp(0.5,0); dd=(tb[i]-conj(tb[j]))*comp(0,-0.5); a[j]=da*dc+da*dd*comp(0,1); b[j]=db*dc+db*dd*comp(0,1); &#125; fft(a,lim);fft(b,lim); for(i=0;i&lt;lim;i++)&#123; ll da,db,dc,dd; da=(ll)(a[i].x/lim+0.5)%mod; db=(ll)(a[i].y/lim+0.5)%mod; dc=(ll)(b[i].x/lim+0.5)%mod; dd=(ll)(b[i].y/lim+0.5)%mod; z[i]=(da+((db+dc)&lt;&lt;15)+(dd&lt;&lt;30))%mod; &#125;&#125;int arr[N],fac[N]=&#123;1&#125;,inv[N]=&#123;1&#125;;int qp(int x,int p)&#123; int ans=1; for(;p;p&gt;&gt;=1,x=(ll)x*x%mod)if(p&amp;1)ans=(ll)ans*x%mod; return ans;&#125;int Ai[N],Bi[N],P[N],cpow[N]=&#123;1&#125;;int main()&#123; int i,n,b,c,d; scanf("%d%d%d%d",&amp;n,&amp;b,&amp;c,&amp;d); while((1&lt;&lt;mx)&lt;4*n)mx++; lim=1&lt;&lt;mx; fft_prepare(); for(i=1;i&lt;n;i++)fac[i]=(ll)fac[i-1]*i%mod,inv[i]=qp(fac[i],mod-2); for(i=1;i&lt;n;i++)cpow[i]=qp(c,(ll)i*i%(mod-1)); for(i=0;i&lt;n;i++)scanf("%d",&amp;arr[i]); for(i=0;i&lt;=n;i++)Ai[i]=(ll)arr[n-i]*fac[n-i]%mod,Bi[i]=(ll)qp(d,i)*inv[i]%mod; conv(Ai,Bi,P); Ai[n]=0; for(i=0;i&lt;n;i++)Ai[i]=(ll)P[n-i]*qp(b,i)%mod*inv[i]%mod*cpow[i]%mod; for(i=0;i&lt;n+n;i++)Bi[i]=qp(i-n&gt;=0?cpow[i-n]:cpow[n-i],mod-2); conv(Ai,Bi,P); for(i=0;i&lt;n;i++)&#123; P[i+n]=(ll)P[i+n]*cpow[i]%mod; printf("%d\n",(P[i+n]+mod)%mod); &#125; return 0;&#125; E CF662C - Binary Table 题目描述给定一个$n\times m(1\leq m\leq 20,1\leq n\leq 100000)$的$01$矩阵，每次可以反转任意一列一行，求最终$1$的最少个数。 解题思路看到$m$范围极小，考虑枚举每一行的翻转状态$S$。 由于每一行反转后，后面的所有行答案便已经确定，考虑求出$ans[S]$。 那么可以设$a[i]$为$i$这个状态出现的次数，$b[i]$为$i$这个状态中对应的$1$的个数和$0$的个数中的较小值，则$ans[s]=\sum_{j\oplus k=s}a[j]\times b[k]$，用$FWT$板子即可求出。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define N (1&lt;&lt;20)+10typedef long long ll;ll a[N],b[N],c[N];void fwtxor(int f,int l,ll a[])&#123; int i,j,k;ll t; if(f==-1)f=2; for(i=1;i*2&lt;=l;i&lt;&lt;=1) for(j=0;j&lt;l;j+=i*2) for(k=0;k&lt;i;k++) t=a[j+k], a[j+k]=(t+a[j+k+i])/f, a[j+k+i]=(t-a[j+k+i])/f;&#125;char ch[22][100010];int main()&#123; int i,j,n,m; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)scanf("%s",ch[i]); for(j=0;j&lt;m;j++)&#123; int now=0; for(i=0;i&lt;n;i++)now=(now&lt;&lt;1)+ch[i][j]-'0'; a[now]++; &#125; for(i=1;i&lt;1&lt;&lt;n;i++)b[i]=b[i/2]+(i&amp;1); for(i=0;i&lt;1&lt;&lt;n;i++)b[i]=std::min(b[i],n-b[i]); ll ans=n*m; n=1&lt;&lt;n; fwtxor(1,n,a);fwtxor(1,n,b); for(i=0;i&lt;n;i++)c[i]=a[i]*b[i]; fwtxor(-1,n,c); for(i=0;i&lt;n;i++)ans=std::min(ans,c[i]); printf("%I64d",ans); return 0;&#125; F CF914G - Sum the Fibonacci 题目描述给定一个集合$S$，求出使得$(s_a|s_b)&amp;(s_c)&amp;(s_d\oplus s_e)==2^p,s_a&amp;s_b==0$的$fib(s_a|s_b)\times fib(s_c)\times fib(s_d\oplus s_e)$的和，其中$s_a,s_b,s_c,s_d,s_e$均为$S$的子集。$s_i&lt;2^{17}$。 解题思路非常有意思的$FMT+FWT$练习题。先求出每个数出现的次数$s_i$，求出$s_a,s_b$的子集卷积，$s_d,s_e$的对称差（异或）卷积，分别乘上$fib$再进行（或）变换，乘起来再做逆运算即可。 既然是写博，就要自己在复习一遍，故下面是对$FMT$和子集卷积的理解。 首先是$FMT$。 定义$H_S=\sum_{L\subseteq S}\sum_{R\subseteq S}f_L\times g_R(L\bigcup R\subseteq S)$（①），我们要求出这个卷积$H$。定义莫比乌斯变换为$f_S^{‘}=\sum_{T\subseteq S}f_T$。对于①式，左右两端取莫比乌斯变换：$H_S^{‘}=\sum_{L\subseteq S}\sum_{R\subseteq S}f_L\times g_R$故可以进行变换，卷积运算。变换过程：设 $f_S^{‘}(i)=\sum_{T\subseteq S}f_T((S-T)\subseteq(1,2,…,i))$那么，对于任意不包含${i}$的集合$S$，有$f_S^{‘}(i)=f_S^{‘}(i-1)$，$f_{S\bigcup {i}}^{‘}(i)=f_{S\bigcup {i}}^{‘}(i-1)+f_S^{‘}(i-1)$，这样就可以$O(n\times 2^n)$解决了。反演同理。 对于子集卷积： 定义$H_S=\sum_{L\subseteq S}f_L\times g_{S-L}$，我们现在要求出这个卷积$H$。因为需要满足交集为空，所以增设一维表示集合大小。设$f_{i,S}$为集合中有$i$个元素、集合表示为$S$的值，那么求卷积的时候$h_{i,S}=\sum_{j=0}^i f_{j,S}\times g_{i-j,S}$（从$f$中选出$j$个元素，从$g$中选出$i-j$个元素，只有他们互不相交的情况下才能够保证$h_{i,S}$合理）。（非常玄学，怎么想出来的）那么最后的结果就是$h_{cnt_i,i}$这个数组了。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 18#define M (1&lt;&lt;17)#define P M+10ll a[P],b[P],w=1000000007,subset[P],fib[P]=&#123;0,1&#125;;ll Xor[P];ll div(int x,ll p)&#123; if(x==1)return p; if(p&amp;1)return (p+w)/2%w; else return p/2;&#125;void fwtand(ll a[],int l,int f)&#123; int i,j,k; for(i=1;i*2&lt;=l;i&lt;&lt;=1) for(j=0;j&lt;l;j+=i*2) for(k=0;k&lt;i;k++) (a[j+k]+=a[j+k+i]*f)%=w;&#125;void fwtxor(ll a[],int l,int f)&#123; int i,j,k;ll t; if(f==-1)f=2; for(i=1;i*2&lt;=l;i&lt;&lt;=1) for(j=0;j&lt;l;j+=i*2) for(k=0;k&lt;i;k++) t=a[j+k], (a[j+k]=div(f,t+a[j+k+i]))%=w, (a[j+k+i]=div(f,t-a[j+k+i]))%=w;&#125;void fmt(ll a[],int n,int f)&#123; int i,j; for(i=0;i&lt;n;i++)for(j=0;j&lt;1&lt;&lt;n;j++)if(j&amp;(1&lt;&lt;i))a[j]=(a[j]+f*a[j^(1&lt;&lt;i)])%w;&#125;ll f[20][P],cnt[P];void subsetconvolution(int n,ll a[],ll c[])&#123; int i,j,k; for(i=0;i&lt;1&lt;&lt;n;i++)cnt[i]=cnt[i&gt;&gt;1]+(i&amp;1); for(i=0;i&lt;1&lt;&lt;n;i++)f[cnt[i]][i]=a[i]; for(i=0;i&lt;=n;i++)fmt(f[i],n,1); for(i=n;i&gt;=0;i--)&#123; for(j=0;j&lt;1&lt;&lt;n;j++)&#123; ll x=0; for(k=0;k&lt;=i;k++)(x+=f[k][j]*f[i-k][j])%=w; f[i][j]=x; &#125; &#125; for(i=0;i&lt;=n;i++)fmt(f[i],n,-1); for(i=0;i&lt;1&lt;&lt;n;i++)c[i]=f[cnt[i]][i];&#125;int main()&#123; int i,n,x; for(i=2;i&lt;=M;i++)fib[i]=(fib[i-1]+fib[i-2])%w; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d",&amp;x),b[x]++,a[x]++; subsetconvolution(17,a,subset); fwtxor(a,M,1); for(i=0;i&lt;M;i++)Xor[i]=a[i]*a[i]%w; fwtxor(Xor,M,-1); for(i=0;i&lt;M;i++)&#123; subset[i]=subset[i]*fib[i]%w; b[i]=b[i]*fib[i]%w; Xor[i]=Xor[i]*fib[i]%w; &#125; fwtand(subset,M,1); fwtand(b,M,1); fwtand(Xor,M,1); for(i=0;i&lt;M;i++)b[i]=b[i]*subset[i]%w*Xor[i]%w; fwtand(b,M,-1); ll ans=0; for(i=1;i&lt;M;i&lt;&lt;=1) ans=(ans+b[i])%w; printf("%I64d",(ans+w)%w); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 7 题解]]></title>
    <url>%2F2019%2F05%2F27%2F2019springtraining-7%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G 7/7 O O Ø O O Ø Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A CF1082G - Petya and Graph 题目描述给一个无向图，其中每个边和点都分别有正的边权和点权，定义一个子图的价值为所有边的权值之和减去所有点的权值之和，要求所有边的两个顶点都在该子图中。求这个无向图最大的子图价值。 解题思路最大权闭合子图。 构图：（设边对应点为$w$，点对应点为$u,v$） $S\rightarrow w\rightarrow u,v\rightarrow T$ 边权$w_i,inf,a_u(a_v)$ 求最小割，割完后与$S$相连的就是答案对应的子图。答案即为所有边的权值减去最小割。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 8020struct Edge&#123; ll l; int e,n;&#125;e[N&lt;&lt;1];int hd[N],cur[N],cnt=1;void add(int a,int b,ll l)&#123; e[++cnt].e=b;e[cnt].l=l;e[cnt].n=hd[a];hd[a]=cnt; e[++cnt].e=a;e[cnt].l=0;e[cnt].n=hd[b];hd[b]=cnt;&#125;ll inf=1e15;int n,m,s,t;ll a[N];int dep[N];queue&lt;int&gt;Q;ll dfs(int p,ll flow)&#123; if(p==t)return flow; int i; for(i=cur[p];i;i=e[i].n)&#123; int q=e[i].e; cur[p]=i; if(dep[q]==1+dep[p]&amp;&amp;e[i].l)&#123; ll ans=dfs(q,min(flow,e[i].l)); if(ans)&#123; e[i].l-=ans; e[i^1].l+=ans; return ans; &#125; &#125; &#125; return 0;&#125;int bfs()&#123; memset(dep,0,sizeof(dep)); Q.push(s);dep[s]=1; int i; while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(!dep[q]&amp;&amp;e[i].l)dep[q]=dep[p]+1,Q.push(q); &#125; &#125; return dep[t];&#125;ll dinic()&#123; int i; ll d,ans=0; while(bfs())&#123; for(i=0;i&lt;=t;i++)cur[i]=hd[i]; while((d=dfs(s,inf)))ans+=d; &#125; return ans;&#125;int main()&#123; int i,u,v; ll w,sum=0; scanf("%d%d",&amp;n,&amp;m); s=0;t=n+m+1; for(i=1;i&lt;=n;i++)scanf("%I64d",&amp;a[i]),add(i+m,t,a[i]); for(i=1;i&lt;=m;i++)&#123; scanf("%d%d%I64d",&amp;u,&amp;v,&amp;w); add(s,i,w); add(i,u+m,inf); add(i,v+m,inf); sum+=w; &#125; printf("%I64d",sum-dinic()); return 0;&#125; B CF513F2 - Scaygerboss 题目描述有一个带障碍的地图，有$male $个男性$scayger$，$female$个女性$scayger$，一个$other$性别$scaygerboss$，分别有其初始坐标和走一个格子需要花费的时间。定义一个$scayger$高兴当且仅当它和与它不同性别的另一个$scayger$占有一个格子，且这个格子只有他们两个。问最少要多长时间所有的$scayger$都高兴。 解题思路先暴力判断$boss$充当的性别，然后二分答案、$bfs$建边即可。 构图：（流量均为$1$） $S\rightarrow male\rightarrow male在t内能去的地方\rightarrow 这个格子的拆点\rightarrow 能在t内去这个格子的female\rightarrow T$ AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 25struct Edge&#123; ll l; int e,n;&#125;e[N*N*N*N*N];int hd[N*N*5],cur[N*N*5],cnt=1;void add(int a,int b,ll l)&#123; e[++cnt].e=b;e[cnt].l=l;e[cnt].n=hd[a];hd[a]=cnt; e[++cnt].e=a;e[cnt].l=0;e[cnt].n=hd[b];hd[b]=cnt;&#125;ll inf=1e15;int n,m,s,t;int dep[N*N*5];queue&lt;int&gt;Q;ll dfs(int p,ll flow)&#123; if(p==t)return flow; int i; for(i=cur[p];i;i=e[i].n)&#123; int q=e[i].e; cur[p]=i; if(dep[q]&gt;dep[p]&amp;&amp;e[i].l)&#123; ll ans=dfs(q,min(flow,e[i].l)); if(ans)&#123; e[i].l-=ans; e[i^1].l+=ans; return ans; &#125; &#125; &#125; return 0;&#125;int bfs()&#123; memset(dep,0,sizeof(dep)); Q.push(s);dep[s]=1; int i; while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(!dep[q]&amp;&amp;e[i].l)dep[q]=dep[p]+1,Q.push(q); &#125; &#125; return dep[t];&#125;ll dinic()&#123; int i; ll d,ans=0; while(bfs())&#123; for(i=0;i&lt;=t;i++)cur[i]=hd[i]; while((d=dfs(s,inf)))ans+=d; &#125; return ans;&#125;char a[N][N];int sign[N][N];struct Per&#123; int x,y; ll v;&#125;boy[N*N],gir[N*N];int boyn,girn;struct QUEUE&#123; int x,y; ll time;&#125;;int vis[N][N];int num;//'.'int in(int flag,int NUM,int x,int y)&#123; if(x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&lt;m&amp;&amp;!vis[x][y]&amp;&amp;a[x][y]=='.')&#123; vis[x][y]=1; if(flag)add(NUM,sign[x][y]+boyn+girn,1);//male else add(sign[x][y]+boyn+girn+num,NUM,1);//female return 1; &#125; return 0;&#125;int jud(ll tim)&#123; int i,j; int now=0; memset(hd,0,sizeof(hd));cnt=1; for(i=0;i&lt;n;i++)for(j=0;j&lt;m;j++)if(a[i][j]=='.')&#123; sign[i][j]=++now; add(boyn+girn+now,boyn+girn+num+now,1); &#125; for(i=0;i&lt;boyn;i++)add(s,i+1,1); for(i=0;i&lt;girn;i++)add(i+1+boyn,t,1); for(i=0;i&lt;boyn;i++)&#123;//bfs int p=i+1; memset(vis,0,sizeof(vis)); queue&lt;QUEUE&gt;Q; while(!Q.empty())Q.pop(); in(1,p,boy[i].x-1,boy[i].y-1); Q.push(&#123;boy[i].x-1,boy[i].y-1,0&#125;); while(!Q.empty())&#123; int x=Q.front().x,y=Q.front().y;ll t=Q.front().time;Q.pop(); if(t+boy[i].v&gt;tim)break; if(in(1,p,x+1,y))Q.push(&#123;x+1,y,t+boy[i].v&#125;); if(in(1,p,x-1,y))Q.push(&#123;x-1,y,t+boy[i].v&#125;); if(in(1,p,x,y+1))Q.push(&#123;x,y+1,t+boy[i].v&#125;); if(in(1,p,x,y-1))Q.push(&#123;x,y-1,t+boy[i].v&#125;); &#125; &#125; for(i=0;i&lt;girn;i++)&#123;//bfs int p=i+1+boyn; memset(vis,0,sizeof(vis)); queue&lt;QUEUE&gt;Q; while(!Q.empty())Q.pop(); in(0,p,gir[i].x-1,gir[i].y-1); Q.push(&#123;gir[i].x-1,gir[i].y-1,0&#125;); while(!Q.empty())&#123; int x=Q.front().x,y=Q.front().y;ll t=Q.front().time;Q.pop(); if(t+gir[i].v&gt;tim)break; if(in(0,p,x+1,y))Q.push(&#123;x+1,y,t+gir[i].v&#125;); if(in(0,p,x-1,y))Q.push(&#123;x-1,y,t+gir[i].v&#125;); if(in(0,p,x,y+1))Q.push(&#123;x,y+1,t+gir[i].v&#125;); if(in(0,p,x,y-1))Q.push(&#123;x,y-1,t+gir[i].v&#125;); &#125; &#125; return dinic()==(boyn+girn)/2;&#125;int main()&#123; int i,j,girnum=0,boynum=0; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;boyn,&amp;girn); for(i=0;i&lt;n;i++)&#123; scanf("%s",a[i]); for(j=0;j&lt;m;j++)if(a[i][j]=='.')num++; &#125; if(num&lt;(boyn+girn+1)/2||(boyn-girn!=1&amp;&amp;girn-boyn!=1))return printf("-1"),0; ll l=0,r=490e9,ans=1e18; if(boyn-girn==1)scanf("%d%d%I64d",&amp;gir[girnum].x,&amp;gir[girnum].y,&amp;gir[girnum].v),girnum++,girn++; else scanf("%d%d%I64d",&amp;boy[boynum].x,&amp;boy[boynum].y,&amp;boy[boynum].v),boynum++,boyn++; while(boynum&lt;boyn)scanf("%d%d%I64d",&amp;boy[boynum].x,&amp;boy[boynum].y,&amp;boy[boynum].v),boynum++; while(girnum&lt;girn)scanf("%d%d%I64d",&amp;gir[girnum].x,&amp;gir[girnum].y,&amp;gir[girnum].v),girnum++; s=0;t=boyn+girn+num*2+2; while(l&lt;=r)&#123; ll mid=(l+r)&gt;&gt;1; if(jud(mid))ans=mid,r=mid-1; else l=mid+1; &#125; printf("%I64d",ans&lt;1e18?ans:-1); return 0;&#125; C CF1045A - Last chance 题目描述有$m$个敌人，$n$次攻击，每次攻击可以选择以下三种之一： 攻击给定集合里至多一个敌人 攻击给定区间里至多一个敌人 攻击给定三人中的两人或零人 其中保证所有敌人至多会位于攻击方式$3$的集合一次。 每个敌人都是一击即死，所以每个敌人只能打一次。 问最多能打死几个敌人，并输出这些敌人分别是被哪回合的攻击打死的。 解题思路攻击$1$直接暴力连边，攻击$2$线段树优化建图连边即可。而攻击$3$可以暴力打死其中两人$BC$，并连$p\rightarrow a$，$b\rightarrow p$，$c\rightarrow p$三条边，不连$s\rightarrow p$边即可（$p$指本次攻击对应的点）。 难点在于最后的输出。可以考虑连一个反向的图，沿着流方向回流到攻击所对应点。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 200010struct Edge&#123; ll l; int e,n;&#125;e[N&lt;&lt;1];int hd[N],cur[N],cnt=1;void add(int a,int b,ll l)&#123; e[++cnt].e=b;e[cnt].l=l;e[cnt].n=hd[a];hd[a]=cnt; e[++cnt].e=a;e[cnt].l=0;e[cnt].n=hd[b];hd[b]=cnt;&#125;ll inf=1e15;int n,m,s,t;ll a[N];int dep[N];queue&lt;int&gt;Q;ll dfs(int p,ll flow)&#123; if(p==t)return flow; int i; for(i=cur[p];i;i=e[i].n)&#123; int q=e[i].e; cur[p]=i; if(dep[q]==dep[p]+1&amp;&amp;e[i].l)&#123; ll ans=dfs(q,min(flow,e[i].l)); if(ans)&#123; e[i].l-=ans; e[i^1].l+=ans; return ans; &#125; &#125; &#125; return 0;&#125;int bfs()&#123; memset(dep,0,sizeof(dep)); Q.push(s);dep[s]=1; int i; while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(!dep[q]&amp;&amp;e[i].l)dep[q]=dep[p]+1,Q.push(q); &#125; &#125; return dep[t];&#125;int tot;//节点ll dinic()&#123; int i; ll d,ans=0; while(bfs())&#123; for(i=0;i&lt;=tot;i++)cur[i]=hd[i]; while((d=dfs(s,inf)))ans+=d; &#125; return ans;&#125;int id[N],L[N],R[N];void build(int p,int l,int r)&#123; id[p]=++tot; L[p]=l;R[p]=r; if(l==r)&#123; add(tot,l,1); return; &#125; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); add(id[p],id[p&lt;&lt;1],inf); add(id[p],id[p&lt;&lt;1|1],inf);&#125;void upd(int p,int l,int r)&#123; if(L[p]&gt;=l&amp;&amp;R[p]&lt;=r)&#123; add(tot,id[p],1); return; &#125; if(L[p]&gt;r||R[p]&lt;l)return; upd(p&lt;&lt;1,l,r); upd(p&lt;&lt;1|1,l,r);&#125;map&lt;int,int&gt;mp[N];int vis[N],start,ret;void solve(int x)&#123; if(x&gt;=start)&#123;ret=x-start;return;&#125; map&lt;int,int&gt;::iterator it=mp[x].begin(); solve(it-&gt;first); --it-&gt;second; if(!it-&gt;second)mp[x].erase(it);&#125;int main()&#123; int i,j,u,k,l,r,opt; int temp=0; scanf("%d%d",&amp;n,&amp;m); tot=m; build(1,1,m); s=++tot;t=++tot; start=tot; for(i=1;i&lt;=n;i++)&#123; ++tot; scanf("%d",&amp;opt); if(opt==0)&#123; add(s,tot,1); scanf("%d",&amp;k); while(k--)scanf("%d",&amp;u),add(tot,u,1); &#125;else if(opt==1)&#123; add(s,tot,1); scanf("%d%d",&amp;l,&amp;r); upd(1,l,r); &#125;else&#123; int A,B,C; scanf("%d%d%d",&amp;A,&amp;B,&amp;C); add(tot,A,1); add(tot,B,0);e[cnt].l=1;vis[B]=1; add(tot,C,1);e[cnt].l=1;vis[C]=1; temp+=2; &#125; &#125; for(i=1;i&lt;=m;i++)if(!vis[i])add(i,t,1); printf("%I64d\n",dinic()+temp); for(i=1;i&lt;=tot;i++) for(j=hd[i];j;j=e[j].n) if((j&amp;1)&amp;&amp;e[j].l)mp[i][e[j].e]=e[j].l; for(i=1;i&lt;=m;i++)&#123; int flag=0; for(j=hd[i];j;j=e[j].n)if(e[j].e==t&amp;&amp;e[j].l)&#123; flag=1; break; &#125; if(flag)continue; solve(i); printf("%d %d\n",ret,i); &#125; return 0;&#125; D CF164C - Machine Programming 题目描述有一堆任务，$k$个机器，每个任务有起始结束时间以及利润，问如何分配能够利益最大化。 解题思路先把任务按照起始时间排序，把每个任务拆点，连边如下 $S\rightarrow i$，流量$k$，费用$0$$i\rightarrow i+1$，流量$inf$，费用$0$$i’\rightarrow t$，流量$inf$，费用$0$$i$完成后首先开始的$j$：$i’\rightarrow j$，流量$1$，费用$0$$i\rightarrow i’$，流量$1$，费用$-profit$ 跑最小费用最大流，保证使用最多的机器的情况下获得利润负值最小。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;#define N 100020struct Edge&#123; int end,len,cost,near;&#125;e[20*N];struct Pre&#123; int pre,edge;&#125;pre[N];int head[N],dis[N],flow[N],vis[N],cnt=1,n,k,s,t;int maxflow,mincost;int inf=2e9;void add(int a,int b,int l,int c)&#123; e[++cnt].end=b; e[cnt].len=l; e[cnt].cost=c; e[cnt].near=head[a]; head[a]=cnt;&#125;queue&lt;int&gt;Q;int spfa()&#123; memset(dis,0x7f,sizeof(dis)); memset(flow,0x7f,sizeof(flow)); memset(vis,0,sizeof(vis)); while(!Q.empty())Q.pop(); int i,top,q; Q.push(s);vis[s]=1;dis[s]=0;pre[t].pre=0; while(!Q.empty())&#123; top=Q.front(); Q.pop(); vis[top]=0; for(i=head[top];i;i=e[i].near)&#123; q=e[i].end; if(e[i].len&amp;&amp;dis[q]&gt;dis[top]+e[i].cost)&#123; dis[q]=dis[top]+e[i].cost; pre[q].pre=top; pre[q].edge=i; flow[q]=min(flow[top],e[i].len); if(!vis[q])&#123; vis[q]=1; Q.push(q); &#125; &#125; &#125; &#125; return pre[t].pre;&#125;void ek()&#123; int i; while(spfa())&#123; maxflow+=flow[t]; mincost+=flow[t]*dis[t]; for(i=t;i!=s;i=pre[i].pre)&#123; e[pre[i].edge].len-=flow[t]; e[pre[i].edge^1].len+=flow[t]; &#125; &#125;&#125;struct A&#123; int s,t,c,i; bool operator&lt;(const A&amp;p)const&#123;return s&lt;p.s||(s==p.s&amp;&amp;t&lt;p.t);&#125;&#125;a[N];int ans[N];int main()&#123; int i,j; scanf("%d%d",&amp;n,&amp;k); for(i=0;i&lt;n;i++)scanf("%d%d%d",&amp;a[i].s,&amp;a[i].t,&amp;a[i].c),a[i].i=i; sort(a,a+n); s=2*n;t=s+1; add(s,0,k,0);add(0,s,0,0); add(n-1,t,k,0);add(t,n-1,0,0); for(i=0;i&lt;n;i++)&#123; add(i,i+n,1,-a[i].c),add(i+n,i,0,a[i].c); add(i+n,t,inf,0),add(t,i+n,0,0); int j=i+1; while(j&lt;n&amp;&amp;a[j].s&lt;a[i].s+a[i].t)j++; if(j&lt;n)add(i+n,j,inf,0),add(j,i+n,0,0); if(i&lt;n-1)add(i,i+1,inf,0),add(i+1,i,0,0); &#125; ek(); for(i=0;i&lt;n;i++)&#123; for(j=head[i];j;j=e[j].near)&#123; int q=e[j].end; if(q==i+n)&#123; if(!e[j].len)ans[a[i].i]=1; break; &#125; &#125; &#125; for(i=0;i&lt;n;i++)printf("%d ",ans[i]); return 0;&#125; E POJ 1273 - Drainage Ditches 题目描述求最大流。 解题思路模板。 必须吐槽$poj$居然不能用万能头！ AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 220#define M 220struct Edge&#123; int l,e,n;&#125;e[M&lt;&lt;1];int hd[M],cur[M],cnt=1;void add(int a,int b,int l)&#123; e[++cnt].e=b;e[cnt].l=l;e[cnt].n=hd[a];hd[a]=cnt; e[++cnt].e=a;e[cnt].l=0;e[cnt].n=hd[b];hd[b]=cnt;&#125;int inf=1e9;int n,m,s,t;ll sum;int dep[M];queue&lt;int&gt;Q;int dfs(int p,int flow)&#123; if(p==t)return flow; int i; for(i=cur[p];i;i=e[i].n)&#123; int q=e[i].e; cur[p]=i; if(dep[q]&gt;dep[p]&amp;&amp;e[i].l)&#123; int ans=dfs(q,min(flow,e[i].l)); if(ans)&#123; e[i].l-=ans; e[i^1].l+=ans; return ans; &#125; &#125; &#125; return 0;&#125;int bfs()&#123; memset(dep,0,sizeof(dep)); Q.push(s);dep[s]=1; int i; while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(!dep[q]&amp;&amp;e[i].l)dep[q]=dep[p]+1,Q.push(q); &#125; &#125; return dep[t];&#125;ll dinic()&#123; int i,d; ll ans=0; while(bfs())&#123; for(i=0;i&lt;=t;i++)cur[i]=hd[i]; while((d=dfs(s,inf)))ans+=d; &#125; return ans;&#125;int main()&#123; int i,w,u,v; while(~scanf("%d%d",&amp;m,&amp;n))&#123; cnt=1;memset(hd,0,sizeof(hd)); s=1;t=n; for(i=0;i&lt;m;i++)scanf("%d%d%d",&amp;u,&amp;v,&amp;w),add(u,v,w); printf("%lld\n",dinic()); &#125; return 0;&#125; F POJ 2396 - Budget 题目描述给一个网格图填数，给一些大小限制和行列总和，求解。 解题思路上下界网络流，把行列都当做点看即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;typedef long long ll;using namespace std;#define N 205#define M 22#define P 240struct Edge&#123; int l,e,n;&#125;e[P*P];int hd[P],cur[P],cnt=1;int inf=1e9;int n,m,s,t,ss,tt;ll sum;int dep[P];queue&lt;int&gt;Q;int dfs(int p,int flow)&#123; if(p==t)return flow; int i; for(i=cur[p];i;i=e[i].n)&#123; int q=e[i].e; cur[p]=i; if(dep[q]&gt;dep[p]&amp;&amp;e[i].l)&#123; int ans=dfs(q,min(flow,e[i].l)); if(ans)&#123; e[i].l-=ans; e[i^1].l+=ans; return ans; &#125; &#125; &#125; return 0;&#125;int bfs()&#123; memset(dep,0,sizeof(dep)); Q.push(s);dep[s]=1; int i; while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(!dep[q]&amp;&amp;e[i].l)dep[q]=dep[p]+1,Q.push(q); &#125; &#125; return dep[t];&#125;ll dinic()&#123; int i,d; ll ans=0; while(bfs())&#123; for(i=0;i&lt;=t;i++)cur[i]=hd[i]; while((d=dfs(s,inf)))ans+=d; &#125; return ans;&#125;int lim[2][N][M],flag,full;int ans[N][M];void init ()&#123; int i,j; memset(lim[0],0,sizeof(lim[0])); memset(lim[1],0x3f,sizeof(lim[1])); memset(hd,0,sizeof(hd)); memset(ans,0,sizeof(ans)); cnt=1; flag=0; full=0;&#125;void add(int a,int b,int l)&#123; if(a==s)full+=l; if(!l)return; e[++cnt].e=b;e[cnt].l=l;e[cnt].n=hd[a];hd[a]=cnt; e[++cnt].e=a;e[cnt].l=0;e[cnt].n=hd[b];hd[b]=cnt;&#125;void ins(int a,int b,int low,int high)&#123; if(high&lt;low)flag=1; add(s,b,low); add(a,t,low); add(a,b,high-low);&#125;int main()&#123; int i,j,T,a,q; scanf("%d",&amp;T); while(T--)&#123; init(); scanf("%d%d",&amp;n,&amp;m); ss=n+m+1;tt=ss+1; s=tt+1;t=s+1; for(i=1;i&lt;=n;i++)scanf("%d",&amp;a),ins(ss,i,a,a); for(i=1;i&lt;=m;i++)scanf("%d",&amp;a),ins(i+n,tt,a,a); scanf("%d",&amp;q); while(q--)&#123; char s[5]=&#123;0&#125;; int u,v,l1,r1,l2,r2; scanf("%d%d%s%d",&amp;u,&amp;v,s,&amp;a); if(!u)l1=1,r1=n;else l1=r1=u; if(!v)l2=1,r2=m;else l2=r2=v; for(i=l1;i&lt;=r1;i++)for(j=l2;j&lt;=r2;j++)&#123; if(s[0]=='&lt;')lim[1][i][j]=min(lim[1][i][j],a-1); if(s[0]=='&gt;')lim[0][i][j]=max(lim[0][i][j],a+1); if(s[0]=='=')lim[0][i][j]=max(lim[0][i][j],a),lim[1][i][j]=min(lim[1][i][j],a); &#125; &#125; for(i=1;i&lt;=n;i++)for(j=1;j&lt;=m;j++)ins(i,j+n,lim[0][i][j],lim[1][i][j]); ins(tt,ss,0,inf); if(flag||dinic()!=full)&#123; printf("IMPOSSIBLE\n\n"); continue; &#125; for(i=2;i&lt;=cnt;i++) if(e[i^1].e&gt;=1&amp;&amp;e[i^1].e&lt;=n&amp;&amp;e[i].e&gt;=n+1&amp;&amp;e[i].e&lt;=n+m) ans[e[i^1].e][e[i].e-n]=e[i^1].l; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)printf("%d ",ans[i][j]+lim[0][i][j]); puts(""); &#125; puts(""); &#125; return 0;&#125; G POJ 3020 - Antenna Placement 题目描述给一个$o$（空地）和$*$（城市）组成的图，一个基站可以覆盖相邻的两个城市，问至少要多少基站才能覆盖所有城市。 解题思路相邻城市建边跑二分图最大匹配即可，假设开始一个城市对应一个基站，则每一个匹配对应一个基站的减少，答案为城市数$-$最大匹配数。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;#define N 45*15#define M N&lt;&lt;2struct Edge&#123;int e,n;&#125;e[M];int hd[N],mt[N],cnt,vis[N];int mp[N][N];void add(int a,int b)&#123;e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;int dfs(int p,int t)&#123; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(vis[q]!=t)&#123; vis[q]=t; if(!mt[q]||dfs(mt[q],t))return mt[q]=p; &#125; &#125; return 0;&#125;int maxmt(int n)&#123; int i,ans=0; for(i=1;i&lt;=n;i++) if(dfs(i,i))ans++; return ans;&#125;char a[N];int main()&#123; int i,j,n,m,t; scanf("%d",&amp;t); while(t--)&#123; int lcnt=0,rcnt=0,tot=0; memset(hd,0,sizeof(hd));cnt=0; memset(vis,0,sizeof(vis)); memset(mt,0,sizeof(mt)); memset(mp,0,sizeof(mp)); scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)&#123; scanf("%s",a); for(j=0;a[j];j++)&#123; if(a[j]=='*')&#123; if((i+j)&amp;1)mp[i][j]=++lcnt; else mp[i][j]=++rcnt; ++tot; &#125; &#125; &#125; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; if(mp[i][j]&amp;&amp;((i+j)&amp;1))&#123; if(i&amp;&amp;mp[i-1][j])add(mp[i][j],mp[i-1][j]); if(i+1&lt;n&amp;&amp;mp[i+1][j])add(mp[i][j],mp[i+1][j]); if(j+1&lt;m&amp;&amp;mp[i][j+1])add(mp[i][j],mp[i][j+1]); if(j&amp;&amp;mp[i][j-1])add(mp[i][j],mp[i][j-1]); &#125; &#125; &#125; printf("%d\n",tot-maxmt(lcnt)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 6 题解]]></title>
    <url>%2F2019%2F05%2F19%2F2019springtraining-6%2F</url>
    <content type="text"><![CDATA[Solved A B C D E 5/5 O Ø Ø O Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A HDU 5943 - Kingdom of Obsession 题目描述一个数可以对应他的所有因数，问$[1,n]$能不能被$[s+1,s+n]$一一对应。 解题思路显然，一个区间内若有两个质数则必然不可行，猜测差别$400$以上不可行，剩余的跑匈牙利。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define N 1010struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int hd[N],cnt,vis[N],mt[N];void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;int n,s;int dfs(int p,int t)&#123; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(vis[q]!=t)&#123; vis[q]=t; if(!mt[q]||dfs(mt[q],t))return mt[q]=p; &#125; &#125; return 0;&#125;int maxmt()&#123; int i; for(i=1;i&lt;=n;i++)if(!dfs(i,i))return 0; return 1;&#125;int main()&#123; int i,j,k,t; scanf("%d",&amp;t); for(k=1;k&lt;=t;k++)&#123; scanf("%d%d",&amp;n,&amp;s); printf("Case #%d: ",k); if(s&lt;n)std::swap(s,n); if(n&gt;400)&#123; printf("No\n"); continue; &#125; memset(hd,0,sizeof(hd));cnt=0; memset(vis,0,sizeof(vis)); memset(mt,0,sizeof(mt)); for(i=s+1;i&lt;=s+n;i++) for(j=1;j&lt;=n;j++) if(i%j==0)add(i-s,j); printf("%s\n",maxmt()?"Yes":"No"); &#125; return 0;&#125; B HDU 6305 - RMQ Similar Sequence 题目描述定义两个序列相似，当且仅当对于任意一个区间$[l,r]$，其最大数的最左位置相同。 给定一个序列$A$，随机产生一个序列$B$，其中$B$的所有元素都是等概率从$(0,1)$中选取的。如果$AB$相似，则$B$的满意度为$B$中所有数之和，否则$B$的满意度为$0$。求$B$的满意度期望。 解题思路笛卡尔树的同构，$[0,1]$之中$n$个数总和期望为$\frac n2$，各个数两两不同的概率为$1$（即不需考虑两个数相同的情况）。树同构的概率为$\prod\frac1{siz[i]}$（证明：用拓扑序表示树，则某一个点$i$作为根的时候位置必然在其所有子树点的后面，则对于该点而言，满足这个条件只需考虑这$siz[i]$个节点的顺序，故满足条件的概率为$\frac 1{siz[i]}$），于是答案为$\frac n2\prod\frac1{siz[i]}$。 AC代码点击 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define N 3000010long long inv[N]=&#123;0,1&#125;,w=1000000007,ans;int a[N],sta[N],top,siz[N],l[N],r[N];void dfs(int p)&#123; if(!p)return; siz[p]=1; dfs(l[p]);siz[p]+=siz[l[p]]; dfs(r[p]);siz[p]+=siz[r[p]]; ans=ans*inv[siz[p]]%w;&#125;int main()&#123; int i,n,t; for(i=2;i&lt;N;i++)inv[i]=inv[w%i]*(w-w/i)%w; scanf("%d",&amp;t); while(t--)&#123; top=0; scanf("%d",&amp;n); ans=n*inv[2]%w; for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),l[i]=r[i]=0; for(i=1;i&lt;=n;i++)&#123; while(top&amp;&amp;a[i]&gt;a[sta[top]])l[i]=sta[top--]; if(top)r[sta[top]]=i; sta[++top]=i; &#125; dfs(sta[1]); printf("%lld\n",ans); &#125; return 0;&#125; C ZOJ 3656 - Bit Magic 题目描述给定一个由$a[n]$经过或、与、异或运算得到的矩阵$b[n][n]$，问能不能够找到$a[n]$的解。 解题思路用并查集模拟或和与的填数以及异或的两元素关系。每个数拆成$32$个$bit$，并分成两半，一半是该数需要与某个数相同，另一半是该数不可与某个数相同。 听说能用$2-sat$做，看来还是要学习一个。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 521#define M 52125int b[N][N],n,f[M];int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;void merge(int x,int p)&#123; int a=find(x),b=find(p); f[a]=f[b]=f[x]=f[p]=std::min(a,b);&#125;int solve()&#123; int i,j,k; for(i=0;i&lt;n;i++)&#123; for(j=i+1;j&lt;n;j++)if(b[i][j]!=b[j][i])return 0; if(b[i][i])return 0; &#125; for(i=0;i&lt;n;i++)&#123; for(j=i+1;j&lt;n;j++)&#123; for(k=0;k&lt;32;k++)&#123; if(i%2&amp;&amp;j%2)&#123; if(!(b[i][j]&amp;(1&lt;&lt;k)))&#123; int p=(i+1)*32+k,q=(j+1)*32+k; if(find(p)==find(1)||find(q)==find(1)||find(p)==find(q+32*n))return 0; merge(p,0);merge(q,0); merge(p+32*n,1);merge(q+32*n,1); &#125; &#125;else if(!(i%2)&amp;&amp;!(j%2))&#123; if(b[i][j]&amp;(1&lt;&lt;k))&#123; int p=(i+1)*32+k,q=(j+1)*32+k; if(find(p)==find(0)||find(q)==find(0)||find(p)==find(q+32*n))return 0; merge(p,1);merge(q,1); merge(p+32*n,0);merge(q+32*n,0); &#125; &#125;else&#123; if(b[i][j]&amp;(1&lt;&lt;k))&#123; int p=(i+1)*32+k,q=(j+1)*32+k; if(find(p)==find(q))return 0; merge(p,q+32*n);merge(q,p+32*n); &#125;else&#123; int p=(i+1)*32+k,q=(j+1)*32+k; if(find(p)==find(q+32*n))return 0; merge(p,q);merge(q+32*n,p+32*n); &#125; &#125; &#125; &#125; &#125; return 1;&#125;int main()&#123; int i,j; while(~scanf("%d",&amp;n))&#123; for(i=0;i&lt;=32*(n+2)*2;i++)f[i]=i; for(i=0;i&lt;n;i++)for(j=0;j&lt;n;j++)scanf("%d",&amp;b[i][j]); printf("%s\n",solve()?"YES":"NO"); &#125; return 0;&#125; D ZJOI2008 - 骑士 题目描述每个人都对应有一个不能同时上台的人，并有一个实力值，问选择出的人的实力值之和最大是多少。 解题思路基环树，也可找到环之后切开分两段$DP$。 AC代码-1点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define N 1000010typedef long long ll;struct Edge&#123; int end,near;&#125;e[N&lt;&lt;1];int head[N],cnt,vis[N],fa[N];void add(int a,int b)&#123; e[++cnt].end=b;e[cnt].near=head[a];head[a]=cnt;&#125;ll str[N],ans,f[2][N];int rt;void dp(int x)&#123; int i,q; if(!vis[x])vis[x]=1; f[0][x]=0; f[1][x]=str[x]; for(i=head[x];i;i=e[i].near)&#123; q=e[i].end; if(q!=rt)&#123; dp(q); f[1][x]+=f[0][q]; f[0][x]+=max(f[1][q],f[0][q]); &#125; &#125; if(x==rt)f[1][x]=0;&#125;void cir(int x)&#123; ll t; vis[x]=1; rt=x; while(!vis[fa[rt]])&#123; rt=fa[rt]; vis[rt]=1; &#125; dp(rt);t=f[0][rt]; rt=fa[rt]; dp(rt);ans+=max(t,f[0][rt]);&#125;int main()&#123; int i,n,y; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf("%lld%d",&amp;str[i],&amp;y); add(y,i);fa[i]=y; &#125; for(i=1;i&lt;=n;i++)if(!vis[i])cir(i); printf("%lld",ans); return 0;&#125; AC代码-2点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#define N 1000010typedef long long ll;ll max(ll a,ll b)&#123;return a&gt;b?a:b;&#125;ll min(ll a,ll b)&#123;return a&gt;b?b:a;&#125;struct Edge&#123; int end,near;&#125;e[N&lt;&lt;1];int head[N],cnt;void add(int a,int b)&#123; e[++cnt].end=b;e[cnt].near=head[a];head[a]=cnt;&#125;ll str[N],f[2][N];int rt;void dp(int x,int fa)&#123; int i,q; f[0][x]=0; f[1][x]=str[x]; for(i=head[x];i;i=e[i].near)&#123; q=e[i].end; if(q!=fa)&#123; dp(q,x); f[1][x]+=f[0][q]; f[0][x]+=max(f[1][q],f[0][q]); &#125; &#125; if(x==rt)f[1][x]=0;&#125;int fla[N],A[N],B[N],tot;int main()&#123; int i,n,y; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf("%lld%d",&amp;str[i],&amp;y); if(fla[i]&amp;&amp;fla[y])&#123; A[++tot]=i;B[tot]=y;continue; &#125; fla[i]=fla[y]=1; add(y,i);add(i,y); &#125; ll ans=0; for(i=1;i&lt;=tot;i++)&#123; dp(A[i],A[i]);ll t=f[0][A[i]]; dp(B[i],B[i]); ans+=max(t,f[0][B[i]]); &#125; printf("%lld",ans); return 0;&#125; E HYSBZ 4774 - 修路 题目描述给一个图，要求选择某些边，使得前$d$个点和后$d$个点必须分别相连通，问最小权值和。 解题思路设$f[i][j]$表示当前斯坦纳树的根为$i$，指定集合中，包含点的集合表示为$j$的生成树最小权值。 则转移方程为：$f[i][j]=min(f[i][S]+f[i][S \oplus j])$（分成两个以$i$为根的斯坦纳树，点集状态分别为$S$和$j\oplus S$），$f[i][j]=min(f[k][j]+len[i][k])$（换根，根再向$i$连边），这一步看起来很像最短路，可以用最短路算法算出。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define N 10010#define M (1&lt;&lt;8)+10struct Edge&#123; int e,n,l;&#125;e[N&lt;&lt;1];int hd[N],cnt,n,m,d;void add(int a,int b,int l)&#123; e[++cnt].e=b;e[cnt].n=hd[a];e[cnt].l=l;hd[a]=cnt;&#125;int f[N][M],g[M],vis[N];queue&lt;int&gt;Q;void spfa(int s)&#123; while(!Q.empty())&#123; int p=Q.front(),i;Q.pop(); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(f[q][s]&gt;f[p][s]+e[i].l)&#123; f[q][s]=f[p][s]+e[i].l; if(!vis[q])Q.push(q),vis[q]=1; &#125; &#125; vis[p]=0; &#125;&#125;int main()&#123; int i,j,k,s,u,v,w; scanf("%d%d%d",&amp;n,&amp;m,&amp;d);s=(1&lt;&lt;(d&lt;&lt;1)); for(i=0;i&lt;m;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;w), add(u,v,w),add(v,u,w); memset(f,0x3f,sizeof(f)); memset(g,0x3f,sizeof(g)); for(i=1;i&lt;=d;i++) f[i][1&lt;&lt;i-1]=0,f[n-i+1][1&lt;&lt;d+i-1]=0; for(j=0;j&lt;s;j++)&#123; for(i=1;i&lt;=n;i++)&#123; for(k=j&amp;(j-1);k;k=(k-1)&amp;j) f[i][j]=min(f[i][j],f[i][k]+f[i][j^k]); if(f[i][j]&lt;1e9)Q.push(i),vis[i]=1; &#125; spfa(j); for(i=1;i&lt;=n;i++)g[j]=min(g[j],f[i][j]); &#125; for(j=0;j&lt;s;j++) for(k=j&amp;(j-1);k;k=(k-1)&amp;j) if((k&amp;((1&lt;&lt;d)-1))==(k&gt;&gt;d)&amp;&amp;((j^k)&amp;((1&lt;&lt;d)-1))==((j^k)&gt;&gt;d)) g[j]=min(g[j],g[k]+g[j^k]); printf("%d\n",g[s-1]&lt;1e9?g[s-1]:-1); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 5 题解]]></title>
    <url>%2F2019%2F05%2F19%2F2019springtraining-5%2F</url>
    <content type="text"><![CDATA[Solved A B C D E 5/5 Ø O Ø Ø O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述现有一棵 $n$ 个点的树，每条边 $i$ 都一个边权 $w_i$，接下来有 $m$ 个操作：第一种操作给出两个点 $a_i$,$ b_i$，一个数 $y_i$：从 $a_i$ 沿最短路走到 $b_i$ 的过程中，每经过一条边 $j$，就将 $y_i$ 除以边权 $w_j$ 并向下取整，即进行 $y_i=\lfloor\frac{y_i}{w_j}\rfloor $ ，输出走完后的 $y_i$。第二种操作给出某条边 $e_i$，一个数 $c_i$，满足 $c_i$ &lt; $w_{e_i}$：将 $e_i$ 边权修改为 $c_i$。 解题思路刚开始傻乎乎瞎改点剖模板然后$T$了。 TLE代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 200010int n,m,r,mod;double a[N];int count=2,head[N];struct Edge&#123; int end,near,sign; double len;&#125;edge[2*N];void addedge(int begin,int end,double len)&#123; edge[count].end=end; edge[count].near=head[begin]; edge[count].len=len; head[begin]=count++;&#125;int depth[N],fa[N],size[N],son[N],pos[N],top[N];double temp[N],sonlen[N];int cnt;struct Tree&#123; int left,right; double data;&#125;tree[4*N];void build(int p,int left,int right)&#123; tree[p].left=left; tree[p].right=right; if(left==right)&#123; tree[p].data=temp[left]; return; &#125; build(p&lt;&lt;1,left,(left+right)&gt;&gt;1); build(p&lt;&lt;1|1,((left+right)&gt;&gt;1)+1,right); tree[p].data=tree[p&lt;&lt;1].data*tree[p&lt;&lt;1|1].data;&#125;double query(int p,int left,int right)&#123; int l=tree[p].left,r=tree[p].right; if(l&gt;=left&amp;&amp;r&lt;=right)return tree[p].data; if(r&lt;left||l&gt;right)return 1; return query(p&lt;&lt;1,left,right)*query(p&lt;&lt;1|1,left,right);&#125;void dfs1(int now,int f,int dep)&#123; depth[now]=dep; fa[now]=f; size[now]=1; int i,max=0; for(i=head[now];i;i=edge[i].near)&#123; int p=edge[i].end; if(p!=f)&#123; edge[i].sign=1; dfs1(p,now,dep+1); size[now]+=size[p]; if(size[p]&gt;max)&#123; max=size[p]; son[now]=p; sonlen[now]=edge[i].len; &#125; &#125; &#125;&#125;void dfs2(int now,int Top,double x)&#123; int i; pos[now]=++cnt; temp[cnt]=x; top[now]=Top; if(!son[now])return; dfs2(son[now],Top,sonlen[now]); for(i=head[now];i;i=edge[i].near)&#123; int p=edge[i].end; if(p-son[now]&amp;&amp;p-fa[now])dfs2(p,p,edge[i].len); &#125;&#125;int bot[N],mxd[N];void dfs3(int p,int f)&#123; int i,tmp=p; mxd[p]=depth[p]; for(i=head[p];i;i=edge[i].near)&#123; int q=edge[i].end; if(q==f)continue; dfs3(q,p); if(mxd[q]&gt;mxd[p])mxd[p]=mxd[q],tmp=bot[q]; &#125; bot[p]=tmp;&#125;double rangequery(double fir,int x,int y)&#123; double ans=fir; while(top[x]!=top[y])&#123; if(depth[top[x]]&lt;depth[top[y]])std::swap(x,y); ans/=query(1,pos[top[x]],pos[x]); if(ans&lt;1)return 0; x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y])std::swap(x,y); return ans/query(1,pos[x],pos[y]);&#125;int d[N],Fa[22][N],lg[N];void dfs(int now,int f)&#123; d[now]=d[f]+1; Fa[0][now]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++)Fa[i][now]=Fa[i-1][Fa[i-1][now]]; for(i=head[now];i;i=edge[i].near)&#123; int p=edge[i].end; if(p!=f)dfs(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y])x=Fa[lg[d[x]-d[y]]][x]; if(x==y)return x; for(i=lg[d[x]];~i;i--)if(Fa[i][x]!=Fa[i][y])x=Fa[i][x],y=Fa[i][y]; return Fa[0][x];&#125;void modify(int l,int r,int p,double change,int inin)&#123; if(tree[p].left&lt;=inin&amp;&amp;inin&lt;=tree[p].right)tree[p].data*=change; if(tree[p].left==tree[p].right&amp;&amp;tree[p].left==1)tree[p].data=1; if(tree[p].left&gt;r||tree[p].right&lt;l||p&gt;4*n)return; modify(l,r,p&lt;&lt;1,change,inin); modify(l,r,p&lt;&lt;1|1,change,inin);&#125;int main()&#123; int i,x,y,sign,r=1; double w; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;n;i++)&#123; scanf("%d%d%lf",&amp;x,&amp;y,&amp;w); addedge(x,y,w);addedge(y,x,w); &#125; dfs(r,0); for(i=2;i&lt;=n;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); dfs1(r,0,1); dfs2(r,r,1); dfs3(r,0); build(1,1,n); temp[pos[1]]=1; for(i=0;i&lt;m;i++)&#123; scanf("%d",&amp;sign); if(sign==1)&#123; double y;int a,b; scanf("%d%d%lf",&amp;a,&amp;b,&amp;y); int ff=lca(a,b); double rq=rangequery(y*temp[pos[ff]],a,b); printf("%I64d\n",(long long)(1e-8+rq)); &#125;else&#123; int a;double b; scanf("%d%lf",&amp;a,&amp;b);a&lt;&lt;=1; int p=edge[a].sign?edge[a].end:edge[a^1].end,q=p,tmp=p; p=top[p];q=bot[q]; p=pos[p];q=pos[q]; if(p&gt;q)std::swap(p,q); double change=b/edge[a].len; modify(p,q,1,change,pos[tmp]); &#125; &#125; return 0;&#125; 考虑每次边权只能减小，每次将权值为$1$的路径用并查集合并起来即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;typedef long long ll;#define N 200010struct Edge&#123; int e,n,i; ll len;&#125;e[N&lt;&lt;1];int hd[N],cnt=1,n,m;void add(int a,int b,ll w,int i)&#123; e[++cnt].e=b;e[cnt].n=hd[a];e[cnt].len=w;e[cnt].i=i;hd[a]=cnt;&#125;int fa[N],dep[N],to[N];ll up[N];void dfs(int p,int d)&#123; dep[p]=d; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q==fa[p])continue; fa[q]=p; up[q]=e[i].len; to[e[i].i]=q; dfs(q,d+1); &#125;&#125;int f[N];int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;ll solve(int u,int v,ll w)&#123; u=find(u),v=find(v); while(u!=v)&#123; if(dep[u]&lt;dep[v])std::swap(u,v); w/=up[u]; if(!w)return 0; u=find(fa[u]); &#125; return w;&#125;int main()&#123; int i,u,v,opt; ll w; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;n;i++)&#123; scanf("%d%d%I64d",&amp;u,&amp;v,&amp;w); add(u,v,w,i),add(v,u,w,i); f[i]=i; &#125;f[n]=n; dfs(1,0); for(i=1;i&lt;=n;i++)if(up[i]==1)f[i]=find(fa[i]); for(i=0;i&lt;m;i++)&#123; scanf("%d",&amp;opt); if(opt==1)&#123; scanf("%d%d%I64d",&amp;u,&amp;v,&amp;w); printf("%I64d\n",solve(u,v,w)); &#125;else&#123; scanf("%d%I64d",&amp;u,&amp;w); up[to[u]]=w; if(w==1)f[to[u]]=find(fa[to[u]]); &#125; &#125; return 0;&#125; B 题目描述现有一棵$n$个点的树，点的编号从 $1$ 起，树以 $1$ 为根，每个点 $i$ 都一个颜色 $c_i$，接下来有$m$个询问，每次询问以 $v_j$ 为根的子树中，求有多少种颜色，这些颜色在子树中出现的次数至少为 $k_j$。 解题思路树上莫队裸题。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define N 100010struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int block;struct DFN&#123; int l,r;&#125;dfn[N];int hd[N],cnt,n,m;void add(int a,int b)&#123;e[++cnt].n=hd[a],e[cnt].e=b,hd[a]=cnt;&#125;int tot=1;int count[N],seq[N];void dfs(int p)&#123; dfn[p].l=tot; seq[tot]=p; tot++; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(!dfn[q].l)dfs(q); &#125; dfn[p].r=tot-1;&#125;int getblock(int x)&#123; return x/block;&#125;struct Query&#123; int p,k,i; bool operator&lt;(const Query &amp;a)const&#123; int l=dfn[p].l,r=dfn[p].r,L=dfn[a.p].l,R=dfn[a.p].r; return getblock(l)==getblock(L)?getblock(r)&lt;getblock(R):getblock(l)&lt;getblock(L); &#125;&#125;q[N];int color[N],sum[N],a[N];void del(int x)&#123; --sum[count[color[seq[x]]]--];&#125;void add(int x)&#123; ++sum[++count[color[seq[x]]]];&#125;int ans[N];int main()&#123; int i,u,v; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;color[i]); for(i=1;i&lt;n;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v),add(v,u); dfs(1); block=n/sqrt(n); for(i=1;i&lt;=m;i++)scanf("%d%d",&amp;q[i].p,&amp;q[i].k),q[i].i=i; std::sort(q+1,q+1+m); int l=1,r=0; for(i=1;i&lt;=m;i++)&#123; int L=dfn[q[i].p].l,R=dfn[q[i].p].r; while(l&gt;L)add(--l); while(r&lt;R)add(++r); while(l&lt;L)del(l++); while(r&gt;R)del(r--); ans[q[i].i]=sum[q[i].k]; &#125; for(i=1;i&lt;=m;i++)printf("%d\n",ans[i]); return 0;&#125; C 题目描述现有一个 $n$ 个点、$m$ 条边的连通无向图，点的编号从 $1$ 起，每条边都有一个边权。图没有重边，也没有自环。 接下来对每条边单独考虑，需要重新设定这条边的边权，使得它绝对能够出现在所有的最小生成树中。 请你对每条边，在满足题意的情况下，可以重新设定的最大边权。 解题思路太神仙了。 先求出最小生成树，然后对于每一个非树边$[start,end]$必然在最小生成树内的充要条件是该边边权比最小生成树中这两点$(start,end)$之间所有边的最大值小，对于每一个树边$[start,end]$必然在最小生成树内的充要条件是该边边权比$start$为根的子树与$end$为根的子树中任意两个点之间连边的边权小。 于是问题就转化成了：对于每一个非树边，求出$[start,end]$路径中的最小值，并更新$[start,end]$路径中所有边对应答案的最小值。显然树剖可做。（就是有点难写） AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;bits/stdc++.h&gt;#define N 200010int temp[N];struct Edge&#123; int b,e,n,l,i; bool operator&lt;(const Edge&amp;a)const&#123; return l&lt;a.l; &#125;&#125;ed[N&lt;&lt;1],e[N&lt;&lt;1];int sign[N];//是否为MST边int hd[N],cnt;int n,m;void add(int a,int b,int l,int i)&#123; e[++cnt].e=b,e[cnt].b=a,e[cnt].l=l,e[cnt].i=i,e[cnt].n=hd[a],hd[a]=cnt;&#125;int F[N];int find(int x)&#123;return x==F[x]?x:F[x]=find(F[x]);&#125;struct segtree&#123; int mn,mx,l,r,lazy;&#125;t[N&lt;&lt;2];int inf=1.2e9;int dep[N],siz[N],son[N],fa[N],lento[N];int pre[N];void dfs1(int p,int f,int d)&#123; int i,mx=0; fa[p]=f; dep[p]=d; siz[p]=1; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q==f)continue; dfs1(q,p,d+1); siz[p]+=siz[q]; lento[q]=e[i].l; pre[q]=e[i].i; if(siz[q]&gt;mx)&#123; mx=siz[q]; son[p]=q; &#125; &#125;&#125;int top[N],pos[N],count;void dfs2(int p,int Top)&#123; int i; pos[p]=++count; temp[count]=lento[p]; top[p]=Top; if(!son[p])return; dfs2(son[p],Top); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q!=son[p]&amp;&amp;q!=fa[p])dfs2(q,q); &#125;&#125;void krustal()&#123; int i; for(i=1;i&lt;=n;i++)F[i]=i; for(i=1;i&lt;=m;i++)&#123; int st,fn,p=ed[i].e,q=ed[i].b; if((st=find(p))==(fn=find(q)))continue; sign[ed[i].i]=1; add(p,q,ed[i].l,ed[i].i); add(q,p,ed[i].l,ed[i].i); F[st]=fn; &#125;&#125;//segtvoid update(int p)&#123; t[p].mn=std::min(t[p&lt;&lt;1].mn,t[p&lt;&lt;1|1].mn); t[p].mx=std::max(t[p&lt;&lt;1].mx,t[p&lt;&lt;1|1].mx);&#125;void build(int p,int l,int r)&#123; t[p].l=l; t[p].r=r; t[p].mn=t[p].lazy=inf; if(l==r)&#123; t[p].mx=temp[l]; return; &#125; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); update(p);&#125;void pushdown(int p)&#123; int lazy=t[p].lazy; t[p&lt;&lt;1].mn=std::min(t[p&lt;&lt;1].mn,lazy); t[p&lt;&lt;1].lazy=std::min(t[p&lt;&lt;1].lazy,lazy); t[p&lt;&lt;1|1].mn=std::min(t[p&lt;&lt;1|1].mn,lazy); t[p&lt;&lt;1|1].lazy=std::min(t[p&lt;&lt;1|1].lazy,lazy); t[p].lazy=inf;&#125;int querymax(int p,int l,int r)&#123; int L=t[p].l,R=t[p].r; pushdown(p); if(l&lt;=L&amp;&amp;R&lt;=r)return t[p].mx; if(l&gt;R||r&lt;L)return 0; return std::max(querymax(p&lt;&lt;1,l,r),querymax(p&lt;&lt;1|1,l,r));&#125;int querymin(int p,int Pos)&#123; int L=t[p].l,R=t[p].r; pushdown(p); if(Pos==L&amp;&amp;R==Pos)return t[p].mn; if(Pos&gt;R||Pos&lt;L)return inf; return std::min(querymin(p&lt;&lt;1,Pos),querymin(p&lt;&lt;1|1,Pos));&#125;void modifymin(int p,int l,int r,int w)&#123; int L=t[p].l,R=t[p].r; pushdown(p); if(l&lt;=L&amp;&amp;r&gt;=R)&#123; t[p].mn=std::min(t[p].mn,w); t[p].lazy=std::min(t[p].lazy,w); return; &#125; if(l&gt;R||r&lt;L)return; modifymin(p&lt;&lt;1,l,r,w); modifymin(p&lt;&lt;1|1,l,r,w); update(p);&#125;//endsegtint ans[N];int rangequerymax(int x,int y)&#123; int ans=0; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])std::swap(x,y); ans=std::max(ans,querymax(1,pos[top[x]],pos[x])); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y])std::swap(x,y); return std::max(ans,querymax(1,pos[y]+1,pos[x]));//!&#125;void rangemodifymin(int x,int y,int w)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])std::swap(x,y); modifymin(1,pos[top[x]],pos[x],w); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y])std::swap(x,y); modifymin(1,pos[y]+1,pos[x],w);//!&#125;void print(int p)&#123; printf("t[%2d]:%2d %2d %2d %2d %2d\n",p,t[p].l,t[p].r,t[p].mn&gt;1000?-1:t[p].mn,t[p].mx&gt;1000?t[p].mx:-1,t[p].lazy&gt;1000?-1:t[p].lazy); if(t[p].l==t[p].r)return; print(p&lt;&lt;1); print(p&lt;&lt;1|1);&#125;int main()&#123; int i; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=m;i++)scanf("%d%d%d",&amp;ed[i].b,&amp;ed[i].e,&amp;ed[i].l),ed[i].i=i; std::sort(ed+1,ed+m+1); krustal(); dfs1(1,0,1); dfs2(1,1); build(1,1,n); for(i=1;i&lt;=m;i++)if(!sign[ed[i].i])&#123; ans[ed[i].i]=rangequerymax(ed[i].b,ed[i].e)-1; rangemodifymin(ed[i].b,ed[i].e,ed[i].l); //print(1);puts(""); &#125; for(i=2;i&lt;=n;i++)ans[pre[i]]=querymin(1,pos[i])-1; for(i=1;i&lt;=m;i++)printf("%d ",ans[i]&lt;=1e9?ans[i]:-1); return 0;&#125; D 题目描述给一棵 $n$ 个节点为红蓝两色的树，节点标号从 $1$ 开始，其中 $1$ 号节点为红色，其它节点为蓝色，要求支持如下操作： 选择一个节点变为红色 查询一个节点到最近红色节点的距离 解题思路怎么还有这种操作$.jpg$ 储存超过$sqrt(n)$个红点的时候暴力$bfs$重置，询问的时候暴力计算距离。复杂度$O(a\sqrt n+blogn)$，$a,b$分别为操作$1,2$的个数。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;#define N 100002struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int hd[N],cnt;void add(int a,int b)&#123; e[++cnt].e=b; e[cnt].n=hd[a]; hd[a]=cnt;&#125;int siz,n,m;int sta[N],top;int dis[N];queue&lt;pair&lt;int,int&gt;&gt;Q;void bfs()&#123; int i; for(i=1;i&lt;=top;i++)Q.push(make_pair(sta[i],0)),dis[sta[i]]=0; while(!Q.empty())&#123; int p=Q.front().first,d=Q.front().second+1;Q.pop(); for(i=hd[p];i;i=e[i].n) if(dis[e[i].e]&gt;d)dis[e[i].e]=d,Q.push(make_pair(e[i].e,d)); &#125; top=0;&#125;int d[N],fa[22][N],lg[N];void dfs(int now,int f)&#123; dis[now]=dis[f]+1; d[now]=d[f]+1; fa[0][now]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++)fa[i][now]=fa[i-1][fa[i-1][now]]; for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=f)dfs(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y])x=fa[lg[d[x]-d[y]]][x]; if(x==y)return x; for(i=lg[d[x]];~i;i--)if(fa[i][x]!=fa[i][y])x=fa[i][x],y=fa[i][y]; return fa[0][x];&#125;int main()&#123; int i,t,v,u; scanf("%d%d",&amp;n,&amp;m); siz=sqrt(n)+1; for(i=1;i&lt;n;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v),add(v,u); for(i=2;i&lt;=n;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); dis[0]=-1; dfs(1,0); while(m--)&#123; scanf("%d%d",&amp;t,&amp;v); if(t==1)&#123; sta[++top]=v; if(siz==top)bfs(); &#125;else&#123; int ans=dis[v]; for(i=1;i&lt;=top;i++)ans=min(ans,d[v]+d[sta[i]]-2*d[lca(v,sta[i])]); printf("%d\n",ans); &#125; &#125; return 0;&#125; E 题目描述给定一棵点权为$0/1$的，以编号 $1$ 的节点为根的树。对每个点$x$可以进行如下操作，把自己的点权异或上$1$，把自己儿子的点权异或上$0$ ， 把儿子的儿子点权异或上$1$，依次类推；即$x$子树中，距离$x$为偶数的点的点权均异或上$1$。 求最少操作次数，使得每个点的点权全部变成给定的一组目标点权。 解题思路暴力从根向下贪心即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;int n;#define N 100010struct Edge&#123; int end,near;&#125;e[N&lt;&lt;1];int cnt,head[N];void add(int a,int b)&#123; e[++cnt].end=b;e[cnt].near=head[a];head[a]=cnt;&#125;int tar[N],fir[N],ans;int sta[N];void solve(int p,int flag,int nxt,int f)&#123; int i; if((tar[p]^flag)!=fir[p])sta[ans++]=p; if(nxt==0)&#123; if(tar[p]!=fir[p])nxt=1,flag=0; &#125;else if(nxt==1)&#123; if(tar[p]!=fir[p])&#123; if(flag)flag=0; else nxt=2,flag=1; &#125;else&#123; if(flag)nxt=flag=0; else flag=1; &#125; &#125;else&#123; if(tar[p]==fir[p])flag=nxt=1; &#125; for(i=head[p];i;i=e[i].near)&#123; int q=e[i].end; if(q==f)continue; solve(q,flag,nxt,p); &#125;&#125;int main()&#123; int i,u,v; scanf("%d",&amp;n); for(i=1;i&lt;n;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v),add(v,u); for(i=1;i&lt;=n;i++)scanf("%d",&amp;fir[i]); for(i=1;i&lt;=n;i++)scanf("%d",&amp;tar[i]); solve(1,0,0,0); printf("%d\n",ans); for(i=0;i&lt;ans;i++)printf("%d\n",sta[i]); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 4 题解]]></title>
    <url>%2F2019%2F05%2F14%2F2019springtraining-4%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F 6/6 Ø Ø Ø Ø Ø Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给一个$n\times m(1\leq n,m\leq 500)$的字符矩阵，问从左上角到右下角的路径（只能往右或者下走）中，有多少个路径得到的字符串为回文串。 解题思路考虑从左上和右下角同时向中间走，记录走的步数和两端对应的横坐标。$dp[i][j][k]$表示走了$i$步，左上角走到横坐标为$x$的位置，右下角走到横坐标为$y$的位置，处理一下边界即可递推解决。（怕超空间用了一下滚动数组） AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define w 1000000007#define N 502typedef long long ll;char a[N][N];ll dp[2][N][N];int main()&#123; int n,m,i,j,k; scanf("%d%d",&amp;n,&amp;m); int mx=(n+m-2)/2,p=0; for(i=1;i&lt;=n;i++)scanf("%s",a[i]+1); dp[0][1][n]=(a[1][1]==a[n][m]); for(i=1;i&lt;=mx;i++)&#123; p^=1; memset(dp[p],0,sizeof(dp[p])); for(j=max(1,i+2-m);j&lt;=n&amp;&amp;j&lt;=i+1;j++)&#123; int x1=j,y1=i-j+2; for(k=max(1,n-i);k&lt;=n&amp;&amp;k&lt;=n+m-i;k++)&#123; int x2=k,y2=n+m-i-k; if(a[x1][y1]==a[x2][y2]) dp[p][j][k]=(dp[p^1][j-1][k]+dp[p^1][j-1][k+1]+dp[p^1][j][k]+dp[p^1][j][k+1])%w; &#125; &#125; &#125; ll ans=0; if((n+m)&amp;1)for(i=1;i&lt;=n;i++)ans+=dp[p][i][i]+dp[p][i][i+1]; else for(i=1;i&lt;=n;i++)ans+=dp[p][i][i]; printf("%I64d\n",ans%w); return 0;&#125; B 题目描述给出长度为$n\leq 500000$的数组$a_i$，可以连续或间断输出，每连续输出一串$[l,r]$，它的费用是$\sum_{i=l}^{r}a_i^2+M$，求最小花费。 解题思路观察状态转移方程$f[i]=min(f[j]+(s[i]-s[j])^2+M)=M+S[i]^2+min(f[j]+s[j]^2-s[j]*s[i])$，尝试对该方程进行优化。从前向后递推，尝试用一种方法保证每次能够$O(1)$地查询到$min$所要求的$j$。对于任意在$j$前面出现的$k$，如果$j$比$k$优，则可以彻底移除$k$。 如果$j$比$k$优：$\frac{f[j]+s[j]^2-f[k]-s[k]^2}{2(f[j]-f[k])}\leq s[i]$，考虑对任意一个位置$i$构造点$(x_i,y_i)=(f[i]+s[i]^2,2f[i])$，则$k$到$j$的线段斜率如果小于$s[i]$则必然会被排除（因为$s[i]$会越变越大，随着$i$的增加$k$永远不如$j$优）。故维护一个单调队列，这个队列的单调性在于把这些位置对应的点连接起来的斜率严格单调增。每次取队首元素，添加队尾元素，即可保证复杂度的线性。 AC代码点击 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 500010ll s[N],f[N];int q[N],hd,tl;ll getup(int x,int y)&#123;return f[x]+s[x]*s[x]-f[y]-s[y]*s[y];&#125;ll getdown(int x,int y)&#123;return 2*s[x]-2*s[y];&#125;int main()&#123; int i,n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; hd=0;tl=1; for(i=1;i&lt;=n;i++)scanf("%d",&amp;s[i]),s[i]+=s[i-1]; for(i=1;i&lt;=n;i++)&#123; while(hd+1&lt;tl&amp;&amp;getup(q[hd+1],q[hd])&lt;=s[i]*getdown(q[hd+1],q[hd]))hd++; f[i]=f[q[hd]]+m+(s[i]-s[q[hd]])*(s[i]-s[q[hd]]); while(hd+1&lt;tl&amp;&amp;getup(q[tl-1],q[tl-2])*getdown(i,q[tl-1])&gt;=getup(i,q[tl-1])*getdown(q[tl-1],q[tl-2]))tl--; q[tl++]=i; &#125; printf("%lld\n",f[n]); &#125; return 0;&#125; C 题目描述给一个$n\times m(1\leq n,m\leq 12)$的玉米田，每一行只能选择有肥料的地方种植，行之间、列之间不允许有相邻的玉米种植，问总共有多少种种法。 解题思路一看数据范围这么小肯定是状态压缩 $dp[i][S]$表示填到第$i$行，这一行状态为$S$的时候有多少种方法。 AC代码点击 12345678910111213141516171819#include&lt;cstdio&gt;typedef long long ll;#define w 100000000#define N 14ll ans,f[N][1&lt;&lt;N]=&#123;1&#125;;int m,n,state[N];int main()&#123; int i,j,k,x; scanf("%d%d",&amp;m,&amp;n); int S=1&lt;&lt;n; for(i=1;i&lt;=m;i++)for(j=1;j&lt;=n;j++) scanf("%d",&amp;x),state[i]=(state[i]&lt;&lt;1)+x; for(i=1;i&lt;=m;i++)for(j=0;j&lt;S;j++) if(!(j&amp;(j&gt;&gt;1))&amp;&amp;!(j&amp;(j&lt;&lt;1))&amp;&amp;!(j&amp;(~state[i]))) for(k=0;k&lt;S;k++)if(!(k&amp;j))(f[i][j]+=f[i-1][k])%=w; for(i=0;i&lt;S;i++)(ans+=f[m][i])%=w; printf("%I64d",ans); return 0;&#125; D 题目描述一群人编号为$1-n$坐成一圈，一个人当且仅当坐在其编号左右两个位置时是高兴的。问$n(3\leq n\leq 2000)$个人中至少让$k$个人高兴有多少种方法。 解题思路先考虑求确定有$p$个人高兴的（可重复）方法$r[p]$，则恰好有$i$个人高兴的方法用容斥可以求出：$sum[i]=\sum_{j=i}^{n}r[j]\times (n-j)!\times C_j^i\times (-1)^{i-j}$那么答案即为$ans=\sum_{i=k}^{n}sum[i]$。 这里为什么不直接令$ans=r[k]$呢？因为$r[p]$使用动归递推得出，可能会有重复计算，具体请看下文。 第一感构造$dp[i][j]$表示填了$i$个人，有$j$个高兴的个数，但发现极难转化。 这时候本题最巧妙的地方到了。 构造一个长度为$N$的环，一个个往里面填人$i$，记录下来$n,1,i$三个点是否高兴的状态进行转移。最后统计答案的时候应当在某处断开构成一个环，所以需要记录第$i+1$个人的状态，以方便与$n,1$比较，方便去重。 故$dp[bit(n)bit(1)][bit(i+1)bit(i)][i][j]$表示状态分别为表示之时，填到第$i$个人，已经有$j$个人高兴的方法。 于是$r[i]=\sum_{a=0}^{3}\sum_{b=0}^{3}(!(a&amp;1,b&amp;2)\quad and\quad!(a&amp;2,b&amp;1))dp[a][b][n][i]$。（判断条件是为了去重） 边界：$i=1$的时候，$bit(1)=bit(i)$，故$dp[0][0][1][0]=1$（都不高兴），$dp[2][0][1][1]=1$（第$n$个人高兴），$dp[0][2][1][1]=1$（第$i+1$个人高兴），$dp[1][1][1][1]=1$（第$1$个人高兴）。 转移： $dp[a][b][i][j]$可以加一个人什么都不做转移到$dp[a][b&gt;&gt;1][i+1][j]$ $dp[a][b][i][j]$可以加一个人使得第$i+2$个人高兴，转移到$dp[a][(1&lt;&lt;1)|(b&gt;&gt;1)][i+1][j+1]$ 如果第$i$个人没有确定高兴，则$dp[a][b][i][j]$可以加一个人使得第$i$个人高兴，转移到$dp[a][b&gt;&gt;1][i+1][j+1]$，这里特判一下$i=1$的情况即可。 如果第$i+1$个人没有确定高兴，则$dp[a][b][i][j]$可以加一个人使得第$i+1$个人高兴，转移到$dp[a][1][i+1][j+1]$ 就结束了。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;typedef long long ll;#define N 2010ll w=1000000007,inv[N]=&#123;1&#125;,fac[N]=&#123;1&#125;;ll qp(ll a,ll b)&#123; ll ans=1; for(;b;b&gt;&gt;=1,a=a*a%w)if(b&amp;1)ans=ans*a%w; return ans;&#125;ll c(int n,int m)&#123;return fac[n]*inv[m]%w*inv[n-m]%w;&#125;ll dp[4][4][N][N];void add(ll &amp;a,ll b)&#123;(a+=b)%=w;if(a&lt;0)a+=w;&#125;void init()&#123; int i,j,a,b; for(i=1;i&lt;2001;i++)fac[i]=fac[i-1]*i%w,inv[i]=qp(fac[i],w-2); dp[0][0][1][0]=dp[2][0][1][1]=dp[1][1][1][1]=dp[0][2][1][1]=1; for(i=1;i&lt;2001;i++)&#123; for(j=0;j&lt;=i;j++)&#123; for(a=0;a&lt;4;a++)&#123; for(b=0;b&lt;4;b++)&#123; ll t=dp[a][b][i][j];if(!t)continue; add(dp[a][b&gt;&gt;1][i+1][j],t); if((b&amp;1)==0)&#123; if(i==1)add(dp[a|1][b&gt;&gt;1][i+1][j+1],t); else add(dp[a][b&gt;&gt;1][i+1][j+1],t); &#125; if((b&amp;2)==0)add(dp[a][1][i+1][j+1],t); add(dp[a][2|(b&gt;&gt;1)][i+1][j+1],t); &#125; &#125; &#125; &#125;&#125;ll r[N];int main()&#123; int i,j,a,b,T,n,k,cas=0; scanf("%d",&amp;T); init(); while(~scanf("%d%d",&amp;n,&amp;k))&#123; ll ans=0; for(j=k;j&lt;=n;j++)&#123; r[j]=0; for(a=0;a&lt;4;a++)for(b=0;b&lt;4;b++) if((a&amp;1)&amp;&amp;(b&amp;2)||(a&amp;2)&amp;&amp;(b&amp;1)); else add(r[j],dp[a][b][n][j]); &#125; for(i=k;i&lt;=n;i++)&#123; for(j=i;j&lt;=n;j++) add(ans,((j-i)&amp;1?-1:1)*(r[j]*fac[n-j]%w*c(j,i)%w)); &#125; printf("Case %d: %lld\n",++cas,ans); &#125; return 0;&#125; E 题目描述定义一个区间的价值为该区间中两两相等的元素个数。给一个长度为$n(2\leq n\leq 10^5)$的序列，把它分成$k(2\leq k\leq min(n,20))$段，求最小总价值。 解题思路设$dp[i][j]$表示选了前$i$个数，分成$j$段的最小总价值。则$dp[i][j]=min(dp[k][j-1]+w(k+1,i))$，$w(l,r)$表示$[l,r]$区间内的价值总和。 很明显，$i_1&gt;i_2$时，设决策点分别为$k_1,k_2$，则有$k_1\geq k_2$，即有决策单调性。 于是考虑分治求$dp$，从小到大枚举分成的段数进行$dp$，记当前计算区间为$[l,r]$，决策所在区间为$[L,R]$ ，则枚举$[L,R]$中的元素找到决策值$nxt$，分别计算$[l,mid-1]$（对应决策区间$[L,nxt]$）和$[mid+1,r]$（对应决策区间$[nxt,R]$）即可。时间复杂度$O(nklogn)$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010int n,k,a[N];ll dp[N][22];int buc[N],pL,pR;ll nowans;void upd(int x,ll f)&#123; nowans+=f*buc[x]*(buc[x]-1)/2;&#125;ll calc(int l,int r)&#123; while(pL&lt;l)&#123; upd(a[pL],-1);buc[a[pL]]--; upd(a[pL],1);pL++; &#125; while(r&lt;pR)&#123; upd(a[pR],-1);buc[a[pR]]--; upd(a[pR],1);pR--; &#125; while(l&lt;pL)&#123; pL--; upd(a[pL],-1);buc[a[pL]]++; upd(a[pL],1); &#125; while(pR&lt;r)&#123; pR++; upd(a[pR],-1);buc[a[pR]]++; upd(a[pR],1); &#125; return nowans;&#125;void solve(int p,int L,int R,int l,int r)&#123; if(l&gt;r||L&gt;R)return; int i,mid=(l+r)&gt;&gt;1,nxt=0; ll &amp;ans=dp[mid][p]; for(i=L;i&lt;=R;i++)&#123; ll tmp=calc(i+1,mid); if(tmp+dp[i][p-1]&lt;ans)ans=tmp+dp[i][p-1],nxt=i; &#125; solve(p,L,nxt,l,mid-1); solve(p,nxt,R,mid+1,r);&#125;int main()&#123; int i; memset(dp,0x3f,sizeof(dp)); dp[0][0]=0; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); buc[a[1]]++;pL=pR=1; for(i=1;i&lt;=k;i++)solve(i,0,n-1,1,n); printf("%lld",dp[n][k]); return 0;&#125; F 题目描述给一个树每一个节点染黑白色，问恰好染$k$个黑色之后黑色点两两之间距离之和与白色点两两之间距离之和的和最大为多少。 解题思路这个树形$DP$很妙，可以找每一条边的贡献。用$f[i][j]$表示节点$i$的子树当前已经选择了$j$个黑色节点时当前节点已枚举子树中所有边对答案的贡献之和。 AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 2010struct Edge&#123; int e,n;ll l;&#125;e[N&lt;&lt;1];int hd[N],cnt;void add(int a,int b,ll l)&#123; e[++cnt]=(Edge)&#123;b,hd[a],l&#125;;hd[a]=cnt;&#125;int siz[N],n,k;ll f[N][N];void dfs(int x,int fa)&#123; int i,j,l; siz[x]=1; for(i=hd[x];i;i=e[i].n)&#123; int q=e[i].e; if(q==fa)continue; dfs(q,x); for(j=min(siz[x],k);j&gt;=0;j--) for(l=min(k-j,siz[q]);l&gt;=0;l--) f[x][j+l]=max(f[x][j+l],f[x][j]+f[q][l]+e[i].l*(1LL*(siz[q]-l)*(n-k+l-siz[q])+1LL*l*(k-l))); siz[x]+=siz[q]; &#125;&#125;int main()&#123; int i,u,v;ll w; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;n;i++)scanf("%d%d%lld",&amp;u,&amp;v,&amp;w),add(u,v,w),add(v,u,w); dfs(1,0); printf("%lld",f[1][k]); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 3 题解]]></title>
    <url>%2F2019%2F05%2F12%2F2019springtraining-3%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F 7/7 O O O Ø O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给一个串，求出是这个串前缀也是其后缀的所有子串，按照长度递增顺序输出长度和在该串中出现的次数。 解题思路用$kmp$算法求出$next(pre)$数组，那么沿着串最后跑$next$边得到的即是既是前缀也是后缀的串。统计个数的时候，每次可以匹配（前缀等于某个子串，即到某个位置时的后缀）时，都进行计数。最后从后往前沿$next$累加个数即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;cstring&gt;#define N 200005struct Ans&#123; int num,pos;&#125;ans[N];char b[N];int pre[N],cnt[N];int main()&#123; int i; scanf("%s",b); int len=strlen(b); for(i=1;i&lt;len;i++)&#123; int p=pre[i]; while(b[i]!=b[p]&amp;&amp;p)p=pre[p]; if(b[p]==b[i])pre[i+1]=p+1; else pre[i+1]=0; &#125; for(i=1;i&lt;len;i++)&#123; int p=pre[i]; while(b[i]!=b[p]&amp;&amp;p)p=pre[p]; if(b[p]==b[i])cnt[++p]++; &#125; for(i=len;i&gt;=0;i--)if(pre[i])cnt[pre[i]]+=cnt[i]; int now=len,p=0; while(now)&#123; ans[p++]=(Ans)&#123;cnt[now],now&#125;; now=pre[now]; &#125; printf("%d\n",p); for(i=p-1;i&gt;=0;i--)printf("%d %d\n",ans[i].pos,ans[i].num+1); return 0;&#125; B 题目描述给$n$个只由$abc$构成的模式串，$m$个询问串，每次询问该串是否能恰好改变一个位置的字符恰好与模式串中的某一个相等。 解题思路可以暴力用哈希做，枚举长度和改变的数值，调调参即可。 这东西$mod$和$base$凡是涉及到$19260817$老是$WA$，看来还是不能乱$%$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 600010#define BASE 257#define mod 1000000007set&lt;ll&gt;s;char a[N];ll h()&#123; int i,l=strlen(a); ll now=0; for(i=0;i&lt;l;i++)now=(now*BASE+a[i])%mod; return now;&#125;ll pw[N]=&#123;1&#125;;int jud()&#123; int i,j,l=strlen(a); ll hash=h(); for(i=0;i&lt;l;i++) for(j='a';j&lt;='c';j++) if(j!=a[i]&amp;&amp;s.find(((hash+(j-a[i])*pw[l-i-1]%mod)%mod+mod)%mod)!=s.end())return 1; return 0;&#125;int main()&#123; int i,n,m; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;N;i++)pw[i]=pw[i-1]*BASE%mod; for(i=0;i&lt;n;i++) scanf("%s",a),s.insert(h()); for(i=0;i&lt;m;i++)&#123; scanf("%s",a); if(jud())printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; C 题目描述字符集大小为$4$，给一堆串作为子串时的权值（可为负），问长为$l$的字符串权值（初始为零，某一个带权子串出现则加上该串对应权值，但只能加一次）最大是多少。 解题思路在$AC$自动机上跑动态规划，$dp[i][j][S]$表示跑到串的第$i$个字符，在$AC$自动机上的节点为$j$，包含的带权字符串集合为$S$这个状态存在不存在。注意状态压缩和滚动数组。注意$ed$在$build$的时候需要根据$fail$更新。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 110#define M 1005int trans[520],dp[2][M][(1&lt;&lt;10)+10];char a[N];int tr[M][4],ed[M],fail[M],tot,score[N],number;void insert()&#123; int i,now=0; for(i=0;a[i];i++)&#123; int p=trans[(int)a[i]]; if(!tr[now][p])&#123; tr[now][p]=++tot; memset(tr[tot],0,sizeof(tr[tot])); &#125; now=tr[now][p]; &#125; ed[now]|=1&lt;&lt;number;&#125;queue&lt;int&gt;Q;void build()&#123; int i,p; for(i=0;i&lt;4;i++)if(tr[0][i])Q.push(tr[0][i]); while(!Q.empty())&#123; p=Q.front();Q.pop(); for(i=0;i&lt;4;i++)&#123; int now=tr[p][i]; if(!now)tr[p][i]=tr[fail[p]][i]; else fail[now]=tr[fail[p]][i],Q.push(now),ed[now]|=ed[fail[now]]; &#125; &#125;&#125;int n,m;int f(int x)&#123; int i,ret=0; for(i=0;i&lt;n;i++) if(x&amp;(1&lt;&lt;i))ret+=score[i+1]; return ret;&#125;int main()&#123; int i,j,k,l; trans['A']=0;trans['G']=1;trans['C']=2;trans['T']=3; while(~scanf("%d%d",&amp;n,&amp;m))&#123; memset(ed,0,sizeof(ed)); memset(fail,0,sizeof(fail)); memset(tr[0],0,sizeof(tr[0])); tot=0; for(i=0;i&lt;n;i++)&#123; number=i; scanf("%s%d",a,&amp;score[i+1]); insert(); &#125; build(); memset(dp,0,sizeof(dp)); dp[0][0][0]=1; int ret=-100,p=1; for(i=0;i&lt;m;i++)&#123; p^=1; memset(dp[p^1],0,sizeof(dp[p^1])); for(j=0;j&lt;=tot;j++)for(k=0;k&lt;1&lt;&lt;n;k++) if(dp[p][j][k]) for(l=0;l&lt;4;l++)dp[p^1][tr[j][l]][k|ed[tr[j][l]]]=1; &#125; for(j=0;j&lt;=tot;j++)for(k=0;k&lt;1&lt;&lt;n;k++) if(dp[p^1][j][k])ret=max(ret,f(k)); if(ret&gt;=0)printf("%d\n",ret); else printf("No Rabbit after 2012!\n"); &#125; return 0;&#125; D 题目描述问一个串中是否存在两个不相交的长度均为$k$的子串，使得串$T$为他们拼起来后串的子串。 解题思路分别从后向前、从前向后递推地求后缀的前缀和前缀的后缀，没处理到的情况特殊判断一下（在$k$之内）即可。注意特判$k&gt;m$（手动再见.jpg） AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;typedef long long ll;#define N 1000021#define BASE 257#define mod 1000000007char a[N],b[N];ll hsa[N],hsb[N],pw[N]=&#123;1&#125;;int n,m,k;void hashf(char c[],int l,ll *h)&#123; int i; for(i=1;i&lt;=l;i++)h[i]=(h[i-1]*BASE+c[i])%mod;&#125;int l[N],r[N];int main()&#123; int i; //freopen("in.txt","r",stdin); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); scanf("%s%s",a+1,b+1); for(i=1;i&lt;=n;i++)pw[i]=pw[i-1]*BASE%mod; hashf(a,n,hsa);hashf(b,m,hsb); for(i=m;i&lt;=n;i++)&#123; if((hsa[i]-hsa[i-m]*pw[m]%mod-hsb[m])%mod==0)&#123; if(i+k&lt;=n)return printf("Yes\n%d %d",i-m+1,i-m+k+1),0; else if(m&lt;k)&#123;//i-m~i int x=1; while(x+k+k-1&lt;i)x++; if(x+k+k-1&lt;=n)return printf("Yes\n%d %d",x,x+k),0; &#125; &#125; &#125; int p=k; for(i=1;i&lt;=m&amp;&amp;i&lt;=k;i++)&#123; while(p&lt;i)p++; while(p&lt;=n)if((hsa[p]-hsa[p-i]*pw[i]%mod-hsb[i])%mod==0)break;else p++; if((hsa[k]-hsa[k-i]*pw[i]%mod-hsb[i])%mod==0)p=k; l[i]=p; &#125; p=n-k+1; for(i=m;i&gt;=0;i--)&#123; int len=m-i+1; while(n-p+2&lt;len)p--; while(p&gt;0)if((hsa[p+len-1]-hsa[p-1]*pw[len]%mod-hsb[m]+hsb[i-1]*pw[len]%mod)%mod==0)break;else p--; if((hsa[n-k+len]-hsa[n-k]*pw[len]%mod-hsb[m]+hsb[i-1]*pw[len]%mod)%mod==0)p=n-k+1; r[i]=p; &#125; for(i=std::max(0,m-k);i&lt;=m;i++) if(l[i]&gt;=k&amp;&amp;r[i+1]&lt;=n-k+1&amp;&amp;l[i]&amp;&amp;r[i+1]&amp;&amp;l[i]&lt;r[i+1]) return printf("Yes\n%d %d",l[i]-k+1,r[i+1]),0; printf("No"); return 0;&#125; E 题目描述给一个模式串，给出匹配半径，求匹配串能够匹配的位置个数。 解题思路用四个$bitset$保存$ATGC$分别可以在哪里出现，使用差分求出这四个$bitset$。 接下来就是暴力匹配，复杂度可以勉强卡过去。题目很类似于buaa summer practice 2017 字符串专场中的$C$题。 听说正解是$FFT$，看来还是要学习一个。 AC代码点击 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define N 200010using namespace std;bitset&lt;N&gt;b[4],now;char s[N],t[N];int trans[500];int tmp[4][N];int main()&#123; int i,j,n,m,k; trans['A']=0;trans['G']=1;trans['C']=2;trans['T']=3; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); scanf("%s%s",s,t); for(i=0;i&lt;n;i++)&#123; tmp[trans[(int)s[i]]][max(i-k,0)]++; tmp[trans[(int)s[i]]][min(i+k+1,n)]--; &#125; for(i=0;i&lt;=n;i++) for(j=0;j&lt;4;j++)&#123; if(i)tmp[j][i]+=tmp[j][i-1]; if(tmp[j][i]&gt;0)b[j][i]=1; else b[j][i]=0; &#125; for(i=0;i&lt;n-m+1;i++)now[i]=1; for(i=0;i&lt;m;i++)&#123; int p=trans[(int)t[i]]; now&amp;=b[p]; now&lt;&lt;=1; now[0]=0; &#125; printf("%d",now.count()); return 0;&#125; $upd:$会用$FFT$辣！ 分成$ATGC$四部分解决，设$a[i]$表示第$i$位能否匹配当前字符$c$（$0/1$），很容易用差分求出该数组。再设$b[i]=(t[i]==c)$，于是$tot[i]=\sum_{j=0}^{m-1}b[j]\times a[i+j]$表示字符$c$在$i$位能够匹配多少个字符。 考虑把上面的式子转化成卷积的形式。 翻转字符串$T$，设$b[i]=(t[m-1-i]==c)$，则有$tot[i]=\sum_{j=0}^{m-1}b[m-1-j]\times a[i+j]=(b\times a)[i+m-1]$，$FFT$求出即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;typedef long long ll;struct complex&#123; double x,y; complex(double xx=0,double yy=0)&#123;x=xx;y=yy;&#125; complex operator+(const complex a)const&#123;return &#123;x+a.x,y+a.y&#125;;&#125; complex operator-(const complex a)const&#123;return &#123;x-a.x,y-a.y&#125;;&#125; complex operator*(const complex a)const&#123;return &#123;x*a.x-y*a.y,x*a.y+y*a.x&#125;;&#125;&#125;;#define N 800010complex a[N],b[N],wn1,wnk;int m,n,mx,limit;char s[N],t[N];int r[N];void fft(complex *F,int sign)&#123; int i,j,len; for(i=0;i&lt;limit;i++)if(i&lt;r[i])std::swap(F[r[i]],F[i]); for(len=1;len&lt;limit;len&lt;&lt;=1)&#123; wn1=complex(cos(acos(-1)/len),sign*sin(acos(-1)/len)); for(j=0;j&lt;limit;j+=(len&lt;&lt;1))&#123; wnk=complex(1,0); for(i=j;i&lt;j+len;i++)&#123; complex t=F[i+len]*wnk; F[i+len]=F[i]-t; F[i]=F[i]+t; wnk=wnk*wn1; &#125; &#125; &#125; if(sign==-1)for(i=0;i&lt;limit;i++)F[i].x/=limit;&#125;int tot[N],ans,k;void calc(char c)&#123; int i; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); for(i=0;s[i];i++)if(s[i]==c)a[std::max(i-k,0)].x++,a[i+k+1].x--; for(i=1;s[i];i++)a[i].x+=a[i-1].x; for(i=1;s[i];i++)a[i].x=!!a[i].x; for(i=0;t[i];i++)b[i].x=(t[i]==c); fft(a,1);fft(b,1); for(i=0;i&lt;limit;i++)a[i]=a[i]*b[i]; fft(a,-1); for(i=0;i&lt;n;i++)tot[i]+=(int)(0.5+a[i+m-1].x);&#125;int main()&#123; int i; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); scanf("%s%s",s,t); std::reverse(t,t+m); mx=m+n,limit=1; while(limit&lt;=mx)limit&lt;&lt;=1; for(i=0;i&lt;=limit;i++)r[i]=(r[i/2]/2)|((i&amp;1)?limit&gt;&gt;1:0); calc('A');calc('T');calc('G');calc('C'); for(i=0;i&lt;n;i++)if(tot[i]&gt;=m)ans++; printf("%d",ans); return 0;&#125; F 题目描述求一个串的最长回文子串长度。 解题思路签到题，打一遍马拉车的板子即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 1000010char s[2*N]=&#123;',','#'&#125;,a[N];int len[2*N],maxright,mid,max,l,i,cnt;int mn(int x,int y)&#123;return x&gt;y?y:x;&#125;int main()&#123; int cas=0; while(~scanf("%s",a))&#123; max=maxright=0; if(strcmp(a,"END")==0)break; cnt=2; int l=strlen(a); for(i=0;i&lt;l;i++)&#123; s[cnt++]=a[i]; s[cnt++]='#'; &#125; s[cnt]='\0'; for(i=1;i&lt;cnt;i++)&#123; if(i&lt;maxright)len[i]=mn(len[mid*2-i],maxright-i); else len[i]=1; while(s[i-len[i]]==s[i+len[i]])len[i]++; if(len[i]+i&gt;maxright)&#123; maxright=len[i]+i; mid=i; &#125; if(len[i]-1&gt;max)max=len[i]-1; &#125; printf("Case %d: %d\n",++cas,max); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vjudge297843-BUAA Summer Practice 2017 1 字符串专场 题解]]></title>
    <url>%2F2019%2F05%2F11%2Fbuaa2017string%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M 8/13 O O O . O . O O . . O O . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 密码：buaa A 题目描述问长度为$n$，给定的$m$个字符串都为$a$的连续子串的字符串$a$有多少种。 $1\leq n\leq 25,0\leq m\leq 10$ 解题思路看到$n,m$很小（$1&lt;&lt;10=1024$），很容易想到建立$AC$自动机进行爆搜记忆化搜索。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define N 105typedef long long ll;using namespace std;char a[25];int n,m,trie[N][26],fail[N],sign[N],tot;void add(int x)&#123; int now=0,i; for(i=0;a[i];i++)&#123; int p=a[i]-'a'; if(!trie[now][p])trie[now][p]=++tot; now=trie[now][p]; &#125; sign[now]|=1&lt;&lt;x;&#125;queue&lt;int&gt;Q;void build()&#123; int i,pos; for(i=0;i&lt;26;i++)if(trie[0][i])Q.push(trie[0][i]); while(!Q.empty())&#123; pos=Q.front();Q.pop(); for(i=0;i&lt;26;i++)&#123; if(trie[pos][i])&#123; fail[trie[pos][i]]=trie[fail[pos]][i]; Q.push(trie[pos][i]); sign[trie[pos][i]]|=sign[fail[trie[pos][i]]]; &#125;else trie[pos][i]=trie[fail[pos]][i]; &#125; &#125;&#125;ll f[27][N][1030];//f[len][pos][state]ll dp(int len,int state,int pos)&#123; ll &amp;ans=f[len][pos][state]; if(~ans)return ans; if(len==n)return ans=state==(1&lt;&lt;m)-1; int i; ans=0; for(i=0;i&lt;26;i++) ans+=dp(len+1,state|sign[trie[pos][i]],trie[pos][i]); return ans;&#125;char out[30];void print(int len,int state,int pos)&#123; if(len==n)&#123; fwrite(out,sizeof(out[0]),n,stdout); puts(""); return; &#125; int i; for(i=0;i&lt;26;i++)&#123; out[len]=i+'a'; if(f[len+1][trie[pos][i]][state|sign[trie[pos][i]]]&gt;0) print(len+1,state|sign[trie[pos][i]],trie[pos][i]); &#125;&#125;int main()&#123; int i,t=0; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;(n|m))&#123; t++; memset(trie,0,sizeof(trie)); memset(fail,0,sizeof(fail)); memset(f,-1,sizeof(f)); memset(sign,0,sizeof(sign)); tot=0; for(i=0;i&lt;m;i++)scanf("%s",a),add(i); build(); ll ans=dp(0,0,0); printf("Case %d: %lld suspects\n",t,ans); if(ans&lt;=42)print(0,0,0); &#125; return 0;&#125; B 题目描述给定一个字符串的马拉车$len$数组和后缀数组$sa$，求还原字典序最小的原串。 解题思路主要思路是，把每一个排名的数值视为一个点，具有相同的字符的多个位置用并查集缩成一个点，不等的之间连接边（这里从对应字符大的点到小的点连边）。有一点有趣的性质是，$sa$数组所对应的字符必然是单调不减的，于是可以设法找出每一个断点的位置。 所以根据马拉车$len$数组模仿跑一边马拉车，缩点连边，最后用$sa$数组进一步求出解。 这题的麻烦之处就在于各种地方不存在的判断。 具体的实现过程： 设$suffix(x)$为$s[x…n]$。 $Case 1$：$s[sa[i]]\leq s[sa[i+1]]$，而当等号不可能成立时必然有$rk[sa[i]+1]&gt;rk[sa[i+1]+1]$，此时需要连接$i+1,i$。 $Case 2$：跑马拉车回文串时，每次仍然只向外扩展未知字符并缩点。可以证明的是，这样保证了线性的复杂度，而并不会影响解的正确性。 每次向外扩展的时候，把左右两点缩成一点。 扩展完之后，把左右两点连边，并注意扩展的位置的合理性。 $Case 3$：最后从$rk$低到高填字符，并延必需边寻找最小可用字符，并判断点所处集合的合理性。 AC代码-人傻自带大常数，4792ms点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define N 100005typedef long long ll;using namespace std;int sa[N],rk[N],len[N&lt;&lt;1];char s[N];int hd[N],cnt,f[N];int find(int x)&#123;return x==f[x]?f[x]:f[x]=find(f[x]);&#125;struct Edge&#123; int e,n;&#125;e[N&lt;&lt;2];void add(int a,int b)&#123;e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;inline void scan(int &amp;x)&#123; register int ch; while((ch=getchar())&lt;'0'||ch&gt;'9'); for(x=ch-'0';(ch=getchar())&gt;='0'&amp;&amp;ch&lt;='9';x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch-'0'));&#125;int n,mr,mid;int solve()&#123; mr=1; int i,j,k,l,r,now,u,v; for(i=2;i&lt;=n&lt;&lt;1;i++)&#123; if(mr&gt;i)now=min(mr-i,len[(mid&lt;&lt;1)-i]+1); else now=0; if(now&gt;len[i]+1||i-len[i]&lt;1||i+len[i]&gt;(n&lt;&lt;1|1))return 0; l=i-now;r=i+now; for(;now&lt;=len[i];now++,l--,r++)&#123; if((l&amp;1)||l&gt;=r)continue; u=rk[l&gt;&gt;1],v=rk[r&gt;&gt;1]; if(u&gt;v)u^=v^=u^=v; u=find(u),v=find(v); while(u&lt;v)&#123; for(j=hd[u];j;j=e[j].n)if(u&lt;e[j].e)return 0; v=f[v]=find(v-1); &#125; &#125; if(l&gt;=2&amp;&amp;r&lt;=n&lt;&lt;1&amp;&amp;(l&amp;1)==0)&#123; u=rk[l&gt;&gt;1],v=rk[r&gt;&gt;1]; if(u&gt;v)add(u,v); else add(v,u); &#125;else if(l&amp;1)return 0; if(mr&lt;i+now)mr=i+now,mid=i; &#125; char mn='a',cur; for(i=1;i&lt;=n;i++)&#123; cur=mn; j=i+1; while(j&lt;=n&amp;&amp;find(i)==find(j))j++; for(k=i;k&lt;j;k++)&#123; for(l=hd[k];l;l=e[l].n)&#123; if(cur&lt;=s[sa[e[l].e]])cur=s[sa[e[l].e]]+1; if(find(e[l].e)==find(i))return 0; &#125; &#125; if(cur&gt;'z')return 0; while(i&lt;j)s[sa[i++]]=cur; mn=cur;i--; &#125; s[n+1]='\0'; return 1;&#125;int main()&#123; int i,T,cas=0; scan(T); while(T--)&#123; cnt=0; scan(n); memset(hd,0,sizeof(int)*(n+1)); for(i=1;i&lt;=n;i++)&#123; scan(sa[i]);sa[i]++; rk[sa[i]]=i; f[i]=i; &#125; rk[n+1]=-1; for(i=2;i&lt;=n;i++)if(rk[sa[i-1]+1]&gt;rk[sa[i]+1])add(i,i-1); len[0]=-1;len[1]=len[n&lt;&lt;1|1]=0; for(i=2;i&lt;=n&lt;&lt;1;i++)scan(len[i]); printf("Case #%d: ",++cas); if(solve())printf("%s\n",s+1); else printf("Wrong calculation!\n"); &#125; return 0;&#125; 然后看到$tls$也是这么做的，但是才跑了$500ms$，$%%%$ AC代码-tls,502ms点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;const int maxn=100010,maxs=26;int t,n,sa[maxn],rk[maxn],ma[maxn&lt;&lt;1],tot,lnk[maxn],fa[maxn];char str[maxn];struct Edge&#123; int nxt,v;&#125;e[maxn&lt;&lt;2];inline void scan(int &amp;x)&#123; register int ch; while((ch=getchar())&lt;'0'||ch&gt;'9'); for(x=ch-'0';(ch=getchar())&gt;='0'&amp;&amp;ch&lt;='9';x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch-'0'));&#125;int find(int x)&#123; return x==fa[x]?x:fa[x]=find(fa[x]);&#125;int main()&#123; scan(t); for(int Case=1;Case&lt;=t;++Case)&#123; scan(n); tot=0; memset(lnk,-1,n*sizeof(int)); for(int i=0;i&lt;n;++i)&#123; scan(sa[i]); rk[sa[i]]=i; fa[i]=i; &#125; rk[n]=-1; for(int i=1;i&lt;n;++i) if(rk[sa[i-1]+1]&gt;rk[sa[i]+1])&#123; e[tot]=(Edge)&#123;lnk[i],i-1&#125;; lnk[i]=tot++; &#125; ma[0]=-1; ma[1]=ma[n&lt;&lt;1|1]=0; for(int i=2;i&lt;=n&lt;&lt;1;++i) scan(ma[i]); bool flag=1; for(int i=2,mx=1,id=1;i&lt;=n&lt;&lt;1&amp;&amp;flag;++i)&#123; int cur=mx&gt;i?std::min(mx-i,ma[(id&lt;&lt;1)-i]+1):0,pL,pR; flag&amp;=cur&lt;=ma[i]+1&amp;&amp;i-ma[i]&gt;0&amp;&amp;i+ma[i]&lt;n+1&lt;&lt;1; for(pL=i-cur,pR=i+cur;cur&lt;=ma[i]&amp;&amp;flag;++cur,--pL,++pR) if((~pL&amp;1)&amp;&amp;pL&lt;pR)&#123; int u=rk[(pL&gt;&gt;1)-1],v=rk[(pR&gt;&gt;1)-1]; if(u&gt;v) std::swap(u,v); for(u=find(u),v=find(v);u&lt;v&amp;&amp;flag;v=find(v))&#123; for(int it=lnk[v];it!=-1&amp;&amp;flag;it=e[it].nxt) flag&amp;=e[it].v&lt;u; fa[v]=find(v-1); &#125; &#125; if((flag&amp;=(~pL&amp;1))&amp;&amp;pL&gt;=2&amp;&amp;pR&lt;=n&lt;&lt;1)&#123; pL=rk[(pL&gt;&gt;1)-1]; pR=rk[(pR&gt;&gt;1)-1]; if(pL&gt;pR) std::swap(pL,pR); e[tot]=(Edge)&#123;lnk[pR],pL&#125;; lnk[pR]=tot++; &#125; if(mx&lt;i+cur)&#123; mx=i+cur; id=i; &#125; &#125; char last='a'; for(int i=0,j=0;i&lt;n&amp;&amp;flag;i=j)&#123; char cur=last; for(++j;j&lt;n&amp;&amp;find(i)==find(j);++j); for(int k=i;k&lt;j&amp;&amp;flag;++k) for(int it=lnk[k];it!=-1&amp;&amp;flag;it=e[it].nxt) if(find(e[it].v)==find(i)) flag=0; else if(cur&lt;=str[sa[e[it].v]]) cur=str[sa[e[it].v]]+1; if(cur&gt;'z') flag=0; else&#123; for( ;i&lt;j;++i) str[sa[i]]=cur; last=cur; &#125; &#125; str[n]='\0'; if(!flag) printf("Case #%d: Wrong calculation!\n",Case); else printf("Case #%d: %s\n",Case,str); &#125; return 0;&#125; C 题目描述如果一个长度为$n$的字符串$a$满足：对于任意$0&lt; i\leq |n|$，$a_i$属于集合$S_i$，则其是一个合法的串。 给定字符串$a$，集合$S_i(1\leq i\leq n)$，按读入顺序输出$a$中所有合法的连续子串。 $1\leq n \leq 1000,|a|\leq 5\times 10^6$。 解题思路看起来$|a|$比较大，似乎应当用一种比较快速、尽量能递推解决的算法解决。 构造一个$bitset$数组$b$，存放每一个元素$x$允许出现的位置$pos$，即对于每一个合法的位置，有$b[x][pos]=1$。 再构造一个$bitset$存储当前匹配状态$now$，每一次$now$左移$1$（代表开始匹配下一位），最低位设置成$1$（还未判断匹配情况），位运算进行匹配（与对应$b[x]$进行与运算），则如果$now$的第$n$位为$1$，就说明已经匹配成功，输出即可。 AC代码点击 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;bitset&gt;using namespace std;char c[5000001],t;bitset&lt;1001&gt;b[11],now;int main()&#123; int i,n,k,a; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;k); while(k--)scanf("%d",&amp;a),b[a][i]=1; &#125; scanf("%s",c); for(i=0;c[i];i++)&#123; ((now&lt;&lt;=1).set(0))&amp;=b[c[i]-'0']; if(now[n-1])fwrite(c+i-n+1,sizeof(c[0]),n,stdout),putchar('\n'); &#125; return 0;&#125; D 题目描述解题思路AC代码点击 12 E 题目描述给一个长度$1\leq N\leq 5\times 10^5$的串。每次从头扯下来一个字符粘到尾端，进行$k$次这样的操作（$0\leq k&lt;N$），输出每次操作后串中最长回文子串的长度。 解题思路首先想到的办法是，建立一棵回文树，每次添加一个节点，并用一个堆保存当前回文串的位置、长度、回文树中的节点标号，每次被弹出堆的时候，沿$fail$边走并入堆。然而很不幸的是，这样无法保证时间复杂度，$26$个点只过了$18$个，剩下的都$T$掉了。 TLE代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;typedef struct node&#123; int xb,len,i; bool operator&lt;(const node&amp;a)const&#123;return len&lt;a.len;&#125;&#125;nd;priority_queue&lt;nd&gt;Q;#define N 500005#define M 26int length;struct PT&#123; int tr[N][M],fail[N],len[N]; int tot,s[N],n,last,i; int newnode(int l)&#123; for(i=0;i&lt;M;i++)tr[tot][i]=0; len[tot]=l; return tot++; &#125; void init()&#123; n=last=tot=0; newnode(0);newnode(-1); s[0]=-1; fail[0]=1; &#125; int getfail(int po,int p)&#123; while(s[n-len[p]-1]!=s[n]||len[p]+2&gt;length)p=fail[p]; return p; &#125; void add(int po,int p)&#123; s[++n]=p; int cur; cur=getfail(po,last); last=fail[cur]; if(!tr[cur][p])&#123; int now=newnode(len[cur]+2),temp=getfail(po,fail[cur]); fail[now]=tr[temp][p]; tr[cur][p]=now; &#125; last=tr[cur][p]; Q.push((nd)&#123;tr[cur][p],len[tr[cur][p]],po&#125;); &#125;&#125;p;char a[N];int main()&#123; int i; p.init(); scanf("%d",&amp;length); scanf("%s",a); for(i=0;a[i];i++) p.add(i,a[i]-'a'); for(i=0;a[i];i++)&#123; nd t=Q.top(); printf("%d\n",Q.top().len); p.add(i+length,a[i]-'a'); t=Q.top(); while(t.i-t.len&lt;i)&#123; Q.pop(); while(-p.len[p.fail[t.xb]]+t.i&lt;i&amp;&amp;t.len&gt;1) t=(nd)&#123;p.fail[t.xb],p.len[p.fail[t.xb]],t.i&#125;; if(t.len&gt;1)Q.push((nd)&#123;p.fail[t.xb],p.len[p.fail[t.xb]],t.i&#125;); if(Q.empty())break; t=Q.top(); &#125; &#125; return 0;&#125; 过后，想到了一种暴力办法：直接复制串到串的后面，跑一遍马拉车，记录下以某个点为中心的奇数、偶数回文串的长度，分奇偶解决，解决的时候长度从大到小、位置从大到小枚举，记录只最靠后的超出范围的回文串的中心位置$full$，每次根据$full$和$set$中的合法答案更新答案即可。 发现从前往后一上来只能枚举到一半才能之后的保证每次的扩展合理，故反转字符串再跑一遍马拉车、分奇偶再解决一遍即可。 然后$A$了。 AC代码-12860ms点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define N 2000005using namespace std;typedef pair&lt;int,int&gt; ii;char s[N],a[N&lt;&lt;1];int n,odd[N],even[N],len[N&lt;&lt;1],ans[2][N];void manacher()&#123; n&lt;&lt;=1; memset(len,0,sizeof(len)); int m=n&lt;&lt;1,i,mr=0,mid; for(i=0;i&lt;=m;i+=2)a[i]='#'; for(i=0;i&lt;n;i++)a[i*2+1]=s[i+1]; for(i=0;i&lt;=m;i++)&#123; if(i&lt;mr)len[i]=min(len[2*mid-i],mr-i); while(a[i+len[i]]&amp;&amp;a[i+len[i]]==a[i-len[i]])len[i]++; if(i+len[i]&gt;mr)mr=i+len[i],mid=i; &#125; for(i=1;i&lt;=n;i++)odd[i]=len[(i-1)*2+1]/2*2-1; for(i=1;i&lt;=n;i++)even[i-1]=len[(i-1)*2]/2*2; n&gt;&gt;=1;&#125;void solveOdd(int w)&#123; int full=0,i; set&lt;ii&gt;S; for(i=1;i&lt;=(n+1)/2;i++)S.insert(&#123;odd[i],i&#125;); for(i=1;i&lt;=n;i++)&#123; while(S.size())&#123; int x=S.rbegin()-&gt;first,id=S.rbegin()-&gt;second; if(id&lt;i)&#123; S.erase(*S.rbegin()); continue; &#125; if(x&gt;(id-i+1)*2-1)&#123; full=max(full,id); S.erase(*S.rbegin()); continue; &#125; break; &#125; if(S.size())ans[w][i]=max(ans[w][i],S.rbegin()-&gt;first); if(full&gt;=i)ans[w][i]=max(ans[w][i],(full-i+1)*2-1); S.insert(&#123;odd[(n+1)/2+i],(n+1)/2+i&#125;); &#125;&#125;int get(int p)&#123;return min(p,n-p)*2;&#125;void solveEven(int w)&#123; int full=0,i; set&lt;ii&gt;S; for(i=1;i&lt;=(n+1)/2;i++)S.insert(&#123;even[i],i&#125;); for(i=1;i&lt;=n;i++)&#123; while(S.size())&#123; int x=S.rbegin()-&gt;first,id=S.rbegin()-&gt;second; if(id&lt;i)&#123; S.erase(*S.rbegin()); continue; &#125; int mx=get(id-i+1); if(x&gt;mx)&#123; full=max(full,id); S.erase(*S.rbegin()); continue; &#125; break; &#125; if(S.size())ans[w][i]=max(ans[w][i],S.rbegin()-&gt;first); if(full&gt;=i)ans[w][i]=max(ans[w][i],get(full-i+1)); S.insert(&#123;even[(n+1)/2+i],(n+1)/2+i&#125;); &#125;&#125;int main()&#123; scanf("%d%s",&amp;n,s+1); int i; for(i=1;i&lt;=n;i++)s[i+n]=s[i]; manacher();solveOdd(0);solveEven(0); reverse(s+1,s+n*2+1); manacher();solveOdd(1);solveEven(1); printf("%d\n",max(ans[0][1],ans[1][1])); for(i=2;i&lt;=n;i++)printf("%d\n",max(ans[0][i],ans[1][n+1-i+1])); return 0;&#125; 似乎可以从头和尾分别加入和删除，过后学习一下再写写试试。 参考文献 待补代码点击 12 顺便贴一下标程。 标程代码-2336ms点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=5e5,MAXX=MAXN&lt;&lt;1,MAXLEAVES=1&lt;&lt;19;char S[MAXX+1];int R[2][MAXX+1],fsize,T[2][MAXX+1];void manacher(const int length,const int rx)&#123; register int i,j,k; int *table=R[rx]; for(i=j=0;i&lt;length;i+=k,j=max(j-k,0))&#123; while(i-j&gt;=0&amp;&amp;i+j+rx&lt;length&amp;&amp;S[i-j]==S[i+j+rx])++j; table[i]=j; for(k=1;k&lt;j&amp;&amp;table[i-k]!=table[i]-k;++k)&#123; table[i+k]=min(table[i-k],table[i]-k); &#125; &#125;&#125;int tree[(MAXLEAVES&lt;&lt;1)+1],rval,ileft,iright,leaves;void update_tree(const int x,const int left,const int right)&#123; if(ileft&gt;right||iright&lt;left)&#123; return; &#125; if(ileft&lt;=left&amp;&amp;right&lt;=iright)&#123; //node completely inside the update interval tree[x]=max(tree[x],rval); &#125; else&#123; int mid=(left+right)&gt;&gt;1; update_tree(x&lt;&lt;1,left,mid); update_tree((x&lt;&lt;1)+1,mid+1,right); &#125;&#125;void adjust_and_gather(const int pos,const int parity)&#123; int &amp;ptr=R[parity][pos]; int diff=(ptr&lt;&lt;1)-(!parity)-fsize,lx,rx,flen; if(diff&gt;0)&#123; diff+=(diff&amp;1); ptr-=diff&gt;&gt;1; &#125; lx=pos-ptr+1; rx=pos+ptr-(parity==0); flen=(ptr&lt;&lt;1)-(!parity); if((parity==0&amp;&amp;ptr&gt;1)||(parity==1&amp;&amp;ptr&gt;0))&#123; T[0][lx]=max(T[0][lx],flen); T[1][rx]=max(T[1][rx],flen); ileft=max(0,rx-fsize+1),iright=min(fsize-1,lx); rval=flen; update_tree(1,0,leaves-1); &#125;&#125;inline void process_manacher_table(const int length)&#123; for(register int i=0;i&lt;length;++i)&#123; adjust_and_gather(i,0);//odd length; adjust_and_gather(i,1);//even length; &#125;&#125;inline int read_tree(const int pos)&#123; register int x=pos+leaves; int result=1; while(x)&#123; result=max(result,tree[x]); x&gt;&gt;=1; &#125; return result;&#125;inline void init_leaves(const int n)&#123; leaves=1; while(leaves&lt;n)&#123; leaves&lt;&lt;=1; &#125;&#125;int main()&#123; int N,i,answer; scanf("%d%s",&amp;N,S); memcpy(S+N,S,(N-1)*sizeof(char)); init_leaves(N); fsize=N,N=(N&lt;&lt;1)-1; manacher(N,0);//odd length; manacher(N,1);//even length; process_manacher_table(N); for(i=1;i&lt;N;++i)&#123; T[0][i]=max(T[0][i],T[0][i-1]-2); T[1][N-i-1]=max(T[1][N-i-1],T[1][N-i]-2); &#125; for(i=0;i&lt;fsize;++i)&#123; answer=read_tree(i); answer=max(answer,T[0][i]); answer=max(answer,T[1][i+fsize-1]); printf("%d\n",answer); &#125; return 0;&#125; F 题目描述解题思路AC代码点击 12 G 题目描述定义一个$S$的真子串$T$为边界子串，当且仅当$T$为$S$的真前缀和真后缀，定义函数$P(l,r)$表示串$S[l,r]$的回文的边界子串个数。 给定一个串$S$（$|S|\leq 1e5$），求$\sum_{l\leq i\leq j\leq |S|}P(i,j)$。 解题思路考虑每一种回文子串对答案的贡献，设其出现的次数为$cnt$，则其贡献为$\frac {(cnt+1)cnt}2$。 然后就变成回文树裸题了。注意$LL$！ AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define N 100010#define P 8typedef long long ll;ll ans,w=1000000007LL;struct PAM&#123; int i,last,tot,n; int tr[N][P],s[N]; int fail[N],len[N],cnt[N]; int newnode(int l)&#123; for(i=0;i&lt;P;i++)tr[tot][i]=0; len[tot]=l; cnt[tot]=0; return tot++; &#125; void init()&#123; last=tot=n=0; newnode(0);newnode(-1); s[0]=-1; fail[0]=1; &#125; int getfail(int p)&#123; while(s[n-len[p]-1]!=s[n])p=fail[p]; return p; &#125; void add(int x)&#123; s[++n]=x; int cur=getfail(last); if(!tr[cur][x])&#123; int now=newnode(len[cur]+2); fail[now]=tr[getfail(fail[cur])][x]; tr[cur][x]=now; &#125; last=tr[cur][x]; cnt[last]++; &#125; void count()&#123; for(i=tot-1;i&gt;=0;i--)cnt[fail[i]]+=cnt[i]; &#125;&#125;p;char a[N];int main()&#123; int i; scanf("%s",a); p.init(); for(i=0;a[i];i++)p.add(a[i]-'a'); p.count(); for(i=2;i&lt;p.tot;i++)ans=(ans+1LL*p.cnt[i]*(p.cnt[i]-1)/2%w)%w; printf("%lld",ans); return 0;&#125; H 题目描述给$n$个长度小于$30$的小写字母字符串，选取任意两个（可以相同）字符串的任意前缀$a$和$b$，连接形成新的串$S=ab$。问本质不同的$S$共有多少种。 解题思路显然，如果给定串为另一个给定串的前缀，则可以忽略掉它。所以先建立一棵$trie$树，考虑任意两个节点都代表一个前缀，答案初步定为$tot\times tot$（$tot$为$trie$节点数）。 然后考虑除重。假设$a,ab,bc,c$都为合理的前缀，则串$abc$可以由$a$和$bc$组成，亦可由$ab$和$c$组成。对于任意一个节点$i$对应的前缀$b$，假设当它作为$S$的后缀时的方案数为$t_i$，则答案数即为$tot\times tot-\sum_{i=1}^{tot}(t_i-1)$。 考虑如何求$t_i$，建立一棵$fail$树，根据$fail$树的性质：一个节点对应的串为（该节点子树大小个）前缀的后缀。于是在$fail$树上$dfs$算出子树大小，则$t_i=sum[rt]$（$rt$代表该串对应的最靠近根节点的节点）。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define N 300010typedef long long ll;using namespace std;int len[N],t[N][26],fail[N],sum[N],fa[N],tot;char a[40];void ins()&#123; int i,now=0,p; for(i=0;a[i];i++)&#123; p=a[i]-'a'; if(!t[now][p]) t[now][p]=++tot,len[tot]=len[now]+1,fa[tot]=now; now=t[now][p]; &#125;&#125;queue&lt;int&gt;Q;void build()&#123; int i,p; for(i=0;i&lt;26;i++)if(t[0][i])Q.push(t[0][i]); while(!Q.empty())&#123; p=Q.front();Q.pop(); for(i=0;i&lt;26;i++)&#123; if(!t[p][i])t[p][i]=t[fail[p]][i]; else fail[t[p][i]]=t[fail[p]][i],Q.push(t[p][i]); &#125; &#125;&#125;struct Edge&#123; int e,n;&#125;e[N];int hd[N],cnt;void add(int a,int b)&#123; e[++cnt].e=b; e[cnt].n=hd[a]; hd[a]=cnt;&#125;void dfs(int p)&#123; int i; sum[p]=1; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; dfs(q); sum[p]+=sum[q]; &#125;&#125;int main()&#123; int i,n; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; memset(len,0,sizeof(len));tot=0; memset(sum,0,sizeof(sum)); memset(t,0,sizeof(t)); memset(fa,0,sizeof(fa)); memset(fail,0,sizeof(fail)); memset(hd,0,sizeof(hd));cnt=0; for(i=0;i&lt;n;i++)scanf("%s",a),ins(); build(); for(i=1;i&lt;=tot;i++)add(fail[i],i); dfs(0); ll ans=1LL*tot*tot; for(i=1;i&lt;=tot;i++)&#123; if(fail[i])&#123; int temp=len[fail[i]],now=i; while(temp--)now=fa[now]; ans-=(sum[now]-1); &#125; &#125; printf("%lld\n",ans); &#125; return 0;&#125; I 题目描述解题思路AC代码点击 12 J 题目描述解题思路AC代码点击 12 K 题目描述定义一个串是好串，当且仅当它可以表示成$A+B+…+A+B+A$的形式，其中$A,B$可以为空，分别出现了$k+1$次和$k$次。 给定一个字符串$a(1\leq |a|\leq 10^6)$和$k(1\leq k\leq 10^6)$，求每一个前缀是否是好串。 解题思路假设字符串$s$的前$i$位为$ABAB…ABA$，则显然，$AB…ABA$和$ABAB…A$可以匹配。 于是用$kmp$字符串匹配的思想自己匹配自己，有$|BA|=i-nxt[i]$。 如果$B$可以为空，也即$s$的前$i$位为$SS…S(共出现num=\frac i{|BA|}次)$，也即$i%|BA|==0$，则只需要满足分成恰好$k$段后的剩余段长度小于等于前面段长度（设新生成的前面段$|A|$为$SS…S(共出现\frac{num}k次)$，剩余段为$SS…S(共出现num%k次)$，则需要满足$\frac{num}k\geq num%k$）。 否则，同理可分析出要求为$\frac{num}k&gt;num%k$。 AC代码点击 1234567891011121314151617181920#include&lt;stdio.h&gt;#define N 1000005int n,k;char a[N];int nxt[N],ans[N];int main()&#123; int i,j=0; scanf("%d%d",&amp;n,&amp;k); scanf("%s",a); for(i=1;i&lt;=n;i++)&#123; while(j&amp;&amp;a[i]!=a[j])j=nxt[j]; if(a[i]==a[j])j++; nxt[i+1]=j; int r=i-nxt[i],num=i/r; if(i%r)ans[i]=num/k&gt;num%k; else ans[i]=num/k&gt;=num%k; &#125; for(i=1;i&lt;=n;i++)printf("%d",ans[i]); return 0;&#125; L 题目描述给两个字符串$A,B(1\leq |A|,|B|\leq 2\times 10^5)$，求不同的公共回文子串$P,Q$个数，重复出现也要算入。 解题思路使用两棵回文树，分别在偶数根和奇数根上同时深搜，把结果加起来即可。 刚学习回文树，感觉十分巧妙。大致说一下它的思路。 不同于$AC$自动机，回文树的建立基于对每一个回文串的中心向两端扩张，树上的每一个节点代表的是一种回文串，所以$fail$指针指向的是与当前节点具有最长公共回文后缀的串的树上的节点位置（不是字符位置！不是字符位置！）。最初状态只有两个树根，分别为奇数长度回文串的树根和偶数长度回文串的树根。每次添加一个节点$p$的时候，找到上一个节点$last$的最长回文后缀$S$，使得新形成的$pSp$为回文串。当然，如果找不到，那只能让$p$单独成为一个回文串。 用$len[i]$表示节点$i$代表的回文串长度，$cnt[i]$表示这个回文串出现的次数，剩下的就是在$fail$上面跳就好了。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#define N 200005typedef long long ll;struct PT&#123; int tr[N][26],fail[N],cnt[N]/*,num[N]*/,len[N]; int tot,s[N],n,last,i; int newnode(int l)&#123; for(i=0;i&lt;26;i++)tr[tot][i]=0; cnt[tot]=0; len[tot]=l; //num[tot]=l; return tot++; &#125; void init()&#123; n=last=tot=0; newnode(0);newnode(-1);//建立两个树根 s[0]=-1;//奇数回文树树根len=-1 fail[0]=1;//奇数的fail指向偶数树根 &#125; int getfail(int p)&#123; while(s[n-len[p]-1]!=s[n])p=fail[p];//找到最长的能构成回文串的节点 return p; &#125; void add(int p)&#123; s[++n]=p; int cur=getfail(last); if(!tr[cur][p])&#123; int now=newnode(len[cur]+2);//向两端扩张，长度+2 fail[now]=tr[getfail(fail[cur])][p]; tr[cur][p]=now; //num[now]=num[fail[now]]+1; &#125; last=tr[cur][p]; cnt[last]++; &#125; void count()&#123; for(i=tot-1;i&gt;=0;i--)cnt[fail[i]]+=cnt[i]; &#125;&#125;p1,p2;char a[N],b[N];ll dfs(int a,int b)&#123; ll ans=0;int i; for(i=0;i&lt;26;i++) if(p1.tr[a][i]&amp;&amp;p2.tr[b][i]) ans+=1LL*p1.cnt[p1.tr[a][i]]*p2.cnt[p2.tr[b][i]]+dfs(p1.tr[a][i],p2.tr[b][i]); return ans;&#125;int main()&#123; int i,j,t; scanf("%d",&amp;t); for(i=1;i&lt;=t;i++)&#123; p1.init();p2.init(); scanf("%s%s",a,b); for(j=0;a[j];j++)p1.add(a[j]-'a'); for(j=0;b[j];j++)p2.add(b[j]-'a'); p1.count();p2.count(); printf("Case #%d: %lld\n",i,dfs(0,0)+dfs(1,1)); &#125; return 0;&#125; M 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vjudge299952-后缀数组练习 题解]]></title>
    <url>%2F2019%2F05%2F05%2Fvjudge299952suffixarraypractice%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M N O P Q 5/17 O O O O O . . . . . . . . . . . . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 最近在学习后缀数组，打一场练习。 密码：buaa 故事开始的地方 比赛链接 A 题目描述求一个串的差分串的最长不重叠相同子串。 解题思路问题3 唯一区别在于差分串导致的$jud$函数中$\geq$变为$&gt;$。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 20010int s[N],n;int x[N],y[N],c[N],sa[N],rank[N],height[N];void getsa()&#123; int i,k,m=200; n++; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]=s[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i]; std::swap(x,y); num=1; x[sa[0]]=0; for(i=1;i&lt;n;i++) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++; if(num&gt;=n)break; m=num; &#125; n--;&#125;void getheight()&#123; int i,j,k=0; for(i=1;i&lt;=n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125;int jud(int x)&#123; int i,mn=1e9,mx=-1e9; for(i=0;i&lt;=n;i++)&#123; if(height[i]&lt;x)mn=mx=sa[i]; else&#123; mn=std::min(mn,sa[i]); mx=std::max(mx,sa[i]); if(mx-mn&gt;x)return 1; &#125; &#125; return 0;&#125;int main()&#123; int i; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; for(i=0;i&lt;n;i++)scanf("%d",&amp;s[i]); for(i=0;i&lt;n-1;i++)s[i]=s[i+1]-s[i]+90;s[n-1]=0; getsa();getheight(); int l=0,r=n,ans=0; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(jud(mid))l=mid+1,ans=mid; else r=mid; &#125; if(ans&gt;=4)printf("%d\n",ans+1); else printf("0\n"); &#125; return 0;&#125; B 题目描述求一个串中最长的出现$k$次的可重叠子串。 解题思路同样二分，每一个组的串个数$\geq k$即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 20010int s[N],n;int x[N],y[N],c[N],sa[N],rank[N],height[N];int k;void getsa()&#123; int i,k,m=1000000; n++; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]=s[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i]; std::swap(x,y); num=1; x[sa[0]]=0; for(i=1;i&lt;n;i++) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++; if(num&gt;=n)break; m=num; &#125; n--;&#125;void getheight()&#123; int i,j,k=0; for(i=1;i&lt;=n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125;int jud(int x)&#123; int i,num=0; for(i=0;i&lt;=n;i++)&#123; if(height[i]&lt;x)num=1; else if(++num&gt;=k)return 1; &#125; return 0;&#125;int main()&#123; int i; while(~scanf("%d%d",&amp;n,&amp;k)&amp;&amp;n)&#123; for(i=0;i&lt;n;i++)scanf("%d",&amp;s[i]); getsa();getheight(); int l=0,r=n,ans=0; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(jud(mid))l=mid+1,ans=mid; else r=mid; &#125; printf("%d\n",ans); &#125; return 0;&#125; C 题目描述求一个串中所有不同的子串。 解题思路因为每一个子串都是某一个后缀的前缀，考虑加入每一个后缀的贡献。 每加入一个后缀$suffix(i)$，其与前面的重复的前缀个数为$height[i]$。于是答案为$\frac {n\times (n+1)}2 -\sum_{i=1}^{n}height[i]$。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;typedef long long ll;#define N 1000010char s[N];int x[N],y[N],sa[N],c[10*N],rank[N],height[N],n;void getsa()&#123; int i,k,m=10000; n++; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]=s[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i]; std::swap(x,y); num=1; x[sa[0]]=0; for(i=1;i&lt;n;i++) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++; if(num&gt;=n)break; m=num; &#125; n--;&#125;void getheight()&#123; int i,j,k=0; for(i=0;i&lt;=n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125;void solve()&#123; ll ans=1LL*n*(n+1)/2; int i; for(i=1;i&lt;=n;i++)ans-=height[i]; printf("%lld\n",ans);&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",s); n=strlen(s); getsa(); getheight(); solve(); &#125; return 0;&#125; D 题目描述这题跟上一题重了… 解题思路同上 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;typedef long long ll;#define N 1000010char s[N];int x[N],y[N],sa[N],c[10*N],rank[N],height[N],n;void getsa()&#123; int i,k,m=10000; n++; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]=s[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i]; std::swap(x,y); num=1; x[sa[0]]=0; for(i=1;i&lt;n;i++) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++; if(num&gt;=n)break; m=num; &#125; n--;&#125;void getheight()&#123; int i,j,k=0; for(i=0;i&lt;=n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125;void solve()&#123; ll ans=1LL*n*(n+1)/2; int i; for(i=1;i&lt;=n;i++)ans-=height[i]; printf("%lld\n",ans);&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",s); n=strlen(s); getsa(); getheight(); solve(); &#125; return 0;&#125; E 题目描述给定若干个长度 $≤ 1000000$ 的字符串，询问每个字符串最多是由多少个相同的子字符串重复连接而成的。如：ababab 则最多有 $3$ 个 ab 连接而成。 解题思路枚举循环节，如果$l$是最小循环节长度，则有$s[0…n-l-1]==s[l…n-1]$。 思路1：后缀数组如果$l$为最小循环节长度，则必有$rank[0]==rank[l]+1$且$height[rank[0]]==n-l$。 数据范围需要$DC3$，否则会$T$掉。 AC代码（2547ms）点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;typedef long long ll;#define N 1000010char str[N];int s[N],sa[N*3],c[10*N],rank[N],height[N];int wa[N],wb[N],ws[N],wv[N];#define F(x) ((x)/3+((x)%3==1?0:tb))#define G(x) ((x)&lt;tb?(x)*3+1:((x)-tb)*3+2)int c0(int *r,int a,int b)&#123; return r[a]==r[b]&amp;&amp;r[a+1]==r[b+1]&amp;&amp;r[a+2]==r[b+2];&#125;int c12(int k,int *r,int a,int b)&#123; if(k==2)return r[a]&lt;r[b]||r[a]==r[b]&amp;&amp;c12(1,r,a+1,b+1); return r[a]&lt;r[b]||r[a]==r[b]&amp;&amp;wv[a+1]&lt;wv[b+1];&#125;void sort(int *r,int *a,int *b,int n,int m)&#123; int i; for(i=0;i&lt;n;i++)wv[i]=r[a[i]]; for(i=0;i&lt;m;i++)ws[i]=0; for(i=0;i&lt;n;i++)ws[wv[i]]++; for(i=1;i&lt;m;i++)ws[i] += ws[i-1]; for(i=n-1;i&gt;=0;i--)b[--ws[wv[i]]]=a[i];&#125;void dc3(int *r,int *sa,int n,int m)&#123; int i,j,*rn=r+n,*san=sa+n,ta=0,tb=(n+1)/3,tbc=0,p; r[n]=r[n+1]=0; for(i=0;i&lt;n;i++)if(i%3!=0)wa[tbc++]=i; sort(r+2,wa,wb,tbc,m); sort(r+1,wb,wa,tbc,m); sort(r,wa,wb,tbc,m); for(p=1,rn[F(wb[0])]=0,i=1;i&lt;tbc;i++) rn[F(wb[i])]=c0(r,wb[i-1],wb[i])?p-1:p++; if(p&lt;tbc)dc3(rn,san,tbc,p); else for(i=0;i&lt;tbc;i++)san[rn[i]]=i; for(i=0;i&lt;tbc;i++)if(san[i]&lt;tb)wb[ta++]=san[i]*3; if(n%3==1)wb[ta++]=n-1; sort(r,wb,wa,ta,m); for(i=0;i&lt;tbc;i++)wv[wb[i]=G(san[i])]=i; for(i=0,j=0,p=0;i&lt;ta&amp;&amp;j&lt;tbc;p++)sa[p]=c12(wb[j]%3,r,wa[i],wb[j])?wa[i++]:wb[j++]; for(;i&lt;ta;p++)sa[p]=wa[i++]; for(;j&lt;tbc;p++)sa[p]=wb[j++];&#125;void getheight(int *s,int *sa,int n)&#123; int i,j,k=0; for(i=0;i&lt;=n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125;int solve(int n)&#123; int i; for(i=1;i&lt;=n;i++) if(n%i==0&amp;&amp;rank[0]==rank[i]+1&amp;&amp;height[rank[0]]==n-i)return i; return n;&#125;int main()&#123; int i; while(~scanf("%s",str))&#123; if(str[0]=='.'&amp;&amp;!str[1])break; int n=strlen(str); for(i=0;i&lt;n;i++)s[i]=str[i]-'a'+1; s[n]=0; dc3(s,sa,n+1,105); getheight(s,sa,n); printf("%d\n",n/solve(n)); &#125; return 0;&#125; 思路2：kmp$next$数组保证了$s[0…n-l-1]==s[l…n-1]$性质，其中$l=n-next[n]$。 AC代码（125ms）点击 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;cstring&gt;#define N 1000003char a[N];int nxt[N],n;int main()&#123; int i,j; while(~scanf("%s",a)&amp;&amp;a[0]!='.')&#123; j=0; n=strlen(a); for(i=1;i&lt;=n;i++)&#123; while(j&amp;&amp;a[i]!=a[j])j=nxt[j]; if(a[i]==a[j])j++; nxt[i+1]=j; &#125; int l=n-nxt[n]; if(n%l==0)printf("%d\n",n/l); else printf("1\n"); &#125; return 0;&#125; F 题目描述求一个串中连续重复出现次数最多的串的出现次数。 解题思路枚举该串长度$i$，从头到尾以$i$为步长求出$LCP(suffix(k\times i),suffix((k+1)\times i))$，再向前延伸，每次更新答案为$max(ans,lcp/i+1)$。 复杂度为调和级数，$O(nlgn)$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#define N 50004#define M 150004int s[M],sa[M],rank[M],height[M];int wa[M],wb[M],ws[M],wv[M];#define F(x) ((x)/3+((x)%3==1?0:tb))#define G(x) ((x)&lt;tb?(x)*3+1:((x)-tb)*3+2)int c0(int *r,int a,int b)&#123; return r[a]==r[b]&amp;&amp;r[a+1]==r[b+1]&amp;&amp;r[a+2]==r[b+2];&#125;int c12(int k,int *r,int a,int b)&#123; if(k==2)return r[a]&lt;r[b]||r[a]==r[b]&amp;&amp;c12(1,r,a+1,b+1); return r[a]&lt;r[b]||r[a]==r[b]&amp;&amp;wv[a+1]&lt;wv[b+1];&#125;void sort(int *r,int *a,int *b,int n,int m)&#123; int i; for(i=0;i&lt;n;i++)wv[i]=r[a[i]]; for(i=0;i&lt;m;i++)ws[i]=0; for(i=0;i&lt;n;i++)ws[wv[i]]++; for(i=1;i&lt;m;i++)ws[i] += ws[i-1]; for(i=n-1;i&gt;=0;i--)b[--ws[wv[i]]]=a[i];&#125;void dc3(int *r,int *sa,int n,int m)&#123; int i,j,*rn=r+n,*san=sa+n,ta=0,tb=(n+1)/3,tbc=0,p; r[n]=r[n+1]=0; for(i=0;i&lt;n;i++)if(i%3!=0)wa[tbc++]=i; sort(r+2,wa,wb,tbc,m); sort(r+1,wb,wa,tbc,m); sort(r,wa,wb,tbc,m); for(p=1,rn[F(wb[0])]=0,i=1;i&lt;tbc;i++) rn[F(wb[i])]=c0(r,wb[i-1],wb[i])?p-1:p++; if(p&lt;tbc)dc3(rn,san,tbc,p); else for(i=0;i&lt;tbc;i++)san[rn[i]]=i; for(i=0;i&lt;tbc;i++)if(san[i]&lt;tb)wb[ta++]=san[i]*3; if(n%3==1)wb[ta++]=n-1; sort(r,wb,wa,ta,m); for(i=0;i&lt;tbc;i++)wv[wb[i]=G(san[i])]=i; for(i=0,j=0,p=0;i&lt;ta&amp;&amp;j&lt;tbc;p++)sa[p]=c12(wb[j]%3,r,wa[i],wb[j])?wa[i++]:wb[j++]; for(;i&lt;ta;p++)sa[p]=wa[i++]; for(;j&lt;tbc;p++)sa[p]=wb[j++];&#125;void getheight(int *s,int *sa,int n)&#123; int i,j,k=0; for(i=0;i&lt;=n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125;int st[20][N];void init(int n)&#123; int i,j; for(i=0;i&lt;=n;i++)st[0][i]=height[i]; for(i=n-1;i;i--) for(j=1;(1&lt;&lt;j)+i-1&lt;=n;j++) st[j][i]=std::min(st[j-1][i],st[j-1][i+(1&lt;&lt;(j-1))]);&#125;int query(int l,int r)&#123; int m=0; if(l&gt;r)std::swap(l,r); l++; while((1&lt;&lt;(m+1))&lt;r-l+1)m++; return std::min(st[m][l],st[m][r-(1&lt;&lt;m)+1]);&#125;int solve(int n)&#123; int i,j,ans=1,lcp,remain; for(i=1;i&lt;=n;i++)&#123; for(j=0;j+i&lt;n;j+=i)&#123; lcp=query(rank[j],rank[j+i]); remain=i-lcp%i; int start=j-remain; if(start&gt;=0&amp;&amp;lcp%i&amp;&amp;query(rank[start],rank[start+i])&gt;=remain) lcp+=remain; ans=std::max(ans,lcp/i+1); &#125; &#125; return ans;&#125;int main()&#123; int i,n,t; char a[10]=&#123;0&#125;; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%s",a),s[i]=a[0]-'a'+1; s[i]=0; dc3(s,sa,n+1,4); getheight(s,sa,n); init(n); printf("%d\n",solve(n)); &#125; return 0;&#125; G 题目描述解题思路AC代码点击 12 H 题目描述解题思路AC代码点击 12 I 题目描述解题思路AC代码点击 12 J 题目描述解题思路AC代码点击 12 K 题目描述解题思路AC代码点击 12 L 题目描述解题思路AC代码点击 12 M 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 2 题解]]></title>
    <url>%2F2019%2F04%2F29%2F2019springtraining-2%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G 7/7 Ø Ø Ø Ø Ø Ø Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述有$n$个人可以任选$2$的倍数，有$m$个人可以任选$3$的倍数。任意两个人选的数不相同，求选择的最大数的最小值。（$0\leq n,m\leq 10^6,n+m&gt;0$） 解题思路枚举每一个$6$的倍数被选$2$的那帮人取了还是被选$3$的那帮人取了即可。 AC代码点击 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int i,n,m,a,b; scanf("%d%d",&amp;n,&amp;m); a=n*2,b=m*3; for(i=6;i&lt;=min(a,b);i+=6)&#123; if(a&lt;=b)a+=2; else b+=3; &#125; printf("%d",max(a,b)); return 0;&#125; B 题目描述$g^0(x)=x,g^n(x)=a\times g^{n-1}(x)+b$。输入$a,b,n,x$，求$g^n(x)$。（$1\leq a,b\leq 10^9,1\leq n\leq 10^{18}$，对$1e9+7$取模） 解题思路手推一下式子，很显然的等比数列求和。 AC代码点击 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll a,b,n,w=1000000007,x;ll qp(ll a,ll b)&#123; ll ans=1; for(;b;b&gt;&gt;=1,a=a*a%w)if(b&amp;1)ans=ans*a%w; return ans;&#125;ll inv(ll x)&#123;return qp(x,w-2);&#125;int main()&#123; scanf("%I64d%I64d%I64d%I64d",&amp;a,&amp;b,&amp;n,&amp;x); if(a==1)printf("%I64d",(x+n%w*b)%w); else&#123; ll apn=qp(a,n); ll ans=apn*x%w+b*(apn-1)%w*inv(a-1)%w; printf("%I64d",(ans%w+w)%w); &#125; return 0;&#125; C 题目描述给一个长度$n\leq 10^5$的数列$a_i(0&lt;a_i\leq 10^5)$。定义$f(l,r)$为$[l,r]$中任意一个数$i$，不存在一个$[l,r]$中与$i$不同的数$j$使得$a_i%a_j==0$。求$\sum_{i=1}^{n}\sum_{j=i}^{n}f(i,j)%(10^9+7)$。 解题思路考虑每一个位置$i$对答案的贡献，即为向左右延伸长度的乘积。 故可以考虑左右两侧最靠近$i$且满足$a[i]%a[j]==0$的数字$j$，分别定为$l[i],r[i]$，用一个$loc$数组记录每一个数字最后出现的位置，递推求出即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll w=1000000007;#define N 100010#define M 10010int a[N],n,l[N],r[N],loc[M];int main()&#123; int i,j; while(~scanf("%d",&amp;n))&#123; ll ans=0; for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); memset(loc,0,sizeof(loc)); for(i=1;i&lt;=n;i++)&#123; l[i]=0; for(j=1;j*j&lt;=a[i];j++)&#123; if(a[i]%j==0)&#123; if(loc[j]&amp;&amp;loc[j]&gt;l[i])l[i]=loc[j]; if(loc[a[i]/j]&amp;&amp;loc[a[i]/j]&gt;l[i])l[i]=loc[a[i]/j]; &#125; &#125; loc[a[i]]=i; &#125; memset(loc,0,sizeof(loc)); for(i=n;i;i--)&#123; r[i]=n+1; for(j=1;j*j&lt;=a[i];j++)&#123; if(a[i]%j==0)&#123; if(loc[j]&amp;&amp;loc[j]&lt;r[i])r[i]=loc[j]; if(loc[a[i]/j]&amp;&amp;loc[a[i]/j]&lt;r[i])r[i]=loc[a[i]/j]; &#125; &#125; loc[a[i]]=i; &#125; for(i=1;i&lt;=n;i++)ans=(ans+(i-l[i])*(r[i]-i)%w)%w; printf("%lld\n",ans); &#125; return 0;&#125; D 题目描述给一个正整数$n$，问有没有一种选择数组$a_i,b_i(i∈[1,k])$的方案满足 $b_i$是$n$的因数 $1\leq a_i&lt;b_i$ $\sum_{i=1}^{k}\frac{a_i}{b_i}=1-\frac1n$ 解题思路显然如果能构成答案，则必定只需要两个分数（任意两个不同的分数都可相加成另一个合法的分数）。 于是本题化为$a_1x+a_2y=n-1$的解，用扩展欧几里得即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll a,b,n,g;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1,y=0; return a; &#125; ll g=exgcd(b,a%b,x,y),tmp=x; x=y;y=tmp-a/b*y; return g;&#125;int main()&#123; ll i; while(~scanf("%I64d",&amp;n))&#123; int flag=0; for(i=2;i*i&lt;n;i++)&#123; if(n%i)continue; ll x,y; a=i,b=n/i,g=exgcd(a,b,x,y); a/=g;b/=g; if((n-1)%g)continue; x*=(n-1)/g;y*=(n-1)/g; if(x&lt;0)&#123; ll k=-x/b+(x%b!=0); x+=k*b; y-=k*a; &#125; if(y&lt;0)&#123; ll k=-y/a+(y%a!=0); x-=k*b; y+=k*a; &#125; if(x&lt;0||y&lt;0)continue; printf("YES\n2\n"); printf("%I64d %I64d\n",y,a*g); printf("%I64d %I64d\n",x,b*g); flag=1; break; &#125; if(!flag)printf("NO\n"); &#125; return 0;&#125; E 题目描述有$n$堆石子，每一堆取出$k$个石子之后就不能再恰好取出$k$个石子。轮流取石子，最后不能取的人输。问先手是否必输。 解题思路手推一下，一堆石头最多可以被拿走$k$次，则贪心地从小到大拿，有$(1+2+…+k)\leq s_i\leq (1+2+…+k+1)$。 把每一堆的数量变成相对应的$k$，就变成简单的$Nim$游戏了。 AC代码点击 123456789101112#include&lt;bits/stdc++.h&gt;int x[]=&#123;0,2,5,9,14,20,27,35,44,54,65&#125;;int n,t,a;int main()&#123; scanf("%d",&amp;n); while(n--)&#123; scanf("%d",&amp;a); t^=std::lower_bound(x,x+10,a)-x; &#125; printf("%s",t?"NO":"YES"); return 0;&#125; F 题目描述$T\leq 50$组询问，每次询问一个区间$[l,r],1\leq l\leq r\leq 10^9$，问这个区间里有多少整数$x$满足$x%f(x)=0$，其中$f(x)$表示$x$的各位数之和。 解题思路观察到$f(x)$只有$81$种选择，可以用数位$DP$，$f[pos][sum][div][r]$表示枚举到第$pos$位，当前已经有的数位和为$sum$时，$f(x)=div$，$x%f(x)=r$的$x$的个数。 注意不是所有时候$dfs$的结果都可以添加到记忆化搜索中的，只有不在限制下的才能成为通用解。 AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int dp[10][82][82][81];int num[10],top;int dfs(int pos,int sum,const int div,int r,int end)&#123;//end:是否为限制位 int i,mx=9,&amp;ans=dp[pos][sum][div][r]; if(pos&lt;0)return !r&amp;&amp;!sum; if(end)mx=num[pos]; if(!end&amp;&amp;~ans)return ans; int temp=0; for(i=0;i&lt;=mx&amp;&amp;i&lt;=sum;i++)temp+=dfs(pos-1,sum-i,div,(r*10+i)%div,end&amp;&amp;(i==mx)); //枚举这一位取值 if(!end)ans=temp;//通用解 return temp;&#125;int f(int x)&#123; if(!x)return 0; int i,ans=0; top=-1; while(x)num[++top]=x%10,x/=10; for(i=1;i&lt;=9*top+num[top];i++)ans+=dfs(top,i,i,0,1); return ans;&#125;int main()&#123; int t,l,r,cas=0; memset(dp,-1,sizeof(dp)); scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;l,&amp;r); printf("Case %d: %d\n",++cas,f(r)-f(l-1)); &#125; return 0;&#125; G 题目描述求$lcm$的二维前缀和。 解题思路$f(n,m)$ $=\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)$ $=\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i\times j}{gcd(i,j)}$ $=\sum_{g=1}^{min(n,m)}g\times \sum_{i=1}^{n}\sum_{j=1}^{m}i\times j(gcd(i,j)==g)$ $=\sum_{g=1}^{min(n,m)}g\times \sum_{i=1}^{\frac ng}\sum_{j=1}^{\frac mg}i\times j(gcd(i,j)==1)$ $=\sum_{g=1}^{min(n,m)}g\times u(\frac ng,\frac mg)$ $u(n,m)$ $=\sum_{i=1}^{n}\sum_{j=1}^{m}i\times j(gcd(i,j)==1)$ $=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k|gcd(i,j)}i\times j\times \mu(k)$ $=\sum_{k=1}^{min(n,m)}\mu(k)\times k^2\sum_{i=1}^{\frac nk}\sum_{j=1}^{\frac mk}i\times j$ 于是预处理$\mu(k)\times k^2$，分块处理后半段即可。 其中：$\sum_{i=1}^{x}\sum_{j=1}^{y}i\times j$ $=(1+2+…+x)(1+2+…+y)$ $=\frac{(1+x)x}2\frac{(1+y)y}2$ 分别对$f(n,m)$，$u(n,m)$分块，复杂度$O(n)$。 $upd:$必须吐槽一波$bzoj$，下面的代码交上去会$CE$，原因就在于全局变量数组不能初始化，，，什么玩意，，，只好手动猜测$CE$原因，，贡献了一大波$CE&amp;WA$ AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 10000010ll mu[N]=&#123;0,1&#125;,w=20101009;int pr[N/10],a[N]=&#123;1,1&#125;,cnt;ll inv;ll qp(ll a,ll b)&#123; if(inv)return inv; ll ans=1; for(;b;b&gt;&gt;=1,a=a*a%w)if(b&amp;1)ans=ans*a%w; return inv=ans;&#125;ll F(int x)&#123; return qp(2,w-2)*x%w*(x+1)%w;&#125;ll u(int n,int m)&#123; int i,r;ll ans=0; for(i=1;i&lt;=n;i=r+1)&#123; r=min(n/(n/i),m/(m/i)); ans=(ans+(mu[r]-mu[i-1])*F(n/i)%w*F(m/i)%w+w)%w; &#125; return ans;&#125;ll f(int n,int m)&#123; int i,r;ll ans=0; for(i=1;i&lt;=n;i=r+1)&#123; r=min(n/(n/i),m/(m/i)); ans=(ans+u(n/i,m/i)*(r-i+1)%w*(r+i)%w*qp(2,w-2))%w; &#125; return ans;&#125;int main()&#123; int i,j,n,m; scanf("%d%d",&amp;n,&amp;m); if(n&gt;m)n^=m^=n^=m; for(i=2;i&lt;=m;i++)&#123; if(!a[i])pr[cnt++]=i,mu[i]=-1; for(j=0;j&lt;cnt&amp;&amp;i*pr[j]&lt;=m;j++)&#123; a[i*pr[j]]=1; if(i%pr[j]==0)break; mu[i*pr[j]]=mu[i]*-1; &#125; &#125; for(i=1;i&lt;=m;i++)&#123; mu[i]=(mu[i]+w)*i%w*i%w; mu[i]=(mu[i]+mu[i-1])%w; &#125; printf("%lld",f(n,m)); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 1 题解]]></title>
    <url>%2F2019%2F04%2F28%2F2019springtraining-1%2F</url>
    <content type="text"><![CDATA[Solved A B C D E 5/5 O Ø O Ø Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给一个括号序列，定义如下 $()$ 是一个括号序列 如果 $A$ 是括号序列，那么 $(A)$ 是括号序列 如果 $A, B$ 是括号序列，那么 $AB$ 是括号序列 括号序列的得分如下 $()$ 的得分是 $1$ 如果 $A$ 是括号序列，记其得分为 $S_A$，那么$ (A)$ 是括号序列，其得分为$ 2S_A$ 如果 $A, B$ 是括号序列，记其得分分别为 $S_A$ 和 $S_B$，那么 $AB$ 是括号序列，其得分为$ S_A + S_B$最终求序列的得分，结果对 $12345678910 $取模 解题思路签到题，用栈模拟即可。 考场上傻了没取模还WA了一发 AC代码点击 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;typedef long long ll;#define w 12345678910int n,top;ll l[100010],ans;int main()&#123; int i,a; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a); if(!a)l[++top]=-1; else&#123; if(l[top]==-1)l[top]=1; else&#123; ll sc=0; while(l[top]!=-1)sc+=l[top--]; l[top]=sc*2%w; &#125; &#125; &#125; for(i=1;i&lt;=top;i++)(ans+=l[i])%=w; printf("%lld",ans); return 0;&#125; B 题目描述给一个全是正整数的$n\times m$的矩阵，要把上面所有数重新标记，使得新生成的矩阵每一行每一列中，原来相同的元素仍相同，且元素间相对大小不变。求重新标记的矩阵中的最大值。 解题思路有好多种做法。 贪心地做，可以考虑把所有值从小到大排序，首先放入第一个元素（坐标为$(x_1,y_1)$）必为$ans[1,1]=1$，限制$x_1$所在行、$y_1$所在列的最小可填值为$1$。 假设正在放第$i$个元素，它的坐标为$(x_i,y_i)$，则找到$x_i$所在行的最小可填值$p$及其所在坐标$y_{max}$、$y_i$所在列的最小可填值$q$及其所在坐标$x_{max}$，则$ans[x_i,y_i]=max(ans[x_i,y_{max}]+(a[x_i,y_i]&gt;a[x_i,y_{max}]),ans[x_{max},y_i]+(a[x_i,y_i]&gt;a[x_{max},y_i]))$ 这时候我们发现了一个问题：当遇到这组数据 3 51 2 3 4 51 5 1 1 51 6 1 1 1 的时候，因为枚举的时候，右边中间的$5$比左边的$5$更晚枚举到，故显然会输出 51 2 3 4 51 3 1 1 51 4 1 1 1 这样的错误矩阵。 于是我们维护一个并查集，并查集存储的是所有同行或同列中相等的元素。这样在每次寻找答案的时候，必然能够保证最大值是可以被更新的，尽管$ans$数组未必是最后的可行方案。 错误代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int n,m;int a[N];struct point&#123; int i,j; bool operator&lt;(const point&amp;b)const&#123;return a[(i-1)*m+j]&lt;a[(b.i-1)*m+b.j];&#125;&#125;p[N];int linemin[N],colmin[N],ans[N];int main()&#123; int i,j; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; int x=(i-1)*m+j; scanf("%d",&amp;a[x]); p[x]=(point)&#123;i,j&#125;; &#125; &#125; int r=0; sort(p+1,p+n*m+1); for(i=1;i&lt;=n*m;i++)&#123; int x=p[i].i,y=p[i].j; int p=linemin[x],q=colmin[y]; int X=(x-1)*m+y; ans[X]=max(ans[p]+(a[X]&gt;a[p]),ans[q]+(a[X]&gt;a[q])); if(ans[X]&gt;r)r=ans[X]; linemin[x]=colmin[y]=X; &#125; printf("%d\n",r); /*for(i=1;i&lt;=n*m;i++)&#123; printf("%d ",ans[i]); if(i%m==0)puts(""); &#125;*/ return 0;&#125; AC代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int n,m;int a[N],f[N];int find(int x)&#123;return x==f[x]?f[x]:f[x]=find(f[x]);&#125;struct point&#123; int i,j; bool operator&lt;(const point&amp;b)const&#123;return a[(i-1)*m+j]&lt;a[(b.i-1)*m+b.j];&#125;&#125;p[N];int linemin[N],colmin[N],ans[N];int main()&#123; int i,j; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; int x=(i-1)*m+j; scanf("%d",&amp;a[x]); p[x]=(point)&#123;i,j&#125;; f[x]=x; &#125; &#125; int r=0; sort(p+1,p+n*m+1); for(i=1;i&lt;=n*m;i++)&#123; int x=p[i].i,y=p[i].j; int p=find(linemin[x]),q=find(colmin[y]); int X=(x-1)*m+y; ans[X]=max(ans[p]+(a[X]&gt;a[p]),ans[q]+(a[X]&gt;a[q])); if(ans[X]&gt;r)r=ans[X]; if(a[X]==a[p])f[p]=X; if(a[X]==a[q])f[q]=X; linemin[x]=colmin[y]=X; &#125; printf("%d",r); return 0;&#125; C 题目描述现有一序列$a_i(1\leq i\leq n)$，初始时$a_i=i$。有$m$个操作，每次操作翻转$[l,r]$区间内所有数并输出其和。 $1\leq n,m \leq 10^5$。 解题思路平衡树，此时用$FHQTreap$。建树不停进行$merge$操作，每次翻转根据子树大小找到$r$的位置并$split$，取左树为$x$，再在$x$中找到$l-1$并$split$，再取右树为$z$。那么$z$的$sum$即为答案。翻转$z$，再$merge$回去即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define ls t[x].s[0]#define rs t[x].s[1]struct FHQTreap&#123; int s[2],v,k,sz,lazy; ll sum;&#125;t[100010];int n,m,tot,rt;void upd(int x)&#123; t[x].sz=t[ls].sz+t[rs].sz+1; t[x].sum=(ls?t[ls].sum:0)+(rs?t[rs].sum:0)+t[x].v;&#125;int newnode(int v)&#123; t[++tot].k=rand();t[tot].sz=1;t[tot].v=t[tot].sum=v; return tot;&#125;void pushdown(int x)&#123; if(t[x].lazy)&#123; if(ls)t[ls].lazy^=1; if(rs)t[rs].lazy^=1; swap(ls,rs); t[x].lazy=0; &#125; upd(x);&#125;void split(int x,int k,int &amp;a,int &amp;b)&#123; if(!x)&#123;a=b=0;return;&#125; pushdown(x); if(t[ls].sz&gt;=k)b=x,split(ls,k,a,ls),upd(x); else a=x,split(rs,k-t[ls].sz-1,rs,b),upd(x);&#125;int merge(int x,int y)&#123; if(!x||!y)return x+y; pushdown(x);pushdown(y); if(t[x].k&lt;t[y].k)&#123;rs=merge(rs,y);upd(x);return x;&#125; t[y].s[0]=merge(x,t[y].s[0]);upd(y);return y;&#125;void rev(int l,int r)&#123; int x,y,z; split(rt,r,x,y); split(x,l-1,x,z); t[z].lazy=1; printf("%lld\n",t[z].sum); int p=merge(x,z); rt=merge(p,y);&#125;void print(int x)&#123; pushdown(x); if(ls)print(ls); printf("%d ",t[x].v); if(rs)print(rs);&#125;int main()&#123; int i,l,r; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)rt=merge(rt,newnode(i)); for(i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;l,&amp;r); rev(l,r); &#125; print(rt); return 0;&#125; D 题目描述有$k$个长度为$k$的数列，有$k^k$种方式从每个数组中恰取出一个数，每一种方式对应一种和。求这些和中，前$k$小的值分别为多少。 解题思路每次合并两个数组，每次取前$k$小。 对两个数组$a,b$排序，显然应当取$(0,0)$这个对（对$(x,y)$表示取$a_x,b_y$）。每次取出$(x,y)$对的时候，扩展出$(x+1,y)(x,y+1)$两个对。注意去重。 AC代码点击 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll a[2][1010],temp[1010]=&#123;1&#125;;struct nd&#123; int x,y; bool operator&lt;(const nd&amp;b)const&#123;return a[x][y]&gt;a[b.x][b.y]||(a[x][y]==a[b.x][b.y]&amp;&amp;(x&gt;b.x||x==b.x&amp;&amp;y&gt;b.y));&#125;//这里一大串其实也是为了去重 bool operator==(const nd&amp;a)const&#123;return x==a.x&amp;&amp;y==a.y;&#125;&#125;t;priority_queue&lt;nd&gt;Q;int main()&#123; int i,j,k; scanf("%d",&amp;k); for(j=0;j&lt;k;j++)scanf("%lld",&amp;a[0][j]);sort(a[0],a[0]+k); for(i=1;i&lt;k;i++)&#123; for(j=0;j&lt;k;j++)scanf("%lld",&amp;a[1][j]);sort(a[1],a[1]+k); Q.push((nd)&#123;0,0&#125;); for(j=0;j&lt;k;j++)&#123; t=Q.top(); while(!Q.empty()&amp;&amp;Q.top()==t)Q.pop();//去重 temp[j]=a[t.x][t.y]; if(t.x+1&lt;k)Q.push((nd)&#123;t.x+1,t.y&#125;); if(t.y+1&lt;k)Q.push((nd)&#123;t.x,t.y+1&#125;); &#125; for(j=0;j&lt;k;j++)a[0][j]=temp[j]; while(!Q.empty())Q.pop(); &#125; for(i=0;i&lt;k;i++)printf("%lld ",temp[i]); return 0;&#125; E 题目描述给一棵树。对于某个节点$x$，有两种操作，第一种是把节点$x$到树根的路径所有的值赋$1$，并输出这次改变的个数；第二种是把$x$和$x$的子树全部置$0$，并输出这次改变的个数。 解题思路树链剖分，注意$lazy$的使用。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;#define N 100010int n;int count=1,head[N];struct Edge&#123; int end,near;&#125;edge[N&lt;&lt;1];void addedge(int begin,int end)&#123; edge[count].end=end; edge[count].near=head[begin]; head[begin]=count++;&#125;struct SegTree&#123; int l,r,lazy; int sum;&#125;t[N&lt;&lt;2];int depth[N],fa[N],size[N],son[N],pos[N],top[N],temp[N];int cnt;struct Ret&#123; int s,r; struct Ret operator+(const Ret&amp;a)const&#123;return &#123;s+a.s,r+a.r&#125;;&#125;&#125;;void build(int p,int l,int r)&#123; t[p].l=l; t[p].r=r; t[p].lazy=-1; if(l==r)return; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r);&#125;void pushdown(int p)&#123; int l=t[p].lazy; if(l==-1)return; t[p&lt;&lt;1].sum=l*(t[p&lt;&lt;1].r-t[p&lt;&lt;1].l+1); t[p&lt;&lt;1|1].sum=l*(t[p&lt;&lt;1|1].r-t[p&lt;&lt;1|1].l+1); t[p&lt;&lt;1].lazy=t[p&lt;&lt;1|1].lazy=l; t[p].lazy=-1;&#125;struct Ret query(int p,int L,int R)&#123; int l=t[p].l,r=t[p].r; if(l&gt;=L&amp;&amp;r&lt;=R)return (Ret)&#123;t[p].sum,t[p].r-t[p].l+1-t[p].sum&#125;; if(r&lt;L||l&gt;R||p&gt;4*n)return (Ret)&#123;0,0&#125;; pushdown(p); return query(p&lt;&lt;1,L,R)+query(p&lt;&lt;1|1,L,R);&#125;void add(int p,int left,int right,int k)&#123; int l=t[p].l,r=t[p].r; if(l&gt;=left&amp;&amp;r&lt;=right)&#123; t[p].sum=k*(t[p].r-t[p].l+1); t[p].lazy=k; return; &#125; if(r&lt;left||l&gt;right)return; pushdown(p); add(p&lt;&lt;1,left,right,k); add(p&lt;&lt;1|1,left,right,k); t[p].sum=t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].sum;&#125;void dfs1(int now,int f,int dep)&#123; depth[now]=dep; fa[now]=f; size[now]=1; int i,mx=0; for(i=head[now];i;i=edge[i].near)&#123; int p=edge[i].end; if(p!=f)&#123; dfs1(p,now,dep+1); size[now]+=size[p]; if(size[p]&gt;mx)&#123; mx=size[p]; son[now]=p; &#125; &#125; &#125;&#125;void dfs2(int now,int Top)&#123; int i; pos[now]=++cnt; top[now]=Top; if(!son[now])return; dfs2(son[now],Top); for(i=head[now];i;i=edge[i].near)&#123; int p=edge[i].end; if(p!=son[now]&amp;&amp;p!=fa[now])dfs2(p,p); &#125;&#125;void swap(int *A,int *B)&#123;int t=*A;*A=*B;*B=t;&#125;int rangequery(int x,int y)&#123; int ans=0; while(top[x]!=top[y])&#123; if(depth[top[x]]&lt;depth[top[y]])swap(&amp;x,&amp;y); ans+=query(1,pos[top[x]],pos[x]).r; x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y])swap(&amp;x,&amp;y); return ans+query(1,pos[x],pos[y]).r;&#125;void rangeadd(int x,int y,int k)&#123; while(top[x]!=top[y])&#123; if(depth[top[x]]&lt;depth[top[y]])swap(&amp;x,&amp;y); add(1,pos[top[x]],pos[x],k); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y])swap(&amp;x,&amp;y); add(1,pos[x],pos[y],k);&#125;int main()&#123; int i,f; scanf("%d",&amp;n); for(i=1;i&lt;n;i++)&#123; scanf("%d",&amp;f); addedge(f,i);addedge(i,f); &#125; int r=0,q,opt,x; dfs1(r,0,1); dfs2(r,r); build(1,1,n); scanf("%d",&amp;q); for(i=0;i&lt;q;i++)&#123; scanf("%d%d",&amp;opt,&amp;x); if(opt==1)&#123; printf("%d\n",rangequery(0,x)); rangeadd(0,x,1); &#125;else&#123; printf("%d\n",query(1,pos[x],pos[x]+size[x]-1).s); add(1,pos[x],pos[x]+size[x]-1,0); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vjudge296318-ICPC2018亚洲区域赛组题 题解]]></title>
    <url>%2F2019%2F04%2F25%2Fvjudge296318regional2018%2F</url>
    <content type="text"><![CDATA[Solved A B C D E 5/5 O O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给定一个$n$个节点的树和$m$个简单路，求有多少个选择$k$个给定简单路并使得这$k$个简单路交于同一点的方案。答案对$1e9+7$取模。 解题思路先用树上差分求出每个点经过的简单路个数$path[i]$，再用$C(path[i],k)$求出该点的贡献，但显然会有重复。显然，所有路径的交点至少为一个$LCA$，故只需记录每一个点作为$LCA$做出的贡献即可。记录每一个点作为$LCA$的个数$num[i]$，则答案为$\sum_{i=1}^{n}C(path[i],k)-C(path[i]-num[i],k)$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 300005#define mid ((l+r)&gt;&gt;1)struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int d[N],fa[N][22],lg[N],hd[N],cnt,n,m,k;void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;void dfs(int now,int f)&#123; d[now]=d[f]+1; fa[now][0]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++)fa[now][i]=fa[fa[now][i-1]][i-1]; for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=f)dfs(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y])x=fa[x][lg[d[x]-d[y]]]; if(x==y)return x; for(i=lg[d[x]];~i;i--)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int path[N],num[N];void init(int now,int f)&#123; int i,q; for(i=hd[now];i;i=e[i].n)&#123; q=e[i].e; if(q!=f)&#123; init(q,now); path[now]+=path[q]; &#125; &#125;&#125;ll jc[N]=&#123;1&#125;,inv[N]=&#123;1&#125;,w=1000000007;ll c(int n,int m)&#123; if(n&lt;m)return 0; return jc[n]*inv[m]%w*inv[n-m]%w;&#125;ll qpow(ll a,ll b)&#123; int i; ll ans=1; for(i=b;i;i&gt;&gt;=1,a=a*a%w)if(i&amp;1)ans=ans*a%w; return ans;&#125;int main()&#123; int i,t,u,v; for(i=2;i&lt;N;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); for(i=1;i&lt;N;i++)jc[i]=jc[i-1]*i%w,inv[i]=qpow(jc[i],w-2); scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(i=1;i&lt;n;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v),add(v,u); dfs(1,0); for(i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); int w=lca(u,v); path[w]--;path[fa[w][0]]--; path[u]++;path[v]++; num[w]++; &#125; init(1,0); ll ans=0; for(i=1;i&lt;=n;i++) ans=((ans+c(path[i],k)-c(path[i]-num[i],k))%w+w)%w; printf("%lld\n",ans); memset(hd,0,sizeof(int)*(n+1));cnt=0; memset(d,0,sizeof(int)*(n+1)); memset(path,0,sizeof(int)*(n+1)); memset(num,0,sizeof(int)*(n+1)); memset(fa,0,sizeof(int)*(n+1)*22); &#125; return 0;&#125; B 题目描述有$n$个战斗回合，$boss$无限血量，初始状态战斗力$A=0$，预备增量$D=0$。 每一个回合有三个参数$a[i],b[i],c[i]$可以任选下面三种策略之一： 攻击，伤害为$A+a[i]$ 不攻击，$A+=b[i]$ 不攻击，$D+=c[i]$ 每回合结束之后，$A+=D$。 求$n$回合后的最大伤害。所有数在$[1,1e9]$范围内。 解题思路开始想了半天如何$DP$，死活无法推出式子。后来经nikkukun同学的提点，发现可以从后到前递推。 原因是： 操作具有后效性但不具有前效性。 故考虑用$f[i][j]$表示到第$i$个人，已经干了$j$架的最大伤害。 推一下状态转移方程：$f[i][j]=max(f[i+1][j]+max(x\times b[i],j\times c[i]),f[i+1][j-1]+a[i])$前半部分表示选择不攻击的两种方法对答案的贡献，后半部分表示选择攻击的贡献。 但是这里出现了一个莫名其妙的$x$，代表的是操作②对答案的贡献，它的值为所有后续打架的位置和当前位置的距离之和，而这里是一个不能确定的变量。于是增加第三维：所有攻击操作的下标之和。于是就可以愉快地递推了，$x=k-i\times j$。 然后快乐地提交，获得了$MLE$。所以需要滚动一下。 AC代码点击 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll f[2][102][5052],a[110],b[110],c[110],ans;int main()&#123; int i,t,j,n,k; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lld%lld%lld",&amp;a[i],&amp;b[i],&amp;c[i]); for(i=0;i&lt;2;i++)for(j=0;j&lt;=n;j++)for(k=0;k&lt;=n*(n+1)/2;k++)f[i][j][k]=-1; f[0][1][n]=a[n]; int p=0; for(i=n-1;i;i--)&#123; p^=1; for(j=n-i+1;j;j--)&#123; for(k=n*(n+1)/2;k&gt;=n;k--)&#123; if(k-i&gt;=n&amp;&amp;j&gt;=2&amp;&amp;~f[p^1][j-1][k-i])f[p][j][k]=f[p^1][j-1][k-i]+a[i]; if(~f[p^1][j][k])f[p][j][k]=max(f[p][j][k],f[p^1][j][k]+max(c[i]*j,(k-i*j)*b[i])); &#125; &#125; for(j=0;j&lt;=n;j++)for(k=0;k&lt;=n*(n+1)/2;k++)f[p^1][j][k]=-1; &#125; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n*(n+1)/2-i*(i-1)/2;j++) ans=max(ans,f[p][i][j]); printf("%lld\n",ans); &#125; return 0;&#125; C 题目描述给定两个长度$2\leq |s|\leq 10^6,1\leq |t|&lt;|s|$的字符串，求满足以下要求的三元组$(i,j,k)$的个数： $1\leq i\leq j\leq |s|$ $1\leq k\leq |t|$ $j-i+1&gt;k$ 把$[s[i],s[j]]$和$[t[1],t[k]]$拼接起来的新串为回文串。 解题思路题目可以转化为：在$s$中找到连续的串$a,b$，在$t$中找到串$c$，且$a,b,c$不空，$b$为回文串且$a$和$c$倒序相等。 可以先$manacher$处理出$s$中每一个$i$开头的回文串个数（用差分思想），再在旋转过的$b$串后缀中字符串哈希二分查找最长公共子串长度，乘起来再求和即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;typedef long long ll;#define N 2000010#define base 998244353#define mod 2078526727ll hs[N],ht[N],pw[N];char s[N],t[N];char a[N]=&#123;'.'&#125;;int len[N];int p[N];using namespace std;int ls,lt;ll hashf(ll*a,int l,int r)&#123; return ((a[r]-a[l]*pw[r-l])%mod+mod)%mod;&#125;int check(int x,int i)&#123; return hashf(ht,lt-x,lt)==hashf(hs,i-x,i);&#125;int main()&#123; int i; pw[0]=1; for(i=1;i&lt;N;i++)pw[i]=pw[i-1]*base%mod; scanf("%s%s",s,t); ls=strlen(s),lt=strlen(t); reverse(t,t+lt); for(i=0;i&lt;ls;i++)&#123; a[2*i+1]='#'; a[2*i+2]=s[i]; &#125; a[2*ls+1]='#'; int mr=0,mid=0; for(i=1;i&lt;=2*ls+2;i++)&#123; if(mr&gt;i)len[i]=min(mr-i,len[2*mid-i]); else len[i]=1; while(a[i+len[i]]==a[i-len[i]])len[i]++; if(i+len[i]&gt;mr)&#123; mr=i+len[i]; mid=i; &#125; &#125; for(i=1;i&lt;2*ls+2;i++)&#123; p[(i-len[i])/2]++; p[(i)/2]--; &#125; for(i=1;i&lt;=ls;i++)p[i]+=p[i-1]; hs[0]=ht[0]=1; for(i=1;i&lt;=ls;i++)hs[i]=(hs[i-1]*base+s[i-1]-'a')%mod; for(i=1;i&lt;=lt;i++)ht[i]=(ht[i-1]*base+t[i-1]-'a')%mod; ll ans=0; for(i=1;i&lt;ls;i++)&#123; if(s[i-1]!=t[lt-1])continue; int l=1,r=min(lt,i); while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid,i))l=mid+1; else r=mid; &#125; if(!check(l,i))l--; ans+=p[i]*1LL*l; &#125; printf("%I64d",ans); return 0;&#125; D 题目描述有$n$个人，每个人能打$t[i]$个怪兽，分别为$m[i][j]$。每个人最多只能打一只怪兽。这时候提供了$k$个膜法药水，一个人最多可以喝一瓶，喝了一瓶之后最多就能打两只怪兽了。 问最好的分配情况下，一共能打多少只怪兽。 解题思路非常裸的网络流，从源点到每个人、每个怪兽到汇点建长度为$1$的边，每个人与他能打的怪兽之间建长度为$1$的边。再考虑膜法药水，从源点到新增节点$magic$建长度为$k$的边，从$magic$到每个人建长度为$1$的边，跑一遍最大流即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1010int s,t,magic;struct Edge&#123; int end,near,len;&#125;e[N*N];int head[N],cnt=1,cur[N];int n,m,k;void add(int a,int b,int l)&#123; e[++cnt].end=b; e[cnt].near=head[a]; e[cnt].len=l; head[a]=cnt;&#125;queue&lt;int&gt;Q;int dep[N];int bfs()&#123; int i,p,q; memset(dep,0,sizeof(dep)); for(i=0;i&lt;=magic;i++)cur[i]=head[i]; Q.push(s);dep[s]=1; while(!Q.empty())&#123; p=Q.front();Q.pop(); for(i=head[p];i;i=e[i].near)&#123; q=e[i].end; if(e[i].len&amp;&amp;!dep[q])&#123; dep[q]=dep[p]+1; Q.push(q); &#125; &#125; &#125; return dep[t];&#125;int dfs(int p,int flow)&#123; if(p==t)return flow; int i,q; for(i=cur[p];i;i=e[i].near)&#123; cur[p]=i; q=e[i].end; if(dep[q]==dep[p]+1&amp;&amp;e[i].len)&#123; int ans=dfs(q,min(flow,e[i].len)); if(ans)&#123; e[i].len-=ans; e[i^1].len+=ans; return ans; &#125; &#125; &#125; return 0;&#125;int dinic()&#123; int d,ans=0; while(bfs())&#123; while((d=dfs(s,1e6))) ans+=d; &#125; return ans;&#125;int main()&#123; int i,j,M,T; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); s=0; t=n+m+1; magic=t+1; for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;T); for(j=0;j&lt;T;j++)scanf("%d",&amp;M),add(i,M+n,1),add(M+n,i,0); &#125; add(s,magic,k),add(magic,s,0); for(i=1;i&lt;=n;i++)&#123; add(s,i,1),add(i,s,0); add(magic,i,1),add(i,magic,0); &#125; for(i=1;i&lt;=m;i++)add(i+n,t,1),add(t,i+n,0); printf("%d",dinic()); return 0;&#125; E 题目描述给定一个有$n$个数（$1\leq n\leq 10^6$）的正整数序列$a[i]$，$1\leq a[i]\leq 10^6$。。定义$mul(l,r)=\prod_{i=l}^{r}a[i]$，$fac(l,r)$为$mul(l,r)$中的所有质因数种数之和。 求$\sum_{i=1}^{n}\sum_{j=i}^{n}fac(i,j)$。 解题思路考虑每一个质因数的贡献，设它出现的位置为$p[1],p[2],…,p[m]$。不妨设$p[0]=0,p[m+1]=n+1$，则其贡献为$\frac{n\times (n+1)}2-\sum_{i=0}^{m}\frac{(p[i+1]-p[i])(p[i+1]-p[i]-1)}2$。枚举每一个$a[i]$，计算出其对应的所有质因数，最后统计即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1000010int n,prime[N],a[N]=&#123;1,1&#125;,cnt;ll ans;vector&lt;int&gt;num[N];ll f(ll a,ll b)&#123;return (b-a+1)*(b-a+2)/2;&#125;int main()&#123; int i,j,p; for(i=2;i&lt;N;i++)&#123; if(!a[i])prime[cnt++]=i,a[i]=cnt-1; for(j=0;i*prime[j]&lt;N&amp;&amp;j&lt;cnt;j++)&#123; a[i*prime[j]]=1; if(i%prime[j]==0)break; &#125; &#125; scanf("%d",&amp;n); for(i=0;i&lt;cnt;i++)num[i].push_back(0); for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;p); for(j=0;j&lt;cnt&amp;&amp;prime[j]*prime[j]&lt;=p;j++)&#123; if(p%prime[j]==0)&#123; num[j].push_back(i); while(p%prime[j]==0)p/=prime[j]; &#125; &#125; if(p&gt;1)num[a[p]].push_back(i); &#125; for(i=0;i&lt;cnt;i++)num[i].push_back(n+1); for(i=0;i&lt;cnt;i++)&#123; ans+=1LL*(n+1)*n/2; for(j=1;j&lt;num[i].size();j++) ans-=f(num[i][j-1]+1,num[i][j]-1); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南昌邀请赛网络赛2019.04.20 题解]]></title>
    <url>%2F2019%2F04%2F21%2Fnanchanginternet2019%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M 7/13 O . . . . . . O O Ø O Ø O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 官方题解 A 题目描述输出前五个完全数。 解题思路打表。 AC代码点击 12345#include&lt;bits/stdc++.h&gt;int main()&#123; printf("6\n28\n496\n8128\n33550336"); return 0;&#125; B 题目描述解题思路AC代码点击 12 C 题目描述解题思路AC代码点击 12 D 题目描述解题思路AC代码点击 12 E 题目描述解题思路AC代码点击 12 F 题目描述解题思路AC代码点击 12 G 题目描述解题思路AC代码点击 12 H 题目描述给定一个$2\times N$的格点图，从左上角走到右下角，可以向上、下、左、右、左上、左下、右上、右下走，走过的点的集合为$S$，求$S$的种数对$1000000007$取模的值。$0&lt;n\leq 10^9$。 解题思路最左一列只能有两种选择：只经过上面、两块都经过 最右一列只能有两种选择：只经过下面、两块都经过 其他列每一列至少需要有一个经过的点，故有三种选择：只经过上面、只经过下面、两块都经过。 于是，答案为$4\times 3^{N-2}$。注意特判$N=1$。 AC代码点击 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int w=1000000007,n;ll qpow(ll a,ll b)&#123; ll ans=1; int i; for(i=b;i;i&gt;&gt;=1,a=a*a%w)if(i&amp;1)ans=ans*a%w; return ans;&#125;int main()&#123; scanf("%d",&amp;n); if(n==1)printf("1"); else printf("%d",1LL*4*qpow(3,n-2)%w); return 0;&#125; I 题目描述给定一个序列，求其中一个子序列，其中元素$a[i]∈[-10^5,10^5]$，使得其区间最小值乘区间和最大，求出最大值。 解题思路代码&amp;思路 by​ Nikkukun 对于每一个值作为区间最小值，求出最大的左端与右端，求出其和的最大值，复杂度$O(n^2)$。 考虑最小值的正负，当最小值为正时，向左右分别延伸到最大值且不含比该值小的数的区间；否则延伸到最小值且不含比该值小的数的区间。 用线段树维护区间最大值，乘以$-1$后也可维护区间最小值（用$ST$表会$MLE$）。 再用含偏移的树状数组（处理负数）维护距离$a[i]$最近的、比$a[i]$小的下标$j$。从左端往右、从右端往左分别维护一个树状数组，树状数组的下标表示$a[i]$，其值表示下标$j$。 AC代码-BIT+线段树 By Nikkukun-223ms点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (o&lt;&lt;1)#define rson ((o&lt;&lt;1)|1)typedef long long ll;const int N=500000+5,BIAS=100000+5,T=BIAS*2,LEN=18+2;const ll INF=0x3f3f3f3f3f3f3f3f;struct BITree&#123; int t[T]; BITree()&#123; memset(t,0,sizeof(t)); &#125; int Lowbit(int x)&#123; return x&amp;(-x); &#125; void Add(int x,int v)&#123; for(;x&lt;T;x+=Lowbit(x)) t[x]=v; &#125; int Query(int x)&#123; int ret=0; for(;x;x-=Lowbit(x)) ret=max(ret,t[x]); return ret; &#125;&#125;;struct ST&#123; ll t[N*4]; void Build(int o,int L,int R,ll a[],int f)&#123; if(L==R)&#123; t[o]=f*a[L]; return; &#125; int M=(L+R)/2; Build(lson,L,M,a,f); Build(rson,M+1,R,a,f); t[o]=max(t[lson],t[rson]); &#125; ll Query(int o,int L,int R,int qL,int qR)&#123; if(qL&lt;=L&amp;&amp;R&lt;=qR)return t[o]; ll ret=-INF; int M=(L+R)/2; if(qL&lt;=M)ret=max(ret,Query(lson,L,M,qL,qR)); if(M+1&lt;=qR)ret=max(ret,Query(rson,M+1,R,qL,qR)); return ret; &#125;&#125;;int a[N];int l[N],r[N];ll suml[N],sumr[N];BITree bitl,bitr;ST stl[2],str[2];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; l[i]=bitl.Query(a[i]+BIAS); bitl.Add(a[i]+BIAS+1,i); suml[i]=suml[i-1]+a[i]; &#125; for(int i=n;i&gt;0;i--)&#123; r[i]=bitr.Query(a[i]+BIAS); bitr.Add(a[i]+BIAS+1,n-i+1); sumr[i]=sumr[i+1]+a[i]; &#125; stl[0].Build(1,1,n,suml,1); stl[1].Build(1,1,n,suml,-1); str[0].Build(1,1,n,sumr,1); str[1].Build(1,1,n,sumr,-1); ll ans=0; for(int i=1;i&lt;=n;i++)&#123; int j=(a[i]&gt;0)?0:1; int f=(a[i]&gt;0)?1:-1; ll L=f*str[j].Query(1,1,n,l[i]+1,i)-sumr[i]; ll R=f*stl[j].Query(1,1,n,i,n-r[i]+1-1)-suml[i]; ans=max(ans,(L+R+a[i])*a[i]); &#125; printf("%lld",ans); return 0;&#125; 赛后突然发现维护一个单调增的单调栈亦可以找出左右端的最大伸展区间。 AC代码-单调栈+线段树 By Potassium-514ms点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 500002#define mid ((l+r)&gt;&gt;1)#define inf 9e18int sta[N],n,top,l[N],r[N];ll a[N],s[N];struct SegTree&#123; ll mn,mx; int l,r;&#125;t[N&lt;&lt;2];void build(int l,int r,int p)&#123; t[p].l=l;t[p].r=r; if(l==r)&#123; t[p].mn=t[p].mx=s[l]; return; &#125; build(l,mid,p&lt;&lt;1); build(mid+1,r,p&lt;&lt;1|1); t[p].mn=min(t[p&lt;&lt;1].mn,t[p&lt;&lt;1|1].mn); t[p].mx=max(t[p&lt;&lt;1].mx,t[p&lt;&lt;1|1].mx);&#125;ll querymin(int l,int r,int p)&#123; int L=t[p].l,R=t[p].r; if(L&gt;=l&amp;&amp;R&lt;=r)return t[p].mn; if(L&gt;r||R&lt;l)return inf; return min(querymin(l,r,p&lt;&lt;1),querymin(l,r,p&lt;&lt;1|1));&#125;ll querymax(int l,int r,int p)&#123; int L=t[p].l,R=t[p].r; if(L&gt;=l&amp;&amp;R&lt;=r)return t[p].mx; if(L&gt;r||R&lt;l)return -inf; return max(querymax(l,r,p&lt;&lt;1),querymax(l,r,p&lt;&lt;1|1));&#125;int main()&#123; int i; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]),s[i]=s[i-1]+a[i]; for(i=1;i&lt;=n;i++)&#123; while(top&amp;&amp;a[sta[top]]&gt;=a[i])top--; l[i]=top?sta[top]+1:1; sta[++top]=i; &#125; top=0; for(i=n;i;i--)&#123; while(top&amp;&amp;a[sta[top]]&gt;=a[i])top--; r[i]=top?sta[top]-1:n; sta[++top]=i; &#125; ll ans=0; build(0,n,1); for(i=1;i&lt;=n;i++)&#123; ll lmn=querymin(l[i]-1,i,1),rmn=querymin(i,r[i],1); ll lmx=querymax(l[i]-1,i,1),rmx=querymax(i,r[i],1); ans=max(ans,a[i]*(rmn-lmx)); ans=max(ans,a[i]*(rmx-lmn)); &#125; printf("%lld",ans); return 0;&#125; J 题目描述给定一棵含$n$个节点的树，有$m$个询问，每个询问$(u,v,k)$求给定两点$(u,v)$之间路径长度不大于$k$的路径数。 $2\leq n \leq 10^5,1\leq m\leq 10^5,1\leq u,v\leq n,0\leq k \leq 10^9$。 解题思路如果求区间小于$k$的个数，可以用主席树；而在树上路径，则可以用在树上建主席树。设$f(b)$表示从根$(1)$到$b$的路径中小于等于$k$的路径个数，则$ans(u,v,k)=f(u)+f(v)-2f(lca(u,v))$。 注意离散化。 主席树早忘光了，赛场上没写出来…… AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100005#define mid ((l+r)&gt;&gt;1)struct Edge&#123; int e,n,l;&#125;e[N&lt;&lt;1];int d[N],fa[22][N],lg[N],hd[N],cnt;void add(int a,int b,int l)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;e[cnt].l=l;&#125;void dfs2(int now,int f)&#123; d[now]=d[f]+1; fa[0][now]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++) fa[i][now]=fa[i-1][fa[i-1][now]]; for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=f)dfs2(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y]) x=fa[lg[d[x]-d[y]]][x]; if(x==y)return x; for(i=lg[d[x]];~i;i--) if(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y]; return fa[0][x];&#125;int A[N],B[N];int root[N],L[N&lt;&lt;5],R[N&lt;&lt;5],sum[N&lt;&lt;5];int build(int l,int r)&#123; int now=++cnt; sum[now]=0; if(l&lt;r)&#123; L[now]=build(l,mid); R[now]=build(mid+1,r); &#125; return now;&#125;int update(int root,int l,int r,int x)&#123; int now=++cnt; L[now]=L[root]; R[now]=R[root]; sum[now]=sum[root]+1; if(l&lt;r)&#123; if(x&lt;=mid)L[now]=update(L[root],l,mid,x); else R[now]=update(R[root],mid+1,r,x); &#125; return now;&#125;int query(int lt,int rt,int l,int r,int x)&#123; if(l&gt;=r)&#123; if(B[l]&lt;=x)return sum[rt]-sum[lt]; else return 0; &#125; if(B[mid]&lt;=x)return sum[L[rt]]-sum[L[lt]]+query(R[lt],R[rt],mid+1,r,x); return query(L[lt],L[rt],l,mid,x);&#125;int mx;int quer(int x,int z)&#123; return query(root[1],root[x],1,mx,z);&#125;void dfs(int r,int f,int len)&#123; int i; root[r]=update(root[f],1,mx,lower_bound(B+1,B+mx+1,len)-B); for(i=hd[r];i;i=e[i].n)&#123; int q=e[i].e; if(q!=f)dfs(q,r,e[i].l); &#125;&#125;int main()&#123; int i,n,m,a,b,l; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;n;i++)scanf("%d%d%d",&amp;a,&amp;b,&amp;l),add(a,b,l),add(b,a,l),A[i]=B[i]=l; cnt=0; sort(B+1,B+n); mx=unique(B+1,B+n)-B-1; root[0]=build(1,mx); dfs(1,0,0); dfs2(1,0); for(i=2;i&lt;=n;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;l); printf("%d\n",quer(a,l)+quer(b,l)-2*quer(lca(a,b),l)); &#125; return 0;&#125; K 题目描述给定一个序列${a_n}$，定义三个函数$f,g,w$，$f(l,r)=\oplus a[x] (l\leq x\leq r)$，$g(l,r)=\oplus f(x) (l\leq x\leq r)$，$w(l,r)=\oplus g(x) (l\leq x\leq r)$。 有$q$个询问，每次询问一个区间$[l,r]$，输出$w(l,r)$。 解题思路比赛的时候模拟一下$fgw$打了个表找出来规律，然后就过了。 最后的结果是一个有规律的平行四边形，用线段树很容易维护。（用前缀和也可，但打线段树打上瘾了） 打表代码点击 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;int ans[1000];void f(int x,int y)&#123; int i; for(i=x;i&lt;=y;i++)ans[i]^=1;&#125;void g(int x,int y)&#123; int i,j; for(i=x;i&lt;=y;i++)for(j=i;j&lt;=y;j++)f(i,j);&#125;void w(int x,int y)&#123; int i,j; for(i=x;i&lt;=y;i++)for(j=i;j&lt;=y;j++)g(i,j);&#125;int main()&#123; int i,j; for(i=1;i&lt;=20;i++)&#123; memset(ans,0,sizeof(ans)); w(1,i); for(j=1;j&lt;=i;j++)printf("%d ",ans[j]); puts(""); &#125; return 0;&#125; 输出结果： $1$$1 1$$0 1 0$$0 0 0 0$$1 0 0 0 1$$1 1 0 0 1 1$$0 1 0 0 0 1 0$$0 0 0 0 0 0 0 0$$1 0 0 0 1 0 0 0 1$$1 1 0 0 1 1 0 0 1 1$$0 1 0 0 0 1 0 0 0 1 0$$0 0 0 0 0 0 0 0 0 0 0 0$$1 0 0 0 1 0 0 0 1 0 0 0 1$$1 1 0 0 1 1 0 0 1 1 0 0 1 1$$0 1 0 0 0 1 0 0 0 1 0 0 0 1 0$$0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0$$1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1$$1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1$$0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0$$0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0$ AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int read()&#123; char c=getchar();int now=0,f=1; while(c&gt;'9'||c&lt;'0')&#123; if(c=='-')f=-1; c=getchar(); &#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123; now=(now&lt;&lt;3)+(now&lt;&lt;1)+c-'0'; c=getchar(); &#125; return now*f;&#125;#define N 100010struct Tree&#123; int l,r,dat;&#125;t[4][N&lt;&lt;2];int a[N],n;void build(int R,int p,int l,int r)&#123; t[R][p].l=l;t[R][p].r=r; if(l==r)&#123; t[R][p].dat=(l%4==R)?a[l]:0; return; &#125; build(R,p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(R,p&lt;&lt;1|1,(l+r&gt;&gt;1)+1,r); t[R][p].dat=t[R][p&lt;&lt;1].dat^t[R][p&lt;&lt;1|1].dat;&#125;int query(int R,int p,int l,int r)&#123; int L=t[R][p].l,Rr=t[R][p].r; if(l&lt;=L&amp;&amp;Rr&lt;=r)return t[R][p].dat; if(L&gt;r||Rr&lt;l)return 0; return query(R,p&lt;&lt;1,l,r)^query(R,p&lt;&lt;1|1,l,r);&#125;int main()&#123; int T,i,q; T=read(); while(T--)&#123; n=read(); for(i=1;i&lt;=n;i++)a[i]=read(); for(i=0;i&lt;4;i++)build(i,1,1,n); q=read(); while(q--)&#123; int l=read(),r=read(); int R=l%4; if((r-l+1)%4==0)printf("0\n"); else if((r-l+1)%4==1)printf("%d\n",query(R,1,l,r)); else if((r-l+1)%4==3)printf("%d\n",query((R+1)%4,1,l+1,r)); else printf("%d\n",query(R,1,l,r)^query((R+1)%4,1,l+1,r)); &#125; &#125; return 0;&#125; L 题目描述有一棵树，第一年是一个杆，每年每个叶子节点伸出三个长度为当前树枝长度四分之一的树枝，分别与当前树枝方向呈$0°,60°,-60°$。给一个方程为$y=k(x-x_0)+y_0$的直线去砍这棵树，问最后根节点连带的一段没被砍掉的有多么长。 解题思路？？这么水一题当时怎么没做 根据深度找搜索方向，深搜一遍，$3^{14}$甚至不需要剪枝（什么，最后只跑了14ms）。 AC代码点击 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define delta (k*(a-x)+y-b)using namespace std;int n,l;double x,y,k;int OnLine(double a,double b)&#123; if(fabs(delta)&lt;1e-8)return 0; if(delta&lt;0)return -1; return 1;&#125;double dir[6][2]=&#123;&#123;0,1&#125;,&#123;-sqrt(3)/2,0.5&#125;,&#123;-sqrt(3)/2,-0.5&#125;,&#123;0,-1&#125;,&#123;sqrt(3)/2,-0.5&#125;,&#123;sqrt(3)/2,0.5&#125;&#125;;double dfs(int dep,int di,double a,double b,double len)&#123; if(dep==n||!OnLine(a,b))return 0; double dis=delta/(dir[di][1]-k*dir[di][0]); if(dis&gt;=0&amp;&amp;dis&lt;=len)return dis; return len+ dfs(dep+1,(di+1)%6,a+len*dir[di][0],b+len*dir[di][1],len/4)+ dfs(dep+1,di,a+len*dir[di][0],b+len*dir[di][1],len/4)+ dfs(dep+1,(di+5)%6,a+len*dir[di][0],b+len*dir[di][1],len/4);&#125;int main()&#123; int i,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%lf%lf%lf",&amp;l,&amp;n,&amp;x,&amp;y,&amp;k); printf("%.6f\n",dfs(0,0,0,0,l)); &#125; return 0;&#125; M 题目描述给一个只含小写字母的字符串$S$，$n$个字符串$T$，判断每一个$T$是否是$S$的子串。$0&lt; |S|,|T|\leq 1e5$。 解题思路代码&amp;思路 by Nikkukun 预处理出$nxt[i][j]$表示第$i$位字符之后最接近的字符$j+’a’$的下一个位置，$O(\sum_{i=1}^n len(T_i))$处理。 AC代码-By Nikkukun-1783ms点击 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;const int N=100000+5,C=26+2;char s[N],t[N];int nxt[N][C];int main()&#123; scanf("%s",s); int i,j,n=strlen(s),q; memset(nxt,-1,sizeof(nxt)); for(i=0;i&lt;n;i++)nxt[i][s[i]-'a']=i; for(j=0;j&lt;C;j++)nxt[n][j]=n; for(i=n-1;i&gt;=0;i--) for(j=0;j&lt;C;j++) if(~nxt[i][j])nxt[i][j]=nxt[i+1][j]; scanf("%d",&amp;q); while(q--)&#123; scanf("%s",t); int m=strlen(t); int p=0,cnt=0; while(cnt&lt;m&amp;&amp;nxt[p][t[cnt]-'a']&lt;n)&#123; p=nxt[p][t[cnt]-'a']+1; cnt++; &#125; printf((cnt==m)?"YES\n":"NO\n"); &#125; return 0;&#125; 赛后发现，原来暴力也能过，而且竟然只是$1700ms$和$2000ms$的差别。。。 AC代码-By Potassium-2093ms点击 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;char a[100002],b[100002];int main()&#123; int n,x,y,la,lb,flag; scanf("%s%d",a,&amp;n); while(n--)&#123; scanf("%s",b); if((lb=strlen(b))&gt;(la=strlen(a)))printf("NO\n"); else&#123; x=y=flag=0; while(x&lt;la&amp;&amp;y&lt;lb)&#123; if(a[x]==b[y])x++,y++; else&#123; x++; if(!a[x])&#123; flag=1; break; &#125; &#125; &#125; if(!b[y]&amp;&amp;!flag)printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北理校赛2019.04.14 题解]]></title>
    <url>%2F2019%2F04%2F16%2Fbitcontest2019%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L 12/12 O O O Ø O O Ø O Ø O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给一个表，求打表结果。 解题思路签到打比赛，一个愿打一个愿挨。 AC代码点击 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;int x[10][10]; char ch[4]=&#123;'I','E'&#125;;int main()&#123; int i,n; x[0][5]=x[1][1]=x[1][3]=x[1][5]=x[2][1]=x[2][3]=x[2][5]=1; x[3][1]=x[3][3]=x[3][5]=x[4][1]=x[5][3]=1; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; char a[10]=&#123;0&#125;; scanf("%s",a); int p=a[0]-'0',q=2; if(!p)&#123; printf("X"); continue; &#125; if(a[1])&#123; if(a[2])&#123; if(a[2]=='-')q=0; else q=4; &#125;else&#123; if(a[1]=='-')q=1; else q=3; &#125; &#125; printf("%c",ch[x[q][p]]); &#125; return 0;&#125; B 题目描述给定$m$个字符串$a[i] (1 \leq i \leq m)$，求一个长度为$n$的字符串$A$，使得$a[i] (i\leq i \leq m)$均不为$A$的连续子串。 解题思路$AC$自动机套$DP$。用$dep[i]$表示$i$这个节点最多能延伸到多么深。沿着$trie$图走，记忆化搜索，只要遇到字符串标记则记$dep[i]=0$。如果成环则必定可行（这一个环上都没有子串），所以用$vis[i]$表示当前走过的路径，以缩减搜索时间。最后输出的时候再沿着可行边走即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define N 800010#define P 26int t[N][P],END[N],fail[N],tot,n,m;char a[N];void insert()&#123; int i,now=0; for(i=0;a[i];i++)&#123; int c=a[i]-'a'; if(!t[now][c])t[now][c]=++tot; now=t[now][c]; &#125; END[now]++;&#125;queue&lt;int&gt;Q;void build()&#123; int i; for(i=0;i&lt;P;i++)if(t[0][i])Q.push(t[0][i]); while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=0;i&lt;P;i++)&#123; if(!t[p][i])t[p][i]=t[fail[p]][i]; else&#123; fail[t[p][i]]=t[fail[p]][i]; if(END[fail[t[p][i]]])END[t[p][i]]=1; Q.push(t[p][i]); &#125; &#125; &#125;&#125;int vis[N],dep[N];int dfs(int d,int now)&#123; if(vis[now])return dep[now]=1e6; if(~dep[now])return dep[now]; if(END[now])return dep[now]=0; if(!d)return dep[now]=1; vis[now]=1; dep[now]=0; int i; for(i=0;i&lt;P;i++)dep[now]=max(dep[now],dfs(d-1,t[now][i])+1); vis[now]=0; return dep[now];&#125;void print(int d)&#123; int i,now=0; while(d)&#123; for(i=0;i&lt;P;i++)&#123; if(d&lt;=dep[t[now][i]])&#123; printf("%c",i+'a');d--; now=t[now][i]; break; &#125; &#125; &#125;&#125;int main()&#123; int i; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;m;i++)scanf("%s",a),insert(); build(); memset(dep,-1,sizeof(dep)); dfs(n,0); print(n); return 0;&#125; C 题目描述路上有$n$个怪兽，每个怪兽有攻击力$x[i]$血量$d[i]$，你的攻击力是$k$。每遇到一个怪兽，你先手攻击，之后轮流攻击，当怪兽的血量$\leq 0$的时候该怪兽死亡。 有$c$个道具，该道具可以在瞬间吃下而且使本回合临时增加$k$点攻击力，该道具可以在任意时候吃，且可以连续吃。问你最少消耗多少血量。 解题思路一个道具相当于多打该怪兽一个回合，贪心地攻击攻击力最高的怪兽即可，记得开$long$ $long$。 AC代码点击 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct Monster&#123; int d,x; bool operator&lt;(const Monster&amp;a)const&#123;return x&gt;a.x;&#125;&#125;a[100010];int tot;int main()&#123; int i,n,k,c,d,x; scanf("%d%d%d",&amp;n,&amp;k,&amp;c); for(i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;d,&amp;x); if(d&gt;k)a[tot++]=(Monster)&#123;d/k+(d%k!=0)-1,x&#125;; &#125; sort(a,a+tot); int left=0; for(i=0;i&lt;c;i++)&#123; a[left].d--; if(a[left].d&lt;=0)left++; if(left&gt;=tot)break; &#125; long long ans=0; for(i=0;i&lt;tot;i++)ans+=a[i].d*1LL*a[i].x; printf("%lld",ans); return 0;&#125; D 题目描述在宽为$w$的走廊中有$n$个圆形障碍物，求能通过该走廊的最大圆的半径。 解题思路显然，最大的圆能够使得整个走廊两端连接。故以两点之间距离减两圆半径作为边权，用$krustal$跑一遍最小生成树，答案即为最大边权。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define N 1002using namespace std;struct Circle&#123; int x,y,r; double dis; bool operator&lt;(const Circle&amp;a)const&#123;return dis&lt;a.dis;&#125;&#125;a[N];int x[N],n,w;double dist(int X1,int Y1,int X2,int Y2)&#123; return sqrt((X1-X2)*(X1-X2)+(Y1-Y2)*(Y1-Y2));&#125;void upd(int now,int last)&#123; double d; if(a[last].y+a[last].r&gt;=w&amp;&amp;a[now].y+a[now].r&gt;=w)a[now].dis=0; else if(a[now].dis&gt;(d=dist(a[now].x,a[now].y,a[last].x,a[last].y)-a[now].r-a[last].r))a[now].dis=d;&#125;int main()&#123; int i,j,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;w,&amp;n); for(i=0;i&lt;n;i++)scanf("%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].r),a[i].dis=a[i].y-a[i].r,x[i]=a[i].x; sort(x,x+n); int mx=unique(x,x+n)-x; for(i=0;i&lt;mx;i++)a[n++]=(Circle)&#123;x[i],w,0,w*1.0&#125;; sort(a,a+n); double ans=max(a[0].dis,0.0); for(j=1;j&lt;n;j++)upd(j,0); sort(a,a+n); for(i=1;i&lt;n;i++)&#123; //for(j=0;j&lt;n;j++)printf("%d %d %d %.4f\n",a[j].x,a[j].y,a[j].r,a[j].dis); sort(a+i,a+n); ans=max(ans,a[i].dis); for(j=i+1;j&lt;n;j++)upd(j,i); &#125; printf("%.10f\n",ans/2); &#125; return 0;&#125; E 题目描述给一个全排列，求多少个栈才能把全排列变成有序的升序序列。 解题思路两个栈必定能完成全部操作：想取出任意一个元素均有可行方案。故只需要判断能否用一个栈解决。 AC代码点击 123456789101112131415161718#include&lt;stdio.h&gt;int st[100010],top,t,n,now,a[100010];int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; top=0;now=1; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)&#123; st[top++]=a[i]; while(top&amp;&amp;st[top-1]==now)top--,now++; &#125; if(now!=n+1)printf("2\n"); else printf("1\n"); &#125; return 0;&#125; F 题目描述给一个$n\times m$的网格图，求本质不同的四个顶点都在格点上构成的正方形个数。 解题思路先考虑边长为$i\times i$的正方形，以它的四个边上的点为顶点的正方形个数为$i$。 故答案即为$\sum_{i=1}^{m}(n-i+1)\times (m-i+1)\times i$。 AC代码点击 12345678910111213#include&lt;stdio.h&gt;int t,n,m;int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; long long ans=0; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=m;i++)ans+=1LL*(n-i+1)*(m-i+1)*i; printf("%lld\n",ans); &#125; return 0;&#125; G 题目描述有两个区域，$A$区域的人全都要去$B$区域。$A$区域的人分别位于$c[i]$上，$B$区域只能到达$d[i]$。现在给定$n$条特殊道路，$A$区域$[a,b]$范围和$B$区域$[c,d]$范围连通，需要的耗时为$w$，问$A$区的人同时出发，最后到达的人所需时间是多少。 解题思路新建$s,t$，连$t-&gt;B,B-&gt;A,A-&gt;s$的边，跑最短路，找到$t$到$c[i]$路径最长的即为答案。 三种边分别如何连呢？ $t-&gt;B:$$t$到所有$d[i]$$A-&gt;s:$所有$c[i]$到$s$（其实完全可以不连）$B-&gt;A:$线段树维护，添加特殊点保证连边数量线性。 其中令左线段树($B$)上的点为其编号本身，令右线段树($A$)上的点为其编号本身$+2n$，叶节点序号用$lnum,rnum$表示。 线段树维护过程：将线段树上每一个节点视为点，则该点代表所有以它为根的子树，故初始化的时候左线段树连接从儿子到爸爸权值为$0$的边，右线段树连接从爸爸到儿子权值为$0$的边。添加特殊道路时，添加一个中间特殊点，分别同向连接两棵线段树。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;#define N (100000&lt;&lt;3)struct Edge&#123; int e,n,l;&#125;e[(N)&lt;&lt;2];int hd[N],cnt;void add(int a,int b,int l)&#123; e[++cnt].e=b;e[cnt].n=hd[a];e[cnt].l=l;hd[a]=cnt; //printf("%d %d %d %d\n",a,b,l,cnt);&#125;struct Tree&#123; int l,r;&#125;t1[N],t2[N];int t,s,n,m,p,q;int c[N],d[N];int ltnum(int x)&#123;return x;&#125;//lefttreenumint rtnum(int x)&#123;return x+2*n;&#125;//righttreenumint lnum[N],rnum[N];int tot;void build(struct Tree *a,int l,int r,int p,int dir)&#123;//dir:从根到叶-1；从叶到根-0 a[p].l=l; a[p].r=r; if(l==r)&#123; if(!dir)lnum[l]=p; else rnum[l]=p+2*n; return; &#125; build(a,l,(l+r)&gt;&gt;1,p&lt;&lt;1,dir); build(a,((l+r)&gt;&gt;1)+1,r,p&lt;&lt;1|1,dir); if(a[p&lt;&lt;1].l)&#123; if(!dir)add(ltnum(p&lt;&lt;1),ltnum(p),0); else add(rtnum(p),rtnum(p&lt;&lt;1),0); &#125; if(a[p&lt;&lt;1|1].l)&#123; if(!dir)add(ltnum(p&lt;&lt;1|1),ltnum(p),0); else add(rtnum(p),rtnum(p&lt;&lt;1|1),0); &#125;&#125;void adde(struct Tree *a,int l,int r,int midpoint,int p,int dir,int w,int offset)&#123; //offset:点的id int L=a[p].l,R=a[p].r; if(l&lt;=L&amp;&amp;R&lt;=r)&#123; if(!dir)add(p+offset,midpoint,w); else add(midpoint,p+offset,w); return; &#125; if(a[p&lt;&lt;1].r&gt;=l)adde(a,l,r,midpoint,p&lt;&lt;1,dir,w,offset); if(a[p&lt;&lt;1|1].l&lt;=r)adde(a,l,r,midpoint,p&lt;&lt;1|1,dir,w,offset);&#125;struct Node&#123; int x; long long w; bool operator&lt;(const Node&amp;a)const&#123;return w&gt;a.w;&#125;&#125;;priority_queue&lt;Node&gt;Q;int vis[N];long long dis[N];void dijkstra()&#123; int i; Q.push((Node)&#123;t,0&#125;); while(!Q.empty())&#123; int top=Q.top().x; Q.pop(); if(vis[top])continue; vis[top]=1; for(i=hd[top];i;i=e[i].n)&#123; int q=e[i].e; if(dis[q]&gt;dis[top]+0LL+e[i].l)&#123; dis[q]=dis[top]+0LL+e[i].l; Q.push((Node)&#123;q,dis[q]&#125;); &#125; &#125; &#125;&#125;int main()&#123; int i,a,b,C,D,w; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;p,&amp;q); while(n&amp;(n-1))n++; t=4*n+1; tot=s=4*n+2; build(t1,1,n,1,0); build(t2,1,n,1,1); for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;C,&amp;D,&amp;w); adde(t2,a,b,++tot,1,0,w,2*n); adde(t1,C,D,tot,1,1,0,0); adde(t2,C,D,++tot,1,0,w,0); adde(t1,a,b,tot,1,1,0,2*n); &#125; for(i=0;i&lt;p;i++)scanf("%d",&amp;c[i]); for(i=0;i&lt;q;i++)scanf("%d",&amp;d[i]); sort(d,d+q);q=unique(d,d+q)-d;for(i=0;i&lt;q;i++)add(t,lnum[d[i]],0); sort(c,c+p);p=unique(c,c+p)-c;for(i=0;i&lt;p;i++)add(rnum[c[i]],s,0); memset(dis,0x3f,sizeof(dis)); dis[t]=0; dijkstra(); long long ans=0; for(i=0;i&lt;p;i++)ans=max(ans,dis[rnum[c[i]]]); if(ans&lt;1e16)printf("%I64d",ans); else printf("boring game"); return 0;&#125; H 题目描述找出$\sqrt {ax}+b=x$的解，保证解存在且为整数。 解题思路初中数学题。 AC代码点击 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;math.h&gt;int t,a,b;int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;a,&amp;b); int A[6]=&#123;0&#125;,ans=0; int x1=round(1.0*(2*b+a+sqrt(a*a+4*a*b))/2),x2=round(1.0*(2*b+a-sqrt(a*a+4*a*b))/2); if(fabs(sqrt(a*x1)+b-x1)&lt;1e-5)A[ans++]=x1; if(fabs(sqrt(a*x2)+b-x2)&lt;1e-5&amp;&amp;x2!=x1)A[ans++]=x2; printf("%d\n",ans); for(i=0;i&lt;ans;i++)printf("%d ",A[i]); puts(""); &#125; return 0;&#125; I 题目描述给一个$n\times n$的棋盘，每个格子可以填$[1,k]$的正整数，定义棋盘中某个点为$bi$点当且仅当其为该行该列严格最大值，设$B[i]$为棋盘中恰好存在$i$个$bi$点的方案数，求$\sum_{i=0}^{n^2}i^2B[i]$。 解题思路由于任意交换两行两列不影响$bi$点状况，故可以先讨论$bi$点在对角线且$bi$点非严格单调递增的情况。 设$dp[i][j]$表示已经确定了前$i$个$bi$点，且其中最大的$bi$点对应数值不超过$j$的方案总数。 那么有：$dp[i][j]=\sum_{k=0}^{j-1}dp[k][j-1]\times \frac{(j-1)^{(i-k)(2n-i-k-1)}}{(i-k)!}$。 递推的过程即为填$bi$点值为$j$的状态。其中$dp[k][j-1]$表示前$k$行列不超过$j-1$，$j-1$的次方表示非前$k$行控制的、$k+1$到$i$行列的，由新增加进来的值为$bi$点控制的节点。最后除以$(i-k)!$为了除重。 设至少有$i$个$bi$点的方案数位$b[i]$，则有$b[i]={A_{n}^{i}}^2dp[i][k]\times k^{(n-i)^2}$，即从$n$行$n$列分别选出$i$行$i$列，且最大不超过$k$，剩下未支配的部分从$[1,k]$任取的方案个数，这段可能有重复，不过无关紧要，请看下一步。 再设$f[i]$为恰好有$i$个$bi$点的方案总数，则可以进行容斥：$f[i]=b[i]+\sum_{i&lt;j}(-1)^{(j-i)}b[j]\times C_{j}^{i}$。 最后即可得出结果。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 205typedef long long ll;int f[N],dp[N][N],b[N];ll w=998244353,jc[N]=&#123;1&#125;;ll qpow(ll x,ll p)&#123; int i; ll ans=1; for(i=p;i;i&gt;&gt;=1,x=x*x%w)if(i&amp;1)ans=ans*x%w; return ans;&#125;ll inv(ll x)&#123;return qpow(x,w-2);&#125;int main()&#123; int i,j,k,t,n,K; scanf("%d",&amp;t); for(i=1;i&lt;N;i++)jc[i]=jc[i-1]*i%w; while(t--)&#123; scanf("%d%d",&amp;n,&amp;K); memset(dp,0,sizeof(dp)); memset(b,0,sizeof(b)); memset(f,0,sizeof(f)); for(i=0;i&lt;=n;i++)dp[0][i]=1; for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;=K;j++)&#123; for(k=0;k&lt;=i;k++) dp[i][j]+=dp[k][j-1]*qpow(j-1,(i-k)*(2*n-i-k-1))%w*inv(jc[i-k])%w; &#125; &#125; for(i=1;i&lt;=n;i++) b[i]=jc[n]*inv(jc[n-i])%w*jc[n]*inv(jc[n-i])%w*dp[i][K]%w*qpow(K,(n-i)*(n-i))%w; for(i=1;i&lt;=n;i++)&#123; f[i]=b[i]; int nowsign=-1; for(j=i+1;j&lt;=n;j++)&#123; f[i]+=(nowsign)*b[j]*jc[j]%w*inv(jc[i])%w*inv(jc[j-i])%w; f[i]%=w; nowsign*=-1; &#125; f[i]+=w; f[i]%=w; &#125; ll ans=0; for(i=1;i&lt;=n;i++) (ans+=i*i*f[i])%=w; printf("%lld\n",(ans%w+w)%w); &#125; return 0;&#125; J 题目描述定义一个合法的算式是一个恰好长为$n$的字符串，其中只包含$0-9,+,-$，不允许运算符相邻或出现在首尾，允许前导零。合法的算式的计算结果即为对该字符串模拟十进制加减法运算的结果。 求所有合法算式计算结果的和，答案对$998244353$取模。 解题思路由于$+$和$-$都可以出现，所以能出现加号的地方必能出现减号，只需要考虑算式最左端的数对应的结果即可。 可设： $p[j]=10^i$$f[i]=\frac{10^i}{2}(10^i+1)$，此即只含有$i$位数字的算式计算结果。$g[i]$为长度为$i$、第一个字符为$+$或$-$的不同串总种数。$ans$为长度为$n$的合法算式计算结果的和。 则有$g[2]=20,g[i]=2p[i-1]+\sum_{j=2}^{i-2}2p[i-j-1]g[j]$ 处理成前缀和： $g[i]=2f[i-1]+10^{i-1}\sum_{j=2}^{i-2}2*10^{-j}g[j]$ $=2f[i-1]+p[i-1]h[i-2]$ 其中$h[i]=\sum_{j=2}^{i}2\times 10^{-j}g[j]$，同时处理即可。 $ans=f[n]+\sum_{j=2}^{n-1}f[n-j]g[j]$ AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define N 500002typedef long long ll;int t,a,b;ll inv=299473306;ll w=998244353;ll p[N]=&#123;1&#125;;ll f[N]=&#123;1&#125;,g[N],h[N];ll invf[N]=&#123;1&#125;;int main()&#123; int i,n; scanf("%d",&amp;t); for(i=1;i&lt;N;i++)p[i]=p[i-1]*10%w; for(i=1;i&lt;N;i++) f[i]=(p[i]-1)*p[i-1]*5%w,invf[i]=invf[i-1]*inv%w; g[2]=20; while(t--)&#123; ll ans=0; scanf("%d",&amp;n); for(i=2;i&lt;=n;i++)&#123; g[i]=(2*p[i-1]+p[i-1]*h[i-2])%w; h[i]=(h[i-1]+2*invf[i]*g[i])%w; &#125; for(i=2;i&lt;=n-1;i++)ans=(ans+f[n-i]*g[i])%w; ans=(ans+f[n])%w; //for(i=1;i&lt;n;i++)printf("h:%I64d g:%I64d f:%I64d\n",h[i],g[i],f[i]); printf("%I64d\n",ans); &#125; return 0;&#125; K 题目描述给一个多项式，求其导数各指数的系数。 解题思路签到。 AC代码点击 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int i,j,n,k,a[110]=&#123;0&#125;; scanf("%d%d",&amp;n,&amp;k); for(i=n;i&gt;=0;i--)scanf("%d",&amp;a[i]); for(i=0;i&lt;k;i++)&#123; for(j=0;j&lt;=n;j++) a[j]=(a[j]*((j&gt;i)?j-i:0))%2019; &#125; for(i=0;i&lt;k;i++)printf("0 "); for(i=n;i&gt;=k;i--)printf("%d ",a[i]%2019); return 0;&#125; L 题目描述给定$n$个点，$m$条边权均为$1$的边，从节点$1$开始，等概率选择其后继或停留，最多停留时间 为$1$，问总时间期望。 解题思路推出式子树形$DP$即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#define N 100010typedef long long ll;struct Edge&#123; int e,n;&#125;e[N];int ind[N],oud[N],cnt,hd[N],n,m;void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt; ind[b]++;oud[a]++;&#125;int w=998244353;ll qpow(ll x,ll p)&#123; int i; ll ans=1; for(i=p;i;i&gt;&gt;=1,x=x*x%w)if(i&amp;1)ans=ans*x%w; return ans;&#125;ll inv(ll x)&#123;return qpow(x,w-2);&#125;ll dfs(int x)&#123; if(!oud[x])return 2; int i,q; ll p=0; for(i=hd[x];i;i=e[i].n)&#123; q=e[i].e; (p+=dfs(q))%=w; &#125; return (1+(p+oud[x])*inv(oud[x]+1)%w+inv(oud[x]+1)*inv(oud[x])%w*(p+2*oud[x]))%w;&#125;int main()&#123; int i,t,u,v; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;m;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v); printf("%lld\n",dfs(1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2050 Programming Competition 部分题解]]></title>
    <url>%2F2019%2F04%2F15%2F2050contest%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I 7/9 O O O O O O Ø . . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述问一个字符串是不是$2050$拼成的。 解题思路签到题，暴力求解。 AC代码点击 1234567891011121314151617181920#include&lt;stdio.h&gt;char a[10000010];int main()&#123; int i,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",a); int flag=0; for(i=0;a[i];i+=4)&#123; if(a[i]=='2'&amp;&amp;a[i+1]=='0'&amp;&amp;a[i+2]=='5'&amp;&amp;a[i+3]=='0'); else &#123; flag=1; break; &#125; &#125; if(flag)printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125; B 题目描述给一个年月日时分秒，求这个时间点和$2050$年$1$月$1$日$0$时$0$分$0$秒差多少秒，答案对$100$取模。 解题思路刚开始一边写判断闰年一边暗骂出题者毒瘤，写到一半突然发现答案竟然是对$100$取模？？ （脏话） 直接计算这是该天的第几秒，判断一下这个时间在给定日期之前还是之后即可。 AC代码点击 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int t,y,m,d,h,min,s; scanf("%d",&amp;t); while(t--)&#123; int ans=0; scanf("%d-%d-%d",&amp;y,&amp;m,&amp;d); scanf("%d:%d:%d",&amp;h,&amp;min,&amp;s); ans=h*3600+min*60+s; if(y&lt;2050)ans=86400-ans; printf("%d\n",ans%100); &#125; return 0;&#125; C 题目描述有一堆人，$n+k$个男生，$m+k$个女生，其中$k$对情侣。有双人间$a$、三人间$b$、情侣间$c$，其中情侣间只能住情侣，双人三人间只能住同性且可以不住满。三种房间分别有不同价格，求把他们安排下住宿的最小花费。 解题思路刚开始想的是取情侣全住$c$和全不住$c$的最小值，然后兴高采烈交了个$WA$。 后来才发现，情侣可以部分住$c$，枚举即可。 $f$表示的是$x$个人分配到$a$或$b$间的最小花费，分三种情况（除三的余数）讨论即可。 然后递推就可以了。 AC代码点击 123456789101112131415161718192021222324#include&lt;stdio.h&gt;typedef long long ll; int t,n,m,k;ll a,b,c;ll min(ll a,ll b)&#123;return a&gt;b?b:a;&#125;ll f(int x)&#123; ll ans=0; if(x&lt;3)return min(a,b); if(x%3==1)ans=min((x/3+1)*b,(x/3-1)*b+2*a); else if(x%3==2)ans=min((x/3+1)*b,x/3*b+a); else ans=x/3*b; return min((x/2+(x%2!=0))*a,ans);&#125;int main()&#123; scanf("%d",&amp;t); int i; while(t--)&#123; scanf("%d%d%d%lld%lld%lld",&amp;n,&amp;m,&amp;k,&amp;a,&amp;b,&amp;c); ll ans=f(n+k)+f(m+k); for(i=0;i&lt;k;i++)ans=min(ans,f(n+i)+f(m+i)+(k-i)*c); printf("%lld\n",ans); &#125; return 0;&#125; D 题目描述给一个计分规则，求最终奖品个数。 给定一个$01$串，求每一个前缀包含的所有本质不同的字母串个数。 解题思路纯模拟，没啥好说的。 显然需要离线处理枚举前缀的结尾。 第一思路是，从前缀的结尾$i$往前递推，$num$记录最多能向后延伸几位，$dp[j]$表示$j$之后的字母串种类个数。 AC代码点击 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;int a[10010],num[10010];int peo[10010];int main()&#123; int i; int t,n,m,k; scanf("%d",&amp;t); while(t--)&#123; memset(num,0,sizeof(num)); memset(peo,0,sizeof(peo)); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); num[a[i]]++; &#125; for(i=0;i&lt;=m;i++)peo[i]=num[i]-num[i]/k; int ans=0; for(i=0;i&lt;n/2;i++)if(num[a[i]]&gt;peo[a[i]])num[a[i]]--,ans++; printf("%d\n",ans); &#125; return 0;&#125; E 题目描述两个人打乒乓球。给一个球赛的计分榜，其中有$A$得分、$B$得分、未知得分三种情况，问最多进行了多少场比赛。 解题思路这题的$DP$挺麻烦的。 可以设一个$f[i][j][k]$表示在第$k$个计分之后，$A$和$B$比分为$i:j$的时候，最多可能的比赛轮数，其中$-1$表示不可能到达这种局面。其中，$10:10$之后某方得分可以化为$10:9$，特判即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int f[12][12][10010];char a[10010];int main()&#123; int i,j,k,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",a+1); int l=strlen(a+1); memset(f,-1,sizeof(f)); f[0][0][0]=0; for(i=1;a[i];i++)&#123; if(a[i]=='A')&#123; for(j=1;j&lt;=10;j++) for(k=0;k&lt;=10;k++) if(~f[j-1][k][i-1])f[j][k][i]=f[j-1][k][i-1]; for(j=0;j&lt;10;j++) if(~f[10][j][i-1])f[0][0][i]=max(f[0][0][i],f[10][j][i-1]+1); f[10][9][i]=max(f[10][10][i-1],f[10][9][i]); &#125;else if(a[i]=='B')&#123; for(j=0;j&lt;=10;j++) for(k=1;k&lt;=10;k++) if(~f[j][k-1][i-1])f[j][k][i]=f[j][k-1][i-1]; for(j=0;j&lt;10;j++) if(~f[j][10][i-1])f[0][0][i]=max(f[0][0][i],f[j][10][i-1]+1); f[9][10][i]=max(f[10][10][i-1],f[9][10][i]); &#125;else&#123; for(j=0;j&lt;=10;j++) for(k=0;k&lt;=10;k++)&#123; if(j&amp;&amp;~f[j-1][k][i-1])f[j][k][i]=f[j-1][k][i-1]; if(k&amp;&amp;~f[j][k-1][i-1])f[j][k][i]=f[j][k-1][i-1]; &#125; for(j=0;j&lt;10;j++)&#123; if(~f[j][10][i-1]) f[0][0][i]=max(f[0][0][i],f[j][10][i-1]+1); if(~f[10][j][i-1]) f[0][0][i]=max(f[0][0][i],f[10][j][i-1]+1); &#125; f[9][10][i]=max(f[10][10][i-1],f[9][10][i]); f[10][9][i]=max(f[10][10][i-1],f[10][9][i]); &#125; /*printf("%d %c\n",i,a[i]); for(j=0;j&lt;12;j++)&#123; for(k=0;k&lt;12;k++)printf("%d ",f[j][k][i]); puts(""); &#125; puts("");*/ &#125; int ans=0; for(i=0;i&lt;=10;i++)for(j=0;j&lt;=10;j++) ans=max(ans,f[i][j][l]); printf("%d\n",ans); &#125; return 0;&#125; F 题目描述现在，我们要依次面对$n$个冰水挑战，每个挑战你都可以选择接受或不接受。接受第$i$个挑战会让你丧失$a_i$点体力，因为每个挑战所处的环境不同，如果你要挑战它，在挑战它之前你的体力$x$会变成 $min(x,b_i)$，当你完成这个挑战的时候，你的体力会变成$x−a_i$，体力任何时候不允许小于等于$0$，无论你是否接受第$i$个挑战，在这个挑战结束以后你的体力都会增加$c_i$。 解题思路$f[i][j]$表示进行到第$i$个挑战，已经完成了$j$ 个挑战之后，最大的体力值。然后$dp$即可。 AC代码点击 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;int t,n;long long p,a[1010],b[1010],c[1010];long long f[1010][1010];int main()&#123; int i,j; scanf("%d",&amp;t); while(t--)&#123; memset(f,0,sizeof(f)); scanf("%d%lld",&amp;n,&amp;p); for(i=1;i&lt;=n;i++)scanf("%lld%lld%lld",&amp;a[i],&amp;b[i],&amp;c[i]); f[0][0]=p; for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;=i;j++)&#123; if(f[i-1][j])f[i][j]=f[i-1][j]+c[i]; if(j&amp;&amp;min(f[i-1][j-1],b[i])-a[i]&gt;0) f[i][j]=max(f[i][j],min(f[i-1][j-1],b[i])-a[i]+c[i]); &#125; &#125; int ans=0; for(i=1;i&lt;=n;i++)if(f[n][i])ans=i; printf("%d\n",ans); &#125; return 0;&#125; G 题目描述我们看到了一栋高楼大厦，大厦的墙面可以看做一个$W×H$的矩形，我们把它的左下角当成$(0,0)$，右上角当成$(W,H)$。上面分布着一些$LED$灯，这些$LED$灯与地面呈$45$度倾斜，并且从矩形的边界延伸到另一边界，把大厦分成了若干个区域。我们想数一下这个图里面存在多少个与地面成$45$度角的矩形，其中四条边都是$LED$灯的一部分。 解题思路比赛并没有过这个题，但是想到了一种扫描线算法，出奇的麻烦，结果听学长说用$bitset$简单可过…… AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;bitset&gt;using namespace std;#define N 1002int w,h,n,m,a[N],b[N];long long W=1000000007;bitset&lt;N&gt; B[N];void solve()&#123; long long ans=0; scanf("%d%d%d%d",&amp;w,&amp;h,&amp;n,&amp;m); int i,j; for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); for(j=0;j&lt;N;j++)B[i][j]=0; &#125; for(i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;b[i]); for(j=1;j&lt;=n;j++)if(a[j]+b[i]&gt;=0&amp;&amp;a[j]+b[i]&lt;=2*w&amp;&amp;a[j]&gt;=b[i]&amp;&amp;a[j]-b[i]&lt;=2*h)B[j][i]=1; &#125; for(i=1;i&lt;=n;i++) for(j=i+1;j&lt;=n;j++)&#123; long long sum=(B[i]&amp;B[j]).count(); (ans+=sum*(sum-1)/2)%=W; &#125; printf("%lld\n",ans);&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)solve(); return 0;&#125; 后面的题还没看……]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组&后缀自动机学习笔记]]></title>
    <url>%2F2019%2F04%2F10%2Fsuffixarray%2F</url>
    <content type="text"><![CDATA[今天干了两件事情，学会了后缀数组，搞定了洛谷$AC$数量的问题，以后可以不用洛谷咯！ 继续学习、复习算法，下一步是后缀自动机。 后缀数组这儿有道纯模板题 思路只学了倍增法，但也折腾了半天。贴一下自己的想法。 既然要对后缀排序，那首先当然要找出所有后缀从第一位开始比较了。 于是一上来就有了下面这段代码： 1234for(i=0;i&lt;m;i++)c[i]=0;for(i=0;i&lt;n;i++)c[x[i]=s[i]]++;for(i=1;i&lt;m;i++)c[i]+=c[i-1];for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; 妈耶，这一堆数组都是啥 $c[i]: $一个辅助数组，用处见下面注释$x[i]: $呃，这一步的作用仅仅是记录一下$s[i]$的$ASCII$码值。$s[i]: $就是给定的字符串啦。$sa[i]: $当前排名为$i$的后缀，起始位置的下标。 一句话一句话解释。 1234567891011for(i=0;i&lt;m;i++)c[i]=0;//数组清零for(i=0;i&lt;n;i++)c[x[i]=s[i]]++;//表示这个地方有个东西（比如字符串"abbcc"），最终结果是c['a']=1,c['b']=2,c['c']=2。//那其实这里的c数组就是一个桶。//这里先把第一位排好序。for(i=1;i&lt;m;i++)c[i]+=c[i-1];//统计前缀和，方便后续统计排名。for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i;//统计排名的时候要求排名互不相同，于是强制在字符相同的情况下，第一个字母靠前的排名靠前。//这里倒着循环以满足上述条件。 好了，这步结束之后，第一位比较完了。 先看一个例子：$ababbaba$ 第一次排序后：（$97$为$‘a’$的$ASCII$码值) $i$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $x [i]$ $97$ $98$ $97$ $98$ $98$ $97$ $98$ $97$ $sa [i]$ $0$ $2$ $5$ $7$ $1$ $3$ $4$ $6$ $sa[i+1]$ $2$ $5$ $7$ $1$ $3$ $4$ $6$ $0$ 根据字典序的思想，在第一位字符相同的情况下应该接着比较下一个位置。也就是基数排序，在第一个字符相等的基础上，更细的分离出第二个字符上的区别。 那么我假设前两个字符都比完了，那么接下来该比较的是前三个字符，前四个字符……但实际上，在比完前两个字符的情况下，可以直接添加两个字符（第二关键词）到前四个字符，在下一轮添加四个字符（第二关键词）到前八个字符……这里就可以应用倍增的思想进行比较了。 接下来的代码比较长，分几部分，逐步理解。 123456for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; ...&#125; $y[i]:$ 第二关键词（即第2个，第3,4个，第5,6,7,8个……）的排序，$y[i]=j$表示排名$i$的第二关键词，第一关键词的起始位置为$j$。 $[0,i]$中，后$k$个位置的第二关键词是$0$，所以这是最小的，先加入$y$数组。 然后其他的相应排名为$sa[i]$，前面已经排了$k$个，故排名为$sa[i]-k$。 执行完这段代码后： $i$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $y [i]$ $7$ $1$ $4$ $6$ $0$ $2$ $3$ $5$ 接着和第一次几乎一样的排序： 12345for(i=0;i&lt;m;i++)c[i]=0;//清空桶for(i=0;i&lt;n;i++)c[x[i]]++;//扔进桶for(i=1;i&lt;m;i++)c[i]+=c[i-1];//前缀和for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i];//这里是唯一不一样的地方，起到的作用就是在第一次的基础上对第二关键词排序 执行完这段代码后： $i$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $sa[i]$ $7$ $0$ $2$ $5$ $1$ $4$ $6$ $3$ 对应字符串 $a0$ $ab$ $ab$ $ab$ $ba$ $ba$ $ba$ $bb$ 然后$y$数组已经光荣完成使命，下一轮的$x$数组由这一轮的$x$数组决定。怎么决定呢？显然，如果两个后缀的第一、二关键字在上一轮排名相同，那么本轮排名也相同；否则不同。于是就有： 123456std::swap(x,y);//其实是扔掉了y数组num=1;x[sa[0]]=0;//排名为0for(i=1;i&lt;n;i++)x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++;if(num&gt;=n)break;//排序完成的字符数到了n，也就是没有不同排名的后缀了，那么退出m=num;//优化一下循环 多次类似倍增后，即可得到结果。 代码123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#define N 1000010char s[N];int x[N],y[N],sa[N],c[10*N];int main()&#123; int i,k,n,m=10000; scanf("%s",s); n=strlen(s); for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]=s[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[y[i]]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i]; std::swap(x,y); num=1; x[sa[0]]=0; for(i=1;i&lt;n;i++) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++; if(num&gt;=n)break; m=num; &#125; for(i=0;i&lt;n;i++)printf("%d ",sa[i]+1); return 0;&#125; 可是光排序似乎做不了什么事呢！ 引入一个数组$height[i]$，它代表的意义是，排序第$i$和第$i-1$的两个后缀的最长公共前缀。用符号语言表示就是：$height[i]=LCP(suffix(sa[i]),suffix(sa[i-1]))$。（$suffix(i)$表示以$i$为开头的后缀） 那么如何求这个数组呢？单纯的暴力去求，复杂度是爆炸的$O(n^2)$。 引入$rank[i]$数组，表示$suffix(i)$的排名为$rank[i]$。 设$h[i]=height[rank[i]]$，即$h[i]$表示$suffix(i)$和比$suffix(i)$排名靠前一个的后缀的$LCP$，则有$h[i]\geq h[i-1]-1$（证明略去，手推思考一下就是这么一回事）。故从头枚举$suffix(i)$，递推可以算出$height$数组。 于是就有了这段代码： 1234567891011121314void geth()&#123; int i,j,k=0; for(i=0;i&lt;n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125; 学到这里的时候一直不明白这个数组为什么要叫$height$，刚刚才弄明白原来他的意思是后缀$trie$上的从左到右相邻两个末端节点（指代表后缀结束处的节点）$LCA$的深度。 所以就可以用这个特殊的性质解决问题了。 问题1 求LCP(suffix(i),suffix(j))也就是求$min(height[k]),k∈[i+1,j]$（假设$i$排名靠前）。用$ST$表+$RMQ$或者线段树查询即可。 1234567891011121314151617181920212223242526void init(int n)&#123; int i,j; for(i=0;i&lt;=n;i++)st[0][i]=height[i]; for(i=n-1;i;i--) for(j=1;(1&lt;&lt;j)+i-1&lt;=n;j++) st[j][i]=std::min(st[j-1][i],st[j-1][i+(1&lt;&lt;(j-1))]);&#125;int query(int l,int r)&#123; int m=0; if(l&gt;r)std::swap(l,r); l++; while((1&lt;&lt;(m+1))&lt;r-l+1)m++; return std::min(st[m][l],st[m][r-(1&lt;&lt;m)+1]);&#125;void solve()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%d%d",&amp;l,&amp;r); if(l==r)printf("%d\n",n-l); else&#123; l=rank[l];r=rank[r]; if(l&gt;r)swap(l,r); printf("%d\n",query(l+1,r)); &#125; &#125;&#125; 问题2 求可以重叠的最长重复子串显然，求出$max(height[i])$即可。 （强迫症贴个代码） 1234void solve()&#123; int i,ans=0; for(i=0;i&lt;n;i++)ans=max(ans,height[i]);&#125; 问题3 求不可重叠的最长重复子串考虑到可以枚举答案且答案具有单调性，故考虑二分答案。 问题转化成：是否存在两个长度为$mid$的相同的串，他们的起始位置相差大于等于$mid$。 在后缀数组中转化成：$LCP(i,j)\geq mid,sa[j]-sa[i]\geq mid$。 于是在$height[i]&lt;mid$的地方设置隔板，在每一个小区间内求出$sa$数组的最大最小值，判断即可。 123456789101112131415161718192021int jud(int x)&#123; int i,mx=-1e9,mn=1e9; for(i=0;i&lt;n;i++)&#123; if(height[i]&lt;mid)mx=mn=sa[i]; else&#123; mx=max(mx,sa[i]); mn=min(mn,sa[i]); if(mx-mn&gt;=mid)return 1; &#125; &#125; return 0;&#125;void solve()&#123; int l=0,r=n,ans=0,mid; while(l&lt;r)&#123; mid=(l+r)&gt;&gt;1; if(jud(mid))l=mid+1,ans=mid; else r=mid; &#125; printf("%d",ans);&#125; 其他见这里 后缀自动机此坑待填。]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vjudge294125-动态规划训练 题解]]></title>
    <url>%2F2019%2F04%2F09%2Fvjudge294125dp4-9%2F</url>
    <content type="text"><![CDATA[Solved A B C D 4/4 O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 突然看到有套在线$DP$比赛，就顺便打了一下，还挺有趣的。 比赛链接 A 题目描述给一个$1/2$序列，可以取某一段区间进行翻转操作（该区间所有元素$1$-$2$，$2$-$1$）求一种操作使得最终非严格递增序列最长并求出最大值。 解题思路枚举待操作区间中的一点$i$。枚举区间左端点$j$，统计从$[1,j]$中$1$的总个数与$[j+1,i]$中$2$的总个数和的最大值$l$。枚举区间右端点$j$，统计从$[i,j]$中$1$的总个数与$[j+1,n]$中$2$的总个数和的最大值$r$。则$l+r$即为最大值。用前缀和计算上述问题。 AC代码点击 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 2010int n,a[N],p[N],q[N],ans;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++)p[i]=p[i-1]+(a[i]==1); for(i=n;i;i--)q[i]=q[i+1]+(a[i]==2); for(i=1;i&lt;=n;i++)&#123; int r=0,l=0; for(j=1;j&lt;=i+1;j++)l=max(l,p[j-1]+q[j]-q[i+1]); for(j=i;j&lt;=n;j++)r=max(r,q[j+1]+p[j]-p[i]); ans=max(ans,l+r); &#125; printf("%d",ans); return 0;&#125; B 题目描述题干极长，英语阅读能力差，看了好吓人。题目中给的图$AB$之间还有空缺，理解了半天，原来是图错了。 简单概括为一句话：给定先序遍历的路径，求树的形态种数。 解题思路我们假设$dp[i][j]$是第$i$个字符和第$j$个字符之间的串可能构成的子树形态种数，则答案即为$dp[0][l-1]$。 对于$a[i]==a[j]$，我们先假设这两个点代表同一个节点$a$： $dp[i][j]+=dp[i+1][j-1]$，这时$a$只有一个孩子； $dp[i][j]+=\sum_{k=i+2}^{j-2}dp[i][k]*dp[k+1][j-1] (a[i]==a[k])$，这时$a$有一个右孩子$[k+1,j-1]$，至少一个左孩子$[i,k]$，这个可以继续当做树根。 其实，在递推的时候保证了这是一个子树节点也就是这两个点代表同一个节点。 AC代码点击 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define w 1000000000#define N 310char a[N];long long dp[N][N];long long dfs(int l,int r)&#123; if(~dp[l][r])return dp[l][r]; if(l&gt;=r)return 1; int i; long long ans=0; if(a[l]==a[r]&amp;&amp;r&gt;l+1)&#123; ans=dfs(l+1,r-1); for(i=l+2;i&lt;r-1;i++)if(a[i]==a[l])(ans+=dfs(l,i)*dfs(i+1,r-1))%=w; &#125; return dp[l][r]=ans%w;&#125;int main()&#123; int i; while(~scanf("%s",a))&#123; memset(dp,-1,sizeof(dp)); printf("%lld\n",dfs(0,strlen(a)-1)); &#125; return 0;&#125; C 题目描述给定一段序列，让选一个点$x$，每次选定包含$x$这个元素的包含两种相邻颜色的区域，把他们染成任意一种颜色。求最少多少步能够把所有的点染成一个颜色。 解题思路设$dp[0][l][r]$表示把$[l,r]$区间内的元素染成$color[l]$所需最少步数，设$dp[1][l][r]$表示把$[l,r]$区间内的元素染成$color[r]$所需最少步数。 然后递推就可以了。 AC代码点击 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 5002int n,cnt,a[N],dp[2][N][N];int main()&#123; int i,j,x; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x); if(!i||x!=a[cnt-1])a[cnt++]=x; &#125; n=cnt; memset(dp,0x3f,sizeof(dp)); for(i=0;i&lt;n;i++)dp[0][i][i]=dp[1][i][i]=0; for(i=0;i&lt;n;i++)&#123; for(j=i;j&gt;=0;j--)&#123; if(j)dp[0][j-1][i]=min(dp[0][j-1][i],min(dp[0][j][i]+(a[j-1]!=a[j]),dp[1][j][i]+(a[j-1]!=a[i]))); if(i&lt;n-1)dp[1][j][i+1]=min(dp[1][j][i+1],min(dp[0][j][i]+(a[i+1]!=a[j]),dp[1][j][i]+(a[i+1]!=a[i]))); &#125; &#125; printf("%d",min(dp[0][0][n-1],dp[1][0][n-1])); return 0;&#125; D 题目描述用$1$到$4$位二进制数表示$26$个英文字母，其中$0011,0101,1110,1111$没有对应的英文字母。 给定一个$01$串，求每一个前缀包含的所有本质不同的字母串个数。 解题思路这个题是最有意思的一道题，刚开始没想过来差点没有AK 显然需要离线处理枚举前缀的结尾。 第一思路是，从前缀的结尾$i$往前递推，$num$记录最多能向后延伸几位，$dp[j]$表示$j$之后的字母串种类个数。 那么有$dp[j]=\sum_{k=1}^{num}{dp[j+k]}$，也就是$[j,j+k-1]$表示的一个字母和$[j+k,i]$表示的一段字母串连成一个更大的字母串。 但是要处理本质不同这个问题，有点麻烦。 本来是想用后缀自动机解决，发现没有必要，可以用倒序的字典树直接判重解决。稍微有点细节，直接上代码。 AC代码点击 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define N 3010#define w 1000000007#define rep ((a[j]&lt;&lt;3)+(a[j+1]&lt;&lt;2)+(a[j+2]&lt;&lt;1)+a[j+3])int trie[2][N*N/2],tot;int n,a[N],f[N];int main()&#123; int i,j,k,num,now,ans=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)&#123; f[i+1]=1; now=0; for(j=i;j&gt;=0;j--)&#123; num=std::min(4,i-j+1); f[j]=0; if(num==4&amp;&amp;(rep==3||rep==5||rep==14||rep==15))num--; for(k=1;k&lt;=num;k++)(f[j]+=f[j+k])%=w; if(!trie[a[j]][now])(ans+=f[j])%=w,trie[a[j]][now]=++tot; now=trie[a[j]][now]; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vjudge293222-动态规划基础题集合 题解]]></title>
    <url>%2F2019%2F04%2F07%2Fvjudge293222basicdp%2F</url>
    <content type="text"><![CDATA[最近在学动态规划，看到$vjudge$上这套题感觉挺有意思的。 Solved A B C D E F G H I J K L M N O P Q R S 19/19 O O O O O O O O O O O O O O O O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述求一个序列的最大$m$段非空子段和。 解题思路设$g[i][j]$表示前$i$个元素中选取$j$个段，且必包含第$i$个元素的最大值。设$f[i][j]$表示前$i$个元素中选取$j$个段，且不必包含第$i$个元素的最大值。 则有：$g[i][j]=max(g[i-1][j],f[i-1][j-1])+a[i]$$f[i][j]=max(g[i-1][j],f[i-1][j])$ 答案即为$f[n][m]$。 滚动数组优化掉第一维即可。 AC代码点击 123456789101112131415161718192021#include&lt;stdio.h&gt;#define N 1000010typedef long long ll;int n,m,a[N];ll g[N],f[N];int min(int a,int b)&#123;return a&gt;b?b:a;&#125;ll max(ll a,ll b)&#123;return a&gt;b?a:b;&#125;int main()&#123; int i,j; while(~scanf("%d%d",&amp;m,&amp;n))&#123; for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++)g[i]=f[i]=-1e18; for(i=1;i&lt;=n;i++) for(j=min(i,m);j;j--)&#123; g[j]=max(g[j],f[j-1])+a[i]; f[j]=max(f[j],g[j]); &#125; printf("%lld\n",f[m]); &#125; return 0;&#125; B 题目描述给定一段个数$n$为奇数的序列，其中有一个数字出现了至少$\frac {n+1}2$次，问这个数是多少。 $1\leq n\leq999999$，$a[i]∈[-2^{31},2^{31}-1]$。 解题思路用$map$可以水过，但可以用一种更巧妙的思路做出来。 显然，如果两个数不相等，那么删掉这两个数之后剩下的数仍然满足题目要求。所以可以用一个$cnt$表示当前数出现的净次数（删掉和它不等的相同个数的数），当$cnt=0$时更新答案，也就是说答案在结束的时候必须满足它对应的$cnt\neq0$。所以最后的答案必然是所求。 AC代码-map点击 12345678910111213141516#include&lt;cstdio&gt;#include&lt;map&gt;std::map&lt;int,int&gt;m;int main()&#123; int i,n,a,ans; while(~scanf("%d",&amp;n))&#123; m.clear(); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a); m[a]++; if(m[a]&gt;=(n+1)/2)ans=a; &#125; printf("%d\n",ans); &#125; return 0;&#125; AC代码-递推点击 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int i,n,cnt,a,ans; while(~scanf("%d",&amp;n))&#123; cnt=0; for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a); if(!cnt)cnt=1,ans=a; else cnt+=a==ans?1:-1; &#125; printf("%d\n",ans); &#125; return 0;&#125; C 题目描述给定一些种类的长方体的长宽高，它们有任意多个、可任意摆放（指任意方式竖立），问当保证下一层的长宽严格大于上一层的长宽的时候，可以摞起来的最大高度。 解题思路数据超级水，直接添加所有的长宽高组合，以长为关键词排序，从上到下递推即可。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define N 520using namespace std;struct Box&#123; int x,y,z; bool operator&lt;(const Box&amp;a)const&#123;return x&gt;a.x;&#125;&#125;a[N];int n,tot,dp[N],b[4];void add(int x,int y,int z)&#123;a[tot++]=&#123;x,y,z&#125;;&#125;int main()&#123; int i,j,k,l,ans,cas=0; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; tot=ans=0; memset(dp,0,sizeof(dp)); for(l=0;l&lt;n;l++)&#123; scanf("%d%d%d",&amp;b[0],&amp;b[1],&amp;b[2]); for(i=0;i&lt;3;i++)for(j=0;j&lt;3;j++)for(k=0;k&lt;3;k++) if(i!=j&amp;&amp;i!=k&amp;&amp;j!=k)add(b[i],b[j],b[k]); &#125; sort(a,a+tot); for(i=0;i&lt;tot;i++)&#123; for(j=0;j&lt;i;j++)if(a[i].x&lt;a[j].x&amp;&amp;a[i].y&lt;a[j].y)dp[i]=max(dp[i],dp[j]); dp[i]+=a[i].z; ans=max(ans,dp[i]); &#125; printf("Case %d: maximum height = %d\n",++cas,ans); &#125; return 0;&#125; D 题目描述现在摆在面前一堆作业和$DDL$，并知道每个作业需要的时间，求使得超出$DDL$的时间的总和最小的方案。如果有多种，输出作业名字典序最小的那一种。数据保证给定的顺序符合作业名字典序。 解题思路一上来想了个贪心，哗哗哗写出来了兴高采烈地交上了。 然后获得了$WA$。 WA代码点击 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;struct ddl&#123; char a[110]; int d,c; bool operator&lt;(const ddl&amp;p)const&#123;return d&lt;p.d||(d==p.d&amp;&amp;strcmp(a,p.a)&lt;0);&#125;&#125;a[16];int main()&#123; int i,n;scanf("%*d"); while(~scanf("%d",&amp;n))&#123; for(i=0;i&lt;n;i++)scanf("%s%d%d",a[i].a,&amp;a[i].d,&amp;a[i].c); sort(a,a+n); int ans=0,time=0; for(i=0;i&lt;n;i++)&#123; time+=a[i].c; if(time&gt;a[i].d)ans+=time-a[i].d; &#125; printf("%d\n",ans); for(i=0;i&lt;n;i++)printf("%s\n",a[i].a); &#125; return 0;&#125; 然后找到了下面这组数据： $1$$5$$A$ $10$ $2$$B$ $2$ $8$$C$ $10$ $1$$D$ $9$ $3$$E$ $2$ $1$ $emmmm$，贪心确实行不通。 那咋办呢？一看数据范围，这不赤裸裸地提示状压嘛！从下到上递推，记录一下每一个状态是由哪里转移过来的，然后输出试试？ 诶，$A$了！ AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct ddl&#123; char a[110]; int d,c;&#125;a[16];struct state&#123; int t,pre,v;//走到这一步的时间，总消耗 &#125;dp[1&lt;&lt;15];int seq[16];int f(int x)&#123; int cnt=0; while(x)x&gt;&gt;=1,cnt++; return cnt-1;&#125;int main()&#123; int i,j,n;scanf("%*d"); while(~scanf("%d",&amp;n))&#123; for(i=0;i&lt;n;i++)scanf("%s%d%d",a[i].a,&amp;a[i].d,&amp;a[i].c); for(i=1;i&lt;(1&lt;&lt;n);i++)dp[i].v=1e9; for(i=0;i&lt;(1&lt;&lt;n);i++)&#123; for(j=0;j&lt;n;j++)&#123; if((i&amp;(1&lt;&lt;j))==0)&#123; int tar=i+(1&lt;&lt;j),t=max(0,dp[i].t+a[j].c-a[j].d); if(dp[tar].v&gt;dp[i].v+t)&#123; dp[tar].v=dp[i].v+t; dp[tar].t=dp[i].t+a[j].c; dp[tar].pre=i; &#125; &#125; &#125; &#125; printf("%d\n",dp[(1&lt;&lt;n)-1].v); int p=n; i=(1&lt;&lt;n)-1; while(n)&#123; seq[--n]=f(i^dp[i].pre); i=dp[i].pre; &#125; for(i=0;i&lt;p;i++)printf("%s\n",a[seq[i]].a); &#125; return 0;&#125; 但似乎事情不太对。这个$pre$定下来定的毫无道理啊，不能一定满足字典序最小。 有了！从上向下递推，再$dfs$一遍找出最优解！ 也许只是数据比较水，所以$AC$了也不一定就是对的呢。 AC代码-REAL点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;struct ddl&#123; char a[110]; int d,c;&#125;a[16];struct state&#123; int t,v;//走到这一步的时间，总消耗 &#125;dp[1&lt;&lt;15];int seq[16],tmp[16],n,FLAG;void dfs(int p,int dep)&#123; int i; if(!p)&#123; int flag=0; if(!FLAG)&#123; FLAG=flag=1; &#125;else for(i=n-1;i&gt;=0;i--)&#123; int cmp=strcmp(a[tmp[i]].a,a[seq[i]].a); if(cmp&lt;0)&#123; flag=1; break; &#125;else if(cmp)break; &#125; if(flag)for(i=0;i&lt;n;i++)seq[i]=tmp[i]; return; &#125; for(i=0;i&lt;n;i++)&#123; if(p&amp;(1&lt;&lt;i))&#123; int tar=p-(1&lt;&lt;i),t=max(0,dp[tar].t+a[i].c-a[i].d); if(dp[p].v==dp[tar].v+t)&#123; tmp[dep]=i; dfs(tar,dep+1); &#125; &#125; &#125;&#125;int main()&#123; int i,j;scanf("%*d"); while(~scanf("%d",&amp;n))&#123; FLAG=0; for(i=0;i&lt;n;i++)scanf("%s%d%d",a[i].a,&amp;a[i].d,&amp;a[i].c); for(i=1;i&lt;(1&lt;&lt;n);i++)dp[i].v=1e9; for(i=0;i&lt;(1&lt;&lt;n);i++)&#123; for(j=0;j&lt;n;j++)&#123; if(i&amp;(1&lt;&lt;j))&#123; int tar=i-(1&lt;&lt;j),t=max(0,dp[tar].t+a[j].c-a[j].d); if(dp[i].v&gt;dp[tar].v+t)&#123; dp[i].v=dp[tar].v+t; dp[i].t=dp[tar].t+a[j].c; &#125; &#125; &#125; &#125; printf("%d\n",dp[(1&lt;&lt;n)-1].v); dfs((1&lt;&lt;n)-1,0); for(i=n-1;i&gt;=0;i--)printf("%s\n",a[seq[i]].a); &#125; return 0;&#125; E 题目描述给定一个整数序列，求其严格单调递增子序列（可为空）的最大和。 解题思路从前往后递推即可。 AC代码点击 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 1005int n,a[N];long long ans,dp[N];int main()&#123; int i,j; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; ans=0; for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)&#123; dp[i]=a[i]; for(j=0;j&lt;i;j++)if(a[j]&lt;a[i])dp[i]=max(dp[i],dp[j]+a[i]); ans=max(ans,dp[i]); &#125; printf("%lld\n",ans); &#125; return 0;&#125; F 题目描述给定一堆物品的总重，以及构成这堆物品的所有可能元素的价值和重量，判断存不存在一种方案使得给定元素构成这堆物品。如果存在，输出总价值的下确界。 解题思路完全背包，压缩到一维即可。 AC代码点击 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define N 520int t,n,e,f,v[N],w[N],dp[10010];int main()&#123; int i,j; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;e,&amp;f); f-=e; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d%d",&amp;v[i],&amp;w[i]); memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(i=0;i&lt;n;i++) for(j=w[i];j&lt;=f;j++) dp[j]=std::min(dp[j],dp[j-w[i]]+v[i]); if(dp[f]&lt;1e9)printf("The minimum amount of money in the piggy-bank is %d.\n",dp[f]); else printf("This is impossible.\n"); &#125; return 0;&#125; G 题目描述天上正在掉馅饼，给定掉馅饼的坐标（一维）和时间，初始位置给定，求能够接到的最大馅饼数。 解题思路两种递推思路，从前往后，从后往前。从后往前的比较好写，不用判特殊情况。滚动掉一维即可。 AC代码点击 1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 100010using namespace std;int n,x,t,a[12][N],dp[2][14];int main()&#123; int i,j; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; int mx=0; memset(dp,0,sizeof(dp)); memset(a,0,sizeof(a)); for(i=0;i&lt;n;i++)scanf("%d%d",&amp;x,&amp;t),a[x+1][t]++,mx=max(mx,t); for(i=mx;i&gt;=0;i--) for(j=1;j&lt;12;j++) dp[i&amp;1][j]=max(max(dp[(i+1)&amp;1][j-1],dp[(i+1)&amp;1][j]),dp[(i+1)&amp;1][j+1])+a[j][i]; printf("%d\n",dp[0][6]); &#125; return 0;&#125; H 题目描述有一列人，花费$a[i]$时间可以消除第$i$个人，花费$b[i]$时间可以消除第$i$和第$i+1$个人。求最短用时，求最终时刻的$HH:MM:SS$ $am|pm$表示。 解题思路直接暴力递推即可。 AC代码点击 1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 2010using namespace std;int n,k,a[N],b[N],dp[N];int main()&#123; int i; scanf("%*d"); while(~scanf("%d",&amp;k))&#123; for(i=1;i&lt;=k;i++)scanf("%d",&amp;a[i]); for(i=2;i&lt;=k;i++)scanf("%d",&amp;b[i]); dp[0]=0;dp[1]=a[1]; for(i=2;i&lt;=k;i++)dp[i]=min(dp[i-2]+b[i],dp[i-1]+a[i]); int h=8,m=0,s=dp[k]; if(s&gt;=60)m+=s/60,s%=60; if(m&gt;=60)h+=m/60,m%=60; printf("%02d:%02d:%02d %s\n",(h-1)%12+1,m,s,h&gt;12?"pm":"am"); &#125; return 0;&#125; I 题目描述求一个序列的非严格下降子列的最小个数。 解题思路也就是求严格上升子列长度。$O(log n)$解决。 AC代码点击 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define N 30010int a,dp[N],len;int main()&#123; int i,n; while(~scanf("%d",&amp;n))&#123; scanf("%d",&amp;dp[0]); len=1; for(i=1;i&lt;n;i++)&#123; scanf("%d",&amp;a); if(a&gt;dp[len-1])dp[len++]=a; else&#123; int p=upper_bound(dp,dp+len,a)-dp; if(dp[p]&gt;a)dp[p]=a; &#125; &#125; printf("%d\n",len); memset(dp,0,sizeof(int)*n); &#125; return 0;&#125; J 题目描述给一些老鼠的速度和质量，求最长的子序列保证老鼠的质量严格递增而速度严格递减，输出方案。 解题思路对质量排序后递推并记录从哪里递推得到的，最后递归输出。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 1010using namespace std;struct mouse&#123; int a,b,i; bool operator&lt;(const mouse&amp;p)const&#123;return a&lt;p.a;&#125;&#125;a[N];int len[N],last[N],mx,temp;void print(int x)&#123; if(!x)return; print(last[x]); printf("%d\n",x);&#125;int main()&#123; int j,i=0,k; while(~scanf("%d%d",&amp;a[i].a,&amp;a[i].b))&#123; a[i].i=i+1; i++; &#125; sort(a,a+i); for(j=0;j&lt;i;j++)&#123; len[j]=1; for(k=0;k&lt;j;k++)&#123; if(a[k].a&lt;a[j].a&amp;&amp;a[k].b&gt;a[j].b&amp;&amp;len[k]+1&gt;len[j])&#123; len[j]=len[k]+1; last[a[j].i]=a[k].i; &#125; &#125; if(len[j]&gt;mx)&#123; mx=len[j]; temp=a[j].i; &#125; &#125; printf("%d\n",mx); print(temp); return 0;&#125; K 题目描述给一些人的两种特性$d$和$p$，选择给定数量个人，使得这些人$d$总和$D$与$p$总和$P$之差的绝对值$|D-P|$最小的情况下，$D+P$最大，输出$|D-P|$，$D+P$，并按上升序输出选择人的序号。 解题思路一个个人选择，$dp[i][j]$表示选了$i$个人，其$D-P=j$（没有绝对值）的情况下，$D+P$的最大值。记录下选了$i$个人、每个$j$对应的最优解对应的人的编号$path[i][j]$，每次枚举每一个人，如果在这个条件下没有加入则可以加入这个人。 由于不能加绝对值，需要加一个$offset$调整。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define N 210#define M 22using namespace std;int n,m,d[N],p[N],v[N],s[N];int f[M][M*M*2],path[M][M*M*2];int sel(int num,int val,int now)&#123; while(num&amp;&amp;path[num][val]!=now)val-=v[path[num][val]],num--; return num;&#125;int seq[M];int main()&#123; int i,j,k,cas=0; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;n|m)&#123; cas++; memset(f,-1,sizeof(f)); int offset=m*M; f[0][offset]=0; for(i=1;i&lt;=n;i++) scanf("%d%d",&amp;d[i],&amp;p[i]),v[i]=d[i]-p[i],s[i]=d[i]+p[i]; for(i=1;i&lt;=m;i++)&#123; for(j=0;j&lt;=offset*2;j++)&#123; if(f[i-1][j]&lt;0)continue; for(k=1;k&lt;=n;k++)&#123; if(f[i-1][j]+s[k]&gt;f[i][j+v[k]]&amp;&amp;!sel(i-1,j,k))&#123; path[i][j+v[k]]=k; f[i][j+v[k]]=f[i-1][j]+s[k]; &#125; &#125; &#125; &#125; for(i=0;i&lt;=offset;i++)if(f[m][offset+i]&gt;=0||f[m][offset-i]&gt;=0)break; int ans=f[m][offset+i]&gt;f[m][offset-i]?offset+i:offset-i; printf("Jury #%d\nBest jury has value %d for prosecution and value %d for defence:\n",cas,(ans-offset+f[m][ans])/2,(-ans+offset+f[m][ans])/2); for(i=m;i;i--)seq[i]=path[i][ans],ans-=v[path[i][ans]]; sort(seq+1,seq+m+1); for(i=1;i&lt;=m;i++)printf(" %d",seq[i]); printf("\n\n"); &#125; return 0;&#125; L 题目描述求最长公共子序列。 解题思路裸题，非常裸。 AC代码点击 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define N 1010char a[N],b[N];int dp[N][N];int main()&#123; int i,j; while(~scanf("%s%s",a+1,b+1))&#123; int l=strlen(a+1),L=strlen(b+1); for(i=1;i&lt;=l;i++)&#123; for(j=1;i&lt;=L;j++)&#123; if(a[i]==b[j])dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); &#125; &#125; printf("%d\n",dp[l][L]); memset(dp,0,sizeof(dp)); &#125; return 0;&#125; M 题目描述有一堆高度不同、起终不同的板子，一个人，这个人要到地上，求最短时间。 这人很神奇，下落、平移的速度相同。但下落高度不能超过给定值，否则会摔死。数据保证一定有解。 解题思路纯搜索$T$掉了，记忆化搜索就可以了。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1010using namespace std;struct ck&#123; int x[2],h; bool operator &lt;(const ck&amp;a)const&#123;return h&gt;a.h;&#125;&#125;a[N];int t,n,x,y,mx;int dp[2][1010];int dfs(int now,int dir)&#123; if(dp[dir][now])return dp[dir][now]; int i,x=a[now].x[dir]; for(i=now+1;i&lt;=n+1&amp;&amp;a[now].h-a[i].h&lt;=mx;i++)&#123; if(i==n+1)return dp[dir][now]=a[now].h; if(x&gt;=a[i].x[0]&amp;&amp;x&lt;=a[i].x[1])return dp[dir][now]+=min(x-a[i].x[0]+dfs(i,0),a[i].x[1]-x+dfs(i,1))+a[now].h-a[i].h; &#125; return dp[dir][now]=1e8;&#125;int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d%d",&amp;n,&amp;x,&amp;y,&amp;mx); memset(dp,0,sizeof(dp)); for(i=1;i&lt;=n;i++)scanf("%d%d%d",&amp;a[i].x[0],&amp;a[i].x[1],&amp;a[i].h); a[0].x[0]=a[0].x[1]=x;a[0].h=y; sort(a+1,a+n+1); printf("%d\n",dfs(0,1)); &#125; return 0;&#125; N 题目描述求最长严格上升子序列。 解题思路又是一道裸题。 AC代码点击 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int n,a,len,dp[1010];int main()&#123; int i; scanf("%d",&amp;n); scanf("%d",&amp;a);dp[len++]=a; for(i=1;i&lt;n;i++)&#123; scanf("%d",&amp;a); if(a&gt;dp[len-1])dp[len++]=a; else&#123; int p=upper_bound(dp,dp+len,a)-dp; dp[p]=min(dp[p],a); &#125; &#125; printf("%d",len); return 0;&#125; O 题目描述给定一些食物，其价格与时间成正比，给定系数。每次必须且只能从头或尾取，求最大价格和。 解题思路区间$DP$，从最后一个取出递推到开头，$dp[i][j]$表示$i,j$之间所有元素最后取出的最大价值和。 AC代码点击 1234567891011121314#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define N 2019int a[N],n,dp[N][N];int main()&#123; int i,j; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]),dp[i][i]=a[i]*n; for(i=1;i&lt;n;i++) for(j=0;j+i&lt;n;j++) dp[j][j+i]=std::max(dp[j][j+i-1]+a[j+i]*(n-i),dp[j+1][j+i]+a[j]*(n-i)); printf("%d",dp[0][n-1]); return 0;&#125; P 题目描述一个老鼠在一个由奶酪组成的格子图中走动，每次可以上下走动$1$到$k$个格子，并吃掉这个格子里的奶酪。要求每次吃的奶酪都比上次大，终点任选，求可以吃到的奶酪的最大和。 解题思路记忆化搜索，每次可以向四个方向走一定距离。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 110int a[N][N],n,k,dp[N][N];int dx[4]=&#123;-1,1,0,0&#125;;int dy[4]=&#123;0,0,-1,1&#125;;int dfs(int x,int y)&#123; if(~dp[x][y])return dp[x][y]; dp[x][y]=a[x][y]; int i,j,p,q,mx=0; for(i=0;i&lt;4;i++)&#123; for(j=1;j&lt;=k;j++)&#123; p=x+dx[i]*j; q=y+dy[i]*j; if(p&gt;=0&amp;&amp;q&gt;=0&amp;&amp;p&lt;n&amp;&amp;q&lt;n&amp;&amp;a[p][q]&gt;a[x][y])&#123; dfs(p,q); if(dp[p][q]&gt;mx)mx=dp[p][q]; &#125; &#125; &#125; return dp[x][y]+=mx;&#125;int main()&#123; int i,j; while(~scanf("%d%d",&amp;n,&amp;k)&amp;&amp;~n&amp;&amp;~k)&#123; memset(dp,-1,sizeof(dp)); for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;a[i][j]); printf("%d\n",dfs(0,0)); &#125; return 0;&#125; Q 题目描述求最大关于反对角线对称的子矩阵。 解题思路想法是从右上角枚举到左下角，每次扩展一定范围并判断是否合理（能否对称），但程序很慢，跑了$2000ms$还多。 看到有人跑了不到$200ms$，不知道是什么方法。 AC代码点击 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#define N 1010int n,dp[N][N];char a[N][N];int main()&#123; int i,j,k; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; int ans=0; for(i=0;i&lt;n;i++)scanf("%s",a[i]); for(i=0;i&lt;n;i++)&#123; for(j=n-1;j&gt;=0;j--)&#123; dp[i][j]=1; if(i&amp;&amp;j&lt;n-1)&#123; for(k=1;k&lt;=dp[i-1][j+1];k++)&#123; if(a[i-k][j]==a[i][j+k])dp[i][j]++; else break; &#125; &#125; if(ans&lt;dp[i][j])ans=dp[i][j]; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; R 题目描述给一段挤奶时间的开始和结束点，每次挤奶的产量，求最大总产量。两次挤奶需要间隔一定时间。 解题思路对时间段关于结束时间递减排序，从前向后递推即可。 AC代码点击 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 1010using namespace std;struct interval&#123; int b,e,v; bool operator&lt;(const interval&amp;a)const&#123;return e&lt;a.e;&#125;&#125;a[N];int dp[N];int n,m,r;int main()&#123; int i,j,ans=0; scanf("%d%d%d",&amp;n,&amp;m,&amp;r); for(i=0;i&lt;m;i++)scanf("%d%d%d",&amp;a[i].b,&amp;a[i].e,&amp;a[i].v); sort(a,a+m); for(i=0;i&lt;m;i++)&#123; dp[i]=0; for(j=0;j&lt;i;j++)if(a[j].e+r&lt;=a[i].b)dp[i]=max(dp[i],dp[j]); dp[i]+=a[i].v; ans=max(ans,dp[i]); &#125; printf("%d",ans); return 0;&#125; S 题目描述给定一段序列，增加或减少其中的某些元素的值，使得最终序列非严格单调递增或递减。求最终序列和原序列每一个元素差值绝对值的和的最小值。$1\leq n\leq2000$，序列中的数保证$0\leq a[i]\leq 10^9$。 解题思路数很大，需要离散化，$dp[i][j]$表示枚举到第$i$个数且让它变成第$j$小/大的数$b[j]$时的贡献，因为保证序列单调，有$dp[i][j]=min(dp[i-1][k])(k∈[0,j])+|a[i]-b[j]|$。其中$min(dp[i-1][k])(k∈[0,j])$可以实时更新。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 2010using namespace std;int n;int a[N],b[N],dp[N][N],ans=1e9;int f(int x)&#123;return x&gt;0?x:-x;&#125;int cmp(int x,int y)&#123;return x&gt;y;&#125;void solve()&#123; int i,j; memset(dp,0x3f,sizeof(dp)); for(i=0;i&lt;n;i++)dp[0][i]=f(a[0]-b[i]); for(i=1;i&lt;n;i++)&#123; int mn=1e9; for(j=0;j&lt;n;j++)&#123; mn=min(mn,dp[i-1][j]); dp[i][j]=mn+f(a[i]-b[j]); &#125; &#125; for(i=0;i&lt;n;i++)ans=min(ans,dp[n-1][i]);&#125;int main()&#123; int i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]),b[i]=a[i]; sort(b,b+n);solve(); sort(b,b+n,cmp);solve(); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2019%2F04%2F05%2Frandomtitle%2F</url>
    <content type="text"><![CDATA[随笔一篇，聊以自慰。 最近一段时间，写代码总是没有脑子，很绝望，也很困惑。于是想不出题怎么写的一个人随便来博客发了一条牢骚。 还记得刚上大学的时候，对于程序设计的那一股激情。那时候的自己只有一个动力：一雪高一信息竞赛训练什么题都不会而被劝退的前耻，适应大学生活。那时的自己，对大学充满未知和兴奋，做好了一切努力地准备。 可是现在呢？ 转眼看看现在的自己，什么地方都差别人很远。要说课程学习，因为上学期考的还算可以，下学期就很浮躁起来，学习也只限制于做完作业，没有任何的延伸拓展，也没有任何的总结思考，所有的时间都用在了别的事情上。要说用在了什么事情上，那大概是$ACM$和感情上。要说$ACM$，前些日子的决赛考的一塌糊涂，最近写题也写不进去，读书也倍感时间不够读不完，上学期的算法半数还给了各种$OJ$。要说感情，这可是一件细腻的活，一不小心就有可能会忘记一些很重要的事情，在学习生活中也根本无法静下心来干自己的事。纠结于当下的所有事情，结果只能是一件都做不好。 不可以继续这样颓下去了，这不是我想要的生活。 很烦躁，不知道何从下手这一团乱麻。 有了以前的打击，洛谷这一重要的刷题来源消失，自此本就模糊的目标更加不明确了。 身边的几乎所有人都跟我说，要打进$WF$，为北航争光。我也想啊，可是我真的没有这个能力。我想退出$ACM​$了，因为智商实在不够。但又不甘心，不甘心一个目标的失去，不甘心辜负身边人的期望，不甘心自己为之付出的一切。东野奎吾先生《白夜行》中的一段文字，深以为然： 人生也一样，有白天和黑夜，只是不会像真正的太阳那样，有定时的日出和日落。有些人一辈子都活在太阳的照耀下，也有些人不得不一直活在漆黑的深夜里。人害怕的，就是本来一直存在的太阳落下不再升起，也就是非常害怕原本照在身上的光芒消失。 写到这里，我想自己已经冷静许多了。 因为害怕失去，因为只会隐忍，所以才会造成今日的焦虑与恐惧。 而其实这一些东西，无论是学业还是竞赛，无论是感情还是生活，顺其自然、放平心态才是解决问题的不二法门。害怕失去是人之本性，而解决焦虑的根源便是顺其自然，如果自己不想放弃，那就不要放弃。 我想，自己大概已经拥有许多了。北航是一所很好的学校，而大学生活从不只有学习，更有许多自己想干的、爱干的课余之事。能够遇到让自己又爱又恨的算法竞赛，这或许是一种对自己意志的磨练；而能够遇到和自己志同道合互相欣赏的同学，获得升华的友情，我想这本身就是一种十分幸福的事情了。 至于算法竞赛，有什么可以怕的呢？无论实力在不在，自己学的高兴难道不就是最重要的吗？ 闻道有先后，术业有专攻。 如是而已。 我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳明那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。你明白吗？我从来就没有太阳，所以不怕失去。 我从来就没有太阳，所以不怕失去。]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝书第一章部分经典例题题解]]></title>
    <url>%2F2019%2F04%2F05%2Flrj-blue-1%2F</url>
    <content type="text"><![CDATA[最近在读刘汝佳先生的《算法竞赛入门经典》，收获颇丰，特此记录一些自己以前未曾涉猎算法的经典例题题解。 UVA-10755 Garbage Heap（三维前缀和）题目链接Garbage Heap 解题思路$UVA$上一定要用$%lld$！！！只有$CF$才需要$I64d$！！！空格换行要求也很严格！ 大致思路是，把三维用前缀和表示，每次枚举两维，第三维再用前缀和的思想用类似求最大子序列的求法$O(n)$解决，总复杂度$O(n^5)$。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define For(i,a,b) for(i=a;i&lt;=b;i++)#define FFF For(i,1,a)For(j,1,b)For(k,1,c)typedef long long ll;ll m[25][25][25];int a,b,c,t;ll sumf(int x1,int x2,int y1,int y2,int z1,int z2)&#123; ll num=m[x2][y2][z2]; num-=m[x1-1][y2][z2]; num-=m[x2][y1-1][z2]; num-=m[x2][y2][z1-1]; num+=m[x1-1][y1-1][z2]; num+=m[x1-1][y2][z1-1]; num+=m[x2][y1-1][z1-1]; num-=m[x1-1][y1-1][z1-1]; return num;&#125;int main()&#123; int i,j,k,l,p; ll ans,minpre,sum; scanf("%d",&amp;t); while(t--)&#123; ans=-1e18; memset(m,0,sizeof(m)); scanf("%d%d%d",&amp;a,&amp;b,&amp;c); FFF scanf("%lld",&amp;m[i][j][k]); FFF m[i][j][k]+=m[i-1][j][k]; FFF m[i][j][k]+=m[i][j-1][k]; FFF m[i][j][k]+=m[i][j][k-1]; For(i,1,a)For(j,i,a)For(k,1,b)For(l,k,b)&#123; minpre=0; For(p,1,c)&#123; sum=sumf(i,j,k,l,1,p); if(sum-minpre&gt;ans)ans=sum-minpre; if(sum&lt;minpre)minpre=sum; &#125; &#125; printf("%lld\n",ans); if(t)putchar('\n'); &#125; return 0;&#125; UVA-1326 Jurassic Remains（中途相遇法）题目链接Jurassic Remains 解题思路由于直接状态压缩的消耗太大，分成两部分状态压缩解决，通过保存第一部分的状态，枚举第二部分的状态时$O(lgn)$寻找（$STL$的$map$），时间复杂度从$O(2^n)$降到$O(2^{\frac n2}logn)​$。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;int n,state[50];char s[100010];map&lt;int,int&gt;m;int count(int x)&#123; int p=0; while(x)p+=(x&amp;1),x&gt;&gt;=1; return p;&#125;int main()&#123; int i,j; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; m.clear(); for(i=0;i&lt;n;i++)&#123; scanf("%s",s); state[i]=0; for(j=0;s[j];j++)state[i]^=(1&lt;&lt;(s[j]-'A')); &#125; int n1=n/2,n2=n-n1,ans=0; for(i=0;i&lt;(1&lt;&lt;n1);i++)&#123; int x=0,cnt=0; for(j=0;j&lt;n1;j++)if(i&amp;(1&lt;&lt;j))x^=state[j],cnt++; if(!m.count(x)||cnt&gt;count(m[x]))m[x]=i; &#125; for(i=0;i&lt;(1&lt;&lt;n2);i++)&#123; int x=0; for(j=0;j&lt;n2;j++)if(i&amp;(1&lt;&lt;j))x^=state[j+n1]; if(m.count(x)&amp;&amp;count(m[x])+count(i)&gt;count(ans)) ans=(i&lt;&lt;n1)^m[x]; &#125; printf("%d\n",count(ans)); int flag=0; for(i=0;i&lt;n;i++)if(ans&amp;(1&lt;&lt;i))&#123; if(!flag)printf("%d",i+1); else printf(" %d",i+1); flag=1; &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>LRJ</category>
        <category>Chapter 1</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 547 (Div.3)]]></title>
    <url>%2F2019%2F04%2F02%2Fcf547div3%2F</url>
    <content type="text"><![CDATA[第一次完整的打下来一场比赛。 Solved A B C D E F G 7/7 O O O O O Ø Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接CF Round #547 div.3 F 题目大意给定一段长度$\leq1500$的序列，求一组互不相交的子序列，使得每个子序列内数字之和相等，问这一组子序列最多包含多少个子序列。 解题思路先储存所有子序列和的可能性，再从左往右枚举右端点，枚举左端点，贪心地添加区间信息。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int n;int a[1600],s[1600];vector&lt;int&gt;G;struct Ans&#123; int num,r;//r:上一组区间的右端点 vector&lt;pair&lt;int,int&gt; &gt;vec;&#125;ans[1125080];int f(int x)&#123;return lower_bound(G.begin(),G.end(),x)-G.begin();&#125;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),s[i]=s[i-1]+a[i]; for(i=1;i&lt;=n;i++)for(j=i;j&lt;=n;j++)G.push_back(s[j]-s[i-1]); sort(G.begin(),G.end()); G.erase(unique(G.begin(),G.end()),G.end()); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=i;j++)&#123; int su=s[i]-s[j-1]; int p=f(su); if(ans[p].r&lt;j)&#123; ans[p].r=i; ans[p].num++; ans[p].vec.push_back(&#123;j,i&#125;); &#125; &#125; &#125; int mx=-1e9,temp=0; for(i=0;i&lt;G.size();i++) if(ans[i].num&gt;mx)mx=ans[i].num,temp=i; printf("%d\n",mx); for(i=0;i&lt;ans[temp].vec.size();i++) printf("%d %d\n",ans[temp].vec[i].first,ans[temp].vec[i].second); return 0;&#125; G 题目大意给一棵树，给边染色，对任意一个节点，如果连着多个同样颜色的边就称之为“坏点”，问“坏点”不超过$k$个需要染色的色数最少是多少，并输出一种染色方案。 解题思路题意理解了半天没搞懂，导致最后没有AK 对于“非坏点”，所有连接它的边都是不同颜色的，所以色数是第$k$大度数的点的度数。然后xjb​染就行了。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define N 200010struct Edge&#123; int end,near;&#125;e[N&lt;&lt;1];int head[N],cnt=1;void add(int a,int b)&#123; e[++cnt].end=b;e[cnt].near=head[a];head[a]=cnt;&#125;int deg[N],mx,col[N&lt;&lt;1];void dfs(int c,int p,int f)&#123; int i,q; for(i=head[p];i;i=e[i].near)&#123; q=e[i].end; if(q==f)continue; col[i&gt;&gt;1]=(++c)%mx; dfs(c,q,p); &#125;&#125;int main()&#123; int i,n,k,x,y; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;n;i++)scanf("%d%d",&amp;x,&amp;y),add(x,y),add(y,x),deg[x]++,deg[y]++; sort(deg+1,deg+n+1); printf("%d\n",mx=deg[n-k]); dfs(1,1,0); for(i=1;i&lt;n;i++)printf("%d ",col[i]+1); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十三届北航程序设计竞赛预赛题解]]></title>
    <url>%2F2019%2F03%2F26%2F13thbcpc-pretest%2F</url>
    <content type="text"><![CDATA[大概咕掉了，以后看摸着再回来做吧。 Solved A B C D E F G H I J K L M 6/13 Ø Ø Ø Ø . . Ø Ø . . . . . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述我们将五角星关于它的中心旋转$alpha$角度得到一个新五角星，再与原五角星重叠，得到一个新的平面图形，请问在新的平面图形中二维平面被分成了多少个区域？ 解题思路观察易得，情况就两种。 AC代码点击 12345678910 #include&lt;stdio.h&gt;int main()&#123; int n,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); printf("%d\n",n%72?32:7); &#125; return 0;&#125; B 题目描述给一个$01$串，求一个最短非空$01$串，使得其不是给定串的子串，求最短长度。 解题思路答案不超过$23$（$2^{23}&gt;4.5e6$），故从上界向下枚举即可。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N (1&lt;&lt;23)+10char a[N];int vis[N];int main()&#123; int i,j,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",a); int ans,l=strlen(a),k=0,now=0; while((1&lt;&lt;k)&lt;=l)k++; ans=k; for(i=0;i&lt;l;i++)&#123; if(i&lt;k)now=(now&lt;&lt;1)+a[i]-'0'; else now=((now&amp;((1&lt;&lt;k-1)-1))&lt;&lt;1)+a[i]-'0'; if(i&gt;=k-1)vis[now]=1; &#125; for(i=k-1;i;i--)&#123; int flag=0; for(j=0;j&lt;(1&lt;&lt;i);j++) if(vis[j&lt;&lt;1]||vis[j&lt;&lt;1|1]||vis[j+(1&lt;&lt;i)]||vis[j])vis[j]=1; else flag=1; if(flag)ans=i; else break; &#125; printf("%d\n",ans); memset(vis,0,sizeof(vis)); &#125; return 0;&#125; C 题目描述给定一个等腰梯形，每一行均匀分布一些点，问从这个等腰梯形中的点里面选三个构成正三角形的个数。 解题思路极其麻烦的一道题，做了整整三个小时。（还不是因为菜） 把三角形分为头朝上、头朝下两部分解决。假设头朝下的、底边在宽度为$i$的一层中的正三角形个数为$a_i$，头朝上的、顶点在宽度为$i$的一层中的正三角形个数为$b_i$，那么答案便是$\sum_{i=n}^{m}{a_i+b_i}$。 先求$a_i$。 底边在宽度为$i$的一层中的正三角形，其边长的取值范围为$l∈[1,i-n]$，记$h_i=i-n$，$H=m-n$，于是相当于考虑在$i+1$个点中选择距离$d\leq h_i$的种数，也就是$a_i=h_i(i+1)-\frac{h_i(h_i+1)}2$。 解释一下上面这个式子。在$i+1$个点中任选一个点$p$，在不考虑超出范围的情况下，距离$d\leq h_i$的点有$p+1,p+2,…,p+h_i$，共有$h_i$个。但显然这样多算了选了并不能选的点的情况。这种右端的点超出范围情况共有$(1+2+3+…+h_i)$种情况，即$\frac{h_i(h_i+1)}2$。 于是 $\sum_{i=n}^{m} a_i$ $=\sum_{i=n}^{m}{(i+1)h_i-\frac{h_i(h_i+1)}2}$ $=\sum_{i=0}^{H}{\frac{(i+2n+1)i}2}$ $=\sum_{i=0}^{H}{\frac{i^2}{2}+\frac{(2n+1)i}2}$ $=\frac{H(H+1)(2H+1)}{12}+\frac{(2n+1)(H+1)H}{4}$ $=\frac{n(H+1)H}2+\frac{H(H+1)(H+2)}6$ 再来计算$b_i$。 对于顶点在宽度为$i$的一层中的三角形，其边长为$l=min(i-n,\left\lfloor\frac i2\right\rfloor)$。枚举底边宽度$j$，则正三角形边长为$i-j$，个数为$2j-i+1$。 故$b_i=\sum_{j=n}^{i-1}2j-i+1,k\leq2n;\sum_{j=\left\lfloor\frac{k+1}2\right\rfloor}^{i-1}2j-i+1,k&gt;2n$。 分段求和，有 $1.m\leq2n$ $\sum_{i=n}^{m}b_i$ $=\sum_{i=n}^{m}\sum_{j=n}^{i-1}2j-i+1$ $=\sum_{i=n}^{m}(1-i)(i-1-n+1)+2\frac{(n+i-1)(i-n)}{2}$ $=\sum_{i=n}^{m}n(i-n)$ $=\frac{n(1+H)H}2$ $2.m&gt;2n$ $\sum_{i=n}^{m}b_i$ $=\sum_{i=n}^{2n}b_i+\sum_{i=2n+1}^{m}b_i$ $=\frac{n(1+2n-n)(2n-n)}2+\sum_{i=2n+1}^{m}b_i$ $=\frac{n^2(1+n)}2+\sum_{i=2n+1}^{m}\sum_{j=\left\lfloor\frac{k+1}2\right\rfloor}^{i-1}2j-i+1$ $=\frac{n^2(1+n)}2+\sum_{i=2n+1}^{m}(1-i)(i-\left\lfloor\frac{i+1}2\right\rfloor)+(\left\lfloor\frac{i+1}2\right\rfloor+i-1)(i-\left\lfloor\frac{i+1}2\right\rfloor)$ $=\frac{n^2(1+n)}2+\sum_{i=2n+1}^{m}\left\lfloor\frac{i+1}2\right\rfloor\left\lceil\frac{i+1}2\right\rceil$ $=\frac{n^2(1+n)}2+\sum_{i=2n+1}^{m}\frac{i^2}4-\frac14(当i为奇数)$ $=\frac{n^2(1+n)}2+\frac14(\frac{m(m+1)(2m+1)}6-\frac{2n(2n+1)(4n+1)}6)-\frac14(\left\lfloor\frac m2\right\rfloor-n)$ 然后加起来就行了。 AC代码点击 1234567891011121314151617#include&lt;stdio.h&gt;long long n,m,w=1e9+7;long long ans; int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; ans=0; scanf("%lld%lld",&amp;m,&amp;n); long long H=m-n; ans=(n*H*(H+1)/2+(H+2)*(H+1)*H/6)%w; if(m&lt;=2*n)ans=(ans+(n*H*(H+1)/2)%w)%w; else ans=(ans+n*n*(n+1)/2+(((m*(m+1)*(2*m+1)-(2*n)*(2*n+1)*(4*n+1))/6+n-m/2)/4)%w)%w; printf("%lld\n",ans%w); &#125; return 0;&#125; D 题目描述从几堆牌中随机等概率取牌，一堆中取一张牌则所有的牌被取走。除了第一堆，每一堆牌的个数都是从一个闭区间中等概率选取的。当第一堆被取走时，游戏结束。问游戏结束时，取走的牌数期望值。 解题思路设$P(i,j)$表示第$i$堆牌有$j$个，这堆牌其中某一张牌在第一堆牌某一张牌之前被取走的概率。于是有$P(i,j)=\frac{j}{a_1+j}$。 $ans=\sum_{i=2}^{n}\frac1{up[i]-low[i]+1}\sum_{j=low[i]}^{up[i]}\frac{j^2}{a_1+j}$。 每组数据预处理出后一个求和号里的东西，逆元记忆化搜索即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233 #include&lt;stdio.h&gt;#define N 100010typedef long long ll;int u[N],l[N],w=998244353;ll a[N*10];ll pw(ll a,ll p)&#123; ll x=1; for(;p;p&gt;&gt;=1,a=a*a%w)if(p&amp;1)x=x*a%w; return x;&#125;int inv[N*20];ll invf(int x)&#123; if(inv[x])return inv[x]; return inv[x]=pw(x,w-2);&#125;int main()&#123; int i,t,n,a1; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;a1); int max=0; ll ans=a1; for(i=1;i&lt;n;i++)&#123; scanf("%d%d",&amp;l[i],&amp;u[i]); if(u[i]&gt;max)max=u[i]; &#125; for(i=1;i&lt;=max;i++)a[i]=1LL*i*i%w*invf(a1+i)%w; for(i=1;i&lt;=max;i++)a[i]=(a[i]+a[i-1])%w; for(i=1;i&lt;n;i++)ans=(ans+(invf(u[i]-l[i]+1)*(a[u[i]]-a[l[i]-1]+w)%w)%w)%w; printf("%lld\n",(ans+w)%w); &#125; return 0;&#125; E 题目描述解题思路AC代码点击 1 F 题目描述解题思路AC代码点击 1 G 题目描述给定一个一元二次方程，如果有无限小数实数解则保留到$1e6$位，如果有有限小数实数解则保留所有小数，如果无解则输出无解。 按照以下规则输出：输出$0-9$在解中出现的频率百分比，保留到整数。 解题思路先判断有解无解、有无有理解，如果解无理，则全部输出$10$。 如果有有理解，再分为有限小数、无限小数讨论。如果无限小数且$1e6+1$位$\geq5$，则需要找到循环节中对应的位置进行进位、增加等处理；否则直接处理循环节输出。 我没有AC，但还是要发题解。 没有AC的代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#define M 1000000int num[11],cir[2010],cnt,infinite;//出现次数，余数是否出现，总数，不循环 int len,fir;//循环节长度及初始出现位置 int cy[2010];//循环节 int tail;//第1e6+1位在循环节中的位置 void init()&#123; memset(num,0,sizeof(num)); memset(cir,0,sizeof(cir)); memset(cy,0,sizeof(cy)); fir=tail=infinite=cnt=len=0;&#125;void solveinteger(int x)&#123; if(!x)num[0]++,cnt++; while(x)num[x%10]++,x/=10,cnt++;&#125;void find(int k,int d)&#123; int temp[11]=&#123;0&#125;,tot=0; int i,j,r=k; cir[r]=1; for(i=1;i&lt;=M;i++)&#123; if(!r)break; if(!infinite&amp;&amp;cir[r]&amp;&amp;i!=1)&#123; infinite=1; cy[++len]=r*10/d; for(j=r*10%d;j!=r;j=j*10%d)cy[++len]=j*10/d; fir=i-len; int number=(M-i)/len;//后面循环节个数 for(j=r*10%d;;j=j*10%d)&#123; temp[j*10/d]+=number; if(j==r)break; &#125; i+=number*len; tot+=number*len; tail=(M-i+2)%len;//M+1 &#125; temp[r*10/d]++; tot++; cir[r]=i; r=r*10%d; &#125; if(!infinite||cy[tail]&lt;5)&#123; for(i=0;i&lt;10;i++)num[i]+=temp[i]; cnt+=tot; &#125;else&#123; if(!tail)tail=len; int mx; for(i=1;i&lt;=len;i++)&#123; mx=(tail-1-i+len)%len+1; if(cy[mx]!=9)break; &#125; r=k; cir[r]=1; int tmp=i,flag=0; memset(cir,0,sizeof(cir)); for(i=1;i&lt;=M-tmp;i++)&#123; if(!r)break; if(!flag&amp;&amp;cir[r]&amp;&amp;i!=1)&#123; flag=1; int number=(M-i-tmp)/len;//后面循环节个数 for(j=r*10%d;;j=j*10%d)&#123; num[j*10/d]+=number; if(j==r)break; &#125; i+=number*len; &#125; num[r*10/d]++; cir[r]=i; r=r*10%d; &#125; num[(r*10/d+1)%10]++; for(i=M-tmp+2;i&lt;=M;i++)num[0]++; cnt+=M; &#125;&#125;void printresult()&#123; int i; for(i=0;i&lt;10;i++)&#123; double tp=num[i]*100.0/cnt; printf("%d ",tp-(int)tp&lt;0.5-1e-10?(int)tp:(int)tp+1); &#125; printf("\n");&#125;void print(int k,int d)&#123; if(k&lt;0)k=-k; if(d&lt;0)d=-d; init(); solveinteger(k/d); find(k%d,d); printresult();&#125; int main()&#123; int a,b,c,T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); int delta=b*b-4*a*c; if(delta&lt;0)printf("NO JIE\n"); else if(round(sqrt(delta))*round(sqrt(delta))==delta)&#123; if(a&lt;0)print((-b+round(sqrt(delta))),2*a),print((-b-round(sqrt(delta))),2*a); else print((-b-round(sqrt(delta))),2*a),print((-b+round(sqrt(delta))),2*a); &#125;else printf("10 10 10 10 10 10 10 10 10 10\n10 10 10 10 10 10 10 10 10 10\n"); &#125; return 0;&#125; H 题目描述给定一个$300*300$以内的数字矩阵，其中$’x’$表示这个点不能被选择，再给出$\leq 1000$组询问，每组询问要求输出在包含给定$(x,y)$的基础上的、不选$’x’$点的元素之和最大的子矩阵中元素之和。 解题思路把子矩阵包含$(x,y)$这个条件转化成：在行数范围在$[up,down]$区间内、必选$k$这一列时，最大的子矩阵大小，并在$up\leq x\leq down$条件下取最大值。 $’x’$可设置成一个比较小的数，但不能太小，$-1e7$比较好，而$-1e8$就不太行了，否则可能会爆掉。 通过问题转化，可以$O(n^2m+q)$解决问题。 剧毒，卡常数（还不是因为我太菜了） TLE代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#define N 305int inf=-1e7;int read()&#123; char c=getchar();int f=1,num=0; while(c&gt;'9'||c&lt;'0')&#123; if(c=='-')f=-1; if(c=='x')return inf; c=getchar(); &#125; while(c&gt;='0'&amp;&amp;c&lt;='9')num=(num&lt;&lt;3)+(num&lt;&lt;1)+c-'0',c=getchar(); return num*f;&#125;#define max(a,b) (a&gt;b?(a):(b))int n,m,q,mt[N][N],sum[N][N];int pre[N],suc[N],s[N],mx[N][N][N];int p[N][N][N],f[N][N];void init()&#123; int i,j,k; for(i=1;i&lt;=n;i++)&#123; for(j=i;j&lt;=n;j++)&#123; pre[0]=suc[m+1]=0; for(k=1;k&lt;=m;k++)s[k]=sum[j][k]-sum[j][k-1]-(sum[i-1][k]-sum[i-1][k-1]); //预处理减小常数 for(k=1;k&lt;=m;k++)pre[k]=max(0,pre[k-1])+s[k]; for(k=m;k&gt;=0;k--)suc[k]=max(0,suc[k+1])+s[k]; for(k=1;k&lt;=m;k++)mx[i][j][k]=pre[k]+suc[k]-s[k]; //mx[i][j][k]:i为上界，j为下界，必须包含第k列在上下界范围内全部值的最大值 &#125; &#125; for(i=1;i&lt;=n;i++)&#123; for(k=1;k&lt;=m;k++)&#123; //p[i][j][k]:i为上界，j为下界的上界，必须包含第k列的最大值 //只是起到简化运算的作用 p[i][n+1][k]=inf; for(j=n;j&gt;=i;j--) p[i][j][k]=max(p[i][j+1][k],mx[i][j][k]); &#125; &#125; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++)&#123; //f[i][j]=min&#123;p[up][i][j]&#125;,up&lt;=i f[i][j]=p[1][i][j]; for(k=2;k&lt;=i;k++)f[i][j]=max(f[i][j],p[k][i][j]); &#125;&#125;int main()&#123; int i,j,t,x,y; t=read(); while(t--)&#123; n=read(),m=read(); for(i=1;i&lt;=n;i++)for(j=1;j&lt;=m;j++) mt[i][j]=read(),sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+mt[i][j]; init(); q=read(); while(q--)x=read(),y=read(),printf("%d\n",f[x][y]); &#125; return 0;&#125; AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#define max(a,b) (a&gt;b?(a):(b))#define N 304int inf=-1e7;int read()&#123; char c=getchar();int f=1,num=0; while(c&gt;'9'||c&lt;'0')&#123; if(c=='-')f=-1; if(c=='x')return inf; c=getchar(); &#125; while(c&gt;='0'&amp;&amp;c&lt;='9')num=(num&lt;&lt;3)+(num&lt;&lt;1)+c-'0',c=getchar(); return num*f;&#125;int n,m,q,mt[N][N],sum[N][N];int pre[N],suc[N],mx[N][N];int p[N][N][N],f[N][N],s[N];void init()&#123; int i,j,k; for(i=1;i&lt;=n;i++)&#123;//合并到用一个i for(j=i;j&lt;=n;j++)&#123; pre[0]=suc[m+1]=0; for(k=1;k&lt;=m;k++)s[k]=sum[j][k]-sum[j][k-1]-(sum[i-1][k]-sum[i-1][k-1]); for(k=1;k&lt;=m;k++)pre[k]=max(0,pre[k-1])+s[k]; for(k=m;k&gt;=0;k--)suc[k]=max(0,suc[k+1])+s[k]; for(k=1;k&lt;=m;k++)mx[j][k]=pre[k]+suc[k]-s[k]; //i为上界，j为下界，必须包含第k列的最大值 &#125; for(k=1;k&lt;=m;k++)p[i][n][k]=mx[n][k]; for(j=n-1;j&gt;=i;j--)for(k=1;k&lt;=m;k++)p[i][j][k]=max(p[i][j+1][k],mx[j][k]); for(j=1;j&lt;=m;j++)&#123; f[i][j]=p[1][i][j]; for(k=2;k&lt;=i;k++)f[i][j]=max(f[i][j],p[k][i][j]); &#125; &#125;&#125;int main()&#123; int i,j,t,x,y; t=read(); while(t--)&#123; n=read(),m=read(); for(i=1;i&lt;=n;i++)for(j=1;j&lt;=m;j++) mt[i][j]=read(),sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+mt[i][j]; init(); q=read(); while(q--)x=read(),y=read(),printf("%d\n",f[x][y]); &#125; return 0;&#125; I 题目描述解题思路AC代码点击 12 J 题目描述解题思路AC代码点击 12 K 题目描述解题思路AC代码点击 12 L 题目描述解题思路AC代码点击 12 M 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>BCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四届北航程序设计竞赛预赛题解]]></title>
    <url>%2F2019%2F03%2F21%2F14thbcpc-pretest%2F</url>
    <content type="text"><![CDATA[整整花费了一个周的时间来做，不是依托自身实力而是依托大佬的帮助才完成了这次比赛。题目都很有意思，可惜能想出来的并不多。那集训队的事情就等明年了。 Solved A B C D E F G H I J K L 12/12 O O O O O O O O O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给出一段序列，求最少去除几个数使得剩下的数能够组成总和相同的两堆。 $1≤T≤50$，$1≤n≤50$，$0≤a,b≤10^9$，$0≤b−a≤50$ 解题思路根据$a$的个数和$b-a$的总和进行$DP$，滚动数组优化。 AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;string.h&gt;int ans,x[55];int f[2][110][5015];int max(int p,int q)&#123;return p&gt;q?p:q;&#125;int main()&#123; int i,j,k,t,n,a,b; scanf("%d",&amp;t); while(t--)&#123; memset(f,0,sizeof(f)); f[0][50][2500]=1; int p=0; scanf("%d%d%d",&amp;n,&amp;a,&amp;b); for(i=1;i&lt;=n;i++)scanf("%d",&amp;x[i]),x[i]-=a; for(i=1;i&lt;=n;i++)&#123; p^=1; for(j=50-i;j&lt;=50+i;j++)&#123;//50+ a的个数 for(k=0;k&lt;=5000;k++)&#123;//2500+ b-a累加 f[p][j][k]=f[p^1][j][k]; if(k-x[i]&gt;=0&amp;&amp;j-1&gt;=0&amp;&amp;f[p^1][j-1][k-x[i]])f[p][j][k]=max(f[p][j][k],f[p^1][j-1][k-x[i]]+1); if(k+x[i]&lt;=5000&amp;&amp;j-1&gt;=0&amp;&amp;f[p^1][j+1][k+x[i]])f[p][j][k]=max(f[p][j][k],f[p^1][j+1][k+x[i]]+1); &#125; &#125; &#125; int ans=f[p][50][2500]; for(i=0;i&lt;=100;i++)&#123; if(a*(i-50)+2500&lt;0)continue; if(a*(i-50)+2500&gt;5000)break; ans=max(ans,f[p][i][-a*(i-50)+2500]); &#125; printf("%d\n",n-(ans-1)); &#125; return 0;&#125; B 题目描述升级有两种，吃糖直接升一级，或者攒经验。给定经验值，糖果数，各级升级经验数，问最多升到多少级。 解题思路排完序暴力枚举答案就行了。（虽然可以二分答案） AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct E&#123; int d,i; bool operator &lt;(const E&amp;a)const&#123;return d&gt;a.d&#125;;&#125;exp[110];int n,m,a,b,c,t,p[110];int jud(int x)&#123; int u[110]=&#123;0&#125;; int i,temp=n,mx=m; for(i=1;i&lt;=100;i++)&#123; if(temp&amp;&amp;exp[i].i&lt;=x)u[exp[i].x]=1,temp--; &#125; for(i=1;i&lt;=x;i++)&#123; if(!u[i])&#123; if(mx&gt;=p[i])mx-=p[i]; else return 0; &#125; &#125; return 1;&#125;int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;a,&amp;b,&amp;c); for(i=1;i&lt;=100;i++)p[i]=exp[i].d=(i*a+b)%c,exp[i].i=i; sort(exp+1,exp+100); for(i=1;i&lt;=100;i++)if(!jud(i))break; printf("%d\n",i-1); &#125; return 0;&#125; C 题目描述给一棵树，求出所有节点间路径的权值和和异或和的乘积之和。 解题思路思路一：点分治，求出所有经过当前根的子树中的链，把所有链分别连起来，再减去在多算了的相同子树中链的加和。 思路二：树形DP。还暂时没有实现。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 100010#define w ((ll)(1e9+7))typedef long long ll;int max(int a,int b)&#123;return a&gt;b?a:b;&#125;struct Edge&#123; int end,near; ll len;&#125;e[N&lt;&lt;2];struct Chain&#123; ll sum,xos;&#125;sub[N&lt;&lt;4],all[N&lt;&lt;4];int head[N],cnt;void add(int a,int b,ll l)&#123; e[++cnt].end=b;e[cnt].len=l; e[cnt].near=head[a];head[a]=cnt;&#125;int n,rt,sum;int siz[N],mxt[N],vis[N];void getrt(int v,int fa)&#123; int i,p; siz[v]=1;mxt[v]=0; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(vis[p]||p==fa)continue; getrt(p,v); siz[v]+=siz[p]; mxt[v]=max(mxt[v],siz[p]); &#125; mxt[v]=max(mxt[v],sum-siz[v]); if(mxt[v]&lt;mxt[rt])rt=v;&#125;void getdis(int v,int fa,ll s,ll x)&#123; int i,p; sub[++sub[0].sum].sum=s; sub[sub[0].sum].xos=x; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(p==fa||vis[p])continue; getdis(p,v,(s+e[i].len)%w,x^e[i].len); &#125;&#125;ll allBin[N],subBin[N];ll calcsub()&#123; int i,j; ll ans=0; for(i=1;i&lt;=sub[0].sum;i++)&#123; ll r=0; for(j=0;j&lt;32;j++)&#123; if(sub[i].xos&amp;(1&lt;&lt;j))r+=(sub[0].sum-subBin[j])*(1&lt;&lt;j)%w; else r+=subBin[j]*(1&lt;&lt;j)%w; r%=w; &#125; ans+=r*sub[i].sum%w; ans%=w; &#125; return ans;&#125;ll calcall()&#123; int i,j; ll ans=0; for(i=1;i&lt;=all[0].sum;i++)&#123; ll r=0; for(j=0;j&lt;32;j++)&#123; if(all[i].xos&amp;(1&lt;&lt;j))r+=(all[0].sum-allBin[j])*(1&lt;&lt;j)%w; else r+=allBin[j]*(1&lt;&lt;j)%w; r%=w; &#125; ans+=r*all[i].sum%w; ans%=w; &#125; return ans;&#125;ll sol(int v)&#123; int i,p,j,k; vis[v]=1;all[0].sum=0; ll ans=0; for(i=0;i&lt;32;i++)allBin[i]=0; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(vis[p])continue; sub[0].sum=0; for(j=0;j&lt;32;j++)subBin[j]=0; getdis(p,v,e[i].len,e[i].len); for(j=1;j&lt;=sub[0].sum;j++) for(k=0;k&lt;32;k++) if(sub[j].xos&amp;(1&lt;&lt;k))subBin[k]++; ans-=calcsub();ans%=w; for(j=0;j&lt;32;j++)allBin[j]+=subBin[j]; for(j=1;j&lt;=sub[0].sum;j++)all[++all[0].sum]=sub[j]; &#125; ans+=calcall();ans%=w; for(i=1;i&lt;=all[0].sum;i++)&#123; ans+=all[i].sum*all[i].xos%w; ans%=w; &#125; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(!vis[p])&#123; sum=siz[p];mxt[0]=n;rt=0; getrt(p,v); ans+=sol(rt); ans%=w; &#125; &#125; return (ans+w)%w;&#125;int main()&#123; int i,a,b,t; ll c; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=1;i&lt;n;i++) scanf("%d%d%lld",&amp;a,&amp;b,&amp;c),add(a,b,c),add(b,a,c); rt=0;sum=mxt[0]=n;getrt(1,0); printf("%lld\n",sol(rt)); memset(vis,0,sizeof(int)*(n+1)); memset(head,0,sizeof(int)*(n+1)); cnt=0; &#125; return 0;&#125; D 题目描述一行点，往里头填数，每个点有最低限制，且要满足每个点相对左边的点的数满足给定条件，求最小总数。 解题思路暴力 AC代码点击 12345678910111213141516171819202122#include&lt;stdio.h&gt;int ans,now,a[110],b[110];int main()&#123; int i,t,n; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)scanf("%d",&amp;b[i]); now=ans=a[0]; for(i=1;i&lt;n;i++)&#123; now+=b[i]; if(now&lt;a[i])&#123; ans+=i*(a[i]-now); now=a[i]; &#125; ans+=now; &#125; printf("%d\n",ans); &#125; return 0;&#125; E 题目描述给定$n$个点， 两点间道路长度为两点权值的$gcd$，求最大生成树。（$a_i\leq 1e5$） 解题思路根据$krustal$算法的原理，枚举边长上界，构造生成树。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n,a[100010],f[100010],map[100010];int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;int main()&#123; int i,j,k,l,t,m; scanf("%d",&amp;t); while(t--)&#123; long long ans=0,max; int temp,p,q,u[2]=&#123;0&#125;,now=0,cnt=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); sort(a+1,a+n+1); max=a[n]; for(i=1;i&lt;n;i++)if(a[i]==a[i+1])ans+=a[i],cnt++; for(i=1;i&lt;=n;i++)map[a[i]]=i; for(i=1;i&lt;=n;i++)f[i]=i; for(i=max;i;i--)&#123; now=u[0]=u[1]=0; for(j=1;j*i&lt;=max;j++)&#123; if(map[j*i])&#123; u[now]=map[j*i]; if(u[now^1])&#123; p=find(u[now]); q=find(u[now^1]); if(p!=q)&#123; ans+=i; f[p]=q; cnt++; &#125; &#125; now^=1; &#125; &#125; if(cnt==n-1)break; &#125; printf("%lld\n",ans); memset(map,0,sizeof(map)); &#125; return 0;&#125; F 题目描述求满足$(i+1)^i*i &equiv; 0(mod&ensp; m)$的$m$的个数的前缀和，$i\leq 1e7$。 解题思路先考虑枚举每个数的质因数个数，发现会$T$飞。 故反向从枚举质因数筛原数。 AC代码点击 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#define N 10000002int ans[N+4],w=998244353;int prime[N+4]=&#123;1,1&#125;,a[N/10],tot=1;int main()&#123; int i,j,t,n,cnt; scanf("%d",&amp;t); for(i=1;i&lt;N;i++)ans[i]=1; for(i=2;i&lt;N;i++)&#123; if(!prime[i])a[tot++]=i; for(j=1;j&lt;tot;j++)&#123; if(i*a[j]&gt;=N)break; prime[i*a[j]]=1; if(i%a[j]==0)break; &#125; &#125; for(i=1;i&lt;tot;i++)&#123; for(j=1;j*a[i]&lt;N;j++)&#123; cnt=0; int now=j*a[i],temp=now; while(now%a[i]==0)now/=a[i],cnt++; ans[temp-1]=ans[temp-1]*1LL*(cnt*1LL*(temp-1)+1)%w; ans[temp]=ans[temp]*1LL*(cnt+1)%w; &#125; &#125; for(i=2;i&lt;N;i++)ans[i]=(ans[i]+ans[i-1])%w; while(t--)&#123; scanf("%d",&amp;n); printf("%d\n",ans[n]); &#125; return 0;&#125; G 题目描述给定一个非常长的序列，求其中所有上升子序列的长度 $k$次方之和，答案对$1e9+7$取模，$k\leq 20$。 解题思路先考虑$k=1$的情况。可以想到，从前到后遍历数组，用一个树状数组维护当前所有以$x$为结尾的上升子序列长度的和前缀和，每次加入（$y+query(x-1)$）更新。 在考虑$k\geq 2$的情况。维护$k+1$个树状数组，第$i$个树状数组记录上升子序列长度$l^i$的和的前缀和，更新的时候用二项式定理扫一遍即可。 注意到数据较大，需要离散化。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 131073using namespace std;typedef long long ll;int n,k,x[N],y[N],seq[N*10],M;struct number&#123; int a,b,i; bool operator&lt;(const number&amp;p)const&#123;return a&lt;p.a;&#125;&#125;a[N];ll w=1e9+7,t[21][N],c[25][25];int l(int x)&#123;return x&amp;(-x);&#125;void add(int d,int x,ll p)&#123; while(x&lt;=M)&#123; t[d][x]+=p; t[d][x]%=w; x+=l(x); &#125;&#125;ll query(int d,int x)&#123; ll ans=0; while(x)&#123; ans+=t[d][x]; ans%=w; x-=l(x); &#125; return ans;&#125;int main()&#123; int i,j,m,T; ll now[25]; for(i=0;i&lt;=20;i++)c[i][0]=1; for(i=1;i&lt;=20;i++)for(j=1;j&lt;=20;j++)c[i][j]=c[i-1][j-1]+c[i-1][j]; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;=n;i++)scanf("%d%d",&amp;x[i],&amp;y[i]),a[i].a=x[i],a[i].b=y[i],a[i].i=i; sort(a+1,a+n+1); for(i=1;i&lt;=n;i++)seq[a[i].a]=a[i].a==a[i-1].a?seq[a[i-1].a]:seq[a[i-1].a]+1; M=seq[a[n].a]+1; for(i=1;i&lt;=n;i++)&#123; int X=seq[x[i]]+1,Y=y[i]; for(j=0;j&lt;=k;j++)now[j]=query(j,X-1); for(j=0;j&lt;=k;j++)&#123; ll tot=0; for(m=0;m&lt;=j;m++)tot+=Y*c[j][m]%w*now[m]%w,tot%=w; add(j,X,(tot+Y)%w); &#125; &#125; printf("%lld\n",query(k,M)); for(i=0;i&lt;=k;i++)for(j=0;j&lt;=M;j++)t[i][j]=0; &#125; return 0;&#125; H 题目描述给定五张牌，问加入两张牌成为顺子有多少种情况。 解题思路巨麻烦的分类讨论？ 不，这题可以直接暴力。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;char a[8];int x[150];int main()&#123; int t,i,j,k; x['A']=1;x['2']=2;x['3']=3;x['4']=4; x['5']=5;x['6']=6;x['7']=7;x['8']=8; x['9']=9;x['T']=10;x['J']=11;x['Q']=12; x['K']=13; scanf("%d",&amp;t); while(t--)&#123; int t[25]=&#123;0&#125;,ans=0; int used[60]=&#123;0&#125;,num[20]=&#123;0&#125;; scanf("%s",a); for(i=0;i&lt;5;i++)&#123; int s=x[a[i]]; t[s]++; used[s*4+num[s]++]++; if(a[i]=='A')t[14]++; &#125; for(i=4;i&lt;56;i++)&#123; if(used[i])continue; t[i/4]++; for(j=i+1;j&lt;56;j++)&#123; if(used[j])continue; t[j/4]++; int flag=0; for(k=1;k&lt;=13;k++)&#123; if(t[k]&amp;&amp;t[k+1]&amp;&amp;t[k+2]&amp;&amp;t[k+3]&amp;&amp;(t[k+4]||(k+4==14&amp;&amp;t[1])))&#123; flag=1; break; &#125; &#125; if(flag)ans++; t[j/4]--; &#125; t[i/4]--; &#125; printf("%d\n",ans); &#125; return 0;&#125; I 题目描述给定一个只含有$ATGC$的环，$ATGC$分别代表一种矩阵，定义一次操作为所有矩阵乘上下一个矩阵，问$k$次操作后（$k\leq 1e9$）的环。 解题思路列个表发现$ATGC$之间的乘积具有异或的性质。 然后利用$k$的可加性，找到规律，倍增解决。 AC代码点击 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;char a[4]=&#123;'A','T','G','C'&#125;,c[1000010];int res[4][4]=&#123;&#123;0,1,2,3&#125;,&#123;1,0,3,2&#125;,&#123;2,3,0,1&#125;,&#123;3,2,1,0&#125;&#125;;int now[2][1000010];int map[510];int main()&#123; int i,t,n,k,m; scanf("%d",&amp;t); map['A']=0;map['T']=1; map['G']=2;map['C']=3; while(t--)&#123; m=0; int p,cnt; scanf("%d%d%s",&amp;n,&amp;k,c); for(i=0;i&lt;n;i++)now[1][i]=map[c[i]]; while(k)&#123; p=1;cnt=0; while(k&gt;=(1&lt;&lt;cnt+1))cnt++; int d=(1&lt;&lt;cnt); k-=d; for(i=0;i&lt;n;i++)now[m][i]=res[now[m^1][i]][now[m^1][(i+d)%n]]; m^=1; &#125; for(i=0;i&lt;n;i++)printf("%c",a[now[m^1][i]]); printf("\n"); &#125; return 0;&#125; J 题目描述求满足方程组 $x_1+x_2+…+x_n=m$$0\leq x_i \leq a_i$ 的解的个数， 对一堆素数的乘积取模。 解题思路首先，求答案用插板法，写出组合数。然后，分别对每一个模数取模，得到相应答案。最后，把取模得到的数用中国剩余定理得到最终答案。 毒瘤爆$long long$，CRT需要龟速乘 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;using namespace std;typedef long long ll;int n,k;ll m,v[20],ans[20],p[20];ll jc[20][100010];ll mul(ll x,ll y,ll mod) &#123; ll res=0;x%=mod; for(;y;y&gt;&gt;=1,(x*=2)%=mod)if(y&amp;1)(res+=x)%=mod; return res;&#125;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123;x=1,y=0;return;&#125; exgcd(b,a%b,y,x); y-=a/b*x;&#125;ll China(int n,ll *m,ll *a)&#123; int i; ll M=1,ans=0,y,x=0; for(i=0;i&lt;n;i++)M*=m[i]; for(i=0;i&lt;n;i++)&#123; ll w=M/m[i]; exgcd(m[i],w,x,y); ans=(ans+mul(mul(y,w,M),a[i],M))%M; &#125; return (ans%M+M)%M;&#125;ll pw(ll x,int y,int num)&#123; int i; ll ans=1;x%=p[num]; for(i=y;i;i&gt;&gt;=1,x=x*x%p[num])if(i&amp;1)ans=ans*x%p[num]; return ans;&#125;ll c(ll x,ll y,int num)&#123; if(x&lt;y)return 0; return mul(mul(jc[num][x],pw(jc[num][y],p[num]-2,num),p[num]),pw(jc[num][x-y],p[num]-2,num),p[num]);&#125;ll lucas(ll x,ll y,int num)&#123; if(!y)return 1; return mul(lucas(x/p[num],y/p[num],num),c(x%p[num],y%p[num],num),p[num]);&#125;int main()&#123; int i,s,cnt,t,j; ll temp; scanf("%d",&amp;t); while(t--)&#123; for(i=0;i&lt;20;i++)ans[i]=0; scanf("%d%lld%d",&amp;n,&amp;m,&amp;k); for(i=0;i&lt;n;i++)scanf("%lld",&amp;v[i]); for(i=0;i&lt;k;i++)scanf("%lld",&amp;p[i]); for(i=0;i&lt;k;i++)&#123; jc[i][0]=1; for(j=1;j&lt;=1e5;j++)jc[i][j]=jc[i][j-1]*j%p[i]; &#125; s=(1&lt;&lt;n); for(i=0;i&lt;s;i++)&#123; cnt=1; temp=0; for(j=0;j&lt;n;j++)&#123; if(i&amp;(1&lt;&lt;j))&#123; cnt*=-1; temp+=v[j]+1; &#125; &#125; if(temp&gt;m)continue; for(j=0;j&lt;k;j++) ans[j]=(ans[j]+mul(cnt&lt;0?p[j]-1:1,lucas(m-temp+n-1,n-1,j),p[j]))%p[j]; &#125; printf("%lld\n",China(k,p,ans)); &#125; return 0;&#125; K 题目描述多次操作区间对最小值（定义为非零的最小值）取模，求取模前后该区间数的总和。 解题思路线段树，区间和为$0$时特判剪枝。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt;#define N 200010typedef long long ll;struct SegmentTree&#123; int l,r; ll sum,min;&#125;t[N&lt;&lt;3];int n;ll a[N];ll minf(ll a,ll b)&#123; if(!a||!b)return b|a; return a&gt;b?b:a;&#125;void build(int p,int l,int r)&#123; if(l==r)&#123; t[p].l=t[p].r=l; t[p].min=t[p].sum=a[l]; return; &#125; t[p].l=l;t[p].r=r; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); t[p].sum=t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].sum; t[p].min=minf(t[p&lt;&lt;1].min,t[p&lt;&lt;1|1].min);&#125;ll query(int p,int l,int r)&#123; int L=t[p].l,R=t[p].r; if(l&gt;R||r&lt;L)return 0; if(l&lt;=L&amp;&amp;r&gt;=R)return t[p].sum; return query(p&lt;&lt;1,l,r)+query(p&lt;&lt;1|1,l,r);&#125;ll minquery(int p,int l,int r)&#123; int L=t[p].l,R=t[p].r; if(l&gt;R||r&lt;L)return 0; if(l&lt;=L&amp;&amp;r&gt;=R)return t[p].min; return minf(minquery(p&lt;&lt;1,l,r),minquery(p&lt;&lt;1|1,l,r));&#125;ll modify(int p,int l,int r,ll k)&#123; int L=t[p].l,R=t[p].r; if(l&gt;R||r&lt;L||!t[p].sum)return 0; if(L==R)return t[p].min=t[p].sum%=k; modify(p&lt;&lt;1,l,r,k);modify(p&lt;&lt;1|1,l,r,k); t[p].min=minf(t[p&lt;&lt;1].min,t[p&lt;&lt;1|1].min); t[p].sum=t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].sum; return t[p].min;&#125;void print()&#123; int i; for(i=1;i&lt;=44;i++) if(t[i].l)printf("%d %d %lld %lld\n",t[i].l,t[i].r,t[i].sum,t[i].min); printf("\n");&#125;int main()&#123; int q,i,l,r,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;q); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]); build(1,1,n); for(i=0;i&lt;q;i++)&#123; scanf("%d%d",&amp;l,&amp;r); ll mn=minquery(1,l,r); if(!mn)printf("0 0\n"); else&#123; printf("%lld ",query(1,l,r)); modify(1,l,r,mn); printf("%lld\n",query(1,l,r)); &#125; //print(); &#125; &#125; return 0;&#125; L 题目描述告诉每回合出现哪些神龙，每回合怎么得钱，买一个神龙一块钱，问多少回合能集齐要求的神龙。 解题思路二分答案。注意$p$爆$long long$。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 100010int n,m,p,k,l;int a[N],b[N],tmp[N];int f(int x,int y)&#123;return x*m+y;&#125;//1-&gt;2int g(int x)&#123;return x/m;&#125;//2-&gt;1int seq[N];int jud(int num)&#123; int i,mx=f(num,0)-1; memset(seq,0,sizeof(seq)); memset(tmp,0,sizeof(tmp)); for(i=0;i&lt;l;i++)tmp[b[i]]++; for(i=mx;i&gt;=0;i--)&#123; if(tmp[a[i]])&#123; seq[g(i)]++; tmp[a[i]]--; &#125; &#125; for(i=0;i&lt;l;i++)if(tmp[b[i]])return 0; long long now=p; for(i=0;i&lt;num;i++)&#123; now-=seq[i]; if(now&lt;0)return 0; if(now&lt;l)now+=now/k+p; &#125; return 1;&#125;int main()&#123; int i,j,q,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;p,&amp;k,&amp;l); for(i=0;i&lt;n;i++)for(j=0;j&lt;m;j++)scanf("%d",&amp;a[f(i,j)]); for(i=0;i&lt;l;i++)scanf("%d",&amp;b[i]); int l=0,r=n; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(jud(mid))r=mid; else l=mid+1; &#125; if(!jud(l))l++; if(l&lt;=n)printf("%d\n",l); else printf("-1\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>BCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My first blog]]></title>
    <url>%2F2019%2F03%2F09%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[啦啦啦，换到新的blog啦！ 原博客停用 标题一标题二标题三标题四标题五标题六 这是一段引用 123int mian()&#123;//这是一段代码 retrun 0;&#125; 这是一个链接 $\sum_{k|((1&lt;&lt;k)&amp;S==0)}^{} {f[i-1][S-(1&lt;]}$ 嗯嗯 诶诶诶 黑体 斜体 a 道路千万条 你是第一条 第一条 -.- -。- 第二条~ 第三条 233 322 &lt;addr&gt; 233 $$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$ $$ \sideset{^1_2}{^3_4}\bigotimes $$ $$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$ $$\sqrt{2} \quad and \quad \sqrt[n]{3}$$ $$\vec{a} \cdot \vec{b}=0$$ $$\overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}$$ $$ \lim_{n \to +\infty} \frac{1}{n(n+1)}$$ $$\sum_{i=1}^n \frac{1}{i^2} \quad and \quad \prod_{i=1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i=1}^{2} R$$ $\smash{\displaystyle\max_{0 \leq q \leq n-1}} f(q) \le n$ $f(x + \epsilon) \approx f(x) + f’(x) \epsilon + \mathcal{O}(\epsilon^2).$ $\text{d}x$ $\lim_{n \to +\infty}{1^n}=1$]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
