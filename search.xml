<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 10 题解]]></title>
    <url>%2F2019%2F06%2F02%2F2019springtraining-10%2F</url>
    <content type="text"><![CDATA[Solved A B C D E 3/5 . O . O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述解题思路AC代码点击 12 B 题目描述解题思路先把所有都看成连到主根上，然后对于每一个节点枚举应不应该把它扔到另一个节点上使得叶子数量减少即可。 AC代码点击 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 200005int n,k,mxnum[N]=&#123;1&#125;,f[N],now[N]=&#123;2&#125;;int main()&#123; int i,mx,j; scanf("%d%d%d",&amp;n,&amp;mx,&amp;k); for(i=1;i&lt;=mx;i++)scanf("%d",&amp;mxnum[i]),mxnum[i]+=mxnum[i-1],now[i]=mxnum[i-1]+2; if(n-mx&lt;k||mxnum[mx]-mxnum[mx-1]&gt;k)return printf("-1"),0; int left=n-mx-k; f[2]=1; for(i=1;i&lt;mx;i++)f[mxnum[i]+1]=mxnum[i-1]+1; for(i=1;i&lt;=mx;i++)&#123; for(j=mxnum[i-1]+2;j&lt;=mxnum[i];j++)&#123; if(left&amp;&amp;now[i-1]&lt;=mxnum[i-1])f[j]=now[i-1]++,left--; else f[j]=f[j-1]; &#125; &#125; if(left)return printf("-1"),0; printf("%d\n",n); for(i=2;i&lt;=n;i++)printf("%d %d\n",i,f[i]); return 0;&#125; C 题目描述解题思路AC代码点击 12 D 题目描述可以分裂的$Nim$ 解题思路爆搜一边$SG$发现有规律，直接解决即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int f(int x)&#123; if(x%4==1||x%4==2)return x; if(x%4==3)return x+1; return x-1;&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; int ans=0,a,n,i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a),ans^=f(a); printf("%s\n",ans?"Alice":"Bob"); &#125;&#125;/*#define N 1000int sg[N],vis[N];int main()&#123; int i,j; sg[0]=0;sg[1]=1; for(i=2;i&lt;N;i++)&#123; memset(vis,0,sizeof(vis)); for(j=0;j&lt;i;j++)vis[sg[j]]=vis[sg[j]^sg[i-j]]=1; for(j=0;j&lt;N;j++)if(!vis[j])break; sg[i]=j; &#125; for(i=0;i&lt;N;i++)printf("%d ",sg[i]); return 0;&#125;*/ E 题目描述解题思路广义后缀自动机，对每一个叶子爆搜即可。对于每一个等价类$p$，其对应的不同子串个数为$maxlen(p)-minlen(p)+1$，其中$maxlen(p)$为$len_p$，$minlen(p)$为$len_{fa_p}+1$。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 4000010#define P 11struct Edge&#123;int e,n;&#125;e[N&lt;&lt;1];int hd[N],cnt,deg[N];void add(int a,int b)&#123;e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;struct ExtendedSAM&#123; int len[N],fa[N],tr[N][P]; int siz; void init()&#123; int i; siz=1;len[0]=-1; for(i=0;i&lt;P;i++)tr[0][i]=1; &#125; int insert(int s,int p)&#123; int np=++siz; len[np]=len[p]+1; while(!tr[p][s])tr[p][s]=np,p=fa[p]; int q=tr[p][s]; if(len[p]+1==len[q])fa[np]=q; else&#123; int nq=++siz; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[np]=nq; memcpy(tr[nq],tr[q],sizeof(tr[q])); while(tr[p][s]==q)tr[p][s]=nq,p=fa[p]; &#125; return np; &#125;&#125;sam;int a[N],n,c;void dfs(int now,int f,int pos)&#123; int i,nxt=sam.insert(a[now],pos); for(i=hd[now];i;i=e[i].n)&#123; int q=e[i].e; if(q!=f)dfs(q,now,nxt); &#125;&#125;int main()&#123; int i,u,v; sam.init(); scanf("%d%d",&amp;n,&amp;c); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;n;i++) scanf("%d%d",&amp;u,&amp;v), add(u,v),add(v,u), deg[u]++,deg[v]++; for(i=1;i&lt;=n;i++)if(deg[i]==1)dfs(i,0,1); ll ans=0; for(i=2;i&lt;=sam.siz;i++)ans+=sam.len[i]-sam.len[sam.fa[i]]; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 9 题解]]></title>
    <url>%2F2019%2F06%2F01%2F2019springtraining-9%2F</url>
    <content type="text"><![CDATA[Solved A B C D E 5/5 O O Ø Ø O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述签到$1$ 解题思路一看数据范围直接爆搜，不过似乎也可以用反向推导直接得到。 AC代码点击 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1000020int vis[N],n,m;queue&lt;int&gt;Q;int main()&#123; int i; memset(vis,0x3f,sizeof(vis)); scanf("%d%d",&amp;n,&amp;m); Q.push(n);vis[n]=0; int flag=0; while(!Q.empty()&amp;&amp;!flag)&#123; int x=Q.front();Q.pop(); if(x*2&lt;N&amp;&amp;vis[x*2]&gt;1e9)Q.push(x*2),vis[x*2]=vis[x]+1; if(x-1&gt;0&amp;&amp;vis[x-1]&gt;1e9)Q.push(x-1),vis[x-1]=vis[x]+1; if(x==m)flag=1; &#125; printf("%d",vis[m]); return 0;&#125; B 题目描述签到$2$ 解题思路首先找到出现次数最多的字母，那么整个串都为这个字母是最优选择之一。 然后找到有多少个出现次数为最多次数的字母，假设有$cnt$个。出现次数相同代表在$T$串中任意取这些字母得到的串都是最优选择，于是每一个空位有$cnt$种选择，于是答案为$cnt^n$。 AC代码点击 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;char s[100005];int a[10];ll qp(int a,int p)&#123; ll ans=1,w=1000000007; for(;p;p&gt;&gt;=1,a=1LL*a*a%w)if(p&amp;1)ans=ans*a%w; return ans;&#125;int main()&#123; int i,n; scanf("%d%s",&amp;n,s); for(i=0;s[i];i++)&#123; if(s[i]=='A')a[0]++; if(s[i]=='T')a[1]++; if(s[i]=='G')a[2]++; if(s[i]=='C')a[3]++; &#125; int ans=0,cnt=0; for(i=0;i&lt;4;i++)ans=max(ans,a[i]); for(i=0;i&lt;4;i++)if(ans==a[i])cnt++; printf("%lld",qp(cnt,n)); return 0;&#125; C 题目描述在保证稳定的情况下交替拿取最大值和最小值。 解题思路一开始想用平衡树，后来才发现居然能用$set+map$（$C$党的悲哀.jpg） 注意每次找答案的时候自身也要判断就是了。（也就是说可能会从$set$中取出来） AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100005#define w 1000000009map&lt;pair&lt;int,int&gt;,int&gt;mp;set&lt;int&gt;s;int x[N],y[N];int exist(int x,int y)&#123;return mp.count(make_pair(x,y));&#125;int up(int x,int y)&#123;return exist(x-1,y-1)+exist(x,y-1)+exist(x+1,y-1)&lt;2;&#125;int jud(int p)&#123; if(exist(x[p]-1,y[p]+1))&amp;&amp;up(x[p]-1,y[p]+1))return 0; if(exist(x[p],y[p]+1))&amp;&amp;up(x[p],y[p]+1))return 0; if(exist(x[p]+1,y[p]+1))&amp;&amp;up(x[p]+1,y[p]+1))return 0; return 1;&#125;void ins(int p)&#123; int temp; if(exist(x[p]-1,y[p]-1)&amp;&amp;jud(temp=mp[make_pair(x[p]-1,y[p]-1)]))s.insert(temp); if(exist(x[p],y[p]-1)&amp;&amp;jud(temp=mp[make_pair(x[p],y[p]-1)]))s.insert(temp); if(exist(x[p]+1,y[p]-1))&amp;&amp;jud(temp=mp[make_pair(x[p]+1,y[p]-1)]))s.insert(temp);&#125;int main()&#123; int i,n; ll ans=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;x[i],&amp;y[i]); mp[make_pair(x[i],y[i])]=i; &#125; for(i=0;i&lt;n;i++)if(jud(i))s.insert(i); for(i=0;i&lt;n;i++)&#123; while(!s.empty())&#123; int now=(i&amp;1)?(*s.begin()):(*s.rbegin()); if(jud(now))&#123; ans=(ans*n+now)%w; s.erase(now); mp.erase(make_pair(x[now],y[now])); ins(now); break; &#125; s.erase(now); &#125; &#125; printf("%I64d",ans); return 0;&#125; D 题目描述给一个大整数串$a_i$，求在里面加$k$个加号的所有计算结果之和。 解题思路推出式子预处理。 假设每一位对答案的贡献为$ans_i$，则答案为$\sum_{i=0}^{n-1}ans_i$。 考虑计算从头开始的第$i$位对答案的贡献。 这一位数字可以放在个位、十位、百位……一直到串的末端。考虑分两类讨论： 直接延伸到串的末端，贡献为$a_i\times 10^{n-1-i}\times C_i^k$（在前$i$个空里面选择$k$个加号） 不延伸到末端，设$i$到加号右端数字的长度为$len$，则贡献为$a_i\times 10^{len-1}\times C_{n-len-1}^{k-1}$（本来有$n-1$个空，这一段都不能放置加号，一段结束放置了一个加号，故还剩$n-1-(len-1)-1=n-len-1$个空，放置$k$个加号） 故$ans_i=\sum_{len=1}^{n-1-i}a_i\times 10^{len-1}\times C_{n-len-1}^{k-1}+a_i\times 10^{n-1-i}\times C_i^k$ 发现可以预处理出来这一个求和号，线性解决。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010int n,k;char a[N];ll p[N]=&#123;1&#125;,w=1000000007,fac[N]=&#123;1&#125;,inv[N]=&#123;1&#125;,s[N];ll qp(ll x,int p)&#123; ll ans=1; for(;p;p&gt;&gt;=1,x=x*x%w)if(p&amp;1)ans=ans*x%w; return ans;&#125;ll c(int n,int m)&#123; if(m&lt;0||m&gt;n)return 0; return fac[n]*inv[m]%w*inv[n-m]%w;&#125;int main()&#123; int i; scanf("%d%d",&amp;n,&amp;k); scanf("%s",a); for(i=1;i&lt;=n;i++)&#123; p[i]=p[i-1]*10%w; fac[i]=fac[i-1]*i%w; inv[i]=qp(fac[i],w-2); &#125; for(i=1;i&lt;=n;i++)s[i]=(s[i-1]+c(n-i-1,k-1)*p[i-1])%w; ll ans=0; for(i=0;i&lt;n;i++)ans=(ans+(a[i]-'0')*(s[n-1-i]+p[n-i-1]*c(i,k)))%w; printf("%lld\n",ans); return 0;&#125; E 题目描述给一个数组$a_i$，有三种操作：$a_i$变成给定数，$a_i$加上给定数，$a_i$乘上给定数。所有有关量均为正整数。 按顺序至多采取其中$m$个操作， 问最终结果（$\prod_{i=1}^na_i$）最大时的操作顺序。 解题思路贪心。 显然可证，乘法放到最后是最优的，操作一对于每一个数只能最多进行一次（且变到最大），且放到最前面是最优的。 于是先处理操作一，对于每一个数存储一下最大的改变量，于是转化成了操作二。 现在仅处理操作二的先后顺序。设在某一个时刻，操作二$a_i$优于$a_j$，假设操作$i$对应的数组下标是$pos_i$，改变量为$delta_i$（加或乘），当前数组（不是初始数组！）为$x_i$，则需要满足$\prod_{p=1}^k x_p\times \frac{x_{pos_i}+delta_i}{x_{pos_i}}&gt;\prod_{p=1}^k x_p\times \frac{x_{pos_j}+delta_j}{x_{pos_j}}$，即$\frac{delta_i}{x_{pos_i}}&gt;\frac{delta_j}{x_{pos_j}}$。 现在考虑操作二和操作三的处理顺序。假设某一个操作二$a_i$优于操作三$a_j$，有$\prod_{p=1}^k x_p\times \frac{x_{pos_i}+delta_i}{x_{pos_i}}&gt;\prod_{p=1}^k x_p\times delta_j$，即$\frac{delta_i}{x_{pos_i}}&gt;delta_j-1$。 于是对于每一个操作，记录一下$x,d$。在这里，我们对于每一个操作二以及转化过来的操作一，$x$为$x_{pos_i}$，$d$为$delta_i$，对于每一个操作三，$x$为$1$，$d$为$delta_j-1$，便可以进行排序。 排完序得到的结果中，前$ans$个中，所有的操作一与操作三必然被执行，但操作二的$x$会被操作一改变（注意上面的黑字说明的，$x$是执行这一个操作的时候的当前数组），故需要对所有的操作二进行修改。再次排序，则后面的操作一和操作三可能会上来顶替某些操作二，而这些上来的操作一又对与之对应的操作二产生了影响。重复这个过程，很快就可以到达平衡，得到答案。 非常神秘，比赛的时候我$A$掉了这个题，但是$CF$上却没有这个记录，而且再拿这个代码提交的时候会$WA$掉第$149$个点。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define N 1000005struct Add&#123; int x,d,i; int sign,pos; bool operator&lt;(const Add&amp;p)const&#123;return 1LL*d*p.x&gt;1LL*p.d*x;&#125;&#125;a[N];int cnt,d[N],x[N],p[N];int main()&#123; int i,k,n,m; scanf("%d%d%d",&amp;k,&amp;n,&amp;m); for(i=1;i&lt;=k;i++)scanf("%d",&amp;x[i]); for(i=1;i&lt;=n;i++)&#123; int opt,pos,ch; scanf("%d%d%d",&amp;opt,&amp;pos,&amp;ch); if(opt==1)&#123;if(d[pos]&lt;ch-x[pos])d[pos]=ch-x[pos],p[pos]=i;&#125; else if(opt==2)a[cnt++]=(Add)&#123;x[pos],ch,i,2,pos&#125;; else a[cnt++]=(Add)&#123;1,ch-1,i,3,pos&#125;; &#125; for(i=1;i&lt;=k;i++)if(d[i])a[cnt++]=(Add)&#123;x[i],d[i],p[i],1,i&#125;; std::sort(a,a+cnt); int ans=std::min(cnt,m); printf("%d\n",ans); int flag=1; while(flag)&#123; flag=0; for(i=0;i&lt;ans;i++)if(a[i].sign==1) x[a[i].pos]+=a[i].d,a[i].sign=0,flag=1; for(i=0;i&lt;cnt;i++)if(a[i].sign==2&amp;&amp;a[i].x!=x[a[i].pos]) a[i].x=x[a[i].pos]; std::sort(a,a+cnt); &#125; for(i=0;i&lt;ans;i++)if(a[i].sign&lt;2)printf("%d ",a[i].i); for(i=0;i&lt;ans;i++)if(a[i].sign==2)printf("%d ",a[i].i); for(i=0;i&lt;ans;i++)if(a[i].sign==3)printf("%d ",a[i].i); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 8 题解]]></title>
    <url>%2F2019%2F05%2F29%2F2019springtraining-8%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F 4/6 Ø . . Ø Ø Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给定一堆长度，任选三个问构成三角形的概率。 解题思路建桶，求自身卷积，得到的便是每一个长度由原数组组合出来的方案数。去除自身选择自身、两个相互选择后得到不重复的方案数。 对初始数组排序，从小到大取，每次取该边为最长边，即需要满足剩下两个边都在$i$之前出现且其和大于$a_i$。于是先求和再去重（两个都在$i$后面，一个在前一个在后，一个是$i$另一个任取）即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;typedef long long ll;struct complex&#123; double x,y; complex(double xx=0,double yy=0)&#123;x=xx;y=yy;&#125; complex operator+(const complex a)const&#123;return &#123;x+a.x,y+a.y&#125;;&#125; complex operator-(const complex a)const&#123;return &#123;x-a.x,y-a.y&#125;;&#125; complex operator*(const complex a)const&#123;return &#123;x*a.x-y*a.y,x*a.y+y*a.x&#125;;&#125;&#125;;#define N 463010complex a[N],wn1,wnk,t;int m,n,mx,limit;int r[N];void fft(complex *F,int sign)&#123; int i,j,len; for(i=0;i&lt;limit;i++) if(i&lt;r[i])std::swap(F[r[i]],F[i]); for(len=1;len&lt;limit;len&lt;&lt;=1)&#123; wn1=complex(cos(acos(-1)/len),sign*sin(acos(-1)/len)); for(j=0;j&lt;limit;j+=(len&lt;&lt;1))&#123; wnk=complex(1,0); for(i=j;i&lt;j+len;i++)&#123; t=F[i+len]*wnk; F[i+len]=F[i]-t; F[i]=F[i]+t; wnk=wnk*wn1; &#125; &#125; &#125; if(sign==-1)for(i=0;i&lt;limit;i++)F[i].x/=limit;&#125;ll b[N],s[N],p[N];int main()&#123; int i,n,T,x; scanf("%d",&amp;T); while(T--)&#123; int mx=0; scanf("%d",&amp;n); memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x),b[x]++; p[i]=x;if(x&gt;mx)mx=x; &#125; mx&lt;&lt;=1;limit=1; while(limit&lt;=mx)limit&lt;&lt;=1; for(i=0;i&lt;=limit;i++)a[i].x=b[i]; for(i=0;i&lt;=limit;i++)r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?limit&gt;&gt;1:0); fft(a,1); for(i=0;i&lt;=limit;i++)a[i]=a[i]*a[i]; fft(a,-1); for(i=0;i&lt;=limit;i++)s[i]=round(a[i].x); s[0]=0; for(i=0;i&lt;n;i++)s[p[i]&lt;&lt;1]--; for(i=0;i&lt;=limit;i++)s[i]&gt;&gt;=1; for(i=1;i&lt;=limit;i++)s[i]+=s[i-1]; ll ans=0; std::sort(p,p+n); for(i=0;i&lt;n;i++)&#123; ans+=s[limit]-s[p[i]]; ans-=1LL*i*(n-i-1); ans-=n-1; ans-=1LL*(n-i-1)*(n-i-2)/2; &#125; printf("%.7f\n",ans*1.0/(1LL*n*(n-1)*(n-2)/6)); &#125; return 0;&#125; B 题目描述解题思路AC代码点击 12 C 题目描述解题思路AC代码点击 12 D 题目描述$x_k=b\times c^{2k}+d $$F(x)=a_0x_0+a_1x_1+a_2 x_2+…+a_{n-1 }x_{n-1} $ 给定$n,a_n,b,c,d$，求序列$F(x_i)$。 解题思路神仙题$orzzzzzzz$ $FFT$——从入门到放弃.jpg 整整连学带调写了一天半，终于过了真开心！ 式子明天再写orz 来说几个坑点吧：拆系数的时候注意正负号，注意零的特判，$c$的$i^2$次幂求的时候用$qp(c,i^2\%(mod-1))$，以及这题卡空间…… MLE代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 524290#define M Nstruct comp&#123; double x,y; comp():x(0),y(0)&#123;&#125; comp(const double &amp;_x,const double &amp;_y):x(_x),y(_y)&#123;&#125;&#125;;comp operator+(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x+b.x,a.y+b.y);&#125;comp operator-(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x-b.x,a.y-b.y);&#125;comp operator*(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;comp conj(const comp &amp;a)&#123;return comp(a.x,-a.y);&#125;double PI=acos(-1);comp w[M];int rev[M];int A[M],B[M],C[M],lim,mx,mod=1000003;void fft(comp *a,int n)&#123; int i,j,k,lyc; for(i=0;i&lt;n;i++)if(i&lt;rev[i])swap(a[i],a[rev[i]]); for(i=2,lyc=n&gt;&gt;1;i&lt;=n;i&lt;&lt;=1,lyc&gt;&gt;=1) for(j=0;j&lt;n;j+=i)&#123; comp *l=a+j,*r=a+j+(i&gt;&gt;1),*p=w; for(k=0;k&lt;(i&gt;&gt;1);k++)&#123; comp tmp=*r**p; *r=*l-tmp,*l=*l+tmp; ++l,++r,p+=lyc; &#125; &#125;&#125;void fft_prepare()&#123; int i; for(i=0;i&lt;lim;i++)rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(mx-1)); for(i=0;i&lt;lim;i++)w[i]=comp(cos(2*PI*i/lim),sin(2*PI*i/lim));&#125;comp a[M+5],b[M+5],dfta[M+5],dftb[M+5],dftc[M+5],dftd[M+5];void conv(int *x,int *y,int *z)&#123; int i,j; for(i=0;i&lt;lim;i++)(x[i]+=mod)%=mod,(y[i]+=mod)%=mod; for(i=0;i&lt;lim;i++)&#123; a[i]=comp(x[i]&amp;32767,x[i]&gt;&gt;15); b[i]=comp(y[i]&amp;32767,y[i]&gt;&gt;15); &#125; fft(a,lim);fft(b,lim); for(i=0;i&lt;lim;i++)&#123; j=(lim-i)%lim;//0的特判 comp da,db,dc,dd; da=(a[i]+conj(a[j]))*comp(0.5,0); db=(a[i]-conj(a[j]))*comp(0,-0.5); dc=(b[i]+conj(b[j]))*comp(0.5,0); dd=(b[i]-conj(b[j]))*comp(0,-0.5); dfta[j]=da*dc; dftb[j]=da*dd; dftc[j]=db*dc; dftd[j]=db*dd; &#125; for(i=0;i&lt;lim;i++)&#123; a[i]=dfta[i]+dftb[i]*comp(0,1); b[i]=dftc[i]+dftd[i]*comp(0,1); &#125; fft(a,lim);fft(b,lim); for(i=0;i&lt;lim;i++)&#123; ll da,db,dc,dd; da=(ll)(a[i].x/lim+0.5)%mod; db=(ll)(a[i].y/lim+0.5)%mod; dc=(ll)(b[i].x/lim+0.5)%mod; dd=(ll)(b[i].y/lim+0.5)%mod; z[i]=(da+((db+dc)&lt;&lt;15)+(dd&lt;&lt;30))%mod; &#125;&#125;int arr[N],fac[N]=&#123;1&#125;,inv[N]=&#123;1&#125;,bpow[N]=&#123;1&#125;,dpow[N]=&#123;1&#125;;int qp(int x,int p)&#123; int ans=1; for(;p;p&gt;&gt;=1,x=(ll)x*x%mod)if(p&amp;1)ans=(ll)ans*x%mod; return ans;&#125;int Ai[N],Bi[N],P[N],p[N],ans[N],m[N],cpow[N]=&#123;1&#125;;int main()&#123; int i,n,b,c,d; scanf("%d%d%d%d",&amp;n,&amp;b,&amp;c,&amp;d); while((1&lt;&lt;mx)&lt;4*n)mx++; lim=1&lt;&lt;mx; fft_prepare(); for(i=1;i&lt;n;i++)fac[i]=(ll)fac[i-1]*i%mod,inv[i]=qp(fac[i],mod-2); for(i=1;i&lt;n;i++)dpow[i]=(ll)dpow[i-1]*d%mod,bpow[i]=(ll)bpow[i-1]*b%mod,cpow[i]=qp(c,(ll)i*i%(mod-1)); for(i=0;i&lt;n;i++)scanf("%d",&amp;arr[i]); for(i=0;i&lt;=n;i++)Ai[i]=(ll)arr[n-i]*fac[n-i]%mod,Bi[i]=(ll)dpow[i]*inv[i]%mod; conv(Ai,Bi,P); for(i=0;i&lt;n;i++)p[i]=(ll)P[n-i]*bpow[i]%mod*inv[i]%mod*cpow[i]%mod; for(i=0;i&lt;n+n;i++)m[i]=qp(i-n&gt;=0?cpow[i-n]:cpow[n-i],mod-2); conv(m,p,ans); for(i=0;i&lt;n;i++)&#123; ans[i+n]=(ll)ans[i+n]*cpow[i]%mod; printf("%d\n",(ans[i+n]+mod)%mod); &#125; return 0;&#125; 疯狂删减数组，勉强卡过$65536kb$内存限制。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 524290#define M Nstruct comp&#123; double x,y; comp():x(0),y(0)&#123;&#125; comp(const double &amp;_x,const double &amp;_y):x(_x),y(_y)&#123;&#125;&#125;;comp operator+(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x+b.x,a.y+b.y);&#125;comp operator-(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x-b.x,a.y-b.y);&#125;comp operator*(const comp &amp;a,const comp &amp;b)&#123;return comp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);&#125;comp conj(const comp &amp;a)&#123;return comp(a.x,-a.y);&#125;double PI=acos(-1);comp w[M];int rev[M];int lim,mx,mod=1000003;void fft(comp *a,int n)&#123; int i,j,k,lyc; for(i=0;i&lt;n;i++)if(i&lt;rev[i])swap(a[i],a[rev[i]]); for(i=2,lyc=n&gt;&gt;1;i&lt;=n;i&lt;&lt;=1,lyc&gt;&gt;=1) for(j=0;j&lt;n;j+=i)&#123; comp *l=a+j,*r=a+j+(i&gt;&gt;1),*p=w; for(k=0;k&lt;(i&gt;&gt;1);k++)&#123; comp tmp=*r**p; *r=*l-tmp,*l=*l+tmp; ++l,++r,p+=lyc; &#125; &#125;&#125;void fft_prepare()&#123; int i; for(i=0;i&lt;lim;i++)rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|((i&amp;1)&lt;&lt;(mx-1)); for(i=0;i&lt;lim;i++)w[i]=comp(cos(2*PI*i/lim),sin(2*PI*i/lim));&#125;comp a[M],b[M],ta[M],tb[M];void conv(int *x,int *y,int *z)&#123; int i,j; for(i=0;i&lt;lim;i++)(x[i]+=mod)%=mod,(y[i]+=mod)%=mod; for(i=0;i&lt;lim;i++)&#123; ta[i]=comp(x[i]&amp;32767,x[i]&gt;&gt;15); tb[i]=comp(y[i]&amp;32767,y[i]&gt;&gt;15); &#125; fft(ta,lim);fft(tb,lim); for(i=0;i&lt;lim;i++)&#123; j=(lim-i)%lim;//0的特判 comp da,db,dc,dd; da=(ta[i]+conj(ta[j]))*comp(0.5,0); db=(ta[i]-conj(ta[j]))*comp(0,-0.5); dc=(tb[i]+conj(tb[j]))*comp(0.5,0); dd=(tb[i]-conj(tb[j]))*comp(0,-0.5); a[j]=da*dc+da*dd*comp(0,1); b[j]=db*dc+db*dd*comp(0,1); &#125; fft(a,lim);fft(b,lim); for(i=0;i&lt;lim;i++)&#123; ll da,db,dc,dd; da=(ll)(a[i].x/lim+0.5)%mod; db=(ll)(a[i].y/lim+0.5)%mod; dc=(ll)(b[i].x/lim+0.5)%mod; dd=(ll)(b[i].y/lim+0.5)%mod; z[i]=(da+((db+dc)&lt;&lt;15)+(dd&lt;&lt;30))%mod; &#125;&#125;int arr[N],fac[N]=&#123;1&#125;,inv[N]=&#123;1&#125;;int qp(int x,int p)&#123; int ans=1; for(;p;p&gt;&gt;=1,x=(ll)x*x%mod)if(p&amp;1)ans=(ll)ans*x%mod; return ans;&#125;int Ai[N],Bi[N],P[N],cpow[N]=&#123;1&#125;;int main()&#123; int i,n,b,c,d; scanf("%d%d%d%d",&amp;n,&amp;b,&amp;c,&amp;d); while((1&lt;&lt;mx)&lt;4*n)mx++; lim=1&lt;&lt;mx; fft_prepare(); for(i=1;i&lt;n;i++)fac[i]=(ll)fac[i-1]*i%mod,inv[i]=qp(fac[i],mod-2); for(i=1;i&lt;n;i++)cpow[i]=qp(c,(ll)i*i%(mod-1)); for(i=0;i&lt;n;i++)scanf("%d",&amp;arr[i]); for(i=0;i&lt;=n;i++)Ai[i]=(ll)arr[n-i]*fac[n-i]%mod,Bi[i]=(ll)qp(d,i)*inv[i]%mod; conv(Ai,Bi,P); Ai[n]=0; for(i=0;i&lt;n;i++)Ai[i]=(ll)P[n-i]*qp(b,i)%mod*inv[i]%mod*cpow[i]%mod; for(i=0;i&lt;n+n;i++)Bi[i]=qp(i-n&gt;=0?cpow[i-n]:cpow[n-i],mod-2); conv(Ai,Bi,P); for(i=0;i&lt;n;i++)&#123; P[i+n]=(ll)P[i+n]*cpow[i]%mod; printf("%d\n",(P[i+n]+mod)%mod); &#125; return 0;&#125; E 题目描述给定一个$n\times m(1\leq m\leq 20,1\leq n\leq 100000)$的$01$矩阵，每次可以反转任意一列一行，求最终$1$的最少个数。 解题思路看到$m$范围极小，考虑枚举每一行的翻转状态$S$。 由于每一行反转后，后面的所有行答案便已经确定，考虑求出$ans[S]$。 那么可以设$a[i]$为$i$这个状态出现的次数，$b[i]$为$i$这个状态中对应的$1$的个数和$0$的个数中的较小值，则$ans[s]=\sum_{j\oplus k=s}a[j]\times b[k]$，用$FWT$板子即可求出。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define N (1&lt;&lt;20)+10typedef long long ll;ll a[N],b[N],c[N];void fwtxor(int f,int l,ll a[])&#123; int i,j,k;ll t; if(f==-1)f=2; for(i=1;i*2&lt;=l;i&lt;&lt;=1) for(j=0;j&lt;l;j+=i*2) for(k=0;k&lt;i;k++) t=a[j+k], a[j+k]=(t+a[j+k+i])/f, a[j+k+i]=(t-a[j+k+i])/f;&#125;char ch[22][100010];int main()&#123; int i,j,n,m; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)scanf("%s",ch[i]); for(j=0;j&lt;m;j++)&#123; int now=0; for(i=0;i&lt;n;i++)now=(now&lt;&lt;1)+ch[i][j]-'0'; a[now]++; &#125; for(i=1;i&lt;1&lt;&lt;n;i++)b[i]=b[i/2]+(i&amp;1); for(i=0;i&lt;1&lt;&lt;n;i++)b[i]=std::min(b[i],n-b[i]); ll ans=n*m; n=1&lt;&lt;n; fwtxor(1,n,a);fwtxor(1,n,b); for(i=0;i&lt;n;i++)c[i]=a[i]*b[i]; fwtxor(-1,n,c); for(i=0;i&lt;n;i++)ans=std::min(ans,c[i]); printf("%I64d",ans); return 0;&#125; F 题目描述给定一个集合$S$，求出使得$(s_a|s_b)\&amp;(s_c)\&amp;(s_d\oplus s_e)==2^p,s_a\&amp;s_b==0$的$fib(s_a|s_b)\times fib(s_c)\times fib(s_d\oplus s_e)$的和，其中$s_a,s_b,s_c,s_d,s_e$均为$S$的子集。$s_i&lt;2^{17}$。 解题思路非常有意思的$FMT+FWT$练习题。先求出每个数出现的次数$s_i$，求出$s_a,s_b$的子集卷积，$s_d,s_e$的对称差（异或）卷积，分别乘上$fib$再进行（或）变换，乘起来再做逆运算即可。 既然是写博，就要自己在复习一遍，故下面是对$FMT$和子集卷积的理解。 首先是$FMT$。 定义$H_S=\sum_{L\subseteq S}\sum_{R\subseteq S}f_L\times g_R(L\bigcup R\subseteq S)$（①），我们要求出这个卷积$H$。定义莫比乌斯变换为$f_S^{‘}=\sum_{T\subseteq S}f_T$。对于①式，左右两端取莫比乌斯变换：$H_S^{‘}=\sum_{L\subseteq S}\sum_{R\subseteq S}f_L\times g_R$故可以进行变换，卷积运算。变换过程：设 $f_S^{‘}(i)=\sum_{T\subseteq S}f_T((S-T)\subseteq(1,2,…,i))$那么，对于任意不包含${i}$的集合$S$，有$f_S^{‘}(i)=f_S^{‘}(i-1)$，$f_{S\bigcup {i}}^{‘}(i)=f_{S\bigcup {i}}^{‘}(i-1)+f_S^{‘}(i-1)$，这样就可以$O(n\times 2^n)$解决了。反演同理。 对于子集卷积： 定义$H_S=\sum_{L\subseteq S}f_L\times g_{S-L}$，我们现在要求出这个卷积$H$。因为需要满足交集为空，所以增设一维表示集合大小。设$f_{i,S}$为集合中有$i$个元素、集合表示为$S$的值，那么求卷积的时候$h_{i,S}=\sum_{j=0}^i f_{j,S}\times g_{i-j,S}$（从$f$中选出$j$个元素，从$g$中选出$i-j$个元素，只有他们互不相交的情况下才能够保证$h_{i,S}$合理）。（非常玄学，怎么想出来的）那么最后的结果就是$h_{cnt_i,i}$这个数组了。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 18#define M (1&lt;&lt;17)#define P M+10ll a[P],b[P],w=1000000007,subset[P],fib[P]=&#123;0,1&#125;;ll Xor[P];ll div(int x,ll p)&#123; if(x==1)return p; if(p&amp;1)return (p+w)/2%w; else return p/2;&#125;void fwtand(ll a[],int l,int f)&#123; int i,j,k; for(i=1;i*2&lt;=l;i&lt;&lt;=1) for(j=0;j&lt;l;j+=i*2) for(k=0;k&lt;i;k++) (a[j+k]+=a[j+k+i]*f)%=w;&#125;void fwtxor(ll a[],int l,int f)&#123; int i,j,k;ll t; if(f==-1)f=2; for(i=1;i*2&lt;=l;i&lt;&lt;=1) for(j=0;j&lt;l;j+=i*2) for(k=0;k&lt;i;k++) t=a[j+k], (a[j+k]=div(f,t+a[j+k+i]))%=w, (a[j+k+i]=div(f,t-a[j+k+i]))%=w;&#125;void fmt(ll a[],int n,int f)&#123; int i,j; for(i=0;i&lt;n;i++)for(j=0;j&lt;1&lt;&lt;n;j++)if(j&amp;(1&lt;&lt;i))a[j]=(a[j]+f*a[j^(1&lt;&lt;i)])%w;&#125;ll f[20][P],cnt[P];void subsetconvolution(int n,ll a[],ll c[])&#123; int i,j,k; for(i=0;i&lt;1&lt;&lt;n;i++)cnt[i]=cnt[i&gt;&gt;1]+(i&amp;1); for(i=0;i&lt;1&lt;&lt;n;i++)f[cnt[i]][i]=a[i]; for(i=0;i&lt;=n;i++)fmt(f[i],n,1); for(i=n;i&gt;=0;i--)&#123; for(j=0;j&lt;1&lt;&lt;n;j++)&#123; ll x=0; for(k=0;k&lt;=i;k++)(x+=f[k][j]*f[i-k][j])%=w; f[i][j]=x; &#125; &#125; for(i=0;i&lt;=n;i++)fmt(f[i],n,-1); for(i=0;i&lt;1&lt;&lt;n;i++)c[i]=f[cnt[i]][i];&#125;int main()&#123; int i,n,x; for(i=2;i&lt;=M;i++)fib[i]=(fib[i-1]+fib[i-2])%w; scanf("%d",&amp;n); for(i=0;i&lt;n;i++) scanf("%d",&amp;x),b[x]++,a[x]++; subsetconvolution(17,a,subset); fwtxor(a,M,1); for(i=0;i&lt;M;i++)Xor[i]=a[i]*a[i]%w; fwtxor(Xor,M,-1); for(i=0;i&lt;M;i++)&#123; subset[i]=subset[i]*fib[i]%w; b[i]=b[i]*fib[i]%w; Xor[i]=Xor[i]*fib[i]%w; &#125; fwtand(subset,M,1); fwtand(b,M,1); fwtand(Xor,M,1); for(i=0;i&lt;M;i++)b[i]=b[i]*subset[i]%w*Xor[i]%w; fwtand(b,M,-1); ll ans=0; for(i=1;i&lt;M;i&lt;&lt;=1) ans=(ans+b[i])%w; printf("%I64d",(ans+w)%w); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 7 题解]]></title>
    <url>%2F2019%2F05%2F27%2F2019springtraining-7%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G 7/7 O O Ø O O Ø Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给一个无向图，其中每个边和点都分别有正的边权和点权，定义一个子图的价值为所有边的权值之和减去所有点的权值之和，要求所有边的两个顶点都在该子图中。求这个无向图最大的子图价值。 解题思路最大权闭合子图。 构图：（设边对应点为$w$，点对应点为$u,v$） $S\rightarrow w\rightarrow u,v\rightarrow T$ 边权$w_i,inf,a_u(a_v)$ 求最小割，割完后与$S$相连的就是答案对应的子图。答案即为所有边的权值减去最小割。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 8020struct Edge&#123; ll l; int e,n;&#125;e[N&lt;&lt;1];int hd[N],cur[N],cnt=1;void add(int a,int b,ll l)&#123; e[++cnt].e=b;e[cnt].l=l;e[cnt].n=hd[a];hd[a]=cnt; e[++cnt].e=a;e[cnt].l=0;e[cnt].n=hd[b];hd[b]=cnt;&#125;ll inf=1e15;int n,m,s,t;ll a[N];int dep[N];queue&lt;int&gt;Q;ll dfs(int p,ll flow)&#123; if(p==t)return flow; int i; for(i=cur[p];i;i=e[i].n)&#123; int q=e[i].e; cur[p]=i; if(dep[q]==1+dep[p]&amp;&amp;e[i].l)&#123; ll ans=dfs(q,min(flow,e[i].l)); if(ans)&#123; e[i].l-=ans; e[i^1].l+=ans; return ans; &#125; &#125; &#125; return 0;&#125;int bfs()&#123; memset(dep,0,sizeof(dep)); Q.push(s);dep[s]=1; int i; while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(!dep[q]&amp;&amp;e[i].l)dep[q]=dep[p]+1,Q.push(q); &#125; &#125; return dep[t];&#125;ll dinic()&#123; int i; ll d,ans=0; while(bfs())&#123; for(i=0;i&lt;=t;i++)cur[i]=hd[i]; while((d=dfs(s,inf)))ans+=d; &#125; return ans;&#125;int main()&#123; int i,u,v; ll w,sum=0; scanf("%d%d",&amp;n,&amp;m); s=0;t=n+m+1; for(i=1;i&lt;=n;i++)scanf("%I64d",&amp;a[i]),add(i+m,t,a[i]); for(i=1;i&lt;=m;i++)&#123; scanf("%d%d%I64d",&amp;u,&amp;v,&amp;w); add(s,i,w); add(i,u+m,inf); add(i,v+m,inf); sum+=w; &#125; printf("%I64d",sum-dinic()); return 0;&#125; B 题目描述有一个带障碍的地图，有$male $个男性$scayger$，$female$个女性$scayger$，一个$other$性别$scaygerboss$，分别有其初始坐标和走一个格子需要花费的时间。定义一个$scayger$高兴当且仅当它和与它不同性别的另一个$scayger$占有一个格子，且这个格子只有他们两个。问最少要多长时间所有的$scayger$都高兴。 解题思路先暴力判断$boss$充当的性别，然后二分答案、$bfs$建边即可。 构图：（流量均为$1$） $S\rightarrow male\rightarrow male在t内能去的地方\rightarrow 这个格子的拆点\rightarrow 能在t内去这个格子的female\rightarrow T$ AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 25struct Edge&#123; ll l; int e,n;&#125;e[N*N*N*N*N];int hd[N*N*5],cur[N*N*5],cnt=1;void add(int a,int b,ll l)&#123; e[++cnt].e=b;e[cnt].l=l;e[cnt].n=hd[a];hd[a]=cnt; e[++cnt].e=a;e[cnt].l=0;e[cnt].n=hd[b];hd[b]=cnt;&#125;ll inf=1e15;int n,m,s,t;int dep[N*N*5];queue&lt;int&gt;Q;ll dfs(int p,ll flow)&#123; if(p==t)return flow; int i; for(i=cur[p];i;i=e[i].n)&#123; int q=e[i].e; cur[p]=i; if(dep[q]&gt;dep[p]&amp;&amp;e[i].l)&#123; ll ans=dfs(q,min(flow,e[i].l)); if(ans)&#123; e[i].l-=ans; e[i^1].l+=ans; return ans; &#125; &#125; &#125; return 0;&#125;int bfs()&#123; memset(dep,0,sizeof(dep)); Q.push(s);dep[s]=1; int i; while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(!dep[q]&amp;&amp;e[i].l)dep[q]=dep[p]+1,Q.push(q); &#125; &#125; return dep[t];&#125;ll dinic()&#123; int i; ll d,ans=0; while(bfs())&#123; for(i=0;i&lt;=t;i++)cur[i]=hd[i]; while((d=dfs(s,inf)))ans+=d; &#125; return ans;&#125;char a[N][N];int sign[N][N];struct Per&#123; int x,y; ll v;&#125;boy[N*N],gir[N*N];int boyn,girn;struct QUEUE&#123; int x,y; ll time;&#125;;int vis[N][N];int num;//'.'int in(int flag,int NUM,int x,int y)&#123; if(x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;x&lt;n&amp;&amp;y&lt;m&amp;&amp;!vis[x][y]&amp;&amp;a[x][y]=='.')&#123; vis[x][y]=1; if(flag)add(NUM,sign[x][y]+boyn+girn,1);//male else add(sign[x][y]+boyn+girn+num,NUM,1);//female return 1; &#125; return 0;&#125;int jud(ll tim)&#123; int i,j; int now=0; memset(hd,0,sizeof(hd));cnt=1; for(i=0;i&lt;n;i++)for(j=0;j&lt;m;j++)if(a[i][j]=='.')&#123; sign[i][j]=++now; add(boyn+girn+now,boyn+girn+num+now,1); &#125; for(i=0;i&lt;boyn;i++)add(s,i+1,1); for(i=0;i&lt;girn;i++)add(i+1+boyn,t,1); for(i=0;i&lt;boyn;i++)&#123;//bfs int p=i+1; memset(vis,0,sizeof(vis)); queue&lt;QUEUE&gt;Q; while(!Q.empty())Q.pop(); in(1,p,boy[i].x-1,boy[i].y-1); Q.push(&#123;boy[i].x-1,boy[i].y-1,0&#125;); while(!Q.empty())&#123; int x=Q.front().x,y=Q.front().y;ll t=Q.front().time;Q.pop(); if(t+boy[i].v&gt;tim)break; if(in(1,p,x+1,y))Q.push(&#123;x+1,y,t+boy[i].v&#125;); if(in(1,p,x-1,y))Q.push(&#123;x-1,y,t+boy[i].v&#125;); if(in(1,p,x,y+1))Q.push(&#123;x,y+1,t+boy[i].v&#125;); if(in(1,p,x,y-1))Q.push(&#123;x,y-1,t+boy[i].v&#125;); &#125; &#125; for(i=0;i&lt;girn;i++)&#123;//bfs int p=i+1+boyn; memset(vis,0,sizeof(vis)); queue&lt;QUEUE&gt;Q; while(!Q.empty())Q.pop(); in(0,p,gir[i].x-1,gir[i].y-1); Q.push(&#123;gir[i].x-1,gir[i].y-1,0&#125;); while(!Q.empty())&#123; int x=Q.front().x,y=Q.front().y;ll t=Q.front().time;Q.pop(); if(t+gir[i].v&gt;tim)break; if(in(0,p,x+1,y))Q.push(&#123;x+1,y,t+gir[i].v&#125;); if(in(0,p,x-1,y))Q.push(&#123;x-1,y,t+gir[i].v&#125;); if(in(0,p,x,y+1))Q.push(&#123;x,y+1,t+gir[i].v&#125;); if(in(0,p,x,y-1))Q.push(&#123;x,y-1,t+gir[i].v&#125;); &#125; &#125; return dinic()==(boyn+girn)/2;&#125;int main()&#123; int i,j,girnum=0,boynum=0; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;boyn,&amp;girn); for(i=0;i&lt;n;i++)&#123; scanf("%s",a[i]); for(j=0;j&lt;m;j++)if(a[i][j]=='.')num++; &#125; if(num&lt;(boyn+girn+1)/2||(boyn-girn!=1&amp;&amp;girn-boyn!=1))return printf("-1"),0; ll l=0,r=490e9,ans=1e18; if(boyn-girn==1)scanf("%d%d%I64d",&amp;gir[girnum].x,&amp;gir[girnum].y,&amp;gir[girnum].v),girnum++,girn++; else scanf("%d%d%I64d",&amp;boy[boynum].x,&amp;boy[boynum].y,&amp;boy[boynum].v),boynum++,boyn++; while(boynum&lt;boyn)scanf("%d%d%I64d",&amp;boy[boynum].x,&amp;boy[boynum].y,&amp;boy[boynum].v),boynum++; while(girnum&lt;girn)scanf("%d%d%I64d",&amp;gir[girnum].x,&amp;gir[girnum].y,&amp;gir[girnum].v),girnum++; s=0;t=boyn+girn+num*2+2; while(l&lt;=r)&#123; ll mid=(l+r)&gt;&gt;1; if(jud(mid))ans=mid,r=mid-1; else l=mid+1; &#125; printf("%I64d",ans&lt;1e18?ans:-1); return 0;&#125; C 题目描述有$m$个敌人，$n$次攻击，每次攻击可以选择以下三种之一： 攻击给定集合里至多一个敌人 攻击给定区间里至多一个敌人 攻击给定三人中的两人或零人 其中保证所有敌人至多会位于攻击方式$3$的集合一次。 每个敌人都是一击即死，所以每个敌人只能打一次。 问最多能打死几个敌人，并输出这些敌人分别是被哪回合的攻击打死的。 解题思路攻击$1$直接暴力连边，攻击$2$线段树优化建图连边即可。而攻击$3$可以暴力打死其中两人$BC$，并连$p\rightarrow a$，$b\rightarrow p$，$c\rightarrow p$三条边，不连$s\rightarrow p$边即可（$p$指本次攻击对应的点）。 难点在于最后的输出。可以考虑连一个反向的图，沿着流方向回流到攻击所对应点。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 200010struct Edge&#123; ll l; int e,n;&#125;e[N&lt;&lt;1];int hd[N],cur[N],cnt=1;void add(int a,int b,ll l)&#123; e[++cnt].e=b;e[cnt].l=l;e[cnt].n=hd[a];hd[a]=cnt; e[++cnt].e=a;e[cnt].l=0;e[cnt].n=hd[b];hd[b]=cnt;&#125;ll inf=1e15;int n,m,s,t;ll a[N];int dep[N];queue&lt;int&gt;Q;ll dfs(int p,ll flow)&#123; if(p==t)return flow; int i; for(i=cur[p];i;i=e[i].n)&#123; int q=e[i].e; cur[p]=i; if(dep[q]==dep[p]+1&amp;&amp;e[i].l)&#123; ll ans=dfs(q,min(flow,e[i].l)); if(ans)&#123; e[i].l-=ans; e[i^1].l+=ans; return ans; &#125; &#125; &#125; return 0;&#125;int bfs()&#123; memset(dep,0,sizeof(dep)); Q.push(s);dep[s]=1; int i; while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(!dep[q]&amp;&amp;e[i].l)dep[q]=dep[p]+1,Q.push(q); &#125; &#125; return dep[t];&#125;int tot;//节点ll dinic()&#123; int i; ll d,ans=0; while(bfs())&#123; for(i=0;i&lt;=tot;i++)cur[i]=hd[i]; while((d=dfs(s,inf)))ans+=d; &#125; return ans;&#125;int id[N],L[N],R[N];void build(int p,int l,int r)&#123; id[p]=++tot; L[p]=l;R[p]=r; if(l==r)&#123; add(tot,l,1); return; &#125; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); add(id[p],id[p&lt;&lt;1],inf); add(id[p],id[p&lt;&lt;1|1],inf);&#125;void upd(int p,int l,int r)&#123; if(L[p]&gt;=l&amp;&amp;R[p]&lt;=r)&#123; add(tot,id[p],1); return; &#125; if(L[p]&gt;r||R[p]&lt;l)return; upd(p&lt;&lt;1,l,r); upd(p&lt;&lt;1|1,l,r);&#125;map&lt;int,int&gt;mp[N];int vis[N],start,ret;void solve(int x)&#123; if(x&gt;=start)&#123;ret=x-start;return;&#125; map&lt;int,int&gt;::iterator it=mp[x].begin(); solve(it-&gt;first); --it-&gt;second; if(!it-&gt;second)mp[x].erase(it);&#125;int main()&#123; int i,j,u,k,l,r,opt; int temp=0; scanf("%d%d",&amp;n,&amp;m); tot=m; build(1,1,m); s=++tot;t=++tot; start=tot; for(i=1;i&lt;=n;i++)&#123; ++tot; scanf("%d",&amp;opt); if(opt==0)&#123; add(s,tot,1); scanf("%d",&amp;k); while(k--)scanf("%d",&amp;u),add(tot,u,1); &#125;else if(opt==1)&#123; add(s,tot,1); scanf("%d%d",&amp;l,&amp;r); upd(1,l,r); &#125;else&#123; int A,B,C; scanf("%d%d%d",&amp;A,&amp;B,&amp;C); add(tot,A,1); add(tot,B,0);e[cnt].l=1;vis[B]=1; add(tot,C,1);e[cnt].l=1;vis[C]=1; temp+=2; &#125; &#125; for(i=1;i&lt;=m;i++)if(!vis[i])add(i,t,1); printf("%I64d\n",dinic()+temp); for(i=1;i&lt;=tot;i++) for(j=hd[i];j;j=e[j].n) if((j&amp;1)&amp;&amp;e[j].l)mp[i][e[j].e]=e[j].l; for(i=1;i&lt;=m;i++)&#123; int flag=0; for(j=hd[i];j;j=e[j].n)if(e[j].e==t&amp;&amp;e[j].l)&#123; flag=1; break; &#125; if(flag)continue; solve(i); printf("%d %d\n",ret,i); &#125; return 0;&#125; D 题目描述有一堆任务，$k$个机器，每个任务有起始结束时间以及利润，问如何分配能够利益最大化。 解题思路先把任务按照起始时间排序，把每个任务拆点，连边如下 $S\rightarrow i$，流量$k$，费用$0$$i\rightarrow i+1$，流量$inf$，费用$0$$i’\rightarrow t$，流量$inf$，费用$0$$i$完成后首先开始的$j$：$i’\rightarrow j$，流量$1$，费用$0$$i\rightarrow i’$，流量$1$，费用$-profit$ 跑最小费用最大流，保证使用最多的机器的情况下获得利润负值最小。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;bits/stdc++.h&gt;using namespace std;#define N 100020struct Edge&#123; int end,len,cost,near;&#125;e[20*N];struct Pre&#123; int pre,edge;&#125;pre[N];int head[N],dis[N],flow[N],vis[N],cnt=1,n,k,s,t;int maxflow,mincost;int inf=2e9;void add(int a,int b,int l,int c)&#123; e[++cnt].end=b; e[cnt].len=l; e[cnt].cost=c; e[cnt].near=head[a]; head[a]=cnt;&#125;queue&lt;int&gt;Q;int spfa()&#123; memset(dis,0x7f,sizeof(dis)); memset(flow,0x7f,sizeof(flow)); memset(vis,0,sizeof(vis)); while(!Q.empty())Q.pop(); int i,top,q; Q.push(s);vis[s]=1;dis[s]=0;pre[t].pre=0; while(!Q.empty())&#123; top=Q.front(); Q.pop(); vis[top]=0; for(i=head[top];i;i=e[i].near)&#123; q=e[i].end; if(e[i].len&amp;&amp;dis[q]&gt;dis[top]+e[i].cost)&#123; dis[q]=dis[top]+e[i].cost; pre[q].pre=top; pre[q].edge=i; flow[q]=min(flow[top],e[i].len); if(!vis[q])&#123; vis[q]=1; Q.push(q); &#125; &#125; &#125; &#125; return pre[t].pre;&#125;void ek()&#123; int i; while(spfa())&#123; maxflow+=flow[t]; mincost+=flow[t]*dis[t]; for(i=t;i!=s;i=pre[i].pre)&#123; e[pre[i].edge].len-=flow[t]; e[pre[i].edge^1].len+=flow[t]; &#125; &#125;&#125;struct A&#123; int s,t,c,i; bool operator&lt;(const A&amp;p)const&#123;return s&lt;p.s||(s==p.s&amp;&amp;t&lt;p.t);&#125;&#125;a[N];int ans[N];int main()&#123; int i,j; scanf("%d%d",&amp;n,&amp;k); for(i=0;i&lt;n;i++)scanf("%d%d%d",&amp;a[i].s,&amp;a[i].t,&amp;a[i].c),a[i].i=i; sort(a,a+n); s=2*n;t=s+1; add(s,0,k,0);add(0,s,0,0); add(n-1,t,k,0);add(t,n-1,0,0); for(i=0;i&lt;n;i++)&#123; add(i,i+n,1,-a[i].c),add(i+n,i,0,a[i].c); add(i+n,t,inf,0),add(t,i+n,0,0); int j=i+1; while(j&lt;n&amp;&amp;a[j].s&lt;a[i].s+a[i].t)j++; if(j&lt;n)add(i+n,j,inf,0),add(j,i+n,0,0); if(i&lt;n-1)add(i,i+1,inf,0),add(i+1,i,0,0); &#125; ek(); for(i=0;i&lt;n;i++)&#123; for(j=head[i];j;j=e[j].near)&#123; int q=e[j].end; if(q==i+n)&#123; if(!e[j].len)ans[a[i].i]=1; break; &#125; &#125; &#125; for(i=0;i&lt;n;i++)printf("%d ",ans[i]); return 0;&#125; E 题目描述求最大流。 解题思路模板。 必须吐槽$poj$居然不能用万能头！ AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 220#define M 220struct Edge&#123; int l,e,n;&#125;e[M&lt;&lt;1];int hd[M],cur[M],cnt=1;void add(int a,int b,int l)&#123; e[++cnt].e=b;e[cnt].l=l;e[cnt].n=hd[a];hd[a]=cnt; e[++cnt].e=a;e[cnt].l=0;e[cnt].n=hd[b];hd[b]=cnt;&#125;int inf=1e9;int n,m,s,t;ll sum;int dep[M];queue&lt;int&gt;Q;int dfs(int p,int flow)&#123; if(p==t)return flow; int i; for(i=cur[p];i;i=e[i].n)&#123; int q=e[i].e; cur[p]=i; if(dep[q]&gt;dep[p]&amp;&amp;e[i].l)&#123; int ans=dfs(q,min(flow,e[i].l)); if(ans)&#123; e[i].l-=ans; e[i^1].l+=ans; return ans; &#125; &#125; &#125; return 0;&#125;int bfs()&#123; memset(dep,0,sizeof(dep)); Q.push(s);dep[s]=1; int i; while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(!dep[q]&amp;&amp;e[i].l)dep[q]=dep[p]+1,Q.push(q); &#125; &#125; return dep[t];&#125;ll dinic()&#123; int i,d; ll ans=0; while(bfs())&#123; for(i=0;i&lt;=t;i++)cur[i]=hd[i]; while((d=dfs(s,inf)))ans+=d; &#125; return ans;&#125;int main()&#123; int i,w,u,v; while(~scanf("%d%d",&amp;m,&amp;n))&#123; cnt=1;memset(hd,0,sizeof(hd)); s=1;t=n; for(i=0;i&lt;m;i++)scanf("%d%d%d",&amp;u,&amp;v,&amp;w),add(u,v,w); printf("%lld\n",dinic()); &#125; return 0;&#125; F 题目描述给一个网格图填数，给一些大小限制和行列总和，求解。 解题思路上下界网络流，把行列都当做点看即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt;typedef long long ll;using namespace std;#define N 205#define M 22#define P 240struct Edge&#123; int l,e,n;&#125;e[P*P];int hd[P],cur[P],cnt=1;int inf=1e9;int n,m,s,t,ss,tt;ll sum;int dep[P];queue&lt;int&gt;Q;int dfs(int p,int flow)&#123; if(p==t)return flow; int i; for(i=cur[p];i;i=e[i].n)&#123; int q=e[i].e; cur[p]=i; if(dep[q]&gt;dep[p]&amp;&amp;e[i].l)&#123; int ans=dfs(q,min(flow,e[i].l)); if(ans)&#123; e[i].l-=ans; e[i^1].l+=ans; return ans; &#125; &#125; &#125; return 0;&#125;int bfs()&#123; memset(dep,0,sizeof(dep)); Q.push(s);dep[s]=1; int i; while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(!dep[q]&amp;&amp;e[i].l)dep[q]=dep[p]+1,Q.push(q); &#125; &#125; return dep[t];&#125;ll dinic()&#123; int i,d; ll ans=0; while(bfs())&#123; for(i=0;i&lt;=t;i++)cur[i]=hd[i]; while((d=dfs(s,inf)))ans+=d; &#125; return ans;&#125;int lim[2][N][M],flag,full;int ans[N][M];void init ()&#123; int i,j; memset(lim[0],0,sizeof(lim[0])); memset(lim[1],0x3f,sizeof(lim[1])); memset(hd,0,sizeof(hd)); memset(ans,0,sizeof(ans)); cnt=1; flag=0; full=0;&#125;void add(int a,int b,int l)&#123; if(a==s)full+=l; if(!l)return; e[++cnt].e=b;e[cnt].l=l;e[cnt].n=hd[a];hd[a]=cnt; e[++cnt].e=a;e[cnt].l=0;e[cnt].n=hd[b];hd[b]=cnt;&#125;void ins(int a,int b,int low,int high)&#123; if(high&lt;low)flag=1; add(s,b,low); add(a,t,low); add(a,b,high-low);&#125;int main()&#123; int i,j,T,a,q; scanf("%d",&amp;T); while(T--)&#123; init(); scanf("%d%d",&amp;n,&amp;m); ss=n+m+1;tt=ss+1; s=tt+1;t=s+1; for(i=1;i&lt;=n;i++)scanf("%d",&amp;a),ins(ss,i,a,a); for(i=1;i&lt;=m;i++)scanf("%d",&amp;a),ins(i+n,tt,a,a); scanf("%d",&amp;q); while(q--)&#123; char s[5]=&#123;0&#125;; int u,v,l1,r1,l2,r2; scanf("%d%d%s%d",&amp;u,&amp;v,s,&amp;a); if(!u)l1=1,r1=n;else l1=r1=u; if(!v)l2=1,r2=m;else l2=r2=v; for(i=l1;i&lt;=r1;i++)for(j=l2;j&lt;=r2;j++)&#123; if(s[0]=='&lt;')lim[1][i][j]=min(lim[1][i][j],a-1); if(s[0]=='&gt;')lim[0][i][j]=max(lim[0][i][j],a+1); if(s[0]=='=')lim[0][i][j]=max(lim[0][i][j],a),lim[1][i][j]=min(lim[1][i][j],a); &#125; &#125; for(i=1;i&lt;=n;i++)for(j=1;j&lt;=m;j++)ins(i,j+n,lim[0][i][j],lim[1][i][j]); ins(tt,ss,0,inf); if(flag||dinic()!=full)&#123; printf("IMPOSSIBLE\n\n"); continue; &#125; for(i=2;i&lt;=cnt;i++) if(e[i^1].e&gt;=1&amp;&amp;e[i^1].e&lt;=n&amp;&amp;e[i].e&gt;=n+1&amp;&amp;e[i].e&lt;=n+m) ans[e[i^1].e][e[i].e-n]=e[i^1].l; for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)printf("%d ",ans[i][j]+lim[0][i][j]); puts(""); &#125; puts(""); &#125; return 0;&#125; G 题目描述给一个$o$（空地）和$*$（城市）组成的图，一个基站可以覆盖相邻的两个城市，问至少要多少基站才能覆盖所有城市。 解题思路相邻城市建边跑二分图最大匹配即可，假设开始一个城市对应一个基站，则每一个匹配对应一个基站的减少，答案为城市数$-$最大匹配数。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;#define N 45*15#define M N&lt;&lt;2struct Edge&#123;int e,n;&#125;e[M];int hd[N],mt[N],cnt,vis[N];int mp[N][N];void add(int a,int b)&#123;e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;int dfs(int p,int t)&#123; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(vis[q]!=t)&#123; vis[q]=t; if(!mt[q]||dfs(mt[q],t))return mt[q]=p; &#125; &#125; return 0;&#125;int maxmt(int n)&#123; int i,ans=0; for(i=1;i&lt;=n;i++) if(dfs(i,i))ans++; return ans;&#125;char a[N];int main()&#123; int i,j,n,m,t; scanf("%d",&amp;t); while(t--)&#123; int lcnt=0,rcnt=0,tot=0; memset(hd,0,sizeof(hd));cnt=0; memset(vis,0,sizeof(vis)); memset(mt,0,sizeof(mt)); memset(mp,0,sizeof(mp)); scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)&#123; scanf("%s",a); for(j=0;a[j];j++)&#123; if(a[j]=='*')&#123; if((i+j)&amp;1)mp[i][j]=++lcnt; else mp[i][j]=++rcnt; ++tot; &#125; &#125; &#125; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; if(mp[i][j]&amp;&amp;((i+j)&amp;1))&#123; if(i&amp;&amp;mp[i-1][j])add(mp[i][j],mp[i-1][j]); if(i+1&lt;n&amp;&amp;mp[i+1][j])add(mp[i][j],mp[i+1][j]); if(j+1&lt;m&amp;&amp;mp[i][j+1])add(mp[i][j],mp[i][j+1]); if(j&amp;&amp;mp[i][j-1])add(mp[i][j],mp[i][j-1]); &#125; &#125; &#125; printf("%d\n",tot-maxmt(lcnt)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 6 题解]]></title>
    <url>%2F2019%2F05%2F19%2F2019springtraining-6%2F</url>
    <content type="text"><![CDATA[Solved A B C D E 5/5 O Ø Ø O Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述一个数可以对应他的所有因数，问$[1,n]$能不能被$[s+1,s+n]$一一对应。 解题思路显然，一个区间内若有两个质数则必然不可行，猜测差别$400$以上不可行，剩余的跑匈牙利。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define N 1010struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int hd[N],cnt,vis[N],mt[N];void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;int n,s;int dfs(int p,int t)&#123; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(vis[q]!=t)&#123; vis[q]=t; if(!mt[q]||dfs(mt[q],t))return mt[q]=p; &#125; &#125; return 0;&#125;int maxmt()&#123; int i; for(i=1;i&lt;=n;i++)if(!dfs(i,i))return 0; return 1;&#125;int main()&#123; int i,j,k,t; scanf("%d",&amp;t); for(k=1;k&lt;=t;k++)&#123; scanf("%d%d",&amp;n,&amp;s); printf("Case #%d: ",k); if(s&lt;n)std::swap(s,n); if(n&gt;400)&#123; printf("No\n"); continue; &#125; memset(hd,0,sizeof(hd));cnt=0; memset(vis,0,sizeof(vis)); memset(mt,0,sizeof(mt)); for(i=s+1;i&lt;=s+n;i++) for(j=1;j&lt;=n;j++) if(i%j==0)add(i-s,j); printf("%s\n",maxmt()?"Yes":"No"); &#125; return 0;&#125; B 题目描述定义两个序列相似，当且仅当对于任意一个区间$[l,r]$，其最大数的最左位置相同。 给定一个序列$A$，随机产生一个序列$B$，其中$B$的所有元素都是等概率从$(0,1)$中选取的。如果$AB$相似，则$B$的满意度为$B$中所有数之和，否则$B$的满意度为$0$。求$B$的满意度期望。 解题思路笛卡尔树的同构，$[0,1]$之中$n$个数总和期望为$\frac n2$，各个数两两不同的概率为$1$（即不需考虑两个数相同的情况）。树同构的概率为$\prod\frac1{siz[i]}$（证明：用拓扑序表示树，则某一个点$i$作为根的时候位置必然在其所有子树点的后面，则对于该点而言，满足这个条件只需考虑这$siz[i]$个节点的顺序，故满足条件的概率为$\frac 1{siz[i]}$），于是答案为$\frac n2\prod\frac1{siz[i]}$。 AC代码点击 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;#define N 3000010long long inv[N]=&#123;0,1&#125;,w=1000000007,ans;int a[N],sta[N],top,siz[N],l[N],r[N];void dfs(int p)&#123; if(!p)return; siz[p]=1; dfs(l[p]);siz[p]+=siz[l[p]]; dfs(r[p]);siz[p]+=siz[r[p]]; ans=ans*inv[siz[p]]%w;&#125;int main()&#123; int i,n,t; for(i=2;i&lt;N;i++)inv[i]=inv[w%i]*(w-w/i)%w; scanf("%d",&amp;t); while(t--)&#123; top=0; scanf("%d",&amp;n); ans=n*inv[2]%w; for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),l[i]=r[i]=0; for(i=1;i&lt;=n;i++)&#123; while(top&amp;&amp;a[i]&gt;a[sta[top]])l[i]=sta[top--]; if(top)r[sta[top]]=i; sta[++top]=i; &#125; dfs(sta[1]); printf("%lld\n",ans); &#125; return 0;&#125; C 题目描述给定一个由$a[n]$经过或、与、异或运算得到的矩阵$b[n][n]$，问能不能够找到$a[n]$的解。 解题思路用并查集模拟或和与的填数以及异或的两元素关系。每个数拆成$32$个$bit$，并分成两半，一半是该数需要与某个数相同，另一半是该数不可与某个数相同。 听说能用$2-sat$做，看来还是要学习一个。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 521#define M 52125int b[N][N],n,f[M];int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;void merge(int x,int p)&#123; int a=find(x),b=find(p); f[a]=f[b]=f[x]=f[p]=std::min(a,b);&#125;int solve()&#123; int i,j,k; for(i=0;i&lt;n;i++)&#123; for(j=i+1;j&lt;n;j++)if(b[i][j]!=b[j][i])return 0; if(b[i][i])return 0; &#125; for(i=0;i&lt;n;i++)&#123; for(j=i+1;j&lt;n;j++)&#123; for(k=0;k&lt;32;k++)&#123; if(i%2&amp;&amp;j%2)&#123; if(!(b[i][j]&amp;(1&lt;&lt;k)))&#123; int p=(i+1)*32+k,q=(j+1)*32+k; if(find(p)==find(1)||find(q)==find(1)||find(p)==find(q+32*n))return 0; merge(p,0);merge(q,0); merge(p+32*n,1);merge(q+32*n,1); &#125; &#125;else if(!(i%2)&amp;&amp;!(j%2))&#123; if(b[i][j]&amp;(1&lt;&lt;k))&#123; int p=(i+1)*32+k,q=(j+1)*32+k; if(find(p)==find(0)||find(q)==find(0)||find(p)==find(q+32*n))return 0; merge(p,1);merge(q,1); merge(p+32*n,0);merge(q+32*n,0); &#125; &#125;else&#123; if(b[i][j]&amp;(1&lt;&lt;k))&#123; int p=(i+1)*32+k,q=(j+1)*32+k; if(find(p)==find(q))return 0; merge(p,q+32*n);merge(q,p+32*n); &#125;else&#123; int p=(i+1)*32+k,q=(j+1)*32+k; if(find(p)==find(q+32*n))return 0; merge(p,q);merge(q+32*n,p+32*n); &#125; &#125; &#125; &#125; &#125; return 1;&#125;int main()&#123; int i,j; while(~scanf("%d",&amp;n))&#123; for(i=0;i&lt;=32*(n+2)*2;i++)f[i]=i; for(i=0;i&lt;n;i++)for(j=0;j&lt;n;j++)scanf("%d",&amp;b[i][j]); printf("%s\n",solve()?"YES":"NO"); &#125; return 0;&#125; D 题目描述每个人都对应有一个不能同时上台的人，并有一个实力值，问选择出的人的实力值之和最大是多少。 解题思路基环树，也可找到环之后切开分两段$DP$。 AC代码-1点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define N 1000010typedef long long ll;struct Edge&#123; int end,near;&#125;e[N&lt;&lt;1];int head[N],cnt,vis[N],fa[N];void add(int a,int b)&#123; e[++cnt].end=b;e[cnt].near=head[a];head[a]=cnt;&#125;ll str[N],ans,f[2][N];int rt;void dp(int x)&#123; int i,q; if(!vis[x])vis[x]=1; f[0][x]=0; f[1][x]=str[x]; for(i=head[x];i;i=e[i].near)&#123; q=e[i].end; if(q!=rt)&#123; dp(q); f[1][x]+=f[0][q]; f[0][x]+=max(f[1][q],f[0][q]); &#125; &#125; if(x==rt)f[1][x]=0;&#125;void cir(int x)&#123; ll t; vis[x]=1; rt=x; while(!vis[fa[rt]])&#123; rt=fa[rt]; vis[rt]=1; &#125; dp(rt);t=f[0][rt]; rt=fa[rt]; dp(rt);ans+=max(t,f[0][rt]);&#125;int main()&#123; int i,n,y; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf("%lld%d",&amp;str[i],&amp;y); add(y,i);fa[i]=y; &#125; for(i=1;i&lt;=n;i++)if(!vis[i])cir(i); printf("%lld",ans); return 0;&#125; AC代码-2点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#define N 1000010typedef long long ll;ll max(ll a,ll b)&#123;return a&gt;b?a:b;&#125;ll min(ll a,ll b)&#123;return a&gt;b?b:a;&#125;struct Edge&#123; int end,near;&#125;e[N&lt;&lt;1];int head[N],cnt;void add(int a,int b)&#123; e[++cnt].end=b;e[cnt].near=head[a];head[a]=cnt;&#125;ll str[N],f[2][N];int rt;void dp(int x,int fa)&#123; int i,q; f[0][x]=0; f[1][x]=str[x]; for(i=head[x];i;i=e[i].near)&#123; q=e[i].end; if(q!=fa)&#123; dp(q,x); f[1][x]+=f[0][q]; f[0][x]+=max(f[1][q],f[0][q]); &#125; &#125; if(x==rt)f[1][x]=0;&#125;int fla[N],A[N],B[N],tot;int main()&#123; int i,n,y; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf("%lld%d",&amp;str[i],&amp;y); if(fla[i]&amp;&amp;fla[y])&#123; A[++tot]=i;B[tot]=y;continue; &#125; fla[i]=fla[y]=1; add(y,i);add(i,y); &#125; ll ans=0; for(i=1;i&lt;=tot;i++)&#123; dp(A[i],A[i]);ll t=f[0][A[i]]; dp(B[i],B[i]); ans+=max(t,f[0][B[i]]); &#125; printf("%lld",ans); return 0;&#125; E 题目描述给一个图，要求选择某些边，使得前$d$个点和后$d$个点必须分别相连通，问最小权值和。 解题思路设$f[i][j]$表示当前斯坦纳树的根为$i$，指定集合中，包含点的集合表示为$j$的生成树最小权值。 则转移方程为：$f[i][j]=min(f[i][S]+f[i][S \oplus j])$（分成两个以$i$为根的斯坦纳树，点集状态分别为$S$和$j\oplus S$），$f[i][j]=min(f[k][j]+len[i][k])$（换根，根再向$i$连边），这一步看起来很像最短路，可以用最短路算法算出。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define N 10010#define M (1&lt;&lt;8)+10struct Edge&#123; int e,n,l;&#125;e[N&lt;&lt;1];int hd[N],cnt,n,m,d;void add(int a,int b,int l)&#123; e[++cnt].e=b;e[cnt].n=hd[a];e[cnt].l=l;hd[a]=cnt;&#125;int f[N][M],g[M],vis[N];queue&lt;int&gt;Q;void spfa(int s)&#123; while(!Q.empty())&#123; int p=Q.front(),i;Q.pop(); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(f[q][s]&gt;f[p][s]+e[i].l)&#123; f[q][s]=f[p][s]+e[i].l; if(!vis[q])Q.push(q),vis[q]=1; &#125; &#125; vis[p]=0; &#125;&#125;int main()&#123; int i,j,k,s,u,v,w; scanf("%d%d%d",&amp;n,&amp;m,&amp;d);s=(1&lt;&lt;(d&lt;&lt;1)); for(i=0;i&lt;m;i++) scanf("%d%d%d",&amp;u,&amp;v,&amp;w), add(u,v,w),add(v,u,w); memset(f,0x3f,sizeof(f)); memset(g,0x3f,sizeof(g)); for(i=1;i&lt;=d;i++) f[i][1&lt;&lt;i-1]=0,f[n-i+1][1&lt;&lt;d+i-1]=0; for(j=0;j&lt;s;j++)&#123; for(i=1;i&lt;=n;i++)&#123; for(k=j&amp;(j-1);k;k=(k-1)&amp;j) f[i][j]=min(f[i][j],f[i][k]+f[i][j^k]); if(f[i][j]&lt;1e9)Q.push(i),vis[i]=1; &#125; spfa(j); for(i=1;i&lt;=n;i++)g[j]=min(g[j],f[i][j]); &#125; for(j=0;j&lt;s;j++) for(k=j&amp;(j-1);k;k=(k-1)&amp;j) if((k&amp;((1&lt;&lt;d)-1))==(k&gt;&gt;d)&amp;&amp;((j^k)&amp;((1&lt;&lt;d)-1))==((j^k)&gt;&gt;d)) g[j]=min(g[j],g[k]+g[j^k]); printf("%d\n",g[s-1]&lt;1e9?g[s-1]:-1); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 5 题解]]></title>
    <url>%2F2019%2F05%2F19%2F2019springtraining-5%2F</url>
    <content type="text"><![CDATA[Solved A B C D E 5/5 Ø O Ø Ø O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述现有一棵 $n$ 个点的树，每条边 $i$ 都一个边权 $w_i$，接下来有 $m$ 个操作：第一种操作给出两个点 $a_i$,$ b_i$，一个数 $y_i$：从 $a_i$ 沿最短路走到 $b_i$ 的过程中，每经过一条边 $j$，就将 $y_i$ 除以边权 $w_j$ 并向下取整，即进行 $y_i=\lfloor\frac{y_i}{w_j}\rfloor $ ，输出走完后的 $y_i$。第二种操作给出某条边 $e_i$，一个数 $c_i$，满足 $c_i$ &lt; $w_{e_i}$：将 $e_i$ 边权修改为 $c_i$。 解题思路刚开始傻乎乎瞎改点剖模板然后$T$了。 TLE代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 200010int n,m,r,mod;double a[N];int count=2,head[N];struct Edge&#123; int end,near,sign; double len;&#125;edge[2*N];void addedge(int begin,int end,double len)&#123; edge[count].end=end; edge[count].near=head[begin]; edge[count].len=len; head[begin]=count++;&#125;int depth[N],fa[N],size[N],son[N],pos[N],top[N];double temp[N],sonlen[N];int cnt;struct Tree&#123; int left,right; double data;&#125;tree[4*N];void build(int p,int left,int right)&#123; tree[p].left=left; tree[p].right=right; if(left==right)&#123; tree[p].data=temp[left]; return; &#125; build(p&lt;&lt;1,left,(left+right)&gt;&gt;1); build(p&lt;&lt;1|1,((left+right)&gt;&gt;1)+1,right); tree[p].data=tree[p&lt;&lt;1].data*tree[p&lt;&lt;1|1].data;&#125;double query(int p,int left,int right)&#123; int l=tree[p].left,r=tree[p].right; if(l&gt;=left&amp;&amp;r&lt;=right)return tree[p].data; if(r&lt;left||l&gt;right)return 1; return query(p&lt;&lt;1,left,right)*query(p&lt;&lt;1|1,left,right);&#125;void dfs1(int now,int f,int dep)&#123; depth[now]=dep; fa[now]=f; size[now]=1; int i,max=0; for(i=head[now];i;i=edge[i].near)&#123; int p=edge[i].end; if(p!=f)&#123; edge[i].sign=1; dfs1(p,now,dep+1); size[now]+=size[p]; if(size[p]&gt;max)&#123; max=size[p]; son[now]=p; sonlen[now]=edge[i].len; &#125; &#125; &#125;&#125;void dfs2(int now,int Top,double x)&#123; int i; pos[now]=++cnt; temp[cnt]=x; top[now]=Top; if(!son[now])return; dfs2(son[now],Top,sonlen[now]); for(i=head[now];i;i=edge[i].near)&#123; int p=edge[i].end; if(p-son[now]&amp;&amp;p-fa[now])dfs2(p,p,edge[i].len); &#125;&#125;int bot[N],mxd[N];void dfs3(int p,int f)&#123; int i,tmp=p; mxd[p]=depth[p]; for(i=head[p];i;i=edge[i].near)&#123; int q=edge[i].end; if(q==f)continue; dfs3(q,p); if(mxd[q]&gt;mxd[p])mxd[p]=mxd[q],tmp=bot[q]; &#125; bot[p]=tmp;&#125;double rangequery(double fir,int x,int y)&#123; double ans=fir; while(top[x]!=top[y])&#123; if(depth[top[x]]&lt;depth[top[y]])std::swap(x,y); ans/=query(1,pos[top[x]],pos[x]); if(ans&lt;1)return 0; x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y])std::swap(x,y); return ans/query(1,pos[x],pos[y]);&#125;int d[N],Fa[22][N],lg[N];void dfs(int now,int f)&#123; d[now]=d[f]+1; Fa[0][now]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++)Fa[i][now]=Fa[i-1][Fa[i-1][now]]; for(i=head[now];i;i=edge[i].near)&#123; int p=edge[i].end; if(p!=f)dfs(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y])x=Fa[lg[d[x]-d[y]]][x]; if(x==y)return x; for(i=lg[d[x]];~i;i--)if(Fa[i][x]!=Fa[i][y])x=Fa[i][x],y=Fa[i][y]; return Fa[0][x];&#125;void modify(int l,int r,int p,double change,int inin)&#123; if(tree[p].left&lt;=inin&amp;&amp;inin&lt;=tree[p].right)tree[p].data*=change; if(tree[p].left==tree[p].right&amp;&amp;tree[p].left==1)tree[p].data=1; if(tree[p].left&gt;r||tree[p].right&lt;l||p&gt;4*n)return; modify(l,r,p&lt;&lt;1,change,inin); modify(l,r,p&lt;&lt;1|1,change,inin);&#125;int main()&#123; int i,x,y,sign,r=1; double w; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;n;i++)&#123; scanf("%d%d%lf",&amp;x,&amp;y,&amp;w); addedge(x,y,w);addedge(y,x,w); &#125; dfs(r,0); for(i=2;i&lt;=n;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); dfs1(r,0,1); dfs2(r,r,1); dfs3(r,0); build(1,1,n); temp[pos[1]]=1; for(i=0;i&lt;m;i++)&#123; scanf("%d",&amp;sign); if(sign==1)&#123; double y;int a,b; scanf("%d%d%lf",&amp;a,&amp;b,&amp;y); int ff=lca(a,b); double rq=rangequery(y*temp[pos[ff]],a,b); printf("%I64d\n",(long long)(1e-8+rq)); &#125;else&#123; int a;double b; scanf("%d%lf",&amp;a,&amp;b);a&lt;&lt;=1; int p=edge[a].sign?edge[a].end:edge[a^1].end,q=p,tmp=p; p=top[p];q=bot[q]; p=pos[p];q=pos[q]; if(p&gt;q)std::swap(p,q); double change=b/edge[a].len; modify(p,q,1,change,pos[tmp]); &#125; &#125; return 0;&#125; 考虑每次边权只能减小，每次将权值为$1$的路径用并查集合并起来即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;typedef long long ll;#define N 200010struct Edge&#123; int e,n,i; ll len;&#125;e[N&lt;&lt;1];int hd[N],cnt=1,n,m;void add(int a,int b,ll w,int i)&#123; e[++cnt].e=b;e[cnt].n=hd[a];e[cnt].len=w;e[cnt].i=i;hd[a]=cnt;&#125;int fa[N],dep[N],to[N];ll up[N];void dfs(int p,int d)&#123; dep[p]=d; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q==fa[p])continue; fa[q]=p; up[q]=e[i].len; to[e[i].i]=q; dfs(q,d+1); &#125;&#125;int f[N];int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;ll solve(int u,int v,ll w)&#123; u=find(u),v=find(v); while(u!=v)&#123; if(dep[u]&lt;dep[v])std::swap(u,v); w/=up[u]; if(!w)return 0; u=find(fa[u]); &#125; return w;&#125;int main()&#123; int i,u,v,opt; ll w; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;n;i++)&#123; scanf("%d%d%I64d",&amp;u,&amp;v,&amp;w); add(u,v,w,i),add(v,u,w,i); f[i]=i; &#125;f[n]=n; dfs(1,0); for(i=1;i&lt;=n;i++)if(up[i]==1)f[i]=find(fa[i]); for(i=0;i&lt;m;i++)&#123; scanf("%d",&amp;opt); if(opt==1)&#123; scanf("%d%d%I64d",&amp;u,&amp;v,&amp;w); printf("%I64d\n",solve(u,v,w)); &#125;else&#123; scanf("%d%I64d",&amp;u,&amp;w); up[to[u]]=w; if(w==1)f[to[u]]=find(fa[to[u]]); &#125; &#125; return 0;&#125; B 题目描述现有一棵$n$个点的树，点的编号从 $1$ 起，树以 $1$ 为根，每个点 $i$ 都一个颜色 $c_i$，接下来有$m$个询问，每次询问以 $v_j$ 为根的子树中，求有多少种颜色，这些颜色在子树中出现的次数至少为 $k_j$。 解题思路树上莫队裸题。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;#define N 100010struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int block;struct DFN&#123; int l,r;&#125;dfn[N];int hd[N],cnt,n,m;void add(int a,int b)&#123;e[++cnt].n=hd[a],e[cnt].e=b,hd[a]=cnt;&#125;int tot=1;int count[N],seq[N];void dfs(int p)&#123; dfn[p].l=tot; seq[tot]=p; tot++; int i; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(!dfn[q].l)dfs(q); &#125; dfn[p].r=tot-1;&#125;int getblock(int x)&#123; return x/block;&#125;struct Query&#123; int p,k,i; bool operator&lt;(const Query &amp;a)const&#123; int l=dfn[p].l,r=dfn[p].r,L=dfn[a.p].l,R=dfn[a.p].r; return getblock(l)==getblock(L)?getblock(r)&lt;getblock(R):getblock(l)&lt;getblock(L); &#125;&#125;q[N];int color[N],sum[N],a[N];void del(int x)&#123; --sum[count[color[seq[x]]]--];&#125;void add(int x)&#123; ++sum[++count[color[seq[x]]]];&#125;int ans[N];int main()&#123; int i,u,v; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)scanf("%d",&amp;color[i]); for(i=1;i&lt;n;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v),add(v,u); dfs(1); block=n/sqrt(n); for(i=1;i&lt;=m;i++)scanf("%d%d",&amp;q[i].p,&amp;q[i].k),q[i].i=i; std::sort(q+1,q+1+m); int l=1,r=0; for(i=1;i&lt;=m;i++)&#123; int L=dfn[q[i].p].l,R=dfn[q[i].p].r; while(l&gt;L)add(--l); while(r&lt;R)add(++r); while(l&lt;L)del(l++); while(r&gt;R)del(r--); ans[q[i].i]=sum[q[i].k]; &#125; for(i=1;i&lt;=m;i++)printf("%d\n",ans[i]); return 0;&#125; C 题目描述现有一个 $n$ 个点、$m$ 条边的连通无向图，点的编号从 $1$ 起，每条边都有一个边权。图没有重边，也没有自环。 接下来对每条边单独考虑，需要重新设定这条边的边权，使得它绝对能够出现在所有的最小生成树中。 请你对每条边，在满足题意的情况下，可以重新设定的最大边权。 解题思路太神仙了。 先求出最小生成树，然后对于每一个非树边$[start,end]$必然在最小生成树内的充要条件是该边边权比最小生成树中这两点$(start,end)$之间所有边的最大值小，对于每一个树边$[start,end]$必然在最小生成树内的充要条件是该边边权比$start$为根的子树与$end$为根的子树中任意两个点之间连边的边权小。 于是问题就转化成了：对于每一个非树边，求出$[start,end]$路径中的最小值，并更新$[start,end]$路径中所有边对应答案的最小值。显然树剖可做。（就是有点难写） AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;bits/stdc++.h&gt;#define N 200010int temp[N];struct Edge&#123; int b,e,n,l,i; bool operator&lt;(const Edge&amp;a)const&#123; return l&lt;a.l; &#125;&#125;ed[N&lt;&lt;1],e[N&lt;&lt;1];int sign[N];//是否为MST边int hd[N],cnt;int n,m;void add(int a,int b,int l,int i)&#123; e[++cnt].e=b,e[cnt].b=a,e[cnt].l=l,e[cnt].i=i,e[cnt].n=hd[a],hd[a]=cnt;&#125;int F[N];int find(int x)&#123;return x==F[x]?x:F[x]=find(F[x]);&#125;struct segtree&#123; int mn,mx,l,r,lazy;&#125;t[N&lt;&lt;2];int inf=1.2e9;int dep[N],siz[N],son[N],fa[N],lento[N];int pre[N];void dfs1(int p,int f,int d)&#123; int i,mx=0; fa[p]=f; dep[p]=d; siz[p]=1; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q==f)continue; dfs1(q,p,d+1); siz[p]+=siz[q]; lento[q]=e[i].l; pre[q]=e[i].i; if(siz[q]&gt;mx)&#123; mx=siz[q]; son[p]=q; &#125; &#125;&#125;int top[N],pos[N],count;void dfs2(int p,int Top)&#123; int i; pos[p]=++count; temp[count]=lento[p]; top[p]=Top; if(!son[p])return; dfs2(son[p],Top); for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; if(q!=son[p]&amp;&amp;q!=fa[p])dfs2(q,q); &#125;&#125;void krustal()&#123; int i; for(i=1;i&lt;=n;i++)F[i]=i; for(i=1;i&lt;=m;i++)&#123; int st,fn,p=ed[i].e,q=ed[i].b; if((st=find(p))==(fn=find(q)))continue; sign[ed[i].i]=1; add(p,q,ed[i].l,ed[i].i); add(q,p,ed[i].l,ed[i].i); F[st]=fn; &#125;&#125;//segtvoid update(int p)&#123; t[p].mn=std::min(t[p&lt;&lt;1].mn,t[p&lt;&lt;1|1].mn); t[p].mx=std::max(t[p&lt;&lt;1].mx,t[p&lt;&lt;1|1].mx);&#125;void build(int p,int l,int r)&#123; t[p].l=l; t[p].r=r; t[p].mn=t[p].lazy=inf; if(l==r)&#123; t[p].mx=temp[l]; return; &#125; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); update(p);&#125;void pushdown(int p)&#123; int lazy=t[p].lazy; t[p&lt;&lt;1].mn=std::min(t[p&lt;&lt;1].mn,lazy); t[p&lt;&lt;1].lazy=std::min(t[p&lt;&lt;1].lazy,lazy); t[p&lt;&lt;1|1].mn=std::min(t[p&lt;&lt;1|1].mn,lazy); t[p&lt;&lt;1|1].lazy=std::min(t[p&lt;&lt;1|1].lazy,lazy); t[p].lazy=inf;&#125;int querymax(int p,int l,int r)&#123; int L=t[p].l,R=t[p].r; pushdown(p); if(l&lt;=L&amp;&amp;R&lt;=r)return t[p].mx; if(l&gt;R||r&lt;L)return 0; return std::max(querymax(p&lt;&lt;1,l,r),querymax(p&lt;&lt;1|1,l,r));&#125;int querymin(int p,int Pos)&#123; int L=t[p].l,R=t[p].r; pushdown(p); if(Pos==L&amp;&amp;R==Pos)return t[p].mn; if(Pos&gt;R||Pos&lt;L)return inf; return std::min(querymin(p&lt;&lt;1,Pos),querymin(p&lt;&lt;1|1,Pos));&#125;void modifymin(int p,int l,int r,int w)&#123; int L=t[p].l,R=t[p].r; pushdown(p); if(l&lt;=L&amp;&amp;r&gt;=R)&#123; t[p].mn=std::min(t[p].mn,w); t[p].lazy=std::min(t[p].lazy,w); return; &#125; if(l&gt;R||r&lt;L)return; modifymin(p&lt;&lt;1,l,r,w); modifymin(p&lt;&lt;1|1,l,r,w); update(p);&#125;//endsegtint ans[N];int rangequerymax(int x,int y)&#123; int ans=0; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])std::swap(x,y); ans=std::max(ans,querymax(1,pos[top[x]],pos[x])); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y])std::swap(x,y); return std::max(ans,querymax(1,pos[y]+1,pos[x]));//!&#125;void rangemodifymin(int x,int y,int w)&#123; while(top[x]!=top[y])&#123; if(dep[top[x]]&lt;dep[top[y]])std::swap(x,y); modifymin(1,pos[top[x]],pos[x],w); x=fa[top[x]]; &#125; if(dep[x]&lt;dep[y])std::swap(x,y); modifymin(1,pos[y]+1,pos[x],w);//!&#125;void print(int p)&#123; printf("t[%2d]:%2d %2d %2d %2d %2d\n",p,t[p].l,t[p].r,t[p].mn&gt;1000?-1:t[p].mn,t[p].mx&gt;1000?t[p].mx:-1,t[p].lazy&gt;1000?-1:t[p].lazy); if(t[p].l==t[p].r)return; print(p&lt;&lt;1); print(p&lt;&lt;1|1);&#125;int main()&#123; int i; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=m;i++)scanf("%d%d%d",&amp;ed[i].b,&amp;ed[i].e,&amp;ed[i].l),ed[i].i=i; std::sort(ed+1,ed+m+1); krustal(); dfs1(1,0,1); dfs2(1,1); build(1,1,n); for(i=1;i&lt;=m;i++)if(!sign[ed[i].i])&#123; ans[ed[i].i]=rangequerymax(ed[i].b,ed[i].e)-1; rangemodifymin(ed[i].b,ed[i].e,ed[i].l); //print(1);puts(""); &#125; for(i=2;i&lt;=n;i++)ans[pre[i]]=querymin(1,pos[i])-1; for(i=1;i&lt;=m;i++)printf("%d ",ans[i]&lt;=1e9?ans[i]:-1); return 0;&#125; D 题目描述给一棵 $n$ 个节点为红蓝两色的树，节点标号从 $1$ 开始，其中 $1$ 号节点为红色，其它节点为蓝色，要求支持如下操作： 选择一个节点变为红色 查询一个节点到最近红色节点的距离 解题思路怎么还有这种操作$.jpg$ 储存超过$sqrt(n)$个红点的时候暴力$bfs$重置，询问的时候暴力计算距离。复杂度$O(a\sqrt n+blogn)$，$a,b$分别为操作$1,2$的个数。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;#define N 100002struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int hd[N],cnt;void add(int a,int b)&#123; e[++cnt].e=b; e[cnt].n=hd[a]; hd[a]=cnt;&#125;int siz,n,m;int sta[N],top;int dis[N];queue&lt;pair&lt;int,int&gt;&gt;Q;void bfs()&#123; int i; for(i=1;i&lt;=top;i++)Q.push(make_pair(sta[i],0)),dis[sta[i]]=0; while(!Q.empty())&#123; int p=Q.front().first,d=Q.front().second+1;Q.pop(); for(i=hd[p];i;i=e[i].n) if(dis[e[i].e]&gt;d)dis[e[i].e]=d,Q.push(make_pair(e[i].e,d)); &#125; top=0;&#125;int d[N],fa[22][N],lg[N];void dfs(int now,int f)&#123; dis[now]=dis[f]+1; d[now]=d[f]+1; fa[0][now]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++)fa[i][now]=fa[i-1][fa[i-1][now]]; for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=f)dfs(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y])x=fa[lg[d[x]-d[y]]][x]; if(x==y)return x; for(i=lg[d[x]];~i;i--)if(fa[i][x]!=fa[i][y])x=fa[i][x],y=fa[i][y]; return fa[0][x];&#125;int main()&#123; int i,t,v,u; scanf("%d%d",&amp;n,&amp;m); siz=sqrt(n)+1; for(i=1;i&lt;n;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v),add(v,u); for(i=2;i&lt;=n;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); dis[0]=-1; dfs(1,0); while(m--)&#123; scanf("%d%d",&amp;t,&amp;v); if(t==1)&#123; sta[++top]=v; if(siz==top)bfs(); &#125;else&#123; int ans=dis[v]; for(i=1;i&lt;=top;i++)ans=min(ans,d[v]+d[sta[i]]-2*d[lca(v,sta[i])]); printf("%d\n",ans); &#125; &#125; return 0;&#125; E 题目描述给定一棵点权为$0/1$的，以编号 $1$ 的节点为根的树。对每个点$x$可以进行如下操作，把自己的点权异或上$1$，把自己儿子的点权异或上$0$ ， 把儿子的儿子点权异或上$1$，依次类推；即$x$子树中，距离$x$为偶数的点的点权均异或上$1$。 求最少操作次数，使得每个点的点权全部变成给定的一组目标点权。 解题思路暴力从根向下贪心即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;int n;#define N 100010struct Edge&#123; int end,near;&#125;e[N&lt;&lt;1];int cnt,head[N];void add(int a,int b)&#123; e[++cnt].end=b;e[cnt].near=head[a];head[a]=cnt;&#125;int tar[N],fir[N],ans;int sta[N];void solve(int p,int flag,int nxt,int f)&#123; int i; if((tar[p]^flag)!=fir[p])sta[ans++]=p; if(nxt==0)&#123; if(tar[p]!=fir[p])nxt=1,flag=0; &#125;else if(nxt==1)&#123; if(tar[p]!=fir[p])&#123; if(flag)flag=0; else nxt=2,flag=1; &#125;else&#123; if(flag)nxt=flag=0; else flag=1; &#125; &#125;else&#123; if(tar[p]==fir[p])flag=nxt=1; &#125; for(i=head[p];i;i=e[i].near)&#123; int q=e[i].end; if(q==f)continue; solve(q,flag,nxt,p); &#125;&#125;int main()&#123; int i,u,v; scanf("%d",&amp;n); for(i=1;i&lt;n;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v),add(v,u); for(i=1;i&lt;=n;i++)scanf("%d",&amp;fir[i]); for(i=1;i&lt;=n;i++)scanf("%d",&amp;tar[i]); solve(1,0,0,0); printf("%d\n",ans); for(i=0;i&lt;ans;i++)printf("%d\n",sta[i]); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 4 题解]]></title>
    <url>%2F2019%2F05%2F14%2F2019springtraining-4%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F 6/6 Ø Ø Ø Ø Ø Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给一个$n\times m(1\leq n,m\leq 500)$的字符矩阵，问从左上角到右下角的路径（只能往右或者下走）中，有多少个路径得到的字符串为回文串。 解题思路考虑从左上和右下角同时向中间走，记录走的步数和两端对应的横坐标。$dp[i][j][k]$表示走了$i$步，左上角走到横坐标为$x$的位置，右下角走到横坐标为$y$的位置，处理一下边界即可递推解决。（怕超空间用了一下滚动数组） AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define w 1000000007#define N 502typedef long long ll;char a[N][N];ll dp[2][N][N];int main()&#123; int n,m,i,j,k; scanf("%d%d",&amp;n,&amp;m); int mx=(n+m-2)/2,p=0; for(i=1;i&lt;=n;i++)scanf("%s",a[i]+1); dp[0][1][n]=(a[1][1]==a[n][m]); for(i=1;i&lt;=mx;i++)&#123; p^=1; memset(dp[p],0,sizeof(dp[p])); for(j=max(1,i+2-m);j&lt;=n&amp;&amp;j&lt;=i+1;j++)&#123; int x1=j,y1=i-j+2; for(k=max(1,n-i);k&lt;=n&amp;&amp;k&lt;=n+m-i;k++)&#123; int x2=k,y2=n+m-i-k; if(a[x1][y1]==a[x2][y2]) dp[p][j][k]=(dp[p^1][j-1][k]+dp[p^1][j-1][k+1]+dp[p^1][j][k]+dp[p^1][j][k+1])%w; &#125; &#125; &#125; ll ans=0; if((n+m)&amp;1)for(i=1;i&lt;=n;i++)ans+=dp[p][i][i]+dp[p][i][i+1]; else for(i=1;i&lt;=n;i++)ans+=dp[p][i][i]; printf("%I64d\n",ans%w); return 0;&#125; B 题目描述给出长度为$n\leq 500000$的数组$a_i$，可以连续或间断输出，每连续输出一串$[l,r]$，它的费用是$\sum_{i=l}^{r}a_i^2+M$，求最小花费。 解题思路观察状态转移方程$f[i]=min(f[j]+(s[i]-s[j])^2+M)=M+S[i]^2+min(f[j]+s[j]^2-s[j]*s[i])$，尝试对该方程进行优化。从前向后递推，尝试用一种方法保证每次能够$O(1)$地查询到$min$所要求的$j$。对于任意在$j$前面出现的$k$，如果$j$比$k$优，则可以彻底移除$k$。 如果$j$比$k$优：$\frac{f[j]+s[j]^2-f[k]-s[k]^2}{2(f[j]-f[k])}\leq s[i]$，考虑对任意一个位置$i$构造点$(x_i,y_i)=(f[i]+s[i]^2,2f[i])$，则$k$到$j$的线段斜率如果小于$s[i]$则必然会被排除（因为$s[i]$会越变越大，随着$i$的增加$k$永远不如$j$优）。故维护一个单调队列，这个队列的单调性在于把这些位置对应的点连接起来的斜率严格单调增。每次取队首元素，添加队尾元素，即可保证复杂度的线性。 AC代码点击 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 500010ll s[N],f[N];int q[N],hd,tl;ll getup(int x,int y)&#123;return f[x]+s[x]*s[x]-f[y]-s[y]*s[y];&#125;ll getdown(int x,int y)&#123;return 2*s[x]-2*s[y];&#125;int main()&#123; int i,n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; hd=0;tl=1; for(i=1;i&lt;=n;i++)scanf("%d",&amp;s[i]),s[i]+=s[i-1]; for(i=1;i&lt;=n;i++)&#123; while(hd+1&lt;tl&amp;&amp;getup(q[hd+1],q[hd])&lt;=s[i]*getdown(q[hd+1],q[hd]))hd++; f[i]=f[q[hd]]+m+(s[i]-s[q[hd]])*(s[i]-s[q[hd]]); while(hd+1&lt;tl&amp;&amp;getup(q[tl-1],q[tl-2])*getdown(i,q[tl-1])&gt;=getup(i,q[tl-1])*getdown(q[tl-1],q[tl-2]))tl--; q[tl++]=i; &#125; printf("%lld\n",f[n]); &#125; return 0;&#125; C 题目描述给一个$n\times m(1\leq n,m\leq 12)$的玉米田，每一行只能选择有肥料的地方种植，行之间、列之间不允许有相邻的玉米种植，问总共有多少种种法。 解题思路一看数据范围这么小肯定是状态压缩 $dp[i][S]$表示填到第$i$行，这一行状态为$S$的时候有多少种方法。 AC代码点击 12345678910111213141516171819#include&lt;cstdio&gt;typedef long long ll;#define w 100000000#define N 14ll ans,f[N][1&lt;&lt;N]=&#123;1&#125;;int m,n,state[N];int main()&#123; int i,j,k,x; scanf("%d%d",&amp;m,&amp;n); int S=1&lt;&lt;n; for(i=1;i&lt;=m;i++)for(j=1;j&lt;=n;j++) scanf("%d",&amp;x),state[i]=(state[i]&lt;&lt;1)+x; for(i=1;i&lt;=m;i++)for(j=0;j&lt;S;j++) if(!(j&amp;(j&gt;&gt;1))&amp;&amp;!(j&amp;(j&lt;&lt;1))&amp;&amp;!(j&amp;(~state[i]))) for(k=0;k&lt;S;k++)if(!(k&amp;j))(f[i][j]+=f[i-1][k])%=w; for(i=0;i&lt;S;i++)(ans+=f[m][i])%=w; printf("%I64d",ans); return 0;&#125; D 题目描述一群人编号为$1-n$坐成一圈，一个人当且仅当坐在其编号左右两个位置时是高兴的。问$n(3\leq n\leq 2000)$个人中至少让$k$个人高兴有多少种方法。 解题思路先考虑求确定有$p$个人高兴的（可重复）方法$r[p]$，则恰好有$i$个人高兴的方法用容斥可以求出：$sum[i]=\sum_{j=i}^{n}r[j]\times (n-j)!\times C_j^i\times (-1)^{i-j}$那么答案即为$ans=\sum_{i=k}^{n}sum[i]$。 这里为什么不直接令$ans=r[k]$呢？因为$r[p]$使用动归递推得出，可能会有重复计算，具体请看下文。 第一感构造$dp[i][j]$表示填了$i$个人，有$j$个高兴的个数，但发现极难转化。 这时候本题最巧妙的地方到了。 构造一个长度为$N$的环，一个个往里面填人$i$，记录下来$n,1,i$三个点是否高兴的状态进行转移。最后统计答案的时候应当在某处断开构成一个环，所以需要记录第$i+1$个人的状态，以方便与$n,1$比较，方便去重。 故$dp[bit(n)bit(1)][bit(i+1)bit(i)][i][j]$表示状态分别为表示之时，填到第$i$个人，已经有$j$个人高兴的方法。 于是$r[i]=\sum_{a=0}^{3}\sum_{b=0}^{3}(!(a\&amp;1,b\&amp;2)\quad and\quad!(a\&amp;2,b\&amp;1))dp[a][b][n][i]$。（判断条件是为了去重） 边界：$i=1$的时候，$bit(1)=bit(i)$，故$dp[0][0][1][0]=1$（都不高兴），$dp[2][0][1][1]=1$（第$n$个人高兴），$dp[0][2][1][1]=1$（第$i+1$个人高兴），$dp[1][1][1][1]=1$（第$1$个人高兴）。 转移： $dp[a][b][i][j]$可以加一个人什么都不做转移到$dp[a][b&gt;&gt;1][i+1][j]$ $dp[a][b][i][j]$可以加一个人使得第$i+2$个人高兴，转移到$dp[a][(1&lt;&lt;1)|(b&gt;&gt;1)][i+1][j+1]$ 如果第$i$个人没有确定高兴，则$dp[a][b][i][j]$可以加一个人使得第$i$个人高兴，转移到$dp[a][b&gt;&gt;1][i+1][j+1]$，这里特判一下$i=1$的情况即可。 如果第$i+1$个人没有确定高兴，则$dp[a][b][i][j]$可以加一个人使得第$i+1$个人高兴，转移到$dp[a][1][i+1][j+1]$ 就结束了。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;typedef long long ll;#define N 2010ll w=1000000007,inv[N]=&#123;1&#125;,fac[N]=&#123;1&#125;;ll qp(ll a,ll b)&#123; ll ans=1; for(;b;b&gt;&gt;=1,a=a*a%w)if(b&amp;1)ans=ans*a%w; return ans;&#125;ll c(int n,int m)&#123;return fac[n]*inv[m]%w*inv[n-m]%w;&#125;ll dp[4][4][N][N];void add(ll &amp;a,ll b)&#123;(a+=b)%=w;if(a&lt;0)a+=w;&#125;void init()&#123; int i,j,a,b; for(i=1;i&lt;2001;i++)fac[i]=fac[i-1]*i%w,inv[i]=qp(fac[i],w-2); dp[0][0][1][0]=dp[2][0][1][1]=dp[1][1][1][1]=dp[0][2][1][1]=1; for(i=1;i&lt;2001;i++)&#123; for(j=0;j&lt;=i;j++)&#123; for(a=0;a&lt;4;a++)&#123; for(b=0;b&lt;4;b++)&#123; ll t=dp[a][b][i][j];if(!t)continue; add(dp[a][b&gt;&gt;1][i+1][j],t); if((b&amp;1)==0)&#123; if(i==1)add(dp[a|1][b&gt;&gt;1][i+1][j+1],t); else add(dp[a][b&gt;&gt;1][i+1][j+1],t); &#125; if((b&amp;2)==0)add(dp[a][1][i+1][j+1],t); add(dp[a][2|(b&gt;&gt;1)][i+1][j+1],t); &#125; &#125; &#125; &#125;&#125;ll r[N];int main()&#123; int i,j,a,b,T,n,k,cas=0; scanf("%d",&amp;T); init(); while(~scanf("%d%d",&amp;n,&amp;k))&#123; ll ans=0; for(j=k;j&lt;=n;j++)&#123; r[j]=0; for(a=0;a&lt;4;a++)for(b=0;b&lt;4;b++) if((a&amp;1)&amp;&amp;(b&amp;2)||(a&amp;2)&amp;&amp;(b&amp;1)); else add(r[j],dp[a][b][n][j]); &#125; for(i=k;i&lt;=n;i++)&#123; for(j=i;j&lt;=n;j++) add(ans,((j-i)&amp;1?-1:1)*(r[j]*fac[n-j]%w*c(j,i)%w)); &#125; printf("Case %d: %lld\n",++cas,ans); &#125; return 0;&#125; E 题目描述定义一个区间的价值为该区间中两两相等的元素个数。给一个长度为$n(2\leq n\leq 10^5)$的序列，把它分成$k(2\leq k\leq min(n,20))$段，求最小总价值。 解题思路设$dp[i][j]$表示选了前$i$个数，分成$j$段的最小总价值。则$dp[i][j]=min(dp[k][j-1]+w(k+1,i))$，$w(l,r)$表示$[l,r]$区间内的价值总和。 很明显，$i_1&gt;i_2$时，设决策点分别为$k_1,k_2$，则有$k_1\geq k_2$，即有决策单调性。 于是考虑分治求$dp$，从小到大枚举分成的段数进行$dp$，记当前计算区间为$[l,r]$，决策所在区间为$[L,R]$ ，则枚举$[L,R]$中的元素找到决策值$nxt$，分别计算$[l,mid-1]$（对应决策区间$[L,nxt]$）和$[mid+1,r]$（对应决策区间$[nxt,R]$）即可。时间复杂度$O(nklogn)$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100010int n,k,a[N];ll dp[N][22];int buc[N],pL,pR;ll nowans;void upd(int x,ll f)&#123; nowans+=f*buc[x]*(buc[x]-1)/2;&#125;ll calc(int l,int r)&#123; while(pL&lt;l)&#123; upd(a[pL],-1);buc[a[pL]]--; upd(a[pL],1);pL++; &#125; while(r&lt;pR)&#123; upd(a[pR],-1);buc[a[pR]]--; upd(a[pR],1);pR--; &#125; while(l&lt;pL)&#123; pL--; upd(a[pL],-1);buc[a[pL]]++; upd(a[pL],1); &#125; while(pR&lt;r)&#123; pR++; upd(a[pR],-1);buc[a[pR]]++; upd(a[pR],1); &#125; return nowans;&#125;void solve(int p,int L,int R,int l,int r)&#123; if(l&gt;r||L&gt;R)return; int i,mid=(l+r)&gt;&gt;1,nxt=0; ll &amp;ans=dp[mid][p]; for(i=L;i&lt;=R;i++)&#123; ll tmp=calc(i+1,mid); if(tmp+dp[i][p-1]&lt;ans)ans=tmp+dp[i][p-1],nxt=i; &#125; solve(p,L,nxt,l,mid-1); solve(p,nxt,R,mid+1,r);&#125;int main()&#123; int i; memset(dp,0x3f,sizeof(dp)); dp[0][0]=0; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); buc[a[1]]++;pL=pR=1; for(i=1;i&lt;=k;i++)solve(i,0,n-1,1,n); printf("%lld",dp[n][k]); return 0;&#125; F 题目描述给一个树每一个节点染黑白色，问恰好染$k$个黑色之后黑色点两两之间距离之和与白色点两两之间距离之和的和最大为多少。 解题思路这个树形$DP$很妙，可以找每一条边的贡献。用$f[i][j]$表示节点$i$的子树当前已经选择了$j$个黑色节点时当前节点已枚举子树中所有边对答案的贡献之和。 AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 2010struct Edge&#123; int e,n;ll l;&#125;e[N&lt;&lt;1];int hd[N],cnt;void add(int a,int b,ll l)&#123; e[++cnt]=(Edge)&#123;b,hd[a],l&#125;;hd[a]=cnt;&#125;int siz[N],n,k;ll f[N][N];void dfs(int x,int fa)&#123; int i,j,l; siz[x]=1; for(i=hd[x];i;i=e[i].n)&#123; int q=e[i].e; if(q==fa)continue; dfs(q,x); for(j=min(siz[x],k);j&gt;=0;j--) for(l=min(k-j,siz[q]);l&gt;=0;l--) f[x][j+l]=max(f[x][j+l],f[x][j]+f[q][l]+e[i].l*(1LL*(siz[q]-l)*(n-k+l-siz[q])+1LL*l*(k-l))); siz[x]+=siz[q]; &#125;&#125;int main()&#123; int i,u,v;ll w; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;n;i++)scanf("%d%d%lld",&amp;u,&amp;v,&amp;w),add(u,v,w),add(v,u,w); dfs(1,0); printf("%lld",f[1][k]); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 3 题解]]></title>
    <url>%2F2019%2F05%2F12%2F2019springtraining-3%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F 7/7 O O O Ø O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给一个串，求出是这个串前缀也是其后缀的所有子串，按照长度递增顺序输出长度和在该串中出现的次数。 解题思路用$kmp$算法求出$next(pre)$数组，那么沿着串最后跑$next$边得到的即是既是前缀也是后缀的串。统计个数的时候，每次可以匹配（前缀等于某个子串，即到某个位置时的后缀）时，都进行计数。最后从后往前沿$next$累加个数即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;cstring&gt;#define N 200005struct Ans&#123; int num,pos;&#125;ans[N];char b[N];int pre[N],cnt[N];int main()&#123; int i; scanf("%s",b); int len=strlen(b); for(i=1;i&lt;len;i++)&#123; int p=pre[i]; while(b[i]!=b[p]&amp;&amp;p)p=pre[p]; if(b[p]==b[i])pre[i+1]=p+1; else pre[i+1]=0; &#125; for(i=1;i&lt;len;i++)&#123; int p=pre[i]; while(b[i]!=b[p]&amp;&amp;p)p=pre[p]; if(b[p]==b[i])cnt[++p]++; &#125; for(i=len;i&gt;=0;i--)if(pre[i])cnt[pre[i]]+=cnt[i]; int now=len,p=0; while(now)&#123; ans[p++]=(Ans)&#123;cnt[now],now&#125;; now=pre[now]; &#125; printf("%d\n",p); for(i=p-1;i&gt;=0;i--)printf("%d %d\n",ans[i].pos,ans[i].num+1); return 0;&#125; B 题目描述给$n$个只由$abc$构成的模式串，$m$个询问串，每次询问该串是否能恰好改变一个位置的字符恰好与模式串中的某一个相等。 解题思路可以暴力用哈希做，枚举长度和改变的数值，调调参即可。 这东西$mod$和$base$凡是涉及到$19260817$老是$WA$，看来还是不能乱$\%$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 600010#define BASE 257#define mod 1000000007set&lt;ll&gt;s;char a[N];ll h()&#123; int i,l=strlen(a); ll now=0; for(i=0;i&lt;l;i++)now=(now*BASE+a[i])%mod; return now;&#125;ll pw[N]=&#123;1&#125;;int jud()&#123; int i,j,l=strlen(a); ll hash=h(); for(i=0;i&lt;l;i++) for(j='a';j&lt;='c';j++) if(j!=a[i]&amp;&amp;s.find(((hash+(j-a[i])*pw[l-i-1]%mod)%mod+mod)%mod)!=s.end())return 1; return 0;&#125;int main()&#123; int i,n,m; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;N;i++)pw[i]=pw[i-1]*BASE%mod; for(i=0;i&lt;n;i++) scanf("%s",a),s.insert(h()); for(i=0;i&lt;m;i++)&#123; scanf("%s",a); if(jud())printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; C 题目描述字符集大小为$4$，给一堆串作为子串时的权值（可为负），问长为$l$的字符串权值（初始为零，某一个带权子串出现则加上该串对应权值，但只能加一次）最大是多少。 解题思路在$AC$自动机上跑动态规划，$dp[i][j][S]$表示跑到串的第$i$个字符，在$AC$自动机上的节点为$j$，包含的带权字符串集合为$S$这个状态存在不存在。注意状态压缩和滚动数组。注意$ed$在$build$的时候需要根据$fail$更新。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 110#define M 1005int trans[520],dp[2][M][(1&lt;&lt;10)+10];char a[N];int tr[M][4],ed[M],fail[M],tot,score[N],number;void insert()&#123; int i,now=0; for(i=0;a[i];i++)&#123; int p=trans[(int)a[i]]; if(!tr[now][p])&#123; tr[now][p]=++tot; memset(tr[tot],0,sizeof(tr[tot])); &#125; now=tr[now][p]; &#125; ed[now]|=1&lt;&lt;number;&#125;queue&lt;int&gt;Q;void build()&#123; int i,p; for(i=0;i&lt;4;i++)if(tr[0][i])Q.push(tr[0][i]); while(!Q.empty())&#123; p=Q.front();Q.pop(); for(i=0;i&lt;4;i++)&#123; int now=tr[p][i]; if(!now)tr[p][i]=tr[fail[p]][i]; else fail[now]=tr[fail[p]][i],Q.push(now),ed[now]|=ed[fail[now]]; &#125; &#125;&#125;int n,m;int f(int x)&#123; int i,ret=0; for(i=0;i&lt;n;i++) if(x&amp;(1&lt;&lt;i))ret+=score[i+1]; return ret;&#125;int main()&#123; int i,j,k,l; trans['A']=0;trans['G']=1;trans['C']=2;trans['T']=3; while(~scanf("%d%d",&amp;n,&amp;m))&#123; memset(ed,0,sizeof(ed)); memset(fail,0,sizeof(fail)); memset(tr[0],0,sizeof(tr[0])); tot=0; for(i=0;i&lt;n;i++)&#123; number=i; scanf("%s%d",a,&amp;score[i+1]); insert(); &#125; build(); memset(dp,0,sizeof(dp)); dp[0][0][0]=1; int ret=-100,p=1; for(i=0;i&lt;m;i++)&#123; p^=1; memset(dp[p^1],0,sizeof(dp[p^1])); for(j=0;j&lt;=tot;j++)for(k=0;k&lt;1&lt;&lt;n;k++) if(dp[p][j][k]) for(l=0;l&lt;4;l++)dp[p^1][tr[j][l]][k|ed[tr[j][l]]]=1; &#125; for(j=0;j&lt;=tot;j++)for(k=0;k&lt;1&lt;&lt;n;k++) if(dp[p^1][j][k])ret=max(ret,f(k)); if(ret&gt;=0)printf("%d\n",ret); else printf("No Rabbit after 2012!\n"); &#125; return 0;&#125; D 题目描述问一个串中是否存在两个不相交的长度均为$k$的子串，使得串$T$为他们拼起来后串的子串。 解题思路分别从后向前、从前向后递推地求后缀的前缀和前缀的后缀，没处理到的情况特殊判断一下（在$k$之内）即可。注意特判$k&gt;m$（手动再见.jpg） AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;typedef long long ll;#define N 1000021#define BASE 257#define mod 1000000007char a[N],b[N];ll hsa[N],hsb[N],pw[N]=&#123;1&#125;;int n,m,k;void hashf(char c[],int l,ll *h)&#123; int i; for(i=1;i&lt;=l;i++)h[i]=(h[i-1]*BASE+c[i])%mod;&#125;int l[N],r[N];int main()&#123; int i; //freopen("in.txt","r",stdin); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); scanf("%s%s",a+1,b+1); for(i=1;i&lt;=n;i++)pw[i]=pw[i-1]*BASE%mod; hashf(a,n,hsa);hashf(b,m,hsb); for(i=m;i&lt;=n;i++)&#123; if((hsa[i]-hsa[i-m]*pw[m]%mod-hsb[m])%mod==0)&#123; if(i+k&lt;=n)return printf("Yes\n%d %d",i-m+1,i-m+k+1),0; else if(m&lt;k)&#123;//i-m~i int x=1; while(x+k+k-1&lt;i)x++; if(x+k+k-1&lt;=n)return printf("Yes\n%d %d",x,x+k),0; &#125; &#125; &#125; int p=k; for(i=1;i&lt;=m&amp;&amp;i&lt;=k;i++)&#123; while(p&lt;i)p++; while(p&lt;=n)if((hsa[p]-hsa[p-i]*pw[i]%mod-hsb[i])%mod==0)break;else p++; if((hsa[k]-hsa[k-i]*pw[i]%mod-hsb[i])%mod==0)p=k; l[i]=p; &#125; p=n-k+1; for(i=m;i&gt;=0;i--)&#123; int len=m-i+1; while(n-p+2&lt;len)p--; while(p&gt;0)if((hsa[p+len-1]-hsa[p-1]*pw[len]%mod-hsb[m]+hsb[i-1]*pw[len]%mod)%mod==0)break;else p--; if((hsa[n-k+len]-hsa[n-k]*pw[len]%mod-hsb[m]+hsb[i-1]*pw[len]%mod)%mod==0)p=n-k+1; r[i]=p; &#125; for(i=std::max(0,m-k);i&lt;=m;i++) if(l[i]&gt;=k&amp;&amp;r[i+1]&lt;=n-k+1&amp;&amp;l[i]&amp;&amp;r[i+1]&amp;&amp;l[i]&lt;r[i+1]) return printf("Yes\n%d %d",l[i]-k+1,r[i+1]),0; printf("No"); return 0;&#125; E 题目描述给一个模式串，给出匹配半径，求匹配串能够匹配的位置个数。 解题思路用四个$bitset$保存$ATGC$分别可以在哪里出现，使用差分求出这四个$bitset$。 接下来就是暴力匹配，复杂度可以勉强卡过去。题目很类似于buaa summer practice 2017 字符串专场中的$C$题。 听说正解是$FFT$，看来还是要学习一个。 AC代码点击 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define N 200010using namespace std;bitset&lt;N&gt;b[4],now;char s[N],t[N];int trans[500];int tmp[4][N];int main()&#123; int i,j,n,m,k; trans['A']=0;trans['G']=1;trans['C']=2;trans['T']=3; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); scanf("%s%s",s,t); for(i=0;i&lt;n;i++)&#123; tmp[trans[(int)s[i]]][max(i-k,0)]++; tmp[trans[(int)s[i]]][min(i+k+1,n)]--; &#125; for(i=0;i&lt;=n;i++) for(j=0;j&lt;4;j++)&#123; if(i)tmp[j][i]+=tmp[j][i-1]; if(tmp[j][i]&gt;0)b[j][i]=1; else b[j][i]=0; &#125; for(i=0;i&lt;n-m+1;i++)now[i]=1; for(i=0;i&lt;m;i++)&#123; int p=trans[(int)t[i]]; now&amp;=b[p]; now&lt;&lt;=1; now[0]=0; &#125; printf("%d",now.count()); return 0;&#125; $upd:$会用$FFT$辣！ 分成$ATGC$四部分解决，设$a[i]$表示第$i$位能否匹配当前字符$c$（$0/1$），很容易用差分求出该数组。再设$b[i]=(t[i]==c)$，于是$tot[i]=\sum_{j=0}^{m-1}b[j]\times a[i+j]$表示字符$c$在$i$位能够匹配多少个字符。 考虑把上面的式子转化成卷积的形式。 翻转字符串$T$，设$b[i]=(t[m-1-i]==c)$，则有$tot[i]=\sum_{j=0}^{m-1}b[m-1-j]\times a[i+j]=(b\times a)[i+m-1]$，$FFT$求出即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;typedef long long ll;struct complex&#123; double x,y; complex(double xx=0,double yy=0)&#123;x=xx;y=yy;&#125; complex operator+(const complex a)const&#123;return &#123;x+a.x,y+a.y&#125;;&#125; complex operator-(const complex a)const&#123;return &#123;x-a.x,y-a.y&#125;;&#125; complex operator*(const complex a)const&#123;return &#123;x*a.x-y*a.y,x*a.y+y*a.x&#125;;&#125;&#125;;#define N 800010complex a[N],b[N],wn1,wnk;int m,n,mx,limit;char s[N],t[N];int r[N];void fft(complex *F,int sign)&#123; int i,j,len; for(i=0;i&lt;limit;i++)if(i&lt;r[i])std::swap(F[r[i]],F[i]); for(len=1;len&lt;limit;len&lt;&lt;=1)&#123; wn1=complex(cos(acos(-1)/len),sign*sin(acos(-1)/len)); for(j=0;j&lt;limit;j+=(len&lt;&lt;1))&#123; wnk=complex(1,0); for(i=j;i&lt;j+len;i++)&#123; complex t=F[i+len]*wnk; F[i+len]=F[i]-t; F[i]=F[i]+t; wnk=wnk*wn1; &#125; &#125; &#125; if(sign==-1)for(i=0;i&lt;limit;i++)F[i].x/=limit;&#125;int tot[N],ans,k;void calc(char c)&#123; int i; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); for(i=0;s[i];i++)if(s[i]==c)a[std::max(i-k,0)].x++,a[i+k+1].x--; for(i=1;s[i];i++)a[i].x+=a[i-1].x; for(i=1;s[i];i++)a[i].x=!!a[i].x; for(i=0;t[i];i++)b[i].x=(t[i]==c); fft(a,1);fft(b,1); for(i=0;i&lt;limit;i++)a[i]=a[i]*b[i]; fft(a,-1); for(i=0;i&lt;n;i++)tot[i]+=(int)(0.5+a[i+m-1].x);&#125;int main()&#123; int i; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); scanf("%s%s",s,t); std::reverse(t,t+m); mx=m+n,limit=1; while(limit&lt;=mx)limit&lt;&lt;=1; for(i=0;i&lt;=limit;i++)r[i]=(r[i/2]/2)|((i&amp;1)?limit&gt;&gt;1:0); calc('A');calc('T');calc('G');calc('C'); for(i=0;i&lt;n;i++)if(tot[i]&gt;=m)ans++; printf("%d",ans); return 0;&#125; F 题目描述求一个串的最长回文子串长度。 解题思路签到题，打一遍马拉车的板子即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 1000010char s[2*N]=&#123;',','#'&#125;,a[N];int len[2*N],maxright,mid,max,l,i,cnt;int mn(int x,int y)&#123;return x&gt;y?y:x;&#125;int main()&#123; int cas=0; while(~scanf("%s",a))&#123; max=maxright=0; if(strcmp(a,"END")==0)break; cnt=2; int l=strlen(a); for(i=0;i&lt;l;i++)&#123; s[cnt++]=a[i]; s[cnt++]='#'; &#125; s[cnt]='\0'; for(i=1;i&lt;cnt;i++)&#123; if(i&lt;maxright)len[i]=mn(len[mid*2-i],maxright-i); else len[i]=1; while(s[i-len[i]]==s[i+len[i]])len[i]++; if(len[i]+i&gt;maxright)&#123; maxright=len[i]+i; mid=i; &#125; if(len[i]-1&gt;max)max=len[i]-1; &#125; printf("Case %d: %d\n",++cas,max); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vjudge297843-BUAA Summer Practice 2017 1 字符串专场 题解]]></title>
    <url>%2F2019%2F05%2F11%2Fbuaa2017string%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M 8/13 O O O . O . O O . . O O . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 密码：buaa A 题目描述问长度为$n$，给定的$m$个字符串都为$a$的连续子串的字符串$a$有多少种。 $1\leq n\leq 25,0\leq m\leq 10$ 解题思路看到$n,m$很小（$1&lt;&lt;10=1024$），很容易想到建立$AC$自动机进行爆搜记忆化搜索。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define N 105typedef long long ll;using namespace std;char a[25];int n,m,trie[N][26],fail[N],sign[N],tot;void add(int x)&#123; int now=0,i; for(i=0;a[i];i++)&#123; int p=a[i]-'a'; if(!trie[now][p])trie[now][p]=++tot; now=trie[now][p]; &#125; sign[now]|=1&lt;&lt;x;&#125;queue&lt;int&gt;Q;void build()&#123; int i,pos; for(i=0;i&lt;26;i++)if(trie[0][i])Q.push(trie[0][i]); while(!Q.empty())&#123; pos=Q.front();Q.pop(); for(i=0;i&lt;26;i++)&#123; if(trie[pos][i])&#123; fail[trie[pos][i]]=trie[fail[pos]][i]; Q.push(trie[pos][i]); sign[trie[pos][i]]|=sign[fail[trie[pos][i]]]; &#125;else trie[pos][i]=trie[fail[pos]][i]; &#125; &#125;&#125;ll f[27][N][1030];//f[len][pos][state]ll dp(int len,int state,int pos)&#123; ll &amp;ans=f[len][pos][state]; if(~ans)return ans; if(len==n)return ans=state==(1&lt;&lt;m)-1; int i; ans=0; for(i=0;i&lt;26;i++) ans+=dp(len+1,state|sign[trie[pos][i]],trie[pos][i]); return ans;&#125;char out[30];void print(int len,int state,int pos)&#123; if(len==n)&#123; fwrite(out,sizeof(out[0]),n,stdout); puts(""); return; &#125; int i; for(i=0;i&lt;26;i++)&#123; out[len]=i+'a'; if(f[len+1][trie[pos][i]][state|sign[trie[pos][i]]]&gt;0) print(len+1,state|sign[trie[pos][i]],trie[pos][i]); &#125;&#125;int main()&#123; int i,t=0; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;(n|m))&#123; t++; memset(trie,0,sizeof(trie)); memset(fail,0,sizeof(fail)); memset(f,-1,sizeof(f)); memset(sign,0,sizeof(sign)); tot=0; for(i=0;i&lt;m;i++)scanf("%s",a),add(i); build(); ll ans=dp(0,0,0); printf("Case %d: %lld suspects\n",t,ans); if(ans&lt;=42)print(0,0,0); &#125; return 0;&#125; B 题目描述给定一个字符串的马拉车$len$数组和后缀数组$sa$，求还原字典序最小的原串。 解题思路主要思路是，把每一个排名的数值视为一个点，具有相同的字符的多个位置用并查集缩成一个点，不等的之间连接边（这里从对应字符大的点到小的点连边）。有一点有趣的性质是，$sa$数组所对应的字符必然是单调不减的，于是可以设法找出每一个断点的位置。 所以根据马拉车$len$数组模仿跑一边马拉车，缩点连边，最后用$sa$数组进一步求出解。 这题的麻烦之处就在于各种地方不存在的判断。 具体的实现过程： 设$suffix(x)$为$s[x…n]$。 $Case 1$：$s[sa[i]]\leq s[sa[i+1]]$，而当等号不可能成立时必然有$rk[sa[i]+1]&gt;rk[sa[i+1]+1]$，此时需要连接$i+1,i$。 $Case 2$：跑马拉车回文串时，每次仍然只向外扩展未知字符并缩点。可以证明的是，这样保证了线性的复杂度，而并不会影响解的正确性。 每次向外扩展的时候，把左右两点缩成一点。 扩展完之后，把左右两点连边，并注意扩展的位置的合理性。 $Case 3$：最后从$rk$低到高填字符，并延必需边寻找最小可用字符，并判断点所处集合的合理性。 AC代码-人傻自带大常数，4792ms点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;#define N 100005typedef long long ll;using namespace std;int sa[N],rk[N],len[N&lt;&lt;1];char s[N];int hd[N],cnt,f[N];int find(int x)&#123;return x==f[x]?f[x]:f[x]=find(f[x]);&#125;struct Edge&#123; int e,n;&#125;e[N&lt;&lt;2];void add(int a,int b)&#123;e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;inline void scan(int &amp;x)&#123; register int ch; while((ch=getchar())&lt;'0'||ch&gt;'9'); for(x=ch-'0';(ch=getchar())&gt;='0'&amp;&amp;ch&lt;='9';x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch-'0'));&#125;int n,mr,mid;int solve()&#123; mr=1; int i,j,k,l,r,now,u,v; for(i=2;i&lt;=n&lt;&lt;1;i++)&#123; if(mr&gt;i)now=min(mr-i,len[(mid&lt;&lt;1)-i]+1); else now=0; if(now&gt;len[i]+1||i-len[i]&lt;1||i+len[i]&gt;(n&lt;&lt;1|1))return 0; l=i-now;r=i+now; for(;now&lt;=len[i];now++,l--,r++)&#123; if((l&amp;1)||l&gt;=r)continue; u=rk[l&gt;&gt;1],v=rk[r&gt;&gt;1]; if(u&gt;v)u^=v^=u^=v; u=find(u),v=find(v); while(u&lt;v)&#123; for(j=hd[u];j;j=e[j].n)if(u&lt;e[j].e)return 0; v=f[v]=find(v-1); &#125; &#125; if(l&gt;=2&amp;&amp;r&lt;=n&lt;&lt;1&amp;&amp;(l&amp;1)==0)&#123; u=rk[l&gt;&gt;1],v=rk[r&gt;&gt;1]; if(u&gt;v)add(u,v); else add(v,u); &#125;else if(l&amp;1)return 0; if(mr&lt;i+now)mr=i+now,mid=i; &#125; char mn='a',cur; for(i=1;i&lt;=n;i++)&#123; cur=mn; j=i+1; while(j&lt;=n&amp;&amp;find(i)==find(j))j++; for(k=i;k&lt;j;k++)&#123; for(l=hd[k];l;l=e[l].n)&#123; if(cur&lt;=s[sa[e[l].e]])cur=s[sa[e[l].e]]+1; if(find(e[l].e)==find(i))return 0; &#125; &#125; if(cur&gt;'z')return 0; while(i&lt;j)s[sa[i++]]=cur; mn=cur;i--; &#125; s[n+1]='\0'; return 1;&#125;int main()&#123; int i,T,cas=0; scan(T); while(T--)&#123; cnt=0; scan(n); memset(hd,0,sizeof(int)*(n+1)); for(i=1;i&lt;=n;i++)&#123; scan(sa[i]);sa[i]++; rk[sa[i]]=i; f[i]=i; &#125; rk[n+1]=-1; for(i=2;i&lt;=n;i++)if(rk[sa[i-1]+1]&gt;rk[sa[i]+1])add(i,i-1); len[0]=-1;len[1]=len[n&lt;&lt;1|1]=0; for(i=2;i&lt;=n&lt;&lt;1;i++)scan(len[i]); printf("Case #%d: ",++cas); if(solve())printf("%s\n",s+1); else printf("Wrong calculation!\n"); &#125; return 0;&#125; 然后看到$tls$也是这么做的，但是才跑了$500ms$，$\%\%\%$ AC代码-tls,502ms点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;const int maxn=100010,maxs=26;int t,n,sa[maxn],rk[maxn],ma[maxn&lt;&lt;1],tot,lnk[maxn],fa[maxn];char str[maxn];struct Edge&#123; int nxt,v;&#125;e[maxn&lt;&lt;2];inline void scan(int &amp;x)&#123; register int ch; while((ch=getchar())&lt;'0'||ch&gt;'9'); for(x=ch-'0';(ch=getchar())&gt;='0'&amp;&amp;ch&lt;='9';x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch-'0'));&#125;int find(int x)&#123; return x==fa[x]?x:fa[x]=find(fa[x]);&#125;int main()&#123; scan(t); for(int Case=1;Case&lt;=t;++Case)&#123; scan(n); tot=0; memset(lnk,-1,n*sizeof(int)); for(int i=0;i&lt;n;++i)&#123; scan(sa[i]); rk[sa[i]]=i; fa[i]=i; &#125; rk[n]=-1; for(int i=1;i&lt;n;++i) if(rk[sa[i-1]+1]&gt;rk[sa[i]+1])&#123; e[tot]=(Edge)&#123;lnk[i],i-1&#125;; lnk[i]=tot++; &#125; ma[0]=-1; ma[1]=ma[n&lt;&lt;1|1]=0; for(int i=2;i&lt;=n&lt;&lt;1;++i) scan(ma[i]); bool flag=1; for(int i=2,mx=1,id=1;i&lt;=n&lt;&lt;1&amp;&amp;flag;++i)&#123; int cur=mx&gt;i?std::min(mx-i,ma[(id&lt;&lt;1)-i]+1):0,pL,pR; flag&amp;=cur&lt;=ma[i]+1&amp;&amp;i-ma[i]&gt;0&amp;&amp;i+ma[i]&lt;n+1&lt;&lt;1; for(pL=i-cur,pR=i+cur;cur&lt;=ma[i]&amp;&amp;flag;++cur,--pL,++pR) if((~pL&amp;1)&amp;&amp;pL&lt;pR)&#123; int u=rk[(pL&gt;&gt;1)-1],v=rk[(pR&gt;&gt;1)-1]; if(u&gt;v) std::swap(u,v); for(u=find(u),v=find(v);u&lt;v&amp;&amp;flag;v=find(v))&#123; for(int it=lnk[v];it!=-1&amp;&amp;flag;it=e[it].nxt) flag&amp;=e[it].v&lt;u; fa[v]=find(v-1); &#125; &#125; if((flag&amp;=(~pL&amp;1))&amp;&amp;pL&gt;=2&amp;&amp;pR&lt;=n&lt;&lt;1)&#123; pL=rk[(pL&gt;&gt;1)-1]; pR=rk[(pR&gt;&gt;1)-1]; if(pL&gt;pR) std::swap(pL,pR); e[tot]=(Edge)&#123;lnk[pR],pL&#125;; lnk[pR]=tot++; &#125; if(mx&lt;i+cur)&#123; mx=i+cur; id=i; &#125; &#125; char last='a'; for(int i=0,j=0;i&lt;n&amp;&amp;flag;i=j)&#123; char cur=last; for(++j;j&lt;n&amp;&amp;find(i)==find(j);++j); for(int k=i;k&lt;j&amp;&amp;flag;++k) for(int it=lnk[k];it!=-1&amp;&amp;flag;it=e[it].nxt) if(find(e[it].v)==find(i)) flag=0; else if(cur&lt;=str[sa[e[it].v]]) cur=str[sa[e[it].v]]+1; if(cur&gt;'z') flag=0; else&#123; for( ;i&lt;j;++i) str[sa[i]]=cur; last=cur; &#125; &#125; str[n]='\0'; if(!flag) printf("Case #%d: Wrong calculation!\n",Case); else printf("Case #%d: %s\n",Case,str); &#125; return 0;&#125; C 题目描述如果一个长度为$n$的字符串$a$满足：对于任意$0&lt; i\leq |n|$，$a_i$属于集合$S_i$，则其是一个合法的串。 给定字符串$a$，集合$S_i(1\leq i\leq n)$，按读入顺序输出$a$中所有合法的连续子串。 $1\leq n \leq 1000,|a|\leq 5\times 10^6$。 解题思路看起来$|a|$比较大，似乎应当用一种比较快速、尽量能递推解决的算法解决。 构造一个$bitset$数组$b$，存放每一个元素$x$允许出现的位置$pos$，即对于每一个合法的位置，有$b[x][pos]=1$。 再构造一个$bitset$存储当前匹配状态$now$，每一次$now$左移$1$（代表开始匹配下一位），最低位设置成$1$（还未判断匹配情况），位运算进行匹配（与对应$b[x]$进行与运算），则如果$now$的第$n$位为$1$，就说明已经匹配成功，输出即可。 AC代码点击 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;bitset&gt;using namespace std;char c[5000001],t;bitset&lt;1001&gt;b[11],now;int main()&#123; int i,n,k,a; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;k); while(k--)scanf("%d",&amp;a),b[a][i]=1; &#125; scanf("%s",c); for(i=0;c[i];i++)&#123; ((now&lt;&lt;=1).set(0))&amp;=b[c[i]-'0']; if(now[n-1])fwrite(c+i-n+1,sizeof(c[0]),n,stdout),putchar('\n'); &#125; return 0;&#125; D 题目描述解题思路AC代码点击 12 E 题目描述给一个长度$1\leq N\leq 5\times 10^5$的串。每次从头扯下来一个字符粘到尾端，进行$k$次这样的操作（$0\leq k&lt;N$），输出每次操作后串中最长回文子串的长度。 解题思路首先想到的办法是，建立一棵回文树，每次添加一个节点，并用一个堆保存当前回文串的位置、长度、回文树中的节点标号，每次被弹出堆的时候，沿$fail$边走并入堆。然而很不幸的是，这样无法保证时间复杂度，$26$个点只过了$18$个，剩下的都$T$掉了。 TLE代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;typedef struct node&#123; int xb,len,i; bool operator&lt;(const node&amp;a)const&#123;return len&lt;a.len;&#125;&#125;nd;priority_queue&lt;nd&gt;Q;#define N 500005#define M 26int length;struct PT&#123; int tr[N][M],fail[N],len[N]; int tot,s[N],n,last,i; int newnode(int l)&#123; for(i=0;i&lt;M;i++)tr[tot][i]=0; len[tot]=l; return tot++; &#125; void init()&#123; n=last=tot=0; newnode(0);newnode(-1); s[0]=-1; fail[0]=1; &#125; int getfail(int po,int p)&#123; while(s[n-len[p]-1]!=s[n]||len[p]+2&gt;length)p=fail[p]; return p; &#125; void add(int po,int p)&#123; s[++n]=p; int cur; cur=getfail(po,last); last=fail[cur]; if(!tr[cur][p])&#123; int now=newnode(len[cur]+2),temp=getfail(po,fail[cur]); fail[now]=tr[temp][p]; tr[cur][p]=now; &#125; last=tr[cur][p]; Q.push((nd)&#123;tr[cur][p],len[tr[cur][p]],po&#125;); &#125;&#125;p;char a[N];int main()&#123; int i; p.init(); scanf("%d",&amp;length); scanf("%s",a); for(i=0;a[i];i++) p.add(i,a[i]-'a'); for(i=0;a[i];i++)&#123; nd t=Q.top(); printf("%d\n",Q.top().len); p.add(i+length,a[i]-'a'); t=Q.top(); while(t.i-t.len&lt;i)&#123; Q.pop(); while(-p.len[p.fail[t.xb]]+t.i&lt;i&amp;&amp;t.len&gt;1) t=(nd)&#123;p.fail[t.xb],p.len[p.fail[t.xb]],t.i&#125;; if(t.len&gt;1)Q.push((nd)&#123;p.fail[t.xb],p.len[p.fail[t.xb]],t.i&#125;); if(Q.empty())break; t=Q.top(); &#125; &#125; return 0;&#125; 过后，想到了一种暴力办法：直接复制串到串的后面，跑一遍马拉车，记录下以某个点为中心的奇数、偶数回文串的长度，分奇偶解决，解决的时候长度从大到小、位置从大到小枚举，记录只最靠后的超出范围的回文串的中心位置$full$，每次根据$full$和$set$中的合法答案更新答案即可。 发现从前往后一上来只能枚举到一半才能之后的保证每次的扩展合理，故反转字符串再跑一遍马拉车、分奇偶再解决一遍即可。 然后$A$了。 AC代码-12860ms点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define N 2000005using namespace std;typedef pair&lt;int,int&gt; ii;char s[N],a[N&lt;&lt;1];int n,odd[N],even[N],len[N&lt;&lt;1],ans[2][N];void manacher()&#123; n&lt;&lt;=1; memset(len,0,sizeof(len)); int m=n&lt;&lt;1,i,mr=0,mid; for(i=0;i&lt;=m;i+=2)a[i]='#'; for(i=0;i&lt;n;i++)a[i*2+1]=s[i+1]; for(i=0;i&lt;=m;i++)&#123; if(i&lt;mr)len[i]=min(len[2*mid-i],mr-i); while(a[i+len[i]]&amp;&amp;a[i+len[i]]==a[i-len[i]])len[i]++; if(i+len[i]&gt;mr)mr=i+len[i],mid=i; &#125; for(i=1;i&lt;=n;i++)odd[i]=len[(i-1)*2+1]/2*2-1; for(i=1;i&lt;=n;i++)even[i-1]=len[(i-1)*2]/2*2; n&gt;&gt;=1;&#125;void solveOdd(int w)&#123; int full=0,i; set&lt;ii&gt;S; for(i=1;i&lt;=(n+1)/2;i++)S.insert(&#123;odd[i],i&#125;); for(i=1;i&lt;=n;i++)&#123; while(S.size())&#123; int x=S.rbegin()-&gt;first,id=S.rbegin()-&gt;second; if(id&lt;i)&#123; S.erase(*S.rbegin()); continue; &#125; if(x&gt;(id-i+1)*2-1)&#123; full=max(full,id); S.erase(*S.rbegin()); continue; &#125; break; &#125; if(S.size())ans[w][i]=max(ans[w][i],S.rbegin()-&gt;first); if(full&gt;=i)ans[w][i]=max(ans[w][i],(full-i+1)*2-1); S.insert(&#123;odd[(n+1)/2+i],(n+1)/2+i&#125;); &#125;&#125;int get(int p)&#123;return min(p,n-p)*2;&#125;void solveEven(int w)&#123; int full=0,i; set&lt;ii&gt;S; for(i=1;i&lt;=(n+1)/2;i++)S.insert(&#123;even[i],i&#125;); for(i=1;i&lt;=n;i++)&#123; while(S.size())&#123; int x=S.rbegin()-&gt;first,id=S.rbegin()-&gt;second; if(id&lt;i)&#123; S.erase(*S.rbegin()); continue; &#125; int mx=get(id-i+1); if(x&gt;mx)&#123; full=max(full,id); S.erase(*S.rbegin()); continue; &#125; break; &#125; if(S.size())ans[w][i]=max(ans[w][i],S.rbegin()-&gt;first); if(full&gt;=i)ans[w][i]=max(ans[w][i],get(full-i+1)); S.insert(&#123;even[(n+1)/2+i],(n+1)/2+i&#125;); &#125;&#125;int main()&#123; scanf("%d%s",&amp;n,s+1); int i; for(i=1;i&lt;=n;i++)s[i+n]=s[i]; manacher();solveOdd(0);solveEven(0); reverse(s+1,s+n*2+1); manacher();solveOdd(1);solveEven(1); printf("%d\n",max(ans[0][1],ans[1][1])); for(i=2;i&lt;=n;i++)printf("%d\n",max(ans[0][i],ans[1][n+1-i+1])); return 0;&#125; 似乎可以从头和尾分别加入和删除，过后学习一下再写写试试。 参考文献 待补代码点击 12 顺便贴一下标程。 标程代码-2336ms点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int MAXN=5e5,MAXX=MAXN&lt;&lt;1,MAXLEAVES=1&lt;&lt;19;char S[MAXX+1];int R[2][MAXX+1],fsize,T[2][MAXX+1];void manacher(const int length,const int rx)&#123; register int i,j,k; int *table=R[rx]; for(i=j=0;i&lt;length;i+=k,j=max(j-k,0))&#123; while(i-j&gt;=0&amp;&amp;i+j+rx&lt;length&amp;&amp;S[i-j]==S[i+j+rx])++j; table[i]=j; for(k=1;k&lt;j&amp;&amp;table[i-k]!=table[i]-k;++k)&#123; table[i+k]=min(table[i-k],table[i]-k); &#125; &#125;&#125;int tree[(MAXLEAVES&lt;&lt;1)+1],rval,ileft,iright,leaves;void update_tree(const int x,const int left,const int right)&#123; if(ileft&gt;right||iright&lt;left)&#123; return; &#125; if(ileft&lt;=left&amp;&amp;right&lt;=iright)&#123; //node completely inside the update interval tree[x]=max(tree[x],rval); &#125; else&#123; int mid=(left+right)&gt;&gt;1; update_tree(x&lt;&lt;1,left,mid); update_tree((x&lt;&lt;1)+1,mid+1,right); &#125;&#125;void adjust_and_gather(const int pos,const int parity)&#123; int &amp;ptr=R[parity][pos]; int diff=(ptr&lt;&lt;1)-(!parity)-fsize,lx,rx,flen; if(diff&gt;0)&#123; diff+=(diff&amp;1); ptr-=diff&gt;&gt;1; &#125; lx=pos-ptr+1; rx=pos+ptr-(parity==0); flen=(ptr&lt;&lt;1)-(!parity); if((parity==0&amp;&amp;ptr&gt;1)||(parity==1&amp;&amp;ptr&gt;0))&#123; T[0][lx]=max(T[0][lx],flen); T[1][rx]=max(T[1][rx],flen); ileft=max(0,rx-fsize+1),iright=min(fsize-1,lx); rval=flen; update_tree(1,0,leaves-1); &#125;&#125;inline void process_manacher_table(const int length)&#123; for(register int i=0;i&lt;length;++i)&#123; adjust_and_gather(i,0);//odd length; adjust_and_gather(i,1);//even length; &#125;&#125;inline int read_tree(const int pos)&#123; register int x=pos+leaves; int result=1; while(x)&#123; result=max(result,tree[x]); x&gt;&gt;=1; &#125; return result;&#125;inline void init_leaves(const int n)&#123; leaves=1; while(leaves&lt;n)&#123; leaves&lt;&lt;=1; &#125;&#125;int main()&#123; int N,i,answer; scanf("%d%s",&amp;N,S); memcpy(S+N,S,(N-1)*sizeof(char)); init_leaves(N); fsize=N,N=(N&lt;&lt;1)-1; manacher(N,0);//odd length; manacher(N,1);//even length; process_manacher_table(N); for(i=1;i&lt;N;++i)&#123; T[0][i]=max(T[0][i],T[0][i-1]-2); T[1][N-i-1]=max(T[1][N-i-1],T[1][N-i]-2); &#125; for(i=0;i&lt;fsize;++i)&#123; answer=read_tree(i); answer=max(answer,T[0][i]); answer=max(answer,T[1][i+fsize-1]); printf("%d\n",answer); &#125; return 0;&#125; F 题目描述解题思路AC代码点击 12 G 题目描述定义一个$S$的真子串$T$为边界子串，当且仅当$T$为$S$的真前缀和真后缀，定义函数$P(l,r)$表示串$S[l,r]$的回文的边界子串个数。 给定一个串$S$（$|S|\leq 1e5$），求$\sum_{l\leq i\leq j\leq |S|}P(i,j)$。 解题思路考虑每一种回文子串对答案的贡献，设其出现的次数为$cnt$，则其贡献为$\frac {(cnt+1)cnt}2$。 然后就变成回文树裸题了。注意$LL$！ AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;#define N 100010#define P 8typedef long long ll;ll ans,w=1000000007LL;struct PAM&#123; int i,last,tot,n; int tr[N][P],s[N]; int fail[N],len[N],cnt[N]; int newnode(int l)&#123; for(i=0;i&lt;P;i++)tr[tot][i]=0; len[tot]=l; cnt[tot]=0; return tot++; &#125; void init()&#123; last=tot=n=0; newnode(0);newnode(-1); s[0]=-1; fail[0]=1; &#125; int getfail(int p)&#123; while(s[n-len[p]-1]!=s[n])p=fail[p]; return p; &#125; void add(int x)&#123; s[++n]=x; int cur=getfail(last); if(!tr[cur][x])&#123; int now=newnode(len[cur]+2); fail[now]=tr[getfail(fail[cur])][x]; tr[cur][x]=now; &#125; last=tr[cur][x]; cnt[last]++; &#125; void count()&#123; for(i=tot-1;i&gt;=0;i--)cnt[fail[i]]+=cnt[i]; &#125;&#125;p;char a[N];int main()&#123; int i; scanf("%s",a); p.init(); for(i=0;a[i];i++)p.add(a[i]-'a'); p.count(); for(i=2;i&lt;p.tot;i++)ans=(ans+1LL*p.cnt[i]*(p.cnt[i]-1)/2%w)%w; printf("%lld",ans); return 0;&#125; H 题目描述给$n$个长度小于$30$的小写字母字符串，选取任意两个（可以相同）字符串的任意前缀$a$和$b$，连接形成新的串$S=ab$。问本质不同的$S$共有多少种。 解题思路显然，如果给定串为另一个给定串的前缀，则可以忽略掉它。所以先建立一棵$trie$树，考虑任意两个节点都代表一个前缀，答案初步定为$tot\times tot$（$tot$为$trie$节点数）。 然后考虑除重。假设$a,ab,bc,c$都为合理的前缀，则串$abc$可以由$a$和$bc$组成，亦可由$ab$和$c$组成。对于任意一个节点$i$对应的前缀$b$，假设当它作为$S$的后缀时的方案数为$t_i$，则答案数即为$tot\times tot-\sum_{i=1}^{tot}(t_i-1)$。 考虑如何求$t_i$，建立一棵$fail$树，根据$fail$树的性质：一个节点对应的串为（该节点子树大小个）前缀的后缀。于是在$fail$树上$dfs$算出子树大小，则$t_i=sum[rt]$（$rt$代表该串对应的最靠近根节点的节点）。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;#define N 300010typedef long long ll;using namespace std;int len[N],t[N][26],fail[N],sum[N],fa[N],tot;char a[40];void ins()&#123; int i,now=0,p; for(i=0;a[i];i++)&#123; p=a[i]-'a'; if(!t[now][p]) t[now][p]=++tot,len[tot]=len[now]+1,fa[tot]=now; now=t[now][p]; &#125;&#125;queue&lt;int&gt;Q;void build()&#123; int i,p; for(i=0;i&lt;26;i++)if(t[0][i])Q.push(t[0][i]); while(!Q.empty())&#123; p=Q.front();Q.pop(); for(i=0;i&lt;26;i++)&#123; if(!t[p][i])t[p][i]=t[fail[p]][i]; else fail[t[p][i]]=t[fail[p]][i],Q.push(t[p][i]); &#125; &#125;&#125;struct Edge&#123; int e,n;&#125;e[N];int hd[N],cnt;void add(int a,int b)&#123; e[++cnt].e=b; e[cnt].n=hd[a]; hd[a]=cnt;&#125;void dfs(int p)&#123; int i; sum[p]=1; for(i=hd[p];i;i=e[i].n)&#123; int q=e[i].e; dfs(q); sum[p]+=sum[q]; &#125;&#125;int main()&#123; int i,n; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; memset(len,0,sizeof(len));tot=0; memset(sum,0,sizeof(sum)); memset(t,0,sizeof(t)); memset(fa,0,sizeof(fa)); memset(fail,0,sizeof(fail)); memset(hd,0,sizeof(hd));cnt=0; for(i=0;i&lt;n;i++)scanf("%s",a),ins(); build(); for(i=1;i&lt;=tot;i++)add(fail[i],i); dfs(0); ll ans=1LL*tot*tot; for(i=1;i&lt;=tot;i++)&#123; if(fail[i])&#123; int temp=len[fail[i]],now=i; while(temp--)now=fa[now]; ans-=(sum[now]-1); &#125; &#125; printf("%lld\n",ans); &#125; return 0;&#125; I 题目描述解题思路AC代码点击 12 J 题目描述解题思路AC代码点击 12 K 题目描述定义一个串是好串，当且仅当它可以表示成$A+B+…+A+B+A$的形式，其中$A,B$可以为空，分别出现了$k+1$次和$k$次。 给定一个字符串$a(1\leq |a|\leq 10^6)$和$k(1\leq k\leq 10^6)$，求每一个前缀是否是好串。 解题思路假设字符串$s$的前$i$位为$ABAB…ABA$，则显然，$AB…ABA$和$ABAB…A$可以匹配。 于是用$kmp$字符串匹配的思想自己匹配自己，有$|BA|=i-nxt[i]$。 如果$B$可以为空，也即$s$的前$i$位为$SS…S(共出现num=\frac i{|BA|}次)$，也即$i\%|BA|==0$，则只需要满足分成恰好$k$段后的剩余段长度小于等于前面段长度（设新生成的前面段$|A|$为$SS…S(共出现\frac{num}k次)$，剩余段为$SS…S(共出现num\%k次)$，则需要满足$\frac{num}k\geq num\%k$）。 否则，同理可分析出要求为$\frac{num}k&gt;num\%k$。 AC代码点击 1234567891011121314151617181920#include&lt;stdio.h&gt;#define N 1000005int n,k;char a[N];int nxt[N],ans[N];int main()&#123; int i,j=0; scanf("%d%d",&amp;n,&amp;k); scanf("%s",a); for(i=1;i&lt;=n;i++)&#123; while(j&amp;&amp;a[i]!=a[j])j=nxt[j]; if(a[i]==a[j])j++; nxt[i+1]=j; int r=i-nxt[i],num=i/r; if(i%r)ans[i]=num/k&gt;num%k; else ans[i]=num/k&gt;=num%k; &#125; for(i=1;i&lt;=n;i++)printf("%d",ans[i]); return 0;&#125; L 题目描述给两个字符串$A,B(1\leq |A|,|B|\leq 2\times 10^5)$，求不同的公共回文子串$P,Q$个数，重复出现也要算入。 解题思路使用两棵回文树，分别在偶数根和奇数根上同时深搜，把结果加起来即可。 刚学习回文树，感觉十分巧妙。大致说一下它的思路。 不同于$AC$自动机，回文树的建立基于对每一个回文串的中心向两端扩张，树上的每一个节点代表的是一种回文串，所以$fail$指针指向的是与当前节点具有最长公共回文后缀的串的树上的节点位置（不是字符位置！不是字符位置！）。最初状态只有两个树根，分别为奇数长度回文串的树根和偶数长度回文串的树根。每次添加一个节点$p$的时候，找到上一个节点$last$的最长回文后缀$S$，使得新形成的$pSp$为回文串。当然，如果找不到，那只能让$p$单独成为一个回文串。 用$len[i]$表示节点$i$代表的回文串长度，$cnt[i]$表示这个回文串出现的次数，剩下的就是在$fail$上面跳就好了。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#define N 200005typedef long long ll;struct PT&#123; int tr[N][26],fail[N],cnt[N]/*,num[N]*/,len[N]; int tot,s[N],n,last,i; int newnode(int l)&#123; for(i=0;i&lt;26;i++)tr[tot][i]=0; cnt[tot]=0; len[tot]=l; //num[tot]=l; return tot++; &#125; void init()&#123; n=last=tot=0; newnode(0);newnode(-1);//建立两个树根 s[0]=-1;//奇数回文树树根len=-1 fail[0]=1;//奇数的fail指向偶数树根 &#125; int getfail(int p)&#123; while(s[n-len[p]-1]!=s[n])p=fail[p];//找到最长的能构成回文串的节点 return p; &#125; void add(int p)&#123; s[++n]=p; int cur=getfail(last); if(!tr[cur][p])&#123; int now=newnode(len[cur]+2);//向两端扩张，长度+2 fail[now]=tr[getfail(fail[cur])][p]; tr[cur][p]=now; //num[now]=num[fail[now]]+1; &#125; last=tr[cur][p]; cnt[last]++; &#125; void count()&#123; for(i=tot-1;i&gt;=0;i--)cnt[fail[i]]+=cnt[i]; &#125;&#125;p1,p2;char a[N],b[N];ll dfs(int a,int b)&#123; ll ans=0;int i; for(i=0;i&lt;26;i++) if(p1.tr[a][i]&amp;&amp;p2.tr[b][i]) ans+=1LL*p1.cnt[p1.tr[a][i]]*p2.cnt[p2.tr[b][i]]+dfs(p1.tr[a][i],p2.tr[b][i]); return ans;&#125;int main()&#123; int i,j,t; scanf("%d",&amp;t); for(i=1;i&lt;=t;i++)&#123; p1.init();p2.init(); scanf("%s%s",a,b); for(j=0;a[j];j++)p1.add(a[j]-'a'); for(j=0;b[j];j++)p2.add(b[j]-'a'); p1.count();p2.count(); printf("Case #%d: %lld\n",i,dfs(0,0)+dfs(1,1)); &#125; return 0;&#125; M 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vjudge299952-后缀数组练习 题解]]></title>
    <url>%2F2019%2F05%2F05%2Fvjudge299952suffixarraypractice%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M N O P Q 5/17 O O O O O . . . . . . . . . . . . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 最近在学习后缀数组，打一场练习。 密码：buaa 故事开始的地方 比赛链接 A 题目描述求一个串的差分串的最长不重叠相同子串。 解题思路问题3 唯一区别在于差分串导致的$jud$函数中$\geq$变为$&gt;$。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 20010int s[N],n;int x[N],y[N],c[N],sa[N],rank[N],height[N];void getsa()&#123; int i,k,m=200; n++; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]=s[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i]; std::swap(x,y); num=1; x[sa[0]]=0; for(i=1;i&lt;n;i++) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++; if(num&gt;=n)break; m=num; &#125; n--;&#125;void getheight()&#123; int i,j,k=0; for(i=1;i&lt;=n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125;int jud(int x)&#123; int i,mn=1e9,mx=-1e9; for(i=0;i&lt;=n;i++)&#123; if(height[i]&lt;x)mn=mx=sa[i]; else&#123; mn=std::min(mn,sa[i]); mx=std::max(mx,sa[i]); if(mx-mn&gt;x)return 1; &#125; &#125; return 0;&#125;int main()&#123; int i; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; for(i=0;i&lt;n;i++)scanf("%d",&amp;s[i]); for(i=0;i&lt;n-1;i++)s[i]=s[i+1]-s[i]+90;s[n-1]=0; getsa();getheight(); int l=0,r=n,ans=0; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(jud(mid))l=mid+1,ans=mid; else r=mid; &#125; if(ans&gt;=4)printf("%d\n",ans+1); else printf("0\n"); &#125; return 0;&#125; B 题目描述求一个串中最长的出现$k$次的可重叠子串。 解题思路同样二分，每一个组的串个数$\geq k$即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 20010int s[N],n;int x[N],y[N],c[N],sa[N],rank[N],height[N];int k;void getsa()&#123; int i,k,m=1000000; n++; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]=s[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i]; std::swap(x,y); num=1; x[sa[0]]=0; for(i=1;i&lt;n;i++) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++; if(num&gt;=n)break; m=num; &#125; n--;&#125;void getheight()&#123; int i,j,k=0; for(i=1;i&lt;=n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125;int jud(int x)&#123; int i,num=0; for(i=0;i&lt;=n;i++)&#123; if(height[i]&lt;x)num=1; else if(++num&gt;=k)return 1; &#125; return 0;&#125;int main()&#123; int i; while(~scanf("%d%d",&amp;n,&amp;k)&amp;&amp;n)&#123; for(i=0;i&lt;n;i++)scanf("%d",&amp;s[i]); getsa();getheight(); int l=0,r=n,ans=0; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(jud(mid))l=mid+1,ans=mid; else r=mid; &#125; printf("%d\n",ans); &#125; return 0;&#125; C 题目描述求一个串中所有不同的子串。 解题思路因为每一个子串都是某一个后缀的前缀，考虑加入每一个后缀的贡献。 每加入一个后缀$suffix(i)$，其与前面的重复的前缀个数为$height[i]$。于是答案为$\frac {n\times (n+1)}2 -\sum_{i=1}^{n}height[i]$。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;typedef long long ll;#define N 1000010char s[N];int x[N],y[N],sa[N],c[10*N],rank[N],height[N],n;void getsa()&#123; int i,k,m=10000; n++; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]=s[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i]; std::swap(x,y); num=1; x[sa[0]]=0; for(i=1;i&lt;n;i++) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++; if(num&gt;=n)break; m=num; &#125; n--;&#125;void getheight()&#123; int i,j,k=0; for(i=0;i&lt;=n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125;void solve()&#123; ll ans=1LL*n*(n+1)/2; int i; for(i=1;i&lt;=n;i++)ans-=height[i]; printf("%lld\n",ans);&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",s); n=strlen(s); getsa(); getheight(); solve(); &#125; return 0;&#125; D 题目描述这题跟上一题重了… 解题思路同上 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;typedef long long ll;#define N 1000010char s[N];int x[N],y[N],sa[N],c[10*N],rank[N],height[N],n;void getsa()&#123; int i,k,m=10000; n++; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]=s[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i]; std::swap(x,y); num=1; x[sa[0]]=0; for(i=1;i&lt;n;i++) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++; if(num&gt;=n)break; m=num; &#125; n--;&#125;void getheight()&#123; int i,j,k=0; for(i=0;i&lt;=n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125;void solve()&#123; ll ans=1LL*n*(n+1)/2; int i; for(i=1;i&lt;=n;i++)ans-=height[i]; printf("%lld\n",ans);&#125;int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",s); n=strlen(s); getsa(); getheight(); solve(); &#125; return 0;&#125; E 题目描述给定若干个长度 $≤ 1000000$ 的字符串，询问每个字符串最多是由多少个相同的子字符串重复连接而成的。如：ababab 则最多有 $3$ 个 ab 连接而成。 解题思路枚举循环节，如果$l$是最小循环节长度，则有$s[0…n-l-1]==s[l…n-1]$。 思路1：后缀数组如果$l$为最小循环节长度，则必有$rank[0]==rank[l]+1$且$height[rank[0]]==n-l$。 数据范围需要$DC3$，否则会$T$掉。 AC代码（2547ms）点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;typedef long long ll;#define N 1000010char str[N];int s[N],sa[N*3],c[10*N],rank[N],height[N];int wa[N],wb[N],ws[N],wv[N];#define F(x) ((x)/3+((x)%3==1?0:tb))#define G(x) ((x)&lt;tb?(x)*3+1:((x)-tb)*3+2)int c0(int *r,int a,int b)&#123; return r[a]==r[b]&amp;&amp;r[a+1]==r[b+1]&amp;&amp;r[a+2]==r[b+2];&#125;int c12(int k,int *r,int a,int b)&#123; if(k==2)return r[a]&lt;r[b]||r[a]==r[b]&amp;&amp;c12(1,r,a+1,b+1); return r[a]&lt;r[b]||r[a]==r[b]&amp;&amp;wv[a+1]&lt;wv[b+1];&#125;void sort(int *r,int *a,int *b,int n,int m)&#123; int i; for(i=0;i&lt;n;i++)wv[i]=r[a[i]]; for(i=0;i&lt;m;i++)ws[i]=0; for(i=0;i&lt;n;i++)ws[wv[i]]++; for(i=1;i&lt;m;i++)ws[i] += ws[i-1]; for(i=n-1;i&gt;=0;i--)b[--ws[wv[i]]]=a[i];&#125;void dc3(int *r,int *sa,int n,int m)&#123; int i,j,*rn=r+n,*san=sa+n,ta=0,tb=(n+1)/3,tbc=0,p; r[n]=r[n+1]=0; for(i=0;i&lt;n;i++)if(i%3!=0)wa[tbc++]=i; sort(r+2,wa,wb,tbc,m); sort(r+1,wb,wa,tbc,m); sort(r,wa,wb,tbc,m); for(p=1,rn[F(wb[0])]=0,i=1;i&lt;tbc;i++) rn[F(wb[i])]=c0(r,wb[i-1],wb[i])?p-1:p++; if(p&lt;tbc)dc3(rn,san,tbc,p); else for(i=0;i&lt;tbc;i++)san[rn[i]]=i; for(i=0;i&lt;tbc;i++)if(san[i]&lt;tb)wb[ta++]=san[i]*3; if(n%3==1)wb[ta++]=n-1; sort(r,wb,wa,ta,m); for(i=0;i&lt;tbc;i++)wv[wb[i]=G(san[i])]=i; for(i=0,j=0,p=0;i&lt;ta&amp;&amp;j&lt;tbc;p++)sa[p]=c12(wb[j]%3,r,wa[i],wb[j])?wa[i++]:wb[j++]; for(;i&lt;ta;p++)sa[p]=wa[i++]; for(;j&lt;tbc;p++)sa[p]=wb[j++];&#125;void getheight(int *s,int *sa,int n)&#123; int i,j,k=0; for(i=0;i&lt;=n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125;int solve(int n)&#123; int i; for(i=1;i&lt;=n;i++) if(n%i==0&amp;&amp;rank[0]==rank[i]+1&amp;&amp;height[rank[0]]==n-i)return i; return n;&#125;int main()&#123; int i; while(~scanf("%s",str))&#123; if(str[0]=='.'&amp;&amp;!str[1])break; int n=strlen(str); for(i=0;i&lt;n;i++)s[i]=str[i]-'a'+1; s[n]=0; dc3(s,sa,n+1,105); getheight(s,sa,n); printf("%d\n",n/solve(n)); &#125; return 0;&#125; 思路2：kmp$next$数组保证了$s[0…n-l-1]==s[l…n-1]$性质，其中$l=n-next[n]$。 AC代码（125ms）点击 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;cstring&gt;#define N 1000003char a[N];int nxt[N],n;int main()&#123; int i,j; while(~scanf("%s",a)&amp;&amp;a[0]!='.')&#123; j=0; n=strlen(a); for(i=1;i&lt;=n;i++)&#123; while(j&amp;&amp;a[i]!=a[j])j=nxt[j]; if(a[i]==a[j])j++; nxt[i+1]=j; &#125; int l=n-nxt[n]; if(n%l==0)printf("%d\n",n/l); else printf("1\n"); &#125; return 0;&#125; F 题目描述求一个串中连续重复出现次数最多的串的出现次数。 解题思路枚举该串长度$i$，从头到尾以$i$为步长求出$LCP(suffix(k\times i),suffix((k+1)\times i))$，再向前延伸，每次更新答案为$max(ans,lcp/i+1)$。 复杂度为调和级数，$O(nlgn)$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#define N 50004#define M 150004int s[M],sa[M],rank[M],height[M];int wa[M],wb[M],ws[M],wv[M];#define F(x) ((x)/3+((x)%3==1?0:tb))#define G(x) ((x)&lt;tb?(x)*3+1:((x)-tb)*3+2)int c0(int *r,int a,int b)&#123; return r[a]==r[b]&amp;&amp;r[a+1]==r[b+1]&amp;&amp;r[a+2]==r[b+2];&#125;int c12(int k,int *r,int a,int b)&#123; if(k==2)return r[a]&lt;r[b]||r[a]==r[b]&amp;&amp;c12(1,r,a+1,b+1); return r[a]&lt;r[b]||r[a]==r[b]&amp;&amp;wv[a+1]&lt;wv[b+1];&#125;void sort(int *r,int *a,int *b,int n,int m)&#123; int i; for(i=0;i&lt;n;i++)wv[i]=r[a[i]]; for(i=0;i&lt;m;i++)ws[i]=0; for(i=0;i&lt;n;i++)ws[wv[i]]++; for(i=1;i&lt;m;i++)ws[i] += ws[i-1]; for(i=n-1;i&gt;=0;i--)b[--ws[wv[i]]]=a[i];&#125;void dc3(int *r,int *sa,int n,int m)&#123; int i,j,*rn=r+n,*san=sa+n,ta=0,tb=(n+1)/3,tbc=0,p; r[n]=r[n+1]=0; for(i=0;i&lt;n;i++)if(i%3!=0)wa[tbc++]=i; sort(r+2,wa,wb,tbc,m); sort(r+1,wb,wa,tbc,m); sort(r,wa,wb,tbc,m); for(p=1,rn[F(wb[0])]=0,i=1;i&lt;tbc;i++) rn[F(wb[i])]=c0(r,wb[i-1],wb[i])?p-1:p++; if(p&lt;tbc)dc3(rn,san,tbc,p); else for(i=0;i&lt;tbc;i++)san[rn[i]]=i; for(i=0;i&lt;tbc;i++)if(san[i]&lt;tb)wb[ta++]=san[i]*3; if(n%3==1)wb[ta++]=n-1; sort(r,wb,wa,ta,m); for(i=0;i&lt;tbc;i++)wv[wb[i]=G(san[i])]=i; for(i=0,j=0,p=0;i&lt;ta&amp;&amp;j&lt;tbc;p++)sa[p]=c12(wb[j]%3,r,wa[i],wb[j])?wa[i++]:wb[j++]; for(;i&lt;ta;p++)sa[p]=wa[i++]; for(;j&lt;tbc;p++)sa[p]=wb[j++];&#125;void getheight(int *s,int *sa,int n)&#123; int i,j,k=0; for(i=0;i&lt;=n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125;int st[20][N];void init(int n)&#123; int i,j; for(i=0;i&lt;=n;i++)st[0][i]=height[i]; for(i=n-1;i;i--) for(j=1;(1&lt;&lt;j)+i-1&lt;=n;j++) st[j][i]=std::min(st[j-1][i],st[j-1][i+(1&lt;&lt;(j-1))]);&#125;int query(int l,int r)&#123; int m=0; if(l&gt;r)std::swap(l,r); l++; while((1&lt;&lt;(m+1))&lt;r-l+1)m++; return std::min(st[m][l],st[m][r-(1&lt;&lt;m)+1]);&#125;int solve(int n)&#123; int i,j,ans=1,lcp,remain; for(i=1;i&lt;=n;i++)&#123; for(j=0;j+i&lt;n;j+=i)&#123; lcp=query(rank[j],rank[j+i]); remain=i-lcp%i; int start=j-remain; if(start&gt;=0&amp;&amp;lcp%i&amp;&amp;query(rank[start],rank[start+i])&gt;=remain) lcp+=remain; ans=std::max(ans,lcp/i+1); &#125; &#125; return ans;&#125;int main()&#123; int i,n,t; char a[10]=&#123;0&#125;; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%s",a),s[i]=a[0]-'a'+1; s[i]=0; dc3(s,sa,n+1,4); getheight(s,sa,n); init(n); printf("%d\n",solve(n)); &#125; return 0;&#125; G 题目描述解题思路AC代码点击 12 H 题目描述解题思路AC代码点击 12 I 题目描述解题思路AC代码点击 12 J 题目描述解题思路AC代码点击 12 K 题目描述解题思路AC代码点击 12 L 题目描述解题思路AC代码点击 12 M 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 2 题解]]></title>
    <url>%2F2019%2F04%2F29%2F2019springtraining-2%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G 7/7 Ø Ø Ø Ø Ø Ø Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述有$n$个人可以任选$2$的倍数，有$m$个人可以任选$3$的倍数。任意两个人选的数不相同，求选择的最大数的最小值。（$0\leq n,m\leq 10^6,n+m&gt;0$） 解题思路枚举每一个$6$的倍数被选$2$的那帮人取了还是被选$3$的那帮人取了即可。 AC代码点击 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int i,n,m,a,b; scanf("%d%d",&amp;n,&amp;m); a=n*2,b=m*3; for(i=6;i&lt;=min(a,b);i+=6)&#123; if(a&lt;=b)a+=2; else b+=3; &#125; printf("%d",max(a,b)); return 0;&#125; B 题目描述$g^0(x)=x,g^n(x)=a\times g^{n-1}(x)+b$。输入$a,b,n,x$，求$g^n(x)$。（$1\leq a,b\leq 10^9,1\leq n\leq 10^{18}$，对$1e9+7$取模） 解题思路手推一下式子，很显然的等比数列求和。 AC代码点击 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll a,b,n,w=1000000007,x;ll qp(ll a,ll b)&#123; ll ans=1; for(;b;b&gt;&gt;=1,a=a*a%w)if(b&amp;1)ans=ans*a%w; return ans;&#125;ll inv(ll x)&#123;return qp(x,w-2);&#125;int main()&#123; scanf("%I64d%I64d%I64d%I64d",&amp;a,&amp;b,&amp;n,&amp;x); if(a==1)printf("%I64d",(x+n%w*b)%w); else&#123; ll apn=qp(a,n); ll ans=apn*x%w+b*(apn-1)%w*inv(a-1)%w; printf("%I64d",(ans%w+w)%w); &#125; return 0;&#125; C 题目描述给一个长度$n\leq 10^5$的数列$a_i(0&lt;a_i\leq 10^5)$。定义$f(l,r)$为$[l,r]$中任意一个数$i$，不存在一个$[l,r]$中与$i$不同的数$j$使得$a_i\%a_j==0$。求$\sum_{i=1}^{n}\sum_{j=i}^{n}f(i,j)\%(10^9+7)$。 解题思路考虑每一个位置$i$对答案的贡献，即为向左右延伸长度的乘积。 故可以考虑左右两侧最靠近$i$且满足$a[i]\%a[j]==0$的数字$j$，分别定为$l[i],r[i]$，用一个$loc$数组记录每一个数字最后出现的位置，递推求出即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll w=1000000007;#define N 100010#define M 10010int a[N],n,l[N],r[N],loc[M];int main()&#123; int i,j; while(~scanf("%d",&amp;n))&#123; ll ans=0; for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); memset(loc,0,sizeof(loc)); for(i=1;i&lt;=n;i++)&#123; l[i]=0; for(j=1;j*j&lt;=a[i];j++)&#123; if(a[i]%j==0)&#123; if(loc[j]&amp;&amp;loc[j]&gt;l[i])l[i]=loc[j]; if(loc[a[i]/j]&amp;&amp;loc[a[i]/j]&gt;l[i])l[i]=loc[a[i]/j]; &#125; &#125; loc[a[i]]=i; &#125; memset(loc,0,sizeof(loc)); for(i=n;i;i--)&#123; r[i]=n+1; for(j=1;j*j&lt;=a[i];j++)&#123; if(a[i]%j==0)&#123; if(loc[j]&amp;&amp;loc[j]&lt;r[i])r[i]=loc[j]; if(loc[a[i]/j]&amp;&amp;loc[a[i]/j]&lt;r[i])r[i]=loc[a[i]/j]; &#125; &#125; loc[a[i]]=i; &#125; for(i=1;i&lt;=n;i++)ans=(ans+(i-l[i])*(r[i]-i)%w)%w; printf("%lld\n",ans); &#125; return 0;&#125; D 题目描述给一个正整数$n$，问有没有一种选择数组$a_i,b_i(i∈[1,k])$的方案满足 $b_i$是$n$的因数 $1\leq a_i&lt;b_i$ $\sum_{i=1}^{k}\frac{a_i}{b_i}=1-\frac1n$ 解题思路显然如果能构成答案，则必定只需要两个分数（任意两个不同的分数都可相加成另一个合法的分数）。 于是本题化为$a_1x+a_2y=n-1$的解，用扩展欧几里得即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll a,b,n,g;ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; x=1,y=0; return a; &#125; ll g=exgcd(b,a%b,x,y),tmp=x; x=y;y=tmp-a/b*y; return g;&#125;int main()&#123; ll i; while(~scanf("%I64d",&amp;n))&#123; int flag=0; for(i=2;i*i&lt;n;i++)&#123; if(n%i)continue; ll x,y; a=i,b=n/i,g=exgcd(a,b,x,y); a/=g;b/=g; if((n-1)%g)continue; x*=(n-1)/g;y*=(n-1)/g; if(x&lt;0)&#123; ll k=-x/b+(x%b!=0); x+=k*b; y-=k*a; &#125; if(y&lt;0)&#123; ll k=-y/a+(y%a!=0); x-=k*b; y+=k*a; &#125; if(x&lt;0||y&lt;0)continue; printf("YES\n2\n"); printf("%I64d %I64d\n",y,a*g); printf("%I64d %I64d\n",x,b*g); flag=1; break; &#125; if(!flag)printf("NO\n"); &#125; return 0;&#125; E 题目描述有$n$堆石子，每一堆取出$k$个石子之后就不能再恰好取出$k$个石子。轮流取石子，最后不能取的人输。问先手是否必输。 解题思路手推一下，一堆石头最多可以被拿走$k$次，则贪心地从小到大拿，有$(1+2+…+k)\leq s_i\leq (1+2+…+k+1)$。 把每一堆的数量变成相对应的$k$，就变成简单的$Nim$游戏了。 AC代码点击 123456789101112#include&lt;bits/stdc++.h&gt;int x[]=&#123;0,2,5,9,14,20,27,35,44,54,65&#125;;int n,t,a;int main()&#123; scanf("%d",&amp;n); while(n--)&#123; scanf("%d",&amp;a); t^=std::lower_bound(x,x+10,a)-x; &#125; printf("%s",t?"NO":"YES"); return 0;&#125; F 题目描述$T\leq 50$组询问，每次询问一个区间$[l,r],1\leq l\leq r\leq 10^9$，问这个区间里有多少整数$x$满足$x\%f(x)=0$，其中$f(x)$表示$x$的各位数之和。 解题思路观察到$f(x)$只有$81$种选择，可以用数位$DP$，$f[pos][sum][div][r]$表示枚举到第$pos$位，当前已经有的数位和为$sum$时，$f(x)=div$，$x\%f(x)=r$的$x$的个数。 注意不是所有时候$dfs$的结果都可以添加到记忆化搜索中的，只有不在限制下的才能成为通用解。 AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int dp[10][82][82][81];int num[10],top;int dfs(int pos,int sum,const int div,int r,int end)&#123;//end:是否为限制位 int i,mx=9,&amp;ans=dp[pos][sum][div][r]; if(pos&lt;0)return !r&amp;&amp;!sum; if(end)mx=num[pos]; if(!end&amp;&amp;~ans)return ans; int temp=0; for(i=0;i&lt;=mx&amp;&amp;i&lt;=sum;i++)temp+=dfs(pos-1,sum-i,div,(r*10+i)%div,end&amp;&amp;(i==mx)); //枚举这一位取值 if(!end)ans=temp;//通用解 return temp;&#125;int f(int x)&#123; if(!x)return 0; int i,ans=0; top=-1; while(x)num[++top]=x%10,x/=10; for(i=1;i&lt;=9*top+num[top];i++)ans+=dfs(top,i,i,0,1); return ans;&#125;int main()&#123; int t,l,r,cas=0; memset(dp,-1,sizeof(dp)); scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;l,&amp;r); printf("Case %d: %d\n",++cas,f(r)-f(l-1)); &#125; return 0;&#125; G 题目描述求$lcm$的二维前缀和。 解题思路$f(n,m)$ $=\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)$ $=\sum_{i=1}^{n}\sum_{j=1}^{m}\frac{i\times j}{gcd(i,j)}$ $=\sum_{g=1}^{min(n,m)}g\times \sum_{i=1}^{n}\sum_{j=1}^{m}i\times j(gcd(i,j)==g)$ $=\sum_{g=1}^{min(n,m)}g\times \sum_{i=1}^{\frac ng}\sum_{j=1}^{\frac mg}i\times j(gcd(i,j)==1)$ $=\sum_{g=1}^{min(n,m)}g\times u(\frac ng,\frac mg)$ $u(n,m)$ $=\sum_{i=1}^{n}\sum_{j=1}^{m}i\times j(gcd(i,j)==1)$ $=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k|gcd(i,j)}i\times j\times \mu(k)$ $=\sum_{k=1}^{min(n,m)}\mu(k)\times k^2\sum_{i=1}^{\frac nk}\sum_{j=1}^{\frac mk}i\times j$ 于是预处理$\mu(k)\times k^2$，分块处理后半段即可。 其中：$\sum_{i=1}^{x}\sum_{j=1}^{y}i\times j$ $=(1+2+…+x)(1+2+…+y)$ $=\frac{(1+x)x}2\frac{(1+y)y}2$ 分别对$f(n,m)$，$u(n,m)$分块，复杂度$O(n)$。 $upd:$必须吐槽一波$bzoj$，下面的代码交上去会$CE$，原因就在于全局变量数组不能初始化，，，什么玩意，，，只好手动猜测$CE$原因，，贡献了一大波$CE\&amp;WA$ AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 10000010ll mu[N]=&#123;0,1&#125;,w=20101009;int pr[N/10],a[N]=&#123;1,1&#125;,cnt;ll inv;ll qp(ll a,ll b)&#123; if(inv)return inv; ll ans=1; for(;b;b&gt;&gt;=1,a=a*a%w)if(b&amp;1)ans=ans*a%w; return inv=ans;&#125;ll F(int x)&#123; return qp(2,w-2)*x%w*(x+1)%w;&#125;ll u(int n,int m)&#123; int i,r;ll ans=0; for(i=1;i&lt;=n;i=r+1)&#123; r=min(n/(n/i),m/(m/i)); ans=(ans+(mu[r]-mu[i-1])*F(n/i)%w*F(m/i)%w+w)%w; &#125; return ans;&#125;ll f(int n,int m)&#123; int i,r;ll ans=0; for(i=1;i&lt;=n;i=r+1)&#123; r=min(n/(n/i),m/(m/i)); ans=(ans+u(n/i,m/i)*(r-i+1)%w*(r+i)%w*qp(2,w-2))%w; &#125; return ans;&#125;int main()&#123; int i,j,n,m; scanf("%d%d",&amp;n,&amp;m); if(n&gt;m)n^=m^=n^=m; for(i=2;i&lt;=m;i++)&#123; if(!a[i])pr[cnt++]=i,mu[i]=-1; for(j=0;j&lt;cnt&amp;&amp;i*pr[j]&lt;=m;j++)&#123; a[i*pr[j]]=1; if(i%pr[j]==0)break; mu[i*pr[j]]=mu[i]*-1; &#125; &#125; for(i=1;i&lt;=m;i++)&#123; mu[i]=(mu[i]+w)*i%w*i%w; mu[i]=(mu[i]+mu[i-1])%w; &#125; printf("%lld",f(n,m)); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 BUAA Spring Training 1 题解]]></title>
    <url>%2F2019%2F04%2F28%2F2019springtraining-1%2F</url>
    <content type="text"><![CDATA[Solved A B C D E 5/5 O Ø O Ø Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给一个括号序列，定义如下 $()$ 是一个括号序列 如果 $A$ 是括号序列，那么 $(A)$ 是括号序列 如果 $A, B$ 是括号序列，那么 $AB$ 是括号序列 括号序列的得分如下 $()$ 的得分是 $1$ 如果 $A$ 是括号序列，记其得分为 $S_A$，那么$ (A)$ 是括号序列，其得分为$ 2S_A$ 如果 $A, B$ 是括号序列，记其得分分别为 $S_A$ 和 $S_B$，那么 $AB$ 是括号序列，其得分为$ S_A + S_B$最终求序列的得分，结果对 $12345678910 $取模 解题思路签到题，用栈模拟即可。 考场上傻了没取模还WA了一发 AC代码点击 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;typedef long long ll;#define w 12345678910int n,top;ll l[100010],ans;int main()&#123; int i,a; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a); if(!a)l[++top]=-1; else&#123; if(l[top]==-1)l[top]=1; else&#123; ll sc=0; while(l[top]!=-1)sc+=l[top--]; l[top]=sc*2%w; &#125; &#125; &#125; for(i=1;i&lt;=top;i++)(ans+=l[i])%=w; printf("%lld",ans); return 0;&#125; B 题目描述给一个全是正整数的$n\times m$的矩阵，要把上面所有数重新标记，使得新生成的矩阵每一行每一列中，原来相同的元素仍相同，且元素间相对大小不变。求重新标记的矩阵中的最大值。 解题思路有好多种做法。 贪心地做，可以考虑把所有值从小到大排序，首先放入第一个元素（坐标为$(x_1,y_1)$）必为$ans[1,1]=1$，限制$x_1$所在行、$y_1$所在列的最小可填值为$1$。 假设正在放第$i$个元素，它的坐标为$(x_i,y_i)$，则找到$x_i$所在行的最小可填值$p$及其所在坐标$y_{max}$、$y_i$所在列的最小可填值$q$及其所在坐标$x_{max}$，则$ans[x_i,y_i]=max(ans[x_i,y_{max}]+(a[x_i,y_i]&gt;a[x_i,y_{max}]),ans[x_{max},y_i]+(a[x_i,y_i]&gt;a[x_{max},y_i]))$ 这时候我们发现了一个问题：当遇到这组数据 3 51 2 3 4 51 5 1 1 51 6 1 1 1 的时候，因为枚举的时候，右边中间的$5$比左边的$5$更晚枚举到，故显然会输出 51 2 3 4 51 3 1 1 51 4 1 1 1 这样的错误矩阵。 于是我们维护一个并查集，并查集存储的是所有同行或同列中相等的元素。这样在每次寻找答案的时候，必然能够保证最大值是可以被更新的，尽管$ans$数组未必是最后的可行方案。 错误代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int n,m;int a[N];struct point&#123; int i,j; bool operator&lt;(const point&amp;b)const&#123;return a[(i-1)*m+j]&lt;a[(b.i-1)*m+b.j];&#125;&#125;p[N];int linemin[N],colmin[N],ans[N];int main()&#123; int i,j; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; int x=(i-1)*m+j; scanf("%d",&amp;a[x]); p[x]=(point)&#123;i,j&#125;; &#125; &#125; int r=0; sort(p+1,p+n*m+1); for(i=1;i&lt;=n*m;i++)&#123; int x=p[i].i,y=p[i].j; int p=linemin[x],q=colmin[y]; int X=(x-1)*m+y; ans[X]=max(ans[p]+(a[X]&gt;a[p]),ans[q]+(a[X]&gt;a[q])); if(ans[X]&gt;r)r=ans[X]; linemin[x]=colmin[y]=X; &#125; printf("%d\n",r); /*for(i=1;i&lt;=n*m;i++)&#123; printf("%d ",ans[i]); if(i%m==0)puts(""); &#125;*/ return 0;&#125; AC代码点击 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int n,m;int a[N],f[N];int find(int x)&#123;return x==f[x]?f[x]:f[x]=find(f[x]);&#125;struct point&#123; int i,j; bool operator&lt;(const point&amp;b)const&#123;return a[(i-1)*m+j]&lt;a[(b.i-1)*m+b.j];&#125;&#125;p[N];int linemin[N],colmin[N],ans[N];int main()&#123; int i,j; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=m;j++)&#123; int x=(i-1)*m+j; scanf("%d",&amp;a[x]); p[x]=(point)&#123;i,j&#125;; f[x]=x; &#125; &#125; int r=0; sort(p+1,p+n*m+1); for(i=1;i&lt;=n*m;i++)&#123; int x=p[i].i,y=p[i].j; int p=find(linemin[x]),q=find(colmin[y]); int X=(x-1)*m+y; ans[X]=max(ans[p]+(a[X]&gt;a[p]),ans[q]+(a[X]&gt;a[q])); if(ans[X]&gt;r)r=ans[X]; if(a[X]==a[p])f[p]=X; if(a[X]==a[q])f[q]=X; linemin[x]=colmin[y]=X; &#125; printf("%d",r); return 0;&#125; C 题目描述现有一序列$a_i(1\leq i\leq n)$，初始时$a_i=i$。有$m$个操作，每次操作翻转$[l,r]$区间内所有数并输出其和。 $1\leq n,m \leq 10^5$。 解题思路平衡树，此时用$FHQTreap$。建树不停进行$merge$操作，每次翻转根据子树大小找到$r$的位置并$split$，取左树为$x$，再在$x$中找到$l-1$并$split$，再取右树为$z$。那么$z$的$sum$即为答案。翻转$z$，再$merge$回去即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define ls t[x].s[0]#define rs t[x].s[1]struct FHQTreap&#123; int s[2],v,k,sz,lazy; ll sum;&#125;t[100010];int n,m,tot,rt;void upd(int x)&#123; t[x].sz=t[ls].sz+t[rs].sz+1; t[x].sum=(ls?t[ls].sum:0)+(rs?t[rs].sum:0)+t[x].v;&#125;int newnode(int v)&#123; t[++tot].k=rand();t[tot].sz=1;t[tot].v=t[tot].sum=v; return tot;&#125;void pushdown(int x)&#123; if(t[x].lazy)&#123; if(ls)t[ls].lazy^=1; if(rs)t[rs].lazy^=1; swap(ls,rs); t[x].lazy=0; &#125; upd(x);&#125;void split(int x,int k,int &amp;a,int &amp;b)&#123; if(!x)&#123;a=b=0;return;&#125; pushdown(x); if(t[ls].sz&gt;=k)b=x,split(ls,k,a,ls),upd(x); else a=x,split(rs,k-t[ls].sz-1,rs,b),upd(x);&#125;int merge(int x,int y)&#123; if(!x||!y)return x+y; pushdown(x);pushdown(y); if(t[x].k&lt;t[y].k)&#123;rs=merge(rs,y);upd(x);return x;&#125; t[y].s[0]=merge(x,t[y].s[0]);upd(y);return y;&#125;void rev(int l,int r)&#123; int x,y,z; split(rt,r,x,y); split(x,l-1,x,z); t[z].lazy=1; printf("%lld\n",t[z].sum); int p=merge(x,z); rt=merge(p,y);&#125;void print(int x)&#123; pushdown(x); if(ls)print(ls); printf("%d ",t[x].v); if(rs)print(rs);&#125;int main()&#123; int i,l,r; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=n;i++)rt=merge(rt,newnode(i)); for(i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;l,&amp;r); rev(l,r); &#125; print(rt); return 0;&#125; D 题目描述有$k$个长度为$k$的数列，有$k^k$种方式从每个数组中恰取出一个数，每一种方式对应一种和。求这些和中，前$k$小的值分别为多少。 解题思路每次合并两个数组，每次取前$k$小。 对两个数组$a,b$排序，显然应当取$(0,0)$这个对（对$(x,y)$表示取$a_x,b_y$）。每次取出$(x,y)$对的时候，扩展出$(x+1,y)(x,y+1)$两个对。注意去重。 AC代码点击 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll a[2][1010],temp[1010]=&#123;1&#125;;struct nd&#123; int x,y; bool operator&lt;(const nd&amp;b)const&#123;return a[x][y]&gt;a[b.x][b.y]||(a[x][y]==a[b.x][b.y]&amp;&amp;(x&gt;b.x||x==b.x&amp;&amp;y&gt;b.y));&#125;//这里一大串其实也是为了去重 bool operator==(const nd&amp;a)const&#123;return x==a.x&amp;&amp;y==a.y;&#125;&#125;t;priority_queue&lt;nd&gt;Q;int main()&#123; int i,j,k; scanf("%d",&amp;k); for(j=0;j&lt;k;j++)scanf("%lld",&amp;a[0][j]);sort(a[0],a[0]+k); for(i=1;i&lt;k;i++)&#123; for(j=0;j&lt;k;j++)scanf("%lld",&amp;a[1][j]);sort(a[1],a[1]+k); Q.push((nd)&#123;0,0&#125;); for(j=0;j&lt;k;j++)&#123; t=Q.top(); while(!Q.empty()&amp;&amp;Q.top()==t)Q.pop();//去重 temp[j]=a[t.x][t.y]; if(t.x+1&lt;k)Q.push((nd)&#123;t.x+1,t.y&#125;); if(t.y+1&lt;k)Q.push((nd)&#123;t.x,t.y+1&#125;); &#125; for(j=0;j&lt;k;j++)a[0][j]=temp[j]; while(!Q.empty())Q.pop(); &#125; for(i=0;i&lt;k;i++)printf("%lld ",temp[i]); return 0;&#125; E 题目描述给一棵树。对于某个节点$x$，有两种操作，第一种是把节点$x$到树根的路径所有的值赋$1$，并输出这次改变的个数；第二种是把$x$和$x$的子树全部置$0$，并输出这次改变的个数。 解题思路树链剖分，注意$lazy$的使用。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;#define N 100010int n;int count=1,head[N];struct Edge&#123; int end,near;&#125;edge[N&lt;&lt;1];void addedge(int begin,int end)&#123; edge[count].end=end; edge[count].near=head[begin]; head[begin]=count++;&#125;struct SegTree&#123; int l,r,lazy; int sum;&#125;t[N&lt;&lt;2];int depth[N],fa[N],size[N],son[N],pos[N],top[N],temp[N];int cnt;struct Ret&#123; int s,r; struct Ret operator+(const Ret&amp;a)const&#123;return &#123;s+a.s,r+a.r&#125;;&#125;&#125;;void build(int p,int l,int r)&#123; t[p].l=l; t[p].r=r; t[p].lazy=-1; if(l==r)return; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r);&#125;void pushdown(int p)&#123; int l=t[p].lazy; if(l==-1)return; t[p&lt;&lt;1].sum=l*(t[p&lt;&lt;1].r-t[p&lt;&lt;1].l+1); t[p&lt;&lt;1|1].sum=l*(t[p&lt;&lt;1|1].r-t[p&lt;&lt;1|1].l+1); t[p&lt;&lt;1].lazy=t[p&lt;&lt;1|1].lazy=l; t[p].lazy=-1;&#125;struct Ret query(int p,int L,int R)&#123; int l=t[p].l,r=t[p].r; if(l&gt;=L&amp;&amp;r&lt;=R)return (Ret)&#123;t[p].sum,t[p].r-t[p].l+1-t[p].sum&#125;; if(r&lt;L||l&gt;R||p&gt;4*n)return (Ret)&#123;0,0&#125;; pushdown(p); return query(p&lt;&lt;1,L,R)+query(p&lt;&lt;1|1,L,R);&#125;void add(int p,int left,int right,int k)&#123; int l=t[p].l,r=t[p].r; if(l&gt;=left&amp;&amp;r&lt;=right)&#123; t[p].sum=k*(t[p].r-t[p].l+1); t[p].lazy=k; return; &#125; if(r&lt;left||l&gt;right)return; pushdown(p); add(p&lt;&lt;1,left,right,k); add(p&lt;&lt;1|1,left,right,k); t[p].sum=t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].sum;&#125;void dfs1(int now,int f,int dep)&#123; depth[now]=dep; fa[now]=f; size[now]=1; int i,mx=0; for(i=head[now];i;i=edge[i].near)&#123; int p=edge[i].end; if(p!=f)&#123; dfs1(p,now,dep+1); size[now]+=size[p]; if(size[p]&gt;mx)&#123; mx=size[p]; son[now]=p; &#125; &#125; &#125;&#125;void dfs2(int now,int Top)&#123; int i; pos[now]=++cnt; top[now]=Top; if(!son[now])return; dfs2(son[now],Top); for(i=head[now];i;i=edge[i].near)&#123; int p=edge[i].end; if(p!=son[now]&amp;&amp;p!=fa[now])dfs2(p,p); &#125;&#125;void swap(int *A,int *B)&#123;int t=*A;*A=*B;*B=t;&#125;int rangequery(int x,int y)&#123; int ans=0; while(top[x]!=top[y])&#123; if(depth[top[x]]&lt;depth[top[y]])swap(&amp;x,&amp;y); ans+=query(1,pos[top[x]],pos[x]).r; x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y])swap(&amp;x,&amp;y); return ans+query(1,pos[x],pos[y]).r;&#125;void rangeadd(int x,int y,int k)&#123; while(top[x]!=top[y])&#123; if(depth[top[x]]&lt;depth[top[y]])swap(&amp;x,&amp;y); add(1,pos[top[x]],pos[x],k); x=fa[top[x]]; &#125; if(depth[x]&gt;depth[y])swap(&amp;x,&amp;y); add(1,pos[x],pos[y],k);&#125;int main()&#123; int i,f; scanf("%d",&amp;n); for(i=1;i&lt;n;i++)&#123; scanf("%d",&amp;f); addedge(f,i);addedge(i,f); &#125; int r=0,q,opt,x; dfs1(r,0,1); dfs2(r,r); build(1,1,n); scanf("%d",&amp;q); for(i=0;i&lt;q;i++)&#123; scanf("%d%d",&amp;opt,&amp;x); if(opt==1)&#123; printf("%d\n",rangequery(0,x)); rangeadd(0,x,1); &#125;else&#123; printf("%d\n",query(1,pos[x],pos[x]+size[x]-1).s); add(1,pos[x],pos[x]+size[x]-1,0); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vjudge296318-ICPC2018亚洲区域赛组题 题解]]></title>
    <url>%2F2019%2F04%2F25%2Fvjudge296318regional2018%2F</url>
    <content type="text"><![CDATA[Solved A B C D E 5/5 O O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给定一个$n$个节点的树和$m$个简单路，求有多少个选择$k$个给定简单路并使得这$k$个简单路交于同一点的方案。答案对$1e9+7$取模。 解题思路先用树上差分求出每个点经过的简单路个数$path[i]$，再用$C(path[i],k)$求出该点的贡献，但显然会有重复。显然，所有路径的交点至少为一个$LCA$，故只需记录每一个点作为$LCA$做出的贡献即可。记录每一个点作为$LCA$的个数$num[i]$，则答案为$\sum_{i=1}^{n}C(path[i],k)-C(path[i]-num[i],k)$。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 300005#define mid ((l+r)&gt;&gt;1)struct Edge&#123; int e,n;&#125;e[N&lt;&lt;1];int d[N],fa[N][22],lg[N],hd[N],cnt,n,m,k;void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;&#125;void dfs(int now,int f)&#123; d[now]=d[f]+1; fa[now][0]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++)fa[now][i]=fa[fa[now][i-1]][i-1]; for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=f)dfs(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y])x=fa[x][lg[d[x]-d[y]]]; if(x==y)return x; for(i=lg[d[x]];~i;i--)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;int path[N],num[N];void init(int now,int f)&#123; int i,q; for(i=hd[now];i;i=e[i].n)&#123; q=e[i].e; if(q!=f)&#123; init(q,now); path[now]+=path[q]; &#125; &#125;&#125;ll jc[N]=&#123;1&#125;,inv[N]=&#123;1&#125;,w=1000000007;ll c(int n,int m)&#123; if(n&lt;m)return 0; return jc[n]*inv[m]%w*inv[n-m]%w;&#125;ll qpow(ll a,ll b)&#123; int i; ll ans=1; for(i=b;i;i&gt;&gt;=1,a=a*a%w)if(i&amp;1)ans=ans*a%w; return ans;&#125;int main()&#123; int i,t,u,v; for(i=2;i&lt;N;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); for(i=1;i&lt;N;i++)jc[i]=jc[i-1]*i%w,inv[i]=qpow(jc[i],w-2); scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(i=1;i&lt;n;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v),add(v,u); dfs(1,0); for(i=0;i&lt;m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); int w=lca(u,v); path[w]--;path[fa[w][0]]--; path[u]++;path[v]++; num[w]++; &#125; init(1,0); ll ans=0; for(i=1;i&lt;=n;i++) ans=((ans+c(path[i],k)-c(path[i]-num[i],k))%w+w)%w; printf("%lld\n",ans); memset(hd,0,sizeof(int)*(n+1));cnt=0; memset(d,0,sizeof(int)*(n+1)); memset(path,0,sizeof(int)*(n+1)); memset(num,0,sizeof(int)*(n+1)); memset(fa,0,sizeof(int)*(n+1)*22); &#125; return 0;&#125; B 题目描述有$n$个战斗回合，$boss$无限血量，初始状态战斗力$A=0$，预备增量$D=0$。 每一个回合有三个参数$a[i],b[i],c[i]$可以任选下面三种策略之一： 攻击，伤害为$A+a[i]$ 不攻击，$A+=b[i]$ 不攻击，$D+=c[i]$ 每回合结束之后，$A+=D$。 求$n$回合后的最大伤害。所有数在$[1,1e9]$范围内。 解题思路开始想了半天如何$DP$，死活无法推出式子。后来经nikkukun同学的提点，发现可以从后到前递推。 原因是： 操作具有后效性但不具有前效性。 故考虑用$f[i][j]$表示到第$i$个人，已经干了$j$架的最大伤害。 推一下状态转移方程：$f[i][j]=max(f[i+1][j]+max(x\times b[i],j\times c[i]),f[i+1][j-1]+a[i])$前半部分表示选择不攻击的两种方法对答案的贡献，后半部分表示选择攻击的贡献。 但是这里出现了一个莫名其妙的$x$，代表的是操作②对答案的贡献，它的值为所有后续打架的位置和当前位置的距离之和，而这里是一个不能确定的变量。于是增加第三维：所有攻击操作的下标之和。于是就可以愉快地递推了，$x=k-i\times j$。 然后快乐地提交，获得了$MLE$。所以需要滚动一下。 AC代码点击 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;ll f[2][102][5052],a[110],b[110],c[110],ans;int main()&#123; int i,t,j,n,k; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lld%lld%lld",&amp;a[i],&amp;b[i],&amp;c[i]); for(i=0;i&lt;2;i++)for(j=0;j&lt;=n;j++)for(k=0;k&lt;=n*(n+1)/2;k++)f[i][j][k]=-1; f[0][1][n]=a[n]; int p=0; for(i=n-1;i;i--)&#123; p^=1; for(j=n-i+1;j;j--)&#123; for(k=n*(n+1)/2;k&gt;=n;k--)&#123; if(k-i&gt;=n&amp;&amp;j&gt;=2&amp;&amp;~f[p^1][j-1][k-i])f[p][j][k]=f[p^1][j-1][k-i]+a[i]; if(~f[p^1][j][k])f[p][j][k]=max(f[p][j][k],f[p^1][j][k]+max(c[i]*j,(k-i*j)*b[i])); &#125; &#125; for(j=0;j&lt;=n;j++)for(k=0;k&lt;=n*(n+1)/2;k++)f[p^1][j][k]=-1; &#125; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n*(n+1)/2-i*(i-1)/2;j++) ans=max(ans,f[p][i][j]); printf("%lld\n",ans); &#125; return 0;&#125; C 题目描述给定两个长度$2\leq |s|\leq 10^6,1\leq |t|&lt;|s|$的字符串，求满足以下要求的三元组$(i,j,k)$的个数： $1\leq i\leq j\leq |s|$ $1\leq k\leq |t|$ $j-i+1&gt;k$ 把$[s[i],s[j]]$和$[t[1],t[k]]$拼接起来的新串为回文串。 解题思路题目可以转化为：在$s$中找到连续的串$a,b$，在$t$中找到串$c$，且$a,b,c$不空，$b$为回文串且$a$和$c$倒序相等。 可以先$manacher$处理出$s$中每一个$i$开头的回文串个数（用差分思想），再在旋转过的$b$串后缀中字符串哈希二分查找最长公共子串长度，乘起来再求和即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;typedef long long ll;#define N 2000010#define base 998244353#define mod 2078526727ll hs[N],ht[N],pw[N];char s[N],t[N];char a[N]=&#123;'.'&#125;;int len[N];int p[N];using namespace std;int ls,lt;ll hashf(ll*a,int l,int r)&#123; return ((a[r]-a[l]*pw[r-l])%mod+mod)%mod;&#125;int check(int x,int i)&#123; return hashf(ht,lt-x,lt)==hashf(hs,i-x,i);&#125;int main()&#123; int i; pw[0]=1; for(i=1;i&lt;N;i++)pw[i]=pw[i-1]*base%mod; scanf("%s%s",s,t); ls=strlen(s),lt=strlen(t); reverse(t,t+lt); for(i=0;i&lt;ls;i++)&#123; a[2*i+1]='#'; a[2*i+2]=s[i]; &#125; a[2*ls+1]='#'; int mr=0,mid=0; for(i=1;i&lt;=2*ls+2;i++)&#123; if(mr&gt;i)len[i]=min(mr-i,len[2*mid-i]); else len[i]=1; while(a[i+len[i]]==a[i-len[i]])len[i]++; if(i+len[i]&gt;mr)&#123; mr=i+len[i]; mid=i; &#125; &#125; for(i=1;i&lt;2*ls+2;i++)&#123; p[(i-len[i])/2]++; p[(i)/2]--; &#125; for(i=1;i&lt;=ls;i++)p[i]+=p[i-1]; hs[0]=ht[0]=1; for(i=1;i&lt;=ls;i++)hs[i]=(hs[i-1]*base+s[i-1]-'a')%mod; for(i=1;i&lt;=lt;i++)ht[i]=(ht[i-1]*base+t[i-1]-'a')%mod; ll ans=0; for(i=1;i&lt;ls;i++)&#123; if(s[i-1]!=t[lt-1])continue; int l=1,r=min(lt,i); while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid,i))l=mid+1; else r=mid; &#125; if(!check(l,i))l--; ans+=p[i]*1LL*l; &#125; printf("%I64d",ans); return 0;&#125; D 题目描述有$n$个人，每个人能打$t[i]$个怪兽，分别为$m[i][j]$。每个人最多只能打一只怪兽。这时候提供了$k$个膜法药水，一个人最多可以喝一瓶，喝了一瓶之后最多就能打两只怪兽了。 问最好的分配情况下，一共能打多少只怪兽。 解题思路非常裸的网络流，从源点到每个人、每个怪兽到汇点建长度为$1$的边，每个人与他能打的怪兽之间建长度为$1$的边。再考虑膜法药水，从源点到新增节点$magic$建长度为$k$的边，从$magic$到每个人建长度为$1$的边，跑一遍最大流即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1010int s,t,magic;struct Edge&#123; int end,near,len;&#125;e[N*N];int head[N],cnt=1,cur[N];int n,m,k;void add(int a,int b,int l)&#123; e[++cnt].end=b; e[cnt].near=head[a]; e[cnt].len=l; head[a]=cnt;&#125;queue&lt;int&gt;Q;int dep[N];int bfs()&#123; int i,p,q; memset(dep,0,sizeof(dep)); for(i=0;i&lt;=magic;i++)cur[i]=head[i]; Q.push(s);dep[s]=1; while(!Q.empty())&#123; p=Q.front();Q.pop(); for(i=head[p];i;i=e[i].near)&#123; q=e[i].end; if(e[i].len&amp;&amp;!dep[q])&#123; dep[q]=dep[p]+1; Q.push(q); &#125; &#125; &#125; return dep[t];&#125;int dfs(int p,int flow)&#123; if(p==t)return flow; int i,q; for(i=cur[p];i;i=e[i].near)&#123; cur[p]=i; q=e[i].end; if(dep[q]==dep[p]+1&amp;&amp;e[i].len)&#123; int ans=dfs(q,min(flow,e[i].len)); if(ans)&#123; e[i].len-=ans; e[i^1].len+=ans; return ans; &#125; &#125; &#125; return 0;&#125;int dinic()&#123; int d,ans=0; while(bfs())&#123; while((d=dfs(s,1e6))) ans+=d; &#125; return ans;&#125;int main()&#123; int i,j,M,T; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); s=0; t=n+m+1; magic=t+1; for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;T); for(j=0;j&lt;T;j++)scanf("%d",&amp;M),add(i,M+n,1),add(M+n,i,0); &#125; add(s,magic,k),add(magic,s,0); for(i=1;i&lt;=n;i++)&#123; add(s,i,1),add(i,s,0); add(magic,i,1),add(i,magic,0); &#125; for(i=1;i&lt;=m;i++)add(i+n,t,1),add(t,i+n,0); printf("%d",dinic()); return 0;&#125; E 题目描述给定一个有$n$个数（$1\leq n\leq 10^6$）的正整数序列$a[i]$，$1\leq a[i]\leq 10^6$。。定义$mul(l,r)=\prod_{i=l}^{r}a[i]$，$fac(l,r)$为$mul(l,r)$中的所有质因数种数之和。 求$\sum_{i=1}^{n}\sum_{j=i}^{n}fac(i,j)$。 解题思路考虑每一个质因数的贡献，设它出现的位置为$p[1],p[2],…,p[m]$。不妨设$p[0]=0,p[m+1]=n+1$，则其贡献为$\frac{n\times (n+1)}2-\sum_{i=0}^{m}\frac{(p[i+1]-p[i])(p[i+1]-p[i]-1)}2$。枚举每一个$a[i]$，计算出其对应的所有质因数，最后统计即可。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 1000010int n,prime[N],a[N]=&#123;1,1&#125;,cnt;ll ans;vector&lt;int&gt;num[N];ll f(ll a,ll b)&#123;return (b-a+1)*(b-a+2)/2;&#125;int main()&#123; int i,j,p; for(i=2;i&lt;N;i++)&#123; if(!a[i])prime[cnt++]=i,a[i]=cnt-1; for(j=0;i*prime[j]&lt;N&amp;&amp;j&lt;cnt;j++)&#123; a[i*prime[j]]=1; if(i%prime[j]==0)break; &#125; &#125; scanf("%d",&amp;n); for(i=0;i&lt;cnt;i++)num[i].push_back(0); for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;p); for(j=0;j&lt;cnt&amp;&amp;prime[j]*prime[j]&lt;=p;j++)&#123; if(p%prime[j]==0)&#123; num[j].push_back(i); while(p%prime[j]==0)p/=prime[j]; &#125; &#125; if(p&gt;1)num[a[p]].push_back(i); &#125; for(i=0;i&lt;cnt;i++)num[i].push_back(n+1); for(i=0;i&lt;cnt;i++)&#123; ans+=1LL*(n+1)*n/2; for(j=1;j&lt;num[i].size();j++) ans-=f(num[i][j-1]+1,num[i][j]-1); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南昌邀请赛网络赛2019.04.20 题解]]></title>
    <url>%2F2019%2F04%2F21%2Fnanchanginternet2019%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L M 7/13 O . . . . . . O O Ø O Ø O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 官方题解 A 题目描述输出前五个完全数。 解题思路打表。 AC代码点击 12345#include&lt;bits/stdc++.h&gt;int main()&#123; printf("6\n28\n496\n8128\n33550336"); return 0;&#125; B 题目描述解题思路AC代码点击 12 C 题目描述解题思路AC代码点击 12 D 题目描述解题思路AC代码点击 12 E 题目描述解题思路AC代码点击 12 F 题目描述解题思路AC代码点击 12 G 题目描述解题思路AC代码点击 12 H 题目描述给定一个$2\times N$的格点图，从左上角走到右下角，可以向上、下、左、右、左上、左下、右上、右下走，走过的点的集合为$S$，求$S$的种数对$1000000007$取模的值。$0&lt;n\leq 10^9$。 解题思路最左一列只能有两种选择：只经过上面、两块都经过 最右一列只能有两种选择：只经过下面、两块都经过 其他列每一列至少需要有一个经过的点，故有三种选择：只经过上面、只经过下面、两块都经过。 于是，答案为$4\times 3^{N-2}$。注意特判$N=1$。 AC代码点击 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int w=1000000007,n;ll qpow(ll a,ll b)&#123; ll ans=1; int i; for(i=b;i;i&gt;&gt;=1,a=a*a%w)if(i&amp;1)ans=ans*a%w; return ans;&#125;int main()&#123; scanf("%d",&amp;n); if(n==1)printf("1"); else printf("%d",1LL*4*qpow(3,n-2)%w); return 0;&#125; I 题目描述给定一个序列，求其中一个子序列，其中元素$a[i]∈[-10^5,10^5]$，使得其区间最小值乘区间和最大，求出最大值。 解题思路代码&amp;思路 by​ Nikkukun 对于每一个值作为区间最小值，求出最大的左端与右端，求出其和的最大值，复杂度$O(n^2)$。 考虑最小值的正负，当最小值为正时，向左右分别延伸到最大值且不含比该值小的数的区间；否则延伸到最小值且不含比该值小的数的区间。 用线段树维护区间最大值，乘以$-1$后也可维护区间最小值（用$ST$表会$MLE$）。 再用含偏移的树状数组（处理负数）维护距离$a[i]$最近的、比$a[i]$小的下标$j$。从左端往右、从右端往左分别维护一个树状数组，树状数组的下标表示$a[i]$，其值表示下标$j$。 AC代码-BIT+线段树 By Nikkukun-223ms点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;using namespace std;#define lson (o&lt;&lt;1)#define rson ((o&lt;&lt;1)|1)typedef long long ll;const int N=500000+5,BIAS=100000+5,T=BIAS*2,LEN=18+2;const ll INF=0x3f3f3f3f3f3f3f3f;struct BITree&#123; int t[T]; BITree()&#123; memset(t,0,sizeof(t)); &#125; int Lowbit(int x)&#123; return x&amp;(-x); &#125; void Add(int x,int v)&#123; for(;x&lt;T;x+=Lowbit(x)) t[x]=v; &#125; int Query(int x)&#123; int ret=0; for(;x;x-=Lowbit(x)) ret=max(ret,t[x]); return ret; &#125;&#125;;struct ST&#123; ll t[N*4]; void Build(int o,int L,int R,ll a[],int f)&#123; if(L==R)&#123; t[o]=f*a[L]; return; &#125; int M=(L+R)/2; Build(lson,L,M,a,f); Build(rson,M+1,R,a,f); t[o]=max(t[lson],t[rson]); &#125; ll Query(int o,int L,int R,int qL,int qR)&#123; if(qL&lt;=L&amp;&amp;R&lt;=qR)return t[o]; ll ret=-INF; int M=(L+R)/2; if(qL&lt;=M)ret=max(ret,Query(lson,L,M,qL,qR)); if(M+1&lt;=qR)ret=max(ret,Query(rson,M+1,R,qL,qR)); return ret; &#125;&#125;;int a[N];int l[N],r[N];ll suml[N],sumr[N];BITree bitl,bitr;ST stl[2],str[2];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; l[i]=bitl.Query(a[i]+BIAS); bitl.Add(a[i]+BIAS+1,i); suml[i]=suml[i-1]+a[i]; &#125; for(int i=n;i&gt;0;i--)&#123; r[i]=bitr.Query(a[i]+BIAS); bitr.Add(a[i]+BIAS+1,n-i+1); sumr[i]=sumr[i+1]+a[i]; &#125; stl[0].Build(1,1,n,suml,1); stl[1].Build(1,1,n,suml,-1); str[0].Build(1,1,n,sumr,1); str[1].Build(1,1,n,sumr,-1); ll ans=0; for(int i=1;i&lt;=n;i++)&#123; int j=(a[i]&gt;0)?0:1; int f=(a[i]&gt;0)?1:-1; ll L=f*str[j].Query(1,1,n,l[i]+1,i)-sumr[i]; ll R=f*stl[j].Query(1,1,n,i,n-r[i]+1-1)-suml[i]; ans=max(ans,(L+R+a[i])*a[i]); &#125; printf("%lld",ans); return 0;&#125; 赛后突然发现维护一个单调增的单调栈亦可以找出左右端的最大伸展区间。 AC代码-单调栈+线段树 By Potassium-514ms点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 500002#define mid ((l+r)&gt;&gt;1)#define inf 9e18int sta[N],n,top,l[N],r[N];ll a[N],s[N];struct SegTree&#123; ll mn,mx; int l,r;&#125;t[N&lt;&lt;2];void build(int l,int r,int p)&#123; t[p].l=l;t[p].r=r; if(l==r)&#123; t[p].mn=t[p].mx=s[l]; return; &#125; build(l,mid,p&lt;&lt;1); build(mid+1,r,p&lt;&lt;1|1); t[p].mn=min(t[p&lt;&lt;1].mn,t[p&lt;&lt;1|1].mn); t[p].mx=max(t[p&lt;&lt;1].mx,t[p&lt;&lt;1|1].mx);&#125;ll querymin(int l,int r,int p)&#123; int L=t[p].l,R=t[p].r; if(L&gt;=l&amp;&amp;R&lt;=r)return t[p].mn; if(L&gt;r||R&lt;l)return inf; return min(querymin(l,r,p&lt;&lt;1),querymin(l,r,p&lt;&lt;1|1));&#125;ll querymax(int l,int r,int p)&#123; int L=t[p].l,R=t[p].r; if(L&gt;=l&amp;&amp;R&lt;=r)return t[p].mx; if(L&gt;r||R&lt;l)return -inf; return max(querymax(l,r,p&lt;&lt;1),querymax(l,r,p&lt;&lt;1|1));&#125;int main()&#123; int i; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]),s[i]=s[i-1]+a[i]; for(i=1;i&lt;=n;i++)&#123; while(top&amp;&amp;a[sta[top]]&gt;=a[i])top--; l[i]=top?sta[top]+1:1; sta[++top]=i; &#125; top=0; for(i=n;i;i--)&#123; while(top&amp;&amp;a[sta[top]]&gt;=a[i])top--; r[i]=top?sta[top]-1:n; sta[++top]=i; &#125; ll ans=0; build(0,n,1); for(i=1;i&lt;=n;i++)&#123; ll lmn=querymin(l[i]-1,i,1),rmn=querymin(i,r[i],1); ll lmx=querymax(l[i]-1,i,1),rmx=querymax(i,r[i],1); ans=max(ans,a[i]*(rmn-lmx)); ans=max(ans,a[i]*(rmx-lmn)); &#125; printf("%lld",ans); return 0;&#125; J 题目描述给定一棵含$n$个节点的树，有$m$个询问，每个询问$(u,v,k)$求给定两点$(u,v)$之间路径长度不大于$k$的路径数。 $2\leq n \leq 10^5,1\leq m\leq 10^5,1\leq u,v\leq n,0\leq k \leq 10^9$。 解题思路如果求区间小于$k$的个数，可以用主席树；而在树上路径，则可以用在树上建主席树。设$f(b)$表示从根$(1)$到$b$的路径中小于等于$k$的路径个数，则$ans(u,v,k)=f(u)+f(v)-2f(lca(u,v))$。 注意离散化。 主席树早忘光了，赛场上没写出来…… AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;#define N 100005#define mid ((l+r)&gt;&gt;1)struct Edge&#123; int e,n,l;&#125;e[N&lt;&lt;1];int d[N],fa[22][N],lg[N],hd[N],cnt;void add(int a,int b,int l)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt;e[cnt].l=l;&#125;void dfs2(int now,int f)&#123; d[now]=d[f]+1; fa[0][now]=f; int i; for(i=1;(1&lt;&lt;i)&lt;=d[now];i++) fa[i][now]=fa[i-1][fa[i-1][now]]; for(i=hd[now];i;i=e[i].n)&#123; int p=e[i].e; if(p!=f)dfs2(p,now); &#125;&#125;int lca(int x,int y)&#123; int i; if(d[x]&lt;d[y])&#123;int t=x;x=y;y=t;&#125; while(d[x]&gt;d[y]) x=fa[lg[d[x]-d[y]]][x]; if(x==y)return x; for(i=lg[d[x]];~i;i--) if(fa[i][x]!=fa[i][y]) x=fa[i][x],y=fa[i][y]; return fa[0][x];&#125;int A[N],B[N];int root[N],L[N&lt;&lt;5],R[N&lt;&lt;5],sum[N&lt;&lt;5];int build(int l,int r)&#123; int now=++cnt; sum[now]=0; if(l&lt;r)&#123; L[now]=build(l,mid); R[now]=build(mid+1,r); &#125; return now;&#125;int update(int root,int l,int r,int x)&#123; int now=++cnt; L[now]=L[root]; R[now]=R[root]; sum[now]=sum[root]+1; if(l&lt;r)&#123; if(x&lt;=mid)L[now]=update(L[root],l,mid,x); else R[now]=update(R[root],mid+1,r,x); &#125; return now;&#125;int query(int lt,int rt,int l,int r,int x)&#123; if(l&gt;=r)&#123; if(B[l]&lt;=x)return sum[rt]-sum[lt]; else return 0; &#125; if(B[mid]&lt;=x)return sum[L[rt]]-sum[L[lt]]+query(R[lt],R[rt],mid+1,r,x); return query(L[lt],L[rt],l,mid,x);&#125;int mx;int quer(int x,int z)&#123; return query(root[1],root[x],1,mx,z);&#125;void dfs(int r,int f,int len)&#123; int i; root[r]=update(root[f],1,mx,lower_bound(B+1,B+mx+1,len)-B); for(i=hd[r];i;i=e[i].n)&#123; int q=e[i].e; if(q!=f)dfs(q,r,e[i].l); &#125;&#125;int main()&#123; int i,n,m,a,b,l; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;n;i++)scanf("%d%d%d",&amp;a,&amp;b,&amp;l),add(a,b,l),add(b,a,l),A[i]=B[i]=l; cnt=0; sort(B+1,B+n); mx=unique(B+1,B+n)-B-1; root[0]=build(1,mx); dfs(1,0,0); dfs2(1,0); for(i=2;i&lt;=n;i++)lg[i]=lg[i-1]+(1&lt;&lt;(lg[i-1]+1)==i); for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;l); printf("%d\n",quer(a,l)+quer(b,l)-2*quer(lca(a,b),l)); &#125; return 0;&#125; K 题目描述给定一个序列${a_n}$，定义三个函数$f,g,w$，$f(l,r)=\oplus a[x] (l\leq x\leq r)$，$g(l,r)=\oplus f(x) (l\leq x\leq r)$，$w(l,r)=\oplus g(x) (l\leq x\leq r)$。 有$q$个询问，每次询问一个区间$[l,r]$，输出$w(l,r)$。 解题思路比赛的时候模拟一下$fgw$打了个表找出来规律，然后就过了。 最后的结果是一个有规律的平行四边形，用线段树很容易维护。（用前缀和也可，但打线段树打上瘾了） 打表代码点击 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;int ans[1000];void f(int x,int y)&#123; int i; for(i=x;i&lt;=y;i++)ans[i]^=1;&#125;void g(int x,int y)&#123; int i,j; for(i=x;i&lt;=y;i++)for(j=i;j&lt;=y;j++)f(i,j);&#125;void w(int x,int y)&#123; int i,j; for(i=x;i&lt;=y;i++)for(j=i;j&lt;=y;j++)g(i,j);&#125;int main()&#123; int i,j; for(i=1;i&lt;=20;i++)&#123; memset(ans,0,sizeof(ans)); w(1,i); for(j=1;j&lt;=i;j++)printf("%d ",ans[j]); puts(""); &#125; return 0;&#125; 输出结果： $1$$1 1$$0 1 0$$0 0 0 0$$1 0 0 0 1$$1 1 0 0 1 1$$0 1 0 0 0 1 0$$0 0 0 0 0 0 0 0$$1 0 0 0 1 0 0 0 1$$1 1 0 0 1 1 0 0 1 1$$0 1 0 0 0 1 0 0 0 1 0$$0 0 0 0 0 0 0 0 0 0 0 0$$1 0 0 0 1 0 0 0 1 0 0 0 1$$1 1 0 0 1 1 0 0 1 1 0 0 1 1$$0 1 0 0 0 1 0 0 0 1 0 0 0 1 0$$0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0$$1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1$$1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1$$0 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 0 1 0$$0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0$ AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int read()&#123; char c=getchar();int now=0,f=1; while(c&gt;'9'||c&lt;'0')&#123; if(c=='-')f=-1; c=getchar(); &#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123; now=(now&lt;&lt;3)+(now&lt;&lt;1)+c-'0'; c=getchar(); &#125; return now*f;&#125;#define N 100010struct Tree&#123; int l,r,dat;&#125;t[4][N&lt;&lt;2];int a[N],n;void build(int R,int p,int l,int r)&#123; t[R][p].l=l;t[R][p].r=r; if(l==r)&#123; t[R][p].dat=(l%4==R)?a[l]:0; return; &#125; build(R,p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(R,p&lt;&lt;1|1,(l+r&gt;&gt;1)+1,r); t[R][p].dat=t[R][p&lt;&lt;1].dat^t[R][p&lt;&lt;1|1].dat;&#125;int query(int R,int p,int l,int r)&#123; int L=t[R][p].l,Rr=t[R][p].r; if(l&lt;=L&amp;&amp;Rr&lt;=r)return t[R][p].dat; if(L&gt;r||Rr&lt;l)return 0; return query(R,p&lt;&lt;1,l,r)^query(R,p&lt;&lt;1|1,l,r);&#125;int main()&#123; int T,i,q; T=read(); while(T--)&#123; n=read(); for(i=1;i&lt;=n;i++)a[i]=read(); for(i=0;i&lt;4;i++)build(i,1,1,n); q=read(); while(q--)&#123; int l=read(),r=read(); int R=l%4; if((r-l+1)%4==0)printf("0\n"); else if((r-l+1)%4==1)printf("%d\n",query(R,1,l,r)); else if((r-l+1)%4==3)printf("%d\n",query((R+1)%4,1,l+1,r)); else printf("%d\n",query(R,1,l,r)^query((R+1)%4,1,l+1,r)); &#125; &#125; return 0;&#125; L 题目描述有一棵树，第一年是一个杆，每年每个叶子节点伸出三个长度为当前树枝长度四分之一的树枝，分别与当前树枝方向呈$0°,60°,-60°$。给一个方程为$y=k(x-x_0)+y_0$的直线去砍这棵树，问最后根节点连带的一段没被砍掉的有多么长。 解题思路？？这么水一题当时怎么没做 根据深度找搜索方向，深搜一遍，$3^{14}$甚至不需要剪枝（什么，最后只跑了14ms）。 AC代码点击 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define delta (k*(a-x)+y-b)using namespace std;int n,l;double x,y,k;int OnLine(double a,double b)&#123; if(fabs(delta)&lt;1e-8)return 0; if(delta&lt;0)return -1; return 1;&#125;double dir[6][2]=&#123;&#123;0,1&#125;,&#123;-sqrt(3)/2,0.5&#125;,&#123;-sqrt(3)/2,-0.5&#125;,&#123;0,-1&#125;,&#123;sqrt(3)/2,-0.5&#125;,&#123;sqrt(3)/2,0.5&#125;&#125;;double dfs(int dep,int di,double a,double b,double len)&#123; if(dep==n||!OnLine(a,b))return 0; double dis=delta/(dir[di][1]-k*dir[di][0]); if(dis&gt;=0&amp;&amp;dis&lt;=len)return dis; return len+ dfs(dep+1,(di+1)%6,a+len*dir[di][0],b+len*dir[di][1],len/4)+ dfs(dep+1,di,a+len*dir[di][0],b+len*dir[di][1],len/4)+ dfs(dep+1,(di+5)%6,a+len*dir[di][0],b+len*dir[di][1],len/4);&#125;int main()&#123; int i,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%lf%lf%lf",&amp;l,&amp;n,&amp;x,&amp;y,&amp;k); printf("%.6f\n",dfs(0,0,0,0,l)); &#125; return 0;&#125; M 题目描述给一个只含小写字母的字符串$S$，$n$个字符串$T$，判断每一个$T$是否是$S$的子串。$0&lt; |S|,|T|\leq 1e5$。 解题思路代码&amp;思路 by Nikkukun 预处理出$nxt[i][j]$表示第$i$位字符之后最接近的字符$j+’a’$的下一个位置，$O(\sum_{i=1}^n len(T_i))$处理。 AC代码-By Nikkukun-1783ms点击 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;const int N=100000+5,C=26+2;char s[N],t[N];int nxt[N][C];int main()&#123; scanf("%s",s); int i,j,n=strlen(s),q; memset(nxt,-1,sizeof(nxt)); for(i=0;i&lt;n;i++)nxt[i][s[i]-'a']=i; for(j=0;j&lt;C;j++)nxt[n][j]=n; for(i=n-1;i&gt;=0;i--) for(j=0;j&lt;C;j++) if(~nxt[i][j])nxt[i][j]=nxt[i+1][j]; scanf("%d",&amp;q); while(q--)&#123; scanf("%s",t); int m=strlen(t); int p=0,cnt=0; while(cnt&lt;m&amp;&amp;nxt[p][t[cnt]-'a']&lt;n)&#123; p=nxt[p][t[cnt]-'a']+1; cnt++; &#125; printf((cnt==m)?"YES\n":"NO\n"); &#125; return 0;&#125; 赛后发现，原来暴力也能过，而且竟然只是$1700ms$和$2000ms$的差别。。。 AC代码-By Potassium-2093ms点击 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;char a[100002],b[100002];int main()&#123; int n,x,y,la,lb,flag; scanf("%s%d",a,&amp;n); while(n--)&#123; scanf("%s",b); if((lb=strlen(b))&gt;(la=strlen(a)))printf("NO\n"); else&#123; x=y=flag=0; while(x&lt;la&amp;&amp;y&lt;lb)&#123; if(a[x]==b[y])x++,y++; else&#123; x++; if(!a[x])&#123; flag=1; break; &#125; &#125; &#125; if(!b[y]&amp;&amp;!flag)printf("YES\n"); else printf("NO\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北理校赛2019.04.14 题解]]></title>
    <url>%2F2019%2F04%2F16%2Fbitcontest2019%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I J K L 12/12 O O O Ø O O Ø O Ø O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给一个表，求打表结果。 解题思路签到打比赛，一个愿打一个愿挨。 AC代码点击 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;int x[10][10]; char ch[4]=&#123;'I','E'&#125;;int main()&#123; int i,n; x[0][5]=x[1][1]=x[1][3]=x[1][5]=x[2][1]=x[2][3]=x[2][5]=1; x[3][1]=x[3][3]=x[3][5]=x[4][1]=x[5][3]=1; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; char a[10]=&#123;0&#125;; scanf("%s",a); int p=a[0]-'0',q=2; if(!p)&#123; printf("X"); continue; &#125; if(a[1])&#123; if(a[2])&#123; if(a[2]=='-')q=0; else q=4; &#125;else&#123; if(a[1]=='-')q=1; else q=3; &#125; &#125; printf("%c",ch[x[q][p]]); &#125; return 0;&#125; B 题目描述给定$m$个字符串$a[i] (1 \leq i \leq m)$，求一个长度为$n$的字符串$A$，使得$a[i] (i\leq i \leq m)$均不为$A$的连续子串。 解题思路$AC$自动机套$DP$。用$dep[i]$表示$i$这个节点最多能延伸到多么深。沿着$trie$图走，记忆化搜索，只要遇到字符串标记则记$dep[i]=0$。如果成环则必定可行（这一个环上都没有子串），所以用$vis[i]$表示当前走过的路径，以缩减搜索时间。最后输出的时候再沿着可行边走即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define N 800010#define P 26int t[N][P],END[N],fail[N],tot,n,m;char a[N];void insert()&#123; int i,now=0; for(i=0;a[i];i++)&#123; int c=a[i]-'a'; if(!t[now][c])t[now][c]=++tot; now=t[now][c]; &#125; END[now]++;&#125;queue&lt;int&gt;Q;void build()&#123; int i; for(i=0;i&lt;P;i++)if(t[0][i])Q.push(t[0][i]); while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(i=0;i&lt;P;i++)&#123; if(!t[p][i])t[p][i]=t[fail[p]][i]; else&#123; fail[t[p][i]]=t[fail[p]][i]; if(END[fail[t[p][i]]])END[t[p][i]]=1; Q.push(t[p][i]); &#125; &#125; &#125;&#125;int vis[N],dep[N];int dfs(int d,int now)&#123; if(vis[now])return dep[now]=1e6; if(~dep[now])return dep[now]; if(END[now])return dep[now]=0; if(!d)return dep[now]=1; vis[now]=1; dep[now]=0; int i; for(i=0;i&lt;P;i++)dep[now]=max(dep[now],dfs(d-1,t[now][i])+1); vis[now]=0; return dep[now];&#125;void print(int d)&#123; int i,now=0; while(d)&#123; for(i=0;i&lt;P;i++)&#123; if(d&lt;=dep[t[now][i]])&#123; printf("%c",i+'a');d--; now=t[now][i]; break; &#125; &#125; &#125;&#125;int main()&#123; int i; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;m;i++)scanf("%s",a),insert(); build(); memset(dep,-1,sizeof(dep)); dfs(n,0); print(n); return 0;&#125; C 题目描述路上有$n$个怪兽，每个怪兽有攻击力$x[i]$血量$d[i]$，你的攻击力是$k$。每遇到一个怪兽，你先手攻击，之后轮流攻击，当怪兽的血量$\leq 0$的时候该怪兽死亡。 有$c$个道具，该道具可以在瞬间吃下而且使本回合临时增加$k$点攻击力，该道具可以在任意时候吃，且可以连续吃。问你最少消耗多少血量。 解题思路一个道具相当于多打该怪兽一个回合，贪心地攻击攻击力最高的怪兽即可，记得开$long$ $long$。 AC代码点击 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct Monster&#123; int d,x; bool operator&lt;(const Monster&amp;a)const&#123;return x&gt;a.x;&#125;&#125;a[100010];int tot;int main()&#123; int i,n,k,c,d,x; scanf("%d%d%d",&amp;n,&amp;k,&amp;c); for(i=0;i&lt;n;i++)&#123; scanf("%d%d",&amp;d,&amp;x); if(d&gt;k)a[tot++]=(Monster)&#123;d/k+(d%k!=0)-1,x&#125;; &#125; sort(a,a+tot); int left=0; for(i=0;i&lt;c;i++)&#123; a[left].d--; if(a[left].d&lt;=0)left++; if(left&gt;=tot)break; &#125; long long ans=0; for(i=0;i&lt;tot;i++)ans+=a[i].d*1LL*a[i].x; printf("%lld",ans); return 0;&#125; D 题目描述在宽为$w$的走廊中有$n$个圆形障碍物，求能通过该走廊的最大圆的半径。 解题思路显然，最大的圆能够使得整个走廊两端连接。故以两点之间距离减两圆半径作为边权，用$krustal$跑一遍最小生成树，答案即为最大边权。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define N 1002using namespace std;struct Circle&#123; int x,y,r; double dis; bool operator&lt;(const Circle&amp;a)const&#123;return dis&lt;a.dis;&#125;&#125;a[N];int x[N],n,w;double dist(int X1,int Y1,int X2,int Y2)&#123; return sqrt((X1-X2)*(X1-X2)+(Y1-Y2)*(Y1-Y2));&#125;void upd(int now,int last)&#123; double d; if(a[last].y+a[last].r&gt;=w&amp;&amp;a[now].y+a[now].r&gt;=w)a[now].dis=0; else if(a[now].dis&gt;(d=dist(a[now].x,a[now].y,a[last].x,a[last].y)-a[now].r-a[last].r))a[now].dis=d;&#125;int main()&#123; int i,j,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;w,&amp;n); for(i=0;i&lt;n;i++)scanf("%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].r),a[i].dis=a[i].y-a[i].r,x[i]=a[i].x; sort(x,x+n); int mx=unique(x,x+n)-x; for(i=0;i&lt;mx;i++)a[n++]=(Circle)&#123;x[i],w,0,w*1.0&#125;; sort(a,a+n); double ans=max(a[0].dis,0.0); for(j=1;j&lt;n;j++)upd(j,0); sort(a,a+n); for(i=1;i&lt;n;i++)&#123; //for(j=0;j&lt;n;j++)printf("%d %d %d %.4f\n",a[j].x,a[j].y,a[j].r,a[j].dis); sort(a+i,a+n); ans=max(ans,a[i].dis); for(j=i+1;j&lt;n;j++)upd(j,i); &#125; printf("%.10f\n",ans/2); &#125; return 0;&#125; E 题目描述给一个全排列，求多少个栈才能把全排列变成有序的升序序列。 解题思路两个栈必定能完成全部操作：想取出任意一个元素均有可行方案。故只需要判断能否用一个栈解决。 AC代码点击 123456789101112131415161718#include&lt;stdio.h&gt;int st[100010],top,t,n,now,a[100010];int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; top=0;now=1; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)&#123; st[top++]=a[i]; while(top&amp;&amp;st[top-1]==now)top--,now++; &#125; if(now!=n+1)printf("2\n"); else printf("1\n"); &#125; return 0;&#125; F 题目描述给一个$n\times m$的网格图，求本质不同的四个顶点都在格点上构成的正方形个数。 解题思路先考虑边长为$i\times i$的正方形，以它的四个边上的点为顶点的正方形个数为$i$。 故答案即为$\sum_{i=1}^{m}(n-i+1)\times (m-i+1)\times i$。 AC代码点击 12345678910111213#include&lt;stdio.h&gt;int t,n,m;int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; long long ans=0; scanf("%d%d",&amp;n,&amp;m); for(i=1;i&lt;=m;i++)ans+=1LL*(n-i+1)*(m-i+1)*i; printf("%lld\n",ans); &#125; return 0;&#125; G 题目描述有两个区域，$A$区域的人全都要去$B$区域。$A$区域的人分别位于$c[i]$上，$B$区域只能到达$d[i]$。现在给定$n$条特殊道路，$A$区域$[a,b]$范围和$B$区域$[c,d]$范围连通，需要的耗时为$w$，问$A$区的人同时出发，最后到达的人所需时间是多少。 解题思路新建$s,t$，连$t-&gt;B,B-&gt;A,A-&gt;s$的边，跑最短路，找到$t$到$c[i]$路径最长的即为答案。 三种边分别如何连呢？ $t-&gt;B:$$t$到所有$d[i]$$A-&gt;s:$所有$c[i]$到$s$（其实完全可以不连）$B-&gt;A:$线段树维护，添加特殊点保证连边数量线性。 其中令左线段树($B$)上的点为其编号本身，令右线段树($A$)上的点为其编号本身$+2n$，叶节点序号用$lnum,rnum$表示。 线段树维护过程：将线段树上每一个节点视为点，则该点代表所有以它为根的子树，故初始化的时候左线段树连接从儿子到爸爸权值为$0$的边，右线段树连接从爸爸到儿子权值为$0$的边。添加特殊道路时，添加一个中间特殊点，分别同向连接两棵线段树。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;bits/stdc++.h&gt;using namespace std;#define N (100000&lt;&lt;3)struct Edge&#123; int e,n,l;&#125;e[(N)&lt;&lt;2];int hd[N],cnt;void add(int a,int b,int l)&#123; e[++cnt].e=b;e[cnt].n=hd[a];e[cnt].l=l;hd[a]=cnt; //printf("%d %d %d %d\n",a,b,l,cnt);&#125;struct Tree&#123; int l,r;&#125;t1[N],t2[N];int t,s,n,m,p,q;int c[N],d[N];int ltnum(int x)&#123;return x;&#125;//lefttreenumint rtnum(int x)&#123;return x+2*n;&#125;//righttreenumint lnum[N],rnum[N];int tot;void build(struct Tree *a,int l,int r,int p,int dir)&#123;//dir:从根到叶-1；从叶到根-0 a[p].l=l; a[p].r=r; if(l==r)&#123; if(!dir)lnum[l]=p; else rnum[l]=p+2*n; return; &#125; build(a,l,(l+r)&gt;&gt;1,p&lt;&lt;1,dir); build(a,((l+r)&gt;&gt;1)+1,r,p&lt;&lt;1|1,dir); if(a[p&lt;&lt;1].l)&#123; if(!dir)add(ltnum(p&lt;&lt;1),ltnum(p),0); else add(rtnum(p),rtnum(p&lt;&lt;1),0); &#125; if(a[p&lt;&lt;1|1].l)&#123; if(!dir)add(ltnum(p&lt;&lt;1|1),ltnum(p),0); else add(rtnum(p),rtnum(p&lt;&lt;1|1),0); &#125;&#125;void adde(struct Tree *a,int l,int r,int midpoint,int p,int dir,int w,int offset)&#123; //offset:点的id int L=a[p].l,R=a[p].r; if(l&lt;=L&amp;&amp;R&lt;=r)&#123; if(!dir)add(p+offset,midpoint,w); else add(midpoint,p+offset,w); return; &#125; if(a[p&lt;&lt;1].r&gt;=l)adde(a,l,r,midpoint,p&lt;&lt;1,dir,w,offset); if(a[p&lt;&lt;1|1].l&lt;=r)adde(a,l,r,midpoint,p&lt;&lt;1|1,dir,w,offset);&#125;struct Node&#123; int x; long long w; bool operator&lt;(const Node&amp;a)const&#123;return w&gt;a.w;&#125;&#125;;priority_queue&lt;Node&gt;Q;int vis[N];long long dis[N];void dijkstra()&#123; int i; Q.push((Node)&#123;t,0&#125;); while(!Q.empty())&#123; int top=Q.top().x; Q.pop(); if(vis[top])continue; vis[top]=1; for(i=hd[top];i;i=e[i].n)&#123; int q=e[i].e; if(dis[q]&gt;dis[top]+0LL+e[i].l)&#123; dis[q]=dis[top]+0LL+e[i].l; Q.push((Node)&#123;q,dis[q]&#125;); &#125; &#125; &#125;&#125;int main()&#123; int i,a,b,C,D,w; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;p,&amp;q); while(n&amp;(n-1))n++; t=4*n+1; tot=s=4*n+2; build(t1,1,n,1,0); build(t2,1,n,1,1); for(i=0;i&lt;m;i++)&#123; scanf("%d%d%d%d%d",&amp;a,&amp;b,&amp;C,&amp;D,&amp;w); adde(t2,a,b,++tot,1,0,w,2*n); adde(t1,C,D,tot,1,1,0,0); adde(t2,C,D,++tot,1,0,w,0); adde(t1,a,b,tot,1,1,0,2*n); &#125; for(i=0;i&lt;p;i++)scanf("%d",&amp;c[i]); for(i=0;i&lt;q;i++)scanf("%d",&amp;d[i]); sort(d,d+q);q=unique(d,d+q)-d;for(i=0;i&lt;q;i++)add(t,lnum[d[i]],0); sort(c,c+p);p=unique(c,c+p)-c;for(i=0;i&lt;p;i++)add(rnum[c[i]],s,0); memset(dis,0x3f,sizeof(dis)); dis[t]=0; dijkstra(); long long ans=0; for(i=0;i&lt;p;i++)ans=max(ans,dis[rnum[c[i]]]); if(ans&lt;1e16)printf("%I64d",ans); else printf("boring game"); return 0;&#125; H 题目描述找出$\sqrt {ax}+b=x$的解，保证解存在且为整数。 解题思路初中数学题。 AC代码点击 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;math.h&gt;int t,a,b;int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;a,&amp;b); int A[6]=&#123;0&#125;,ans=0; int x1=round(1.0*(2*b+a+sqrt(a*a+4*a*b))/2),x2=round(1.0*(2*b+a-sqrt(a*a+4*a*b))/2); if(fabs(sqrt(a*x1)+b-x1)&lt;1e-5)A[ans++]=x1; if(fabs(sqrt(a*x2)+b-x2)&lt;1e-5&amp;&amp;x2!=x1)A[ans++]=x2; printf("%d\n",ans); for(i=0;i&lt;ans;i++)printf("%d ",A[i]); puts(""); &#125; return 0;&#125; I 题目描述给一个$n\times n$的棋盘，每个格子可以填$[1,k]$的正整数，定义棋盘中某个点为$bi$点当且仅当其为该行该列严格最大值，设$B[i]$为棋盘中恰好存在$i$个$bi$点的方案数，求$\sum_{i=0}^{n^2}i^2B[i]$。 解题思路由于任意交换两行两列不影响$bi$点状况，故可以先讨论$bi$点在对角线且$bi$点非严格单调递增的情况。 设$dp[i][j]$表示已经确定了前$i$个$bi$点，且其中最大的$bi$点对应数值不超过$j$的方案总数。 那么有：$dp[i][j]=\sum_{k=0}^{j-1}dp[k][j-1]\times \frac{(j-1)^{(i-k)(2n-i-k-1)}}{(i-k)!}$。 递推的过程即为填$bi$点值为$j$的状态。其中$dp[k][j-1]$表示前$k$行列不超过$j-1$，$j-1$的次方表示非前$k$行控制的、$k+1$到$i$行列的，由新增加进来的值为$bi$点控制的节点。最后除以$(i-k)!$为了除重。 设至少有$i$个$bi$点的方案数位$b[i]$，则有$b[i]={A_{n}^{i}}^2dp[i][k]\times k^{(n-i)^2}$，即从$n$行$n$列分别选出$i$行$i$列，且最大不超过$k$，剩下未支配的部分从$[1,k]$任取的方案个数，这段可能有重复，不过无关紧要，请看下一步。 再设$f[i]$为恰好有$i$个$bi$点的方案总数，则可以进行容斥：$f[i]=b[i]+\sum_{i&lt;j}(-1)^{(j-i)}b[j]\times C_{j}^{i}$。 最后即可得出结果。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 205typedef long long ll;int f[N],dp[N][N],b[N];ll w=998244353,jc[N]=&#123;1&#125;;ll qpow(ll x,ll p)&#123; int i; ll ans=1; for(i=p;i;i&gt;&gt;=1,x=x*x%w)if(i&amp;1)ans=ans*x%w; return ans;&#125;ll inv(ll x)&#123;return qpow(x,w-2);&#125;int main()&#123; int i,j,k,t,n,K; scanf("%d",&amp;t); for(i=1;i&lt;N;i++)jc[i]=jc[i-1]*i%w; while(t--)&#123; scanf("%d%d",&amp;n,&amp;K); memset(dp,0,sizeof(dp)); memset(b,0,sizeof(b)); memset(f,0,sizeof(f)); for(i=0;i&lt;=n;i++)dp[0][i]=1; for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;=K;j++)&#123; for(k=0;k&lt;=i;k++) dp[i][j]+=dp[k][j-1]*qpow(j-1,(i-k)*(2*n-i-k-1))%w*inv(jc[i-k])%w; &#125; &#125; for(i=1;i&lt;=n;i++) b[i]=jc[n]*inv(jc[n-i])%w*jc[n]*inv(jc[n-i])%w*dp[i][K]%w*qpow(K,(n-i)*(n-i))%w; for(i=1;i&lt;=n;i++)&#123; f[i]=b[i]; int nowsign=-1; for(j=i+1;j&lt;=n;j++)&#123; f[i]+=(nowsign)*b[j]*jc[j]%w*inv(jc[i])%w*inv(jc[j-i])%w; f[i]%=w; nowsign*=-1; &#125; f[i]+=w; f[i]%=w; &#125; ll ans=0; for(i=1;i&lt;=n;i++) (ans+=i*i*f[i])%=w; printf("%lld\n",(ans%w+w)%w); &#125; return 0;&#125; J 题目描述定义一个合法的算式是一个恰好长为$n$的字符串，其中只包含$0-9,+,-$，不允许运算符相邻或出现在首尾，允许前导零。合法的算式的计算结果即为对该字符串模拟十进制加减法运算的结果。 求所有合法算式计算结果的和，答案对$998244353$取模。 解题思路由于$+$和$-$都可以出现，所以能出现加号的地方必能出现减号，只需要考虑算式最左端的数对应的结果即可。 可设： $p[j]=10^i$$f[i]=\frac{10^i}{2}(10^i+1)$，此即只含有$i$位数字的算式计算结果。$g[i]$为长度为$i$、第一个字符为$+$或$-$的不同串总种数。$ans$为长度为$n$的合法算式计算结果的和。 则有$g[2]=20,g[i]=2p[i-1]+\sum_{j=2}^{i-2}2p[i-j-1]g[j]$ 处理成前缀和： $g[i]=2f[i-1]+10^{i-1}\sum_{j=2}^{i-2}2*10^{-j}g[j]$ $=2f[i-1]+p[i-1]h[i-2]$ 其中$h[i]=\sum_{j=2}^{i}2\times 10^{-j}g[j]$，同时处理即可。 $ans=f[n]+\sum_{j=2}^{n-1}f[n-j]g[j]$ AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define N 500002typedef long long ll;int t,a,b;ll inv=299473306;ll w=998244353;ll p[N]=&#123;1&#125;;ll f[N]=&#123;1&#125;,g[N],h[N];ll invf[N]=&#123;1&#125;;int main()&#123; int i,n; scanf("%d",&amp;t); for(i=1;i&lt;N;i++)p[i]=p[i-1]*10%w; for(i=1;i&lt;N;i++) f[i]=(p[i]-1)*p[i-1]*5%w,invf[i]=invf[i-1]*inv%w; g[2]=20; while(t--)&#123; ll ans=0; scanf("%d",&amp;n); for(i=2;i&lt;=n;i++)&#123; g[i]=(2*p[i-1]+p[i-1]*h[i-2])%w; h[i]=(h[i-1]+2*invf[i]*g[i])%w; &#125; for(i=2;i&lt;=n-1;i++)ans=(ans+f[n-i]*g[i])%w; ans=(ans+f[n])%w; //for(i=1;i&lt;n;i++)printf("h:%I64d g:%I64d f:%I64d\n",h[i],g[i],f[i]); printf("%I64d\n",ans); &#125; return 0;&#125; K 题目描述给一个多项式，求其导数各指数的系数。 解题思路签到。 AC代码点击 12345678910111213#include&lt;stdio.h&gt;int main()&#123; int i,j,n,k,a[110]=&#123;0&#125;; scanf("%d%d",&amp;n,&amp;k); for(i=n;i&gt;=0;i--)scanf("%d",&amp;a[i]); for(i=0;i&lt;k;i++)&#123; for(j=0;j&lt;=n;j++) a[j]=(a[j]*((j&gt;i)?j-i:0))%2019; &#125; for(i=0;i&lt;k;i++)printf("0 "); for(i=n;i&gt;=k;i--)printf("%d ",a[i]%2019); return 0;&#125; L 题目描述给定$n$个点，$m$条边权均为$1$的边，从节点$1$开始，等概率选择其后继或停留，最多停留时间 为$1$，问总时间期望。 解题思路推出式子树形$DP$即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#define N 100010typedef long long ll;struct Edge&#123; int e,n;&#125;e[N];int ind[N],oud[N],cnt,hd[N],n,m;void add(int a,int b)&#123; e[++cnt].e=b;e[cnt].n=hd[a];hd[a]=cnt; ind[b]++;oud[a]++;&#125;int w=998244353;ll qpow(ll x,ll p)&#123; int i; ll ans=1; for(i=p;i;i&gt;&gt;=1,x=x*x%w)if(i&amp;1)ans=ans*x%w; return ans;&#125;ll inv(ll x)&#123;return qpow(x,w-2);&#125;ll dfs(int x)&#123; if(!oud[x])return 2; int i,q; ll p=0; for(i=hd[x];i;i=e[i].n)&#123; q=e[i].e; (p+=dfs(q))%=w; &#125; return (1+(p+oud[x])*inv(oud[x]+1)%w+inv(oud[x]+1)*inv(oud[x])%w*(p+2*oud[x]))%w;&#125;int main()&#123; int i,t,u,v; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;m); for(i=0;i&lt;m;i++)scanf("%d%d",&amp;u,&amp;v),add(u,v); printf("%lld\n",dfs(1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2050 Programming Competition 部分题解]]></title>
    <url>%2F2019%2F04%2F15%2F2050contest%2F</url>
    <content type="text"><![CDATA[Solved A B C D E F G H I 7/9 O O O O O O Ø . . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述问一个字符串是不是$2050$拼成的。 解题思路签到题，暴力求解。 AC代码点击 1234567891011121314151617181920#include&lt;stdio.h&gt;char a[10000010];int main()&#123; int i,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",a); int flag=0; for(i=0;a[i];i+=4)&#123; if(a[i]=='2'&amp;&amp;a[i+1]=='0'&amp;&amp;a[i+2]=='5'&amp;&amp;a[i+3]=='0'); else &#123; flag=1; break; &#125; &#125; if(flag)printf("No\n"); else printf("Yes\n"); &#125; return 0;&#125; B 题目描述给一个年月日时分秒，求这个时间点和$2050$年$1$月$1$日$0$时$0$分$0$秒差多少秒，答案对$100$取模。 解题思路刚开始一边写判断闰年一边暗骂出题者毒瘤，写到一半突然发现答案竟然是对$100$取模？？ （脏话） 直接计算这是该天的第几秒，判断一下这个时间在给定日期之前还是之后即可。 AC代码点击 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int t,y,m,d,h,min,s; scanf("%d",&amp;t); while(t--)&#123; int ans=0; scanf("%d-%d-%d",&amp;y,&amp;m,&amp;d); scanf("%d:%d:%d",&amp;h,&amp;min,&amp;s); ans=h*3600+min*60+s; if(y&lt;2050)ans=86400-ans; printf("%d\n",ans%100); &#125; return 0;&#125; C 题目描述有一堆人，$n+k$个男生，$m+k$个女生，其中$k$对情侣。有双人间$a$、三人间$b$、情侣间$c$，其中情侣间只能住情侣，双人三人间只能住同性且可以不住满。三种房间分别有不同价格，求把他们安排下住宿的最小花费。 解题思路刚开始想的是取情侣全住$c$和全不住$c$的最小值，然后兴高采烈交了个$WA$。 后来才发现，情侣可以部分住$c$，枚举即可。 $f$表示的是$x$个人分配到$a$或$b$间的最小花费，分三种情况（除三的余数）讨论即可。 然后递推就可以了。 AC代码点击 123456789101112131415161718192021222324#include&lt;stdio.h&gt;typedef long long ll; int t,n,m,k;ll a,b,c;ll min(ll a,ll b)&#123;return a&gt;b?b:a;&#125;ll f(int x)&#123; ll ans=0; if(x&lt;3)return min(a,b); if(x%3==1)ans=min((x/3+1)*b,(x/3-1)*b+2*a); else if(x%3==2)ans=min((x/3+1)*b,x/3*b+a); else ans=x/3*b; return min((x/2+(x%2!=0))*a,ans);&#125;int main()&#123; scanf("%d",&amp;t); int i; while(t--)&#123; scanf("%d%d%d%lld%lld%lld",&amp;n,&amp;m,&amp;k,&amp;a,&amp;b,&amp;c); ll ans=f(n+k)+f(m+k); for(i=0;i&lt;k;i++)ans=min(ans,f(n+i)+f(m+i)+(k-i)*c); printf("%lld\n",ans); &#125; return 0;&#125; D 题目描述给一个计分规则，求最终奖品个数。 给定一个$01$串，求每一个前缀包含的所有本质不同的字母串个数。 解题思路纯模拟，没啥好说的。 显然需要离线处理枚举前缀的结尾。 第一思路是，从前缀的结尾$i$往前递推，$num$记录最多能向后延伸几位，$dp[j]$表示$j$之后的字母串种类个数。 AC代码点击 1234567891011121314151617181920212223#include&lt;stdio.h&gt;#include&lt;string.h&gt;int a[10010],num[10010];int peo[10010];int main()&#123; int i; int t,n,m,k; scanf("%d",&amp;t); while(t--)&#123; memset(num,0,sizeof(num)); memset(peo,0,sizeof(peo)); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); num[a[i]]++; &#125; for(i=0;i&lt;=m;i++)peo[i]=num[i]-num[i]/k; int ans=0; for(i=0;i&lt;n/2;i++)if(num[a[i]]&gt;peo[a[i]])num[a[i]]--,ans++; printf("%d\n",ans); &#125; return 0;&#125; E 题目描述两个人打乒乓球。给一个球赛的计分榜，其中有$A$得分、$B$得分、未知得分三种情况，问最多进行了多少场比赛。 解题思路这题的$DP$挺麻烦的。 可以设一个$f[i][j][k]$表示在第$k$个计分之后，$A$和$B$比分为$i:j$的时候，最多可能的比赛轮数，其中$-1$表示不可能到达这种局面。其中，$10:10$之后某方得分可以化为$10:9$，特判即可。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int f[12][12][10010];char a[10010];int main()&#123; int i,j,k,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",a+1); int l=strlen(a+1); memset(f,-1,sizeof(f)); f[0][0][0]=0; for(i=1;a[i];i++)&#123; if(a[i]=='A')&#123; for(j=1;j&lt;=10;j++) for(k=0;k&lt;=10;k++) if(~f[j-1][k][i-1])f[j][k][i]=f[j-1][k][i-1]; for(j=0;j&lt;10;j++) if(~f[10][j][i-1])f[0][0][i]=max(f[0][0][i],f[10][j][i-1]+1); f[10][9][i]=max(f[10][10][i-1],f[10][9][i]); &#125;else if(a[i]=='B')&#123; for(j=0;j&lt;=10;j++) for(k=1;k&lt;=10;k++) if(~f[j][k-1][i-1])f[j][k][i]=f[j][k-1][i-1]; for(j=0;j&lt;10;j++) if(~f[j][10][i-1])f[0][0][i]=max(f[0][0][i],f[j][10][i-1]+1); f[9][10][i]=max(f[10][10][i-1],f[9][10][i]); &#125;else&#123; for(j=0;j&lt;=10;j++) for(k=0;k&lt;=10;k++)&#123; if(j&amp;&amp;~f[j-1][k][i-1])f[j][k][i]=f[j-1][k][i-1]; if(k&amp;&amp;~f[j][k-1][i-1])f[j][k][i]=f[j][k-1][i-1]; &#125; for(j=0;j&lt;10;j++)&#123; if(~f[j][10][i-1]) f[0][0][i]=max(f[0][0][i],f[j][10][i-1]+1); if(~f[10][j][i-1]) f[0][0][i]=max(f[0][0][i],f[10][j][i-1]+1); &#125; f[9][10][i]=max(f[10][10][i-1],f[9][10][i]); f[10][9][i]=max(f[10][10][i-1],f[10][9][i]); &#125; /*printf("%d %c\n",i,a[i]); for(j=0;j&lt;12;j++)&#123; for(k=0;k&lt;12;k++)printf("%d ",f[j][k][i]); puts(""); &#125; puts("");*/ &#125; int ans=0; for(i=0;i&lt;=10;i++)for(j=0;j&lt;=10;j++) ans=max(ans,f[i][j][l]); printf("%d\n",ans); &#125; return 0;&#125; F 题目描述现在，我们要依次面对$n$个冰水挑战，每个挑战你都可以选择接受或不接受。接受第$i$个挑战会让你丧失$a_i$点体力，因为每个挑战所处的环境不同，如果你要挑战它，在挑战它之前你的体力$x$会变成 $min(x,b_i)$，当你完成这个挑战的时候，你的体力会变成$x−a_i$，体力任何时候不允许小于等于$0$，无论你是否接受第$i$个挑战，在这个挑战结束以后你的体力都会增加$c_i$。 解题思路$f[i][j]$表示进行到第$i$个挑战，已经完成了$j$ 个挑战之后，最大的体力值。然后$dp$即可。 AC代码点击 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;int t,n;long long p,a[1010],b[1010],c[1010];long long f[1010][1010];int main()&#123; int i,j; scanf("%d",&amp;t); while(t--)&#123; memset(f,0,sizeof(f)); scanf("%d%lld",&amp;n,&amp;p); for(i=1;i&lt;=n;i++)scanf("%lld%lld%lld",&amp;a[i],&amp;b[i],&amp;c[i]); f[0][0]=p; for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;=i;j++)&#123; if(f[i-1][j])f[i][j]=f[i-1][j]+c[i]; if(j&amp;&amp;min(f[i-1][j-1],b[i])-a[i]&gt;0) f[i][j]=max(f[i][j],min(f[i-1][j-1],b[i])-a[i]+c[i]); &#125; &#125; int ans=0; for(i=1;i&lt;=n;i++)if(f[n][i])ans=i; printf("%d\n",ans); &#125; return 0;&#125; G 题目描述我们看到了一栋高楼大厦，大厦的墙面可以看做一个$W×H$的矩形，我们把它的左下角当成$(0,0)$，右上角当成$(W,H)$。上面分布着一些$LED$灯，这些$LED$灯与地面呈$45$度倾斜，并且从矩形的边界延伸到另一边界，把大厦分成了若干个区域。我们想数一下这个图里面存在多少个与地面成$45$度角的矩形，其中四条边都是$LED$灯的一部分。 解题思路比赛并没有过这个题，但是想到了一种扫描线算法，出奇的麻烦，结果听学长说用$bitset$简单可过…… AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;bitset&gt;using namespace std;#define N 1002int w,h,n,m,a[N],b[N];long long W=1000000007;bitset&lt;N&gt; B[N];void solve()&#123; long long ans=0; scanf("%d%d%d%d",&amp;w,&amp;h,&amp;n,&amp;m); int i,j; for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); for(j=0;j&lt;N;j++)B[i][j]=0; &#125; for(i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;b[i]); for(j=1;j&lt;=n;j++)if(a[j]+b[i]&gt;=0&amp;&amp;a[j]+b[i]&lt;=2*w&amp;&amp;a[j]&gt;=b[i]&amp;&amp;a[j]-b[i]&lt;=2*h)B[j][i]=1; &#125; for(i=1;i&lt;=n;i++) for(j=i+1;j&lt;=n;j++)&#123; long long sum=(B[i]&amp;B[j]).count(); (ans+=sum*(sum-1)/2)%=W; &#125; printf("%lld\n",ans);&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--)solve(); return 0;&#125; 后面的题还没看……]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀数组&后缀自动机学习笔记]]></title>
    <url>%2F2019%2F04%2F10%2Fsuffixarray%2F</url>
    <content type="text"><![CDATA[今天干了两件事情，学会了后缀数组，搞定了洛谷$AC$数量的问题，以后可以不用洛谷咯！ 继续学习、复习算法，下一步是后缀自动机。 后缀数组这儿有道纯模板题 思路只学了倍增法，但也折腾了半天。贴一下自己的想法。 既然要对后缀排序，那首先当然要找出所有后缀从第一位开始比较了。 于是一上来就有了下面这段代码： 1234for(i=0;i&lt;m;i++)c[i]=0;for(i=0;i&lt;n;i++)c[x[i]=s[i]]++;for(i=1;i&lt;m;i++)c[i]+=c[i-1];for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; 妈耶，这一堆数组都是啥 $c[i]: $一个辅助数组，用处见下面注释$x[i]: $呃，这一步的作用仅仅是记录一下$s[i]$的$ASCII$码值。$s[i]: $就是给定的字符串啦。$sa[i]: $当前排名为$i$的后缀，起始位置的下标。 一句话一句话解释。 1234567891011for(i=0;i&lt;m;i++)c[i]=0;//数组清零for(i=0;i&lt;n;i++)c[x[i]=s[i]]++;//表示这个地方有个东西（比如字符串"abbcc"），最终结果是c['a']=1,c['b']=2,c['c']=2。//那其实这里的c数组就是一个桶。//这里先把第一位排好序。for(i=1;i&lt;m;i++)c[i]+=c[i-1];//统计前缀和，方便后续统计排名。for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i;//统计排名的时候要求排名互不相同，于是强制在字符相同的情况下，第一个字母靠前的排名靠前。//这里倒着循环以满足上述条件。 好了，这步结束之后，第一位比较完了。 先看一个例子：$ababbaba$ 第一次排序后：（$97$为$‘a’$的$ASCII$码值) $i$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $x [i]$ $97$ $98$ $97$ $98$ $98$ $97$ $98$ $97$ $sa [i]$ $0$ $2$ $5$ $7$ $1$ $3$ $4$ $6$ $sa[i+1]$ $2$ $5$ $7$ $1$ $3$ $4$ $6$ $0$ 根据字典序的思想，在第一位字符相同的情况下应该接着比较下一个位置。也就是基数排序，在第一个字符相等的基础上，更细的分离出第二个字符上的区别。 那么我假设前两个字符都比完了，那么接下来该比较的是前三个字符，前四个字符……但实际上，在比完前两个字符的情况下，可以直接添加两个字符（第二关键词）到前四个字符，在下一轮添加四个字符（第二关键词）到前八个字符……这里就可以应用倍增的思想进行比较了。 接下来的代码比较长，分几部分，逐步理解。 123456for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; ...&#125; $y[i]:$ 第二关键词（即第2个，第3,4个，第5,6,7,8个……）的排序，$y[i]=j$表示排名$i$的第二关键词，第一关键词的起始位置为$j$。 $[0,i]$中，后$k$个位置的第二关键词是$0$，所以这是最小的，先加入$y$数组。 然后其他的相应排名为$sa[i]$，前面已经排了$k$个，故排名为$sa[i]-k$。 执行完这段代码后： $i$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $y [i]$ $7$ $1$ $4$ $6$ $0$ $2$ $3$ $5$ 接着和第一次几乎一样的排序： 12345for(i=0;i&lt;m;i++)c[i]=0;//清空桶for(i=0;i&lt;n;i++)c[x[i]]++;//扔进桶for(i=1;i&lt;m;i++)c[i]+=c[i-1];//前缀和for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i];//这里是唯一不一样的地方，起到的作用就是在第一次的基础上对第二关键词排序 执行完这段代码后： $i$ $0$ $1$ $2$ $3$ $4$ $5$ $6$ $7$ $sa[i]$ $7$ $0$ $2$ $5$ $1$ $4$ $6$ $3$ 对应字符串 $a0$ $ab$ $ab$ $ab$ $ba$ $ba$ $ba$ $bb$ 然后$y$数组已经光荣完成使命，下一轮的$x$数组由这一轮的$x$数组决定。怎么决定呢？显然，如果两个后缀的第一、二关键字在上一轮排名相同，那么本轮排名也相同；否则不同。于是就有： 123456std::swap(x,y);//其实是扔掉了y数组num=1;x[sa[0]]=0;//排名为0for(i=1;i&lt;n;i++)x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++;if(num&gt;=n)break;//排序完成的字符数到了n，也就是没有不同排名的后缀了，那么退出m=num;//优化一下循环 多次类似倍增后，即可得到结果。 代码123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#define N 1000010char s[N];int x[N],y[N],sa[N],c[10*N];int main()&#123; int i,k,n,m=10000; scanf("%s",s); n=strlen(s); for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[i]=s[i]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i; for(k=1;k&lt;=n;k&lt;&lt;=1)&#123; int num=0; for(i=n-k;i&lt;n;i++)y[num++]=i; for(i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[num++]=sa[i]-k; for(i=0;i&lt;m;i++)c[i]=0; for(i=0;i&lt;n;i++)c[x[y[i]]]++; for(i=1;i&lt;m;i++)c[i]+=c[i-1]; for(i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i]; std::swap(x,y); num=1; x[sa[0]]=0; for(i=1;i&lt;n;i++) x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?num-1:num++; if(num&gt;=n)break; m=num; &#125; for(i=0;i&lt;n;i++)printf("%d ",sa[i]+1); return 0;&#125; 可是光排序似乎做不了什么事呢！ 引入一个数组$height[i]$，它代表的意义是，排序第$i$和第$i-1$的两个后缀的最长公共前缀。用符号语言表示就是：$height[i]=LCP(suffix(sa[i]),suffix(sa[i-1]))$。（$suffix(i)$表示以$i$为开头的后缀） 那么如何求这个数组呢？单纯的暴力去求，复杂度是爆炸的$O(n^2)$。 引入$rank[i]$数组，表示$suffix(i)$的排名为$rank[i]$。 设$h[i]=height[rank[i]]$，即$h[i]$表示$suffix(i)$和比$suffix(i)$排名靠前一个的后缀的$LCP$，则有$h[i]\geq h[i-1]-1$（证明略去，手推思考一下就是这么一回事）。故从头枚举$suffix(i)$，递推可以算出$height$数组。 于是就有了这段代码： 1234567891011121314void geth()&#123; int i,j,k=0; for(i=0;i&lt;n;i++)rank[sa[i]]=i; for(i=0;i&lt;n;i++)&#123; if(!rank[i])&#123; height[0]=k=0; continue; &#125; if(k)k--; j=sa[rank[i]-1]; while(s[i+k]==s[j+k])k++; height[rank[i]]=k; &#125;&#125; 学到这里的时候一直不明白这个数组为什么要叫$height$，刚刚才弄明白原来他的意思是后缀$trie$上的从左到右相邻两个末端节点（指代表后缀结束处的节点）$LCA$的深度。 所以就可以用这个特殊的性质解决问题了。 问题1 求LCP(suffix(i),suffix(j))也就是求$min(height[k]),k∈[i+1,j]$（假设$i$排名靠前）。用$ST$表+$RMQ$或者线段树查询即可。 1234567891011121314151617181920212223242526void init(int n)&#123; int i,j; for(i=0;i&lt;=n;i++)st[0][i]=height[i]; for(i=n-1;i;i--) for(j=1;(1&lt;&lt;j)+i-1&lt;=n;j++) st[j][i]=std::min(st[j-1][i],st[j-1][i+(1&lt;&lt;(j-1))]);&#125;int query(int l,int r)&#123; int m=0; if(l&gt;r)std::swap(l,r); l++; while((1&lt;&lt;(m+1))&lt;r-l+1)m++; return std::min(st[m][l],st[m][r-(1&lt;&lt;m)+1]);&#125;void solve()&#123; scanf("%d",&amp;q); while(q--)&#123; scanf("%d%d",&amp;l,&amp;r); if(l==r)printf("%d\n",n-l); else&#123; l=rank[l];r=rank[r]; if(l&gt;r)swap(l,r); printf("%d\n",query(l+1,r)); &#125; &#125;&#125; 问题2 求可以重叠的最长重复子串显然，求出$max(height[i])$即可。 （强迫症贴个代码） 1234void solve()&#123; int i,ans=0; for(i=0;i&lt;n;i++)ans=max(ans,height[i]);&#125; 问题3 求不可重叠的最长重复子串考虑到可以枚举答案且答案具有单调性，故考虑二分答案。 问题转化成：是否存在两个长度为$mid$的相同的串，他们的起始位置相差大于等于$mid$。 在后缀数组中转化成：$LCP(i,j)\geq mid,sa[j]-sa[i]\geq mid$。 于是在$height[i]&lt;mid$的地方设置隔板，在每一个小区间内求出$sa$数组的最大最小值，判断即可。 123456789101112131415161718192021int jud(int x)&#123; int i,mx=-1e9,mn=1e9; for(i=0;i&lt;n;i++)&#123; if(height[i]&lt;mid)mx=mn=sa[i]; else&#123; mx=max(mx,sa[i]); mn=min(mn,sa[i]); if(mx-mn&gt;=mid)return 1; &#125; &#125; return 0;&#125;void solve()&#123; int l=0,r=n,ans=0,mid; while(l&lt;r)&#123; mid=(l+r)&gt;&gt;1; if(jud(mid))l=mid+1,ans=mid; else r=mid; &#125; printf("%d",ans);&#125; 其他见这里 后缀自动机此坑待填。]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vjudge294125-动态规划训练 题解]]></title>
    <url>%2F2019%2F04%2F09%2Fvjudge294125dp4-9%2F</url>
    <content type="text"><![CDATA[Solved A B C D 4/4 O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 突然看到有套在线$DP$比赛，就顺便打了一下，还挺有趣的。 比赛链接 A 题目描述给一个$1/2$序列，可以取某一段区间进行翻转操作（该区间所有元素$1$-$2$，$2$-$1$）求一种操作使得最终非严格递增序列最长并求出最大值。 解题思路枚举待操作区间中的一点$i$。枚举区间左端点$j$，统计从$[1,j]$中$1$的总个数与$[j+1,i]$中$2$的总个数和的最大值$l$。枚举区间右端点$j$，统计从$[i,j]$中$1$的总个数与$[j+1,n]$中$2$的总个数和的最大值$r$。则$l+r$即为最大值。用前缀和计算上述问题。 AC代码点击 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 2010int n,a[N],p[N],q[N],ans;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++)p[i]=p[i-1]+(a[i]==1); for(i=n;i;i--)q[i]=q[i+1]+(a[i]==2); for(i=1;i&lt;=n;i++)&#123; int r=0,l=0; for(j=1;j&lt;=i+1;j++)l=max(l,p[j-1]+q[j]-q[i+1]); for(j=i;j&lt;=n;j++)r=max(r,q[j+1]+p[j]-p[i]); ans=max(ans,l+r); &#125; printf("%d",ans); return 0;&#125; B 题目描述题干极长，英语阅读能力差，看了好吓人。题目中给的图$AB$之间还有空缺，理解了半天，原来是图错了。 简单概括为一句话：给定先序遍历的路径，求树的形态种数。 解题思路我们假设$dp[i][j]$是第$i$个字符和第$j$个字符之间的串可能构成的子树形态种数，则答案即为$dp[0][l-1]$。 对于$a[i]==a[j]$，我们先假设这两个点代表同一个节点$a$： $dp[i][j]+=dp[i+1][j-1]$，这时$a$只有一个孩子； $dp[i][j]+=\sum_{k=i+2}^{j-2}dp[i][k]*dp[k+1][j-1] (a[i]==a[k])$，这时$a$有一个右孩子$[k+1,j-1]$，至少一个左孩子$[i,k]$，这个可以继续当做树根。 其实，在递推的时候保证了这是一个子树节点也就是这两个点代表同一个节点。 AC代码点击 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define w 1000000000#define N 310char a[N];long long dp[N][N];long long dfs(int l,int r)&#123; if(~dp[l][r])return dp[l][r]; if(l&gt;=r)return 1; int i; long long ans=0; if(a[l]==a[r]&amp;&amp;r&gt;l+1)&#123; ans=dfs(l+1,r-1); for(i=l+2;i&lt;r-1;i++)if(a[i]==a[l])(ans+=dfs(l,i)*dfs(i+1,r-1))%=w; &#125; return dp[l][r]=ans%w;&#125;int main()&#123; int i; while(~scanf("%s",a))&#123; memset(dp,-1,sizeof(dp)); printf("%lld\n",dfs(0,strlen(a)-1)); &#125; return 0;&#125; C 题目描述给定一段序列，让选一个点$x$，每次选定包含$x$这个元素的包含两种相邻颜色的区域，把他们染成任意一种颜色。求最少多少步能够把所有的点染成一个颜色。 解题思路设$dp[0][l][r]$表示把$[l,r]$区间内的元素染成$color[l]$所需最少步数，设$dp[1][l][r]$表示把$[l,r]$区间内的元素染成$color[r]$所需最少步数。 然后递推就可以了。 AC代码点击 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 5002int n,cnt,a[N],dp[2][N][N];int main()&#123; int i,j,x; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x); if(!i||x!=a[cnt-1])a[cnt++]=x; &#125; n=cnt; memset(dp,0x3f,sizeof(dp)); for(i=0;i&lt;n;i++)dp[0][i][i]=dp[1][i][i]=0; for(i=0;i&lt;n;i++)&#123; for(j=i;j&gt;=0;j--)&#123; if(j)dp[0][j-1][i]=min(dp[0][j-1][i],min(dp[0][j][i]+(a[j-1]!=a[j]),dp[1][j][i]+(a[j-1]!=a[i]))); if(i&lt;n-1)dp[1][j][i+1]=min(dp[1][j][i+1],min(dp[0][j][i]+(a[i+1]!=a[j]),dp[1][j][i]+(a[i+1]!=a[i]))); &#125; &#125; printf("%d",min(dp[0][0][n-1],dp[1][0][n-1])); return 0;&#125; D 题目描述用$1$到$4$位二进制数表示$26$个英文字母，其中$0011,0101,1110,1111$没有对应的英文字母。 给定一个$01$串，求每一个前缀包含的所有本质不同的字母串个数。 解题思路这个题是最有意思的一道题，刚开始没想过来差点没有AK 显然需要离线处理枚举前缀的结尾。 第一思路是，从前缀的结尾$i$往前递推，$num$记录最多能向后延伸几位，$dp[j]$表示$j$之后的字母串种类个数。 那么有$dp[j]=\sum_{k=1}^{num}{dp[j+k]}$，也就是$[j,j+k-1]$表示的一个字母和$[j+k,i]$表示的一段字母串连成一个更大的字母串。 但是要处理本质不同这个问题，有点麻烦。 本来是想用后缀自动机解决，发现没有必要，可以用倒序的字典树直接判重解决。稍微有点细节，直接上代码。 AC代码点击 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define N 3010#define w 1000000007#define rep ((a[j]&lt;&lt;3)+(a[j+1]&lt;&lt;2)+(a[j+2]&lt;&lt;1)+a[j+3])int trie[2][N*N/2],tot;int n,a[N],f[N];int main()&#123; int i,j,k,num,now,ans=0; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)&#123; f[i+1]=1; now=0; for(j=i;j&gt;=0;j--)&#123; num=std::min(4,i-j+1); f[j]=0; if(num==4&amp;&amp;(rep==3||rep==5||rep==14||rep==15))num--; for(k=1;k&lt;=num;k++)(f[j]+=f[j+k])%=w; if(!trie[a[j]][now])(ans+=f[j])%=w,trie[a[j]][now]=++tot; now=trie[a[j]][now]; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vjudge293222-动态规划基础题集合 题解]]></title>
    <url>%2F2019%2F04%2F07%2Fvjudge293222basicdp%2F</url>
    <content type="text"><![CDATA[最近在学动态规划，看到$vjudge$上这套题感觉挺有意思的。 Solved A B C D E F G H I J K L M N O P Q R S 19/19 O O O O O O O O O O O O O O O O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述求一个序列的最大$m$段非空子段和。 解题思路设$g[i][j]$表示前$i$个元素中选取$j$个段，且必包含第$i$个元素的最大值。设$f[i][j]$表示前$i$个元素中选取$j$个段，且不必包含第$i$个元素的最大值。 则有：$g[i][j]=max(g[i-1][j],f[i-1][j-1])+a[i]$$f[i][j]=max(g[i-1][j],f[i-1][j])$ 答案即为$f[n][m]$。 滚动数组优化掉第一维即可。 AC代码点击 123456789101112131415161718192021#include&lt;stdio.h&gt;#define N 1000010typedef long long ll;int n,m,a[N];ll g[N],f[N];int min(int a,int b)&#123;return a&gt;b?b:a;&#125;ll max(ll a,ll b)&#123;return a&gt;b?a:b;&#125;int main()&#123; int i,j; while(~scanf("%d%d",&amp;m,&amp;n))&#123; for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); for(i=1;i&lt;=n;i++)g[i]=f[i]=-1e18; for(i=1;i&lt;=n;i++) for(j=min(i,m);j;j--)&#123; g[j]=max(g[j],f[j-1])+a[i]; f[j]=max(f[j],g[j]); &#125; printf("%lld\n",f[m]); &#125; return 0;&#125; B 题目描述给定一段个数$n$为奇数的序列，其中有一个数字出现了至少$\frac {n+1}2$次，问这个数是多少。 $1\leq n\leq999999$，$a[i]∈[-2^{31},2^{31}-1]$。 解题思路用$map$可以水过，但可以用一种更巧妙的思路做出来。 显然，如果两个数不相等，那么删掉这两个数之后剩下的数仍然满足题目要求。所以可以用一个$cnt$表示当前数出现的净次数（删掉和它不等的相同个数的数），当$cnt=0$时更新答案，也就是说答案在结束的时候必须满足它对应的$cnt\neq0$。所以最后的答案必然是所求。 AC代码-map点击 12345678910111213141516#include&lt;cstdio&gt;#include&lt;map&gt;std::map&lt;int,int&gt;m;int main()&#123; int i,n,a,ans; while(~scanf("%d",&amp;n))&#123; m.clear(); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a); m[a]++; if(m[a]&gt;=(n+1)/2)ans=a; &#125; printf("%d\n",ans); &#125; return 0;&#125; AC代码-递推点击 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int i,n,cnt,a,ans; while(~scanf("%d",&amp;n))&#123; cnt=0; for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a); if(!cnt)cnt=1,ans=a; else cnt+=a==ans?1:-1; &#125; printf("%d\n",ans); &#125; return 0;&#125; C 题目描述给定一些种类的长方体的长宽高，它们有任意多个、可任意摆放（指任意方式竖立），问当保证下一层的长宽严格大于上一层的长宽的时候，可以摞起来的最大高度。 解题思路数据超级水，直接添加所有的长宽高组合，以长为关键词排序，从上到下递推即可。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define N 520using namespace std;struct Box&#123; int x,y,z; bool operator&lt;(const Box&amp;a)const&#123;return x&gt;a.x;&#125;&#125;a[N];int n,tot,dp[N],b[4];void add(int x,int y,int z)&#123;a[tot++]=&#123;x,y,z&#125;;&#125;int main()&#123; int i,j,k,l,ans,cas=0; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; tot=ans=0; memset(dp,0,sizeof(dp)); for(l=0;l&lt;n;l++)&#123; scanf("%d%d%d",&amp;b[0],&amp;b[1],&amp;b[2]); for(i=0;i&lt;3;i++)for(j=0;j&lt;3;j++)for(k=0;k&lt;3;k++) if(i!=j&amp;&amp;i!=k&amp;&amp;j!=k)add(b[i],b[j],b[k]); &#125; sort(a,a+tot); for(i=0;i&lt;tot;i++)&#123; for(j=0;j&lt;i;j++)if(a[i].x&lt;a[j].x&amp;&amp;a[i].y&lt;a[j].y)dp[i]=max(dp[i],dp[j]); dp[i]+=a[i].z; ans=max(ans,dp[i]); &#125; printf("Case %d: maximum height = %d\n",++cas,ans); &#125; return 0;&#125; D 题目描述现在摆在面前一堆作业和$DDL$，并知道每个作业需要的时间，求使得超出$DDL$的时间的总和最小的方案。如果有多种，输出作业名字典序最小的那一种。数据保证给定的顺序符合作业名字典序。 解题思路一上来想了个贪心，哗哗哗写出来了兴高采烈地交上了。 然后获得了$WA$。 WA代码点击 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;struct ddl&#123; char a[110]; int d,c; bool operator&lt;(const ddl&amp;p)const&#123;return d&lt;p.d||(d==p.d&amp;&amp;strcmp(a,p.a)&lt;0);&#125;&#125;a[16];int main()&#123; int i,n;scanf("%*d"); while(~scanf("%d",&amp;n))&#123; for(i=0;i&lt;n;i++)scanf("%s%d%d",a[i].a,&amp;a[i].d,&amp;a[i].c); sort(a,a+n); int ans=0,time=0; for(i=0;i&lt;n;i++)&#123; time+=a[i].c; if(time&gt;a[i].d)ans+=time-a[i].d; &#125; printf("%d\n",ans); for(i=0;i&lt;n;i++)printf("%s\n",a[i].a); &#125; return 0;&#125; 然后找到了下面这组数据： $1$$5$$A$ $10$ $2$$B$ $2$ $8$$C$ $10$ $1$$D$ $9$ $3$$E$ $2$ $1$ $emmmm$，贪心确实行不通。 那咋办呢？一看数据范围，这不赤裸裸地提示状压嘛！从下到上递推，记录一下每一个状态是由哪里转移过来的，然后输出试试？ 诶，$A$了！ AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct ddl&#123; char a[110]; int d,c;&#125;a[16];struct state&#123; int t,pre,v;//走到这一步的时间，总消耗 &#125;dp[1&lt;&lt;15];int seq[16];int f(int x)&#123; int cnt=0; while(x)x&gt;&gt;=1,cnt++; return cnt-1;&#125;int main()&#123; int i,j,n;scanf("%*d"); while(~scanf("%d",&amp;n))&#123; for(i=0;i&lt;n;i++)scanf("%s%d%d",a[i].a,&amp;a[i].d,&amp;a[i].c); for(i=1;i&lt;(1&lt;&lt;n);i++)dp[i].v=1e9; for(i=0;i&lt;(1&lt;&lt;n);i++)&#123; for(j=0;j&lt;n;j++)&#123; if((i&amp;(1&lt;&lt;j))==0)&#123; int tar=i+(1&lt;&lt;j),t=max(0,dp[i].t+a[j].c-a[j].d); if(dp[tar].v&gt;dp[i].v+t)&#123; dp[tar].v=dp[i].v+t; dp[tar].t=dp[i].t+a[j].c; dp[tar].pre=i; &#125; &#125; &#125; &#125; printf("%d\n",dp[(1&lt;&lt;n)-1].v); int p=n; i=(1&lt;&lt;n)-1; while(n)&#123; seq[--n]=f(i^dp[i].pre); i=dp[i].pre; &#125; for(i=0;i&lt;p;i++)printf("%s\n",a[seq[i]].a); &#125; return 0;&#125; 但似乎事情不太对。这个$pre$定下来定的毫无道理啊，不能一定满足字典序最小。 有了！从上向下递推，再$dfs$一遍找出最优解！ 也许只是数据比较水，所以$AC$了也不一定就是对的呢。 AC代码-REAL点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;struct ddl&#123; char a[110]; int d,c;&#125;a[16];struct state&#123; int t,v;//走到这一步的时间，总消耗 &#125;dp[1&lt;&lt;15];int seq[16],tmp[16],n,FLAG;void dfs(int p,int dep)&#123; int i; if(!p)&#123; int flag=0; if(!FLAG)&#123; FLAG=flag=1; &#125;else for(i=n-1;i&gt;=0;i--)&#123; int cmp=strcmp(a[tmp[i]].a,a[seq[i]].a); if(cmp&lt;0)&#123; flag=1; break; &#125;else if(cmp)break; &#125; if(flag)for(i=0;i&lt;n;i++)seq[i]=tmp[i]; return; &#125; for(i=0;i&lt;n;i++)&#123; if(p&amp;(1&lt;&lt;i))&#123; int tar=p-(1&lt;&lt;i),t=max(0,dp[tar].t+a[i].c-a[i].d); if(dp[p].v==dp[tar].v+t)&#123; tmp[dep]=i; dfs(tar,dep+1); &#125; &#125; &#125;&#125;int main()&#123; int i,j;scanf("%*d"); while(~scanf("%d",&amp;n))&#123; FLAG=0; for(i=0;i&lt;n;i++)scanf("%s%d%d",a[i].a,&amp;a[i].d,&amp;a[i].c); for(i=1;i&lt;(1&lt;&lt;n);i++)dp[i].v=1e9; for(i=0;i&lt;(1&lt;&lt;n);i++)&#123; for(j=0;j&lt;n;j++)&#123; if(i&amp;(1&lt;&lt;j))&#123; int tar=i-(1&lt;&lt;j),t=max(0,dp[tar].t+a[j].c-a[j].d); if(dp[i].v&gt;dp[tar].v+t)&#123; dp[i].v=dp[tar].v+t; dp[i].t=dp[tar].t+a[j].c; &#125; &#125; &#125; &#125; printf("%d\n",dp[(1&lt;&lt;n)-1].v); dfs((1&lt;&lt;n)-1,0); for(i=n-1;i&gt;=0;i--)printf("%s\n",a[seq[i]].a); &#125; return 0;&#125; E 题目描述给定一个整数序列，求其严格单调递增子序列（可为空）的最大和。 解题思路从前往后递推即可。 AC代码点击 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;#define N 1005int n,a[N];long long ans,dp[N];int main()&#123; int i,j; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; ans=0; for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)&#123; dp[i]=a[i]; for(j=0;j&lt;i;j++)if(a[j]&lt;a[i])dp[i]=max(dp[i],dp[j]+a[i]); ans=max(ans,dp[i]); &#125; printf("%lld\n",ans); &#125; return 0;&#125; F 题目描述给定一堆物品的总重，以及构成这堆物品的所有可能元素的价值和重量，判断存不存在一种方案使得给定元素构成这堆物品。如果存在，输出总价值的下确界。 解题思路完全背包，压缩到一维即可。 AC代码点击 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define N 520int t,n,e,f,v[N],w[N],dp[10010];int main()&#123; int i,j; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;e,&amp;f); f-=e; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d%d",&amp;v[i],&amp;w[i]); memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(i=0;i&lt;n;i++) for(j=w[i];j&lt;=f;j++) dp[j]=std::min(dp[j],dp[j-w[i]]+v[i]); if(dp[f]&lt;1e9)printf("The minimum amount of money in the piggy-bank is %d.\n",dp[f]); else printf("This is impossible.\n"); &#125; return 0;&#125; G 题目描述天上正在掉馅饼，给定掉馅饼的坐标（一维）和时间，初始位置给定，求能够接到的最大馅饼数。 解题思路两种递推思路，从前往后，从后往前。从后往前的比较好写，不用判特殊情况。滚动掉一维即可。 AC代码点击 1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 100010using namespace std;int n,x,t,a[12][N],dp[2][14];int main()&#123; int i,j; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; int mx=0; memset(dp,0,sizeof(dp)); memset(a,0,sizeof(a)); for(i=0;i&lt;n;i++)scanf("%d%d",&amp;x,&amp;t),a[x+1][t]++,mx=max(mx,t); for(i=mx;i&gt;=0;i--) for(j=1;j&lt;12;j++) dp[i&amp;1][j]=max(max(dp[(i+1)&amp;1][j-1],dp[(i+1)&amp;1][j]),dp[(i+1)&amp;1][j+1])+a[j][i]; printf("%d\n",dp[0][6]); &#125; return 0;&#125; H 题目描述有一列人，花费$a[i]$时间可以消除第$i$个人，花费$b[i]$时间可以消除第$i$和第$i+1$个人。求最短用时，求最终时刻的$HH:MM:SS$ $am|pm$表示。 解题思路直接暴力递推即可。 AC代码点击 1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 2010using namespace std;int n,k,a[N],b[N],dp[N];int main()&#123; int i; scanf("%*d"); while(~scanf("%d",&amp;k))&#123; for(i=1;i&lt;=k;i++)scanf("%d",&amp;a[i]); for(i=2;i&lt;=k;i++)scanf("%d",&amp;b[i]); dp[0]=0;dp[1]=a[1]; for(i=2;i&lt;=k;i++)dp[i]=min(dp[i-2]+b[i],dp[i-1]+a[i]); int h=8,m=0,s=dp[k]; if(s&gt;=60)m+=s/60,s%=60; if(m&gt;=60)h+=m/60,m%=60; printf("%02d:%02d:%02d %s\n",(h-1)%12+1,m,s,h&gt;12?"pm":"am"); &#125; return 0;&#125; I 题目描述求一个序列的非严格下降子列的最小个数。 解题思路也就是求严格上升子列长度。$O(log n)$解决。 AC代码点击 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define N 30010int a,dp[N],len;int main()&#123; int i,n; while(~scanf("%d",&amp;n))&#123; scanf("%d",&amp;dp[0]); len=1; for(i=1;i&lt;n;i++)&#123; scanf("%d",&amp;a); if(a&gt;dp[len-1])dp[len++]=a; else&#123; int p=upper_bound(dp,dp+len,a)-dp; if(dp[p]&gt;a)dp[p]=a; &#125; &#125; printf("%d\n",len); memset(dp,0,sizeof(int)*n); &#125; return 0;&#125; J 题目描述给一些老鼠的速度和质量，求最长的子序列保证老鼠的质量严格递增而速度严格递减，输出方案。 解题思路对质量排序后递推并记录从哪里递推得到的，最后递归输出。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 1010using namespace std;struct mouse&#123; int a,b,i; bool operator&lt;(const mouse&amp;p)const&#123;return a&lt;p.a;&#125;&#125;a[N];int len[N],last[N],mx,temp;void print(int x)&#123; if(!x)return; print(last[x]); printf("%d\n",x);&#125;int main()&#123; int j,i=0,k; while(~scanf("%d%d",&amp;a[i].a,&amp;a[i].b))&#123; a[i].i=i+1; i++; &#125; sort(a,a+i); for(j=0;j&lt;i;j++)&#123; len[j]=1; for(k=0;k&lt;j;k++)&#123; if(a[k].a&lt;a[j].a&amp;&amp;a[k].b&gt;a[j].b&amp;&amp;len[k]+1&gt;len[j])&#123; len[j]=len[k]+1; last[a[j].i]=a[k].i; &#125; &#125; if(len[j]&gt;mx)&#123; mx=len[j]; temp=a[j].i; &#125; &#125; printf("%d\n",mx); print(temp); return 0;&#125; K 题目描述给一些人的两种特性$d$和$p$，选择给定数量个人，使得这些人$d$总和$D$与$p$总和$P$之差的绝对值$|D-P|$最小的情况下，$D+P$最大，输出$|D-P|$，$D+P$，并按上升序输出选择人的序号。 解题思路一个个人选择，$dp[i][j]$表示选了$i$个人，其$D-P=j$（没有绝对值）的情况下，$D+P$的最大值。记录下选了$i$个人、每个$j$对应的最优解对应的人的编号$path[i][j]$，每次枚举每一个人，如果在这个条件下没有加入则可以加入这个人。 由于不能加绝对值，需要加一个$offset$调整。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define N 210#define M 22using namespace std;int n,m,d[N],p[N],v[N],s[N];int f[M][M*M*2],path[M][M*M*2];int sel(int num,int val,int now)&#123; while(num&amp;&amp;path[num][val]!=now)val-=v[path[num][val]],num--; return num;&#125;int seq[M];int main()&#123; int i,j,k,cas=0; while(~scanf("%d%d",&amp;n,&amp;m)&amp;&amp;n|m)&#123; cas++; memset(f,-1,sizeof(f)); int offset=m*M; f[0][offset]=0; for(i=1;i&lt;=n;i++) scanf("%d%d",&amp;d[i],&amp;p[i]),v[i]=d[i]-p[i],s[i]=d[i]+p[i]; for(i=1;i&lt;=m;i++)&#123; for(j=0;j&lt;=offset*2;j++)&#123; if(f[i-1][j]&lt;0)continue; for(k=1;k&lt;=n;k++)&#123; if(f[i-1][j]+s[k]&gt;f[i][j+v[k]]&amp;&amp;!sel(i-1,j,k))&#123; path[i][j+v[k]]=k; f[i][j+v[k]]=f[i-1][j]+s[k]; &#125; &#125; &#125; &#125; for(i=0;i&lt;=offset;i++)if(f[m][offset+i]&gt;=0||f[m][offset-i]&gt;=0)break; int ans=f[m][offset+i]&gt;f[m][offset-i]?offset+i:offset-i; printf("Jury #%d\nBest jury has value %d for prosecution and value %d for defence:\n",cas,(ans-offset+f[m][ans])/2,(-ans+offset+f[m][ans])/2); for(i=m;i;i--)seq[i]=path[i][ans],ans-=v[path[i][ans]]; sort(seq+1,seq+m+1); for(i=1;i&lt;=m;i++)printf(" %d",seq[i]); printf("\n\n"); &#125; return 0;&#125; L 题目描述求最长公共子序列。 解题思路裸题，非常裸。 AC代码点击 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define N 1010char a[N],b[N];int dp[N][N];int main()&#123; int i,j; while(~scanf("%s%s",a+1,b+1))&#123; int l=strlen(a+1),L=strlen(b+1); for(i=1;i&lt;=l;i++)&#123; for(j=1;i&lt;=L;j++)&#123; if(a[i]==b[j])dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); &#125; &#125; printf("%d\n",dp[l][L]); memset(dp,0,sizeof(dp)); &#125; return 0;&#125; M 题目描述有一堆高度不同、起终不同的板子，一个人，这个人要到地上，求最短时间。 这人很神奇，下落、平移的速度相同。但下落高度不能超过给定值，否则会摔死。数据保证一定有解。 解题思路纯搜索$T$掉了，记忆化搜索就可以了。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 1010using namespace std;struct ck&#123; int x[2],h; bool operator &lt;(const ck&amp;a)const&#123;return h&gt;a.h;&#125;&#125;a[N];int t,n,x,y,mx;int dp[2][1010];int dfs(int now,int dir)&#123; if(dp[dir][now])return dp[dir][now]; int i,x=a[now].x[dir]; for(i=now+1;i&lt;=n+1&amp;&amp;a[now].h-a[i].h&lt;=mx;i++)&#123; if(i==n+1)return dp[dir][now]=a[now].h; if(x&gt;=a[i].x[0]&amp;&amp;x&lt;=a[i].x[1])return dp[dir][now]+=min(x-a[i].x[0]+dfs(i,0),a[i].x[1]-x+dfs(i,1))+a[now].h-a[i].h; &#125; return dp[dir][now]=1e8;&#125;int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d%d",&amp;n,&amp;x,&amp;y,&amp;mx); memset(dp,0,sizeof(dp)); for(i=1;i&lt;=n;i++)scanf("%d%d%d",&amp;a[i].x[0],&amp;a[i].x[1],&amp;a[i].h); a[0].x[0]=a[0].x[1]=x;a[0].h=y; sort(a+1,a+n+1); printf("%d\n",dfs(0,1)); &#125; return 0;&#125; N 题目描述求最长严格上升子序列。 解题思路又是一道裸题。 AC代码点击 12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int n,a,len,dp[1010];int main()&#123; int i; scanf("%d",&amp;n); scanf("%d",&amp;a);dp[len++]=a; for(i=1;i&lt;n;i++)&#123; scanf("%d",&amp;a); if(a&gt;dp[len-1])dp[len++]=a; else&#123; int p=upper_bound(dp,dp+len,a)-dp; dp[p]=min(dp[p],a); &#125; &#125; printf("%d",len); return 0;&#125; O 题目描述给定一些食物，其价格与时间成正比，给定系数。每次必须且只能从头或尾取，求最大价格和。 解题思路区间$DP$，从最后一个取出递推到开头，$dp[i][j]$表示$i,j$之间所有元素最后取出的最大价值和。 AC代码点击 1234567891011121314#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#define N 2019int a[N],n,dp[N][N];int main()&#123; int i,j; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]),dp[i][i]=a[i]*n; for(i=1;i&lt;n;i++) for(j=0;j+i&lt;n;j++) dp[j][j+i]=std::max(dp[j][j+i-1]+a[j+i]*(n-i),dp[j+1][j+i]+a[j]*(n-i)); printf("%d",dp[0][n-1]); return 0;&#125; P 题目描述一个老鼠在一个由奶酪组成的格子图中走动，每次可以上下走动$1$到$k$个格子，并吃掉这个格子里的奶酪。要求每次吃的奶酪都比上次大，终点任选，求可以吃到的奶酪的最大和。 解题思路记忆化搜索，每次可以向四个方向走一定距离。 AC代码点击 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 110int a[N][N],n,k,dp[N][N];int dx[4]=&#123;-1,1,0,0&#125;;int dy[4]=&#123;0,0,-1,1&#125;;int dfs(int x,int y)&#123; if(~dp[x][y])return dp[x][y]; dp[x][y]=a[x][y]; int i,j,p,q,mx=0; for(i=0;i&lt;4;i++)&#123; for(j=1;j&lt;=k;j++)&#123; p=x+dx[i]*j; q=y+dy[i]*j; if(p&gt;=0&amp;&amp;q&gt;=0&amp;&amp;p&lt;n&amp;&amp;q&lt;n&amp;&amp;a[p][q]&gt;a[x][y])&#123; dfs(p,q); if(dp[p][q]&gt;mx)mx=dp[p][q]; &#125; &#125; &#125; return dp[x][y]+=mx;&#125;int main()&#123; int i,j; while(~scanf("%d%d",&amp;n,&amp;k)&amp;&amp;~n&amp;&amp;~k)&#123; memset(dp,-1,sizeof(dp)); for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) scanf("%d",&amp;a[i][j]); printf("%d\n",dfs(0,0)); &#125; return 0;&#125; Q 题目描述求最大关于反对角线对称的子矩阵。 解题思路想法是从右上角枚举到左下角，每次扩展一定范围并判断是否合理（能否对称），但程序很慢，跑了$2000ms$还多。 看到有人跑了不到$200ms$，不知道是什么方法。 AC代码点击 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#define N 1010int n,dp[N][N];char a[N][N];int main()&#123; int i,j,k; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; int ans=0; for(i=0;i&lt;n;i++)scanf("%s",a[i]); for(i=0;i&lt;n;i++)&#123; for(j=n-1;j&gt;=0;j--)&#123; dp[i][j]=1; if(i&amp;&amp;j&lt;n-1)&#123; for(k=1;k&lt;=dp[i-1][j+1];k++)&#123; if(a[i-k][j]==a[i][j+k])dp[i][j]++; else break; &#125; &#125; if(ans&lt;dp[i][j])ans=dp[i][j]; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125; R 题目描述给一段挤奶时间的开始和结束点，每次挤奶的产量，求最大总产量。两次挤奶需要间隔一定时间。 解题思路对时间段关于结束时间递减排序，从前向后递推即可。 AC代码点击 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 1010using namespace std;struct interval&#123; int b,e,v; bool operator&lt;(const interval&amp;a)const&#123;return e&lt;a.e;&#125;&#125;a[N];int dp[N];int n,m,r;int main()&#123; int i,j,ans=0; scanf("%d%d%d",&amp;n,&amp;m,&amp;r); for(i=0;i&lt;m;i++)scanf("%d%d%d",&amp;a[i].b,&amp;a[i].e,&amp;a[i].v); sort(a,a+m); for(i=0;i&lt;m;i++)&#123; dp[i]=0; for(j=0;j&lt;i;j++)if(a[j].e+r&lt;=a[i].b)dp[i]=max(dp[i],dp[j]); dp[i]+=a[i].v; ans=max(ans,dp[i]); &#125; printf("%d",ans); return 0;&#125; S 题目描述给定一段序列，增加或减少其中的某些元素的值，使得最终序列非严格单调递增或递减。求最终序列和原序列每一个元素差值绝对值的和的最小值。$1\leq n\leq2000$，序列中的数保证$0\leq a[i]\leq 10^9$。 解题思路数很大，需要离散化，$dp[i][j]$表示枚举到第$i$个数且让它变成第$j$小/大的数$b[j]$时的贡献，因为保证序列单调，有$dp[i][j]=min(dp[i-1][k])(k∈[0,j])+|a[i]-b[j]|$。其中$min(dp[i-1][k])(k∈[0,j])$可以实时更新。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define N 2010using namespace std;int n;int a[N],b[N],dp[N][N],ans=1e9;int f(int x)&#123;return x&gt;0?x:-x;&#125;int cmp(int x,int y)&#123;return x&gt;y;&#125;void solve()&#123; int i,j; memset(dp,0x3f,sizeof(dp)); for(i=0;i&lt;n;i++)dp[0][i]=f(a[0]-b[i]); for(i=1;i&lt;n;i++)&#123; int mn=1e9; for(j=0;j&lt;n;j++)&#123; mn=min(mn,dp[i-1][j]); dp[i][j]=mn+f(a[i]-b[j]); &#125; &#125; for(i=0;i&lt;n;i++)ans=min(ans,dp[n-1][i]);&#125;int main()&#123; int i; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]),b[i]=a[i]; sort(b,b+n);solve(); sort(b,b+n,cmp);solve(); printf("%d",ans); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2019%2F04%2F05%2Frandomtitle%2F</url>
    <content type="text"><![CDATA[随笔一篇，聊以自慰。 最近一段时间，写代码总是没有脑子，很绝望，也很困惑。于是想不出题怎么写的一个人随便来博客发了一条牢骚。 还记得刚上大学的时候，对于程序设计的那一股激情。那时候的自己只有一个动力：一雪高一信息竞赛训练什么题都不会而被劝退的前耻，适应大学生活。那时的自己，对大学充满未知和兴奋，做好了一切努力地准备。 可是现在呢？ 转眼看看现在的自己，什么地方都差别人很远。要说课程学习，因为上学期考的还算可以，下学期就很浮躁起来，学习也只限制于做完作业，没有任何的延伸拓展，也没有任何的总结思考，所有的时间都用在了别的事情上。要说用在了什么事情上，那大概是$ACM$和感情上。要说$ACM$，前些日子的决赛考的一塌糊涂，最近写题也写不进去，读书也倍感时间不够读不完，上学期的算法半数还给了各种$OJ$。要说感情，这可是一件细腻的活，一不小心就有可能会忘记一些很重要的事情，在学习生活中也根本无法静下心来干自己的事。纠结于当下的所有事情，结果只能是一件都做不好。 不可以继续这样颓下去了，这不是我想要的生活。 很烦躁，不知道何从下手这一团乱麻。 有了以前的打击，洛谷这一重要的刷题来源消失，自此本就模糊的目标更加不明确了。 身边的几乎所有人都跟我说，要打进$WF$，为北航争光。我也想啊，可是我真的没有这个能力。我想退出$ACM​$了，因为智商实在不够。但又不甘心，不甘心一个目标的失去，不甘心辜负身边人的期望，不甘心自己为之付出的一切。东野奎吾先生《白夜行》中的一段文字，深以为然： 人生也一样，有白天和黑夜，只是不会像真正的太阳那样，有定时的日出和日落。有些人一辈子都活在太阳的照耀下，也有些人不得不一直活在漆黑的深夜里。人害怕的，就是本来一直存在的太阳落下不再升起，也就是非常害怕原本照在身上的光芒消失。 写到这里，我想自己已经冷静许多了。 因为害怕失去，因为只会隐忍，所以才会造成今日的焦虑与恐惧。 而其实这一些东西，无论是学业还是竞赛，无论是感情还是生活，顺其自然、放平心态才是解决问题的不二法门。害怕失去是人之本性，而解决焦虑的根源便是顺其自然，如果自己不想放弃，那就不要放弃。 我想，自己大概已经拥有许多了。北航是一所很好的学校，而大学生活从不只有学习，更有许多自己想干的、爱干的课余之事。能够遇到让自己又爱又恨的算法竞赛，这或许是一种对自己意志的磨练；而能够遇到和自己志同道合互相欣赏的同学，获得升华的友情，我想这本身就是一种十分幸福的事情了。 至于算法竞赛，有什么可以怕的呢？无论实力在不在，自己学的高兴难道不就是最重要的吗？ 闻道有先后，术业有专攻。 如是而已。 我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳明那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。你明白吗？我从来就没有太阳，所以不怕失去。 我从来就没有太阳，所以不怕失去。]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝书第一章部分经典例题题解]]></title>
    <url>%2F2019%2F04%2F05%2Flrj-blue-1%2F</url>
    <content type="text"><![CDATA[最近在读刘汝佳先生的《算法竞赛入门经典》，收获颇丰，特此记录一些自己以前未曾涉猎算法的经典例题题解。 UVA-10755 Garbage Heap（三维前缀和）题目链接Garbage Heap 解题思路$UVA$上一定要用$\%lld$！！！只有$CF$才需要$I64d$！！！空格换行要求也很严格！ 大致思路是，把三维用前缀和表示，每次枚举两维，第三维再用前缀和的思想用类似求最大子序列的求法$O(n)$解决，总复杂度$O(n^5)$。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define For(i,a,b) for(i=a;i&lt;=b;i++)#define FFF For(i,1,a)For(j,1,b)For(k,1,c)typedef long long ll;ll m[25][25][25];int a,b,c,t;ll sumf(int x1,int x2,int y1,int y2,int z1,int z2)&#123; ll num=m[x2][y2][z2]; num-=m[x1-1][y2][z2]; num-=m[x2][y1-1][z2]; num-=m[x2][y2][z1-1]; num+=m[x1-1][y1-1][z2]; num+=m[x1-1][y2][z1-1]; num+=m[x2][y1-1][z1-1]; num-=m[x1-1][y1-1][z1-1]; return num;&#125;int main()&#123; int i,j,k,l,p; ll ans,minpre,sum; scanf("%d",&amp;t); while(t--)&#123; ans=-1e18; memset(m,0,sizeof(m)); scanf("%d%d%d",&amp;a,&amp;b,&amp;c); FFF scanf("%lld",&amp;m[i][j][k]); FFF m[i][j][k]+=m[i-1][j][k]; FFF m[i][j][k]+=m[i][j-1][k]; FFF m[i][j][k]+=m[i][j][k-1]; For(i,1,a)For(j,i,a)For(k,1,b)For(l,k,b)&#123; minpre=0; For(p,1,c)&#123; sum=sumf(i,j,k,l,1,p); if(sum-minpre&gt;ans)ans=sum-minpre; if(sum&lt;minpre)minpre=sum; &#125; &#125; printf("%lld\n",ans); if(t)putchar('\n'); &#125; return 0;&#125; UVA-1326 Jurassic Remains（中途相遇法）题目链接Jurassic Remains 解题思路由于直接状态压缩的消耗太大，分成两部分状态压缩解决，通过保存第一部分的状态，枚举第二部分的状态时$O(lgn)$寻找（$STL$的$map$），时间复杂度从$O(2^n)$降到$O(2^{\frac n2}logn)​$。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;int n,state[50];char s[100010];map&lt;int,int&gt;m;int count(int x)&#123; int p=0; while(x)p+=(x&amp;1),x&gt;&gt;=1; return p;&#125;int main()&#123; int i,j; while(~scanf("%d",&amp;n)&amp;&amp;n)&#123; m.clear(); for(i=0;i&lt;n;i++)&#123; scanf("%s",s); state[i]=0; for(j=0;s[j];j++)state[i]^=(1&lt;&lt;(s[j]-'A')); &#125; int n1=n/2,n2=n-n1,ans=0; for(i=0;i&lt;(1&lt;&lt;n1);i++)&#123; int x=0,cnt=0; for(j=0;j&lt;n1;j++)if(i&amp;(1&lt;&lt;j))x^=state[j],cnt++; if(!m.count(x)||cnt&gt;count(m[x]))m[x]=i; &#125; for(i=0;i&lt;(1&lt;&lt;n2);i++)&#123; int x=0; for(j=0;j&lt;n2;j++)if(i&amp;(1&lt;&lt;j))x^=state[j+n1]; if(m.count(x)&amp;&amp;count(m[x])+count(i)&gt;count(ans)) ans=(i&lt;&lt;n1)^m[x]; &#125; printf("%d\n",count(ans)); int flag=0; for(i=0;i&lt;n;i++)if(ans&amp;(1&lt;&lt;i))&#123; if(!flag)printf("%d",i+1); else printf(" %d",i+1); flag=1; &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>LRJ</category>
        <category>Chapter 1</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 547 (Div.3)]]></title>
    <url>%2F2019%2F04%2F02%2Fcf547div3%2F</url>
    <content type="text"><![CDATA[第一次完整的打下来一场比赛。 Solved A B C D E F G 7/7 O O O O O Ø Ø O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接CF Round #547 div.3 F 题目大意给定一段长度$\leq1500$的序列，求一组互不相交的子序列，使得每个子序列内数字之和相等，问这一组子序列最多包含多少个子序列。 解题思路先储存所有子序列和的可能性，再从左往右枚举右端点，枚举左端点，贪心地添加区间信息。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int n;int a[1600],s[1600];vector&lt;int&gt;G;struct Ans&#123; int num,r;//r:上一组区间的右端点 vector&lt;pair&lt;int,int&gt; &gt;vec;&#125;ans[1125080];int f(int x)&#123;return lower_bound(G.begin(),G.end(),x)-G.begin();&#125;int main()&#123; int i,j; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),s[i]=s[i-1]+a[i]; for(i=1;i&lt;=n;i++)for(j=i;j&lt;=n;j++)G.push_back(s[j]-s[i-1]); sort(G.begin(),G.end()); G.erase(unique(G.begin(),G.end()),G.end()); for(i=1;i&lt;=n;i++)&#123; for(j=1;j&lt;=i;j++)&#123; int su=s[i]-s[j-1]; int p=f(su); if(ans[p].r&lt;j)&#123; ans[p].r=i; ans[p].num++; ans[p].vec.push_back(&#123;j,i&#125;); &#125; &#125; &#125; int mx=-1e9,temp=0; for(i=0;i&lt;G.size();i++) if(ans[i].num&gt;mx)mx=ans[i].num,temp=i; printf("%d\n",mx); for(i=0;i&lt;ans[temp].vec.size();i++) printf("%d %d\n",ans[temp].vec[i].first,ans[temp].vec[i].second); return 0;&#125; G 题目大意给一棵树，给边染色，对任意一个节点，如果连着多个同样颜色的边就称之为“坏点”，问“坏点”不超过$k$个需要染色的色数最少是多少，并输出一种染色方案。 解题思路题意理解了半天没搞懂，导致最后没有AK 对于“非坏点”，所有连接它的边都是不同颜色的，所以色数是第$k$大度数的点的度数。然后xjb​染就行了。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define N 200010struct Edge&#123; int end,near;&#125;e[N&lt;&lt;1];int head[N],cnt=1;void add(int a,int b)&#123; e[++cnt].end=b;e[cnt].near=head[a];head[a]=cnt;&#125;int deg[N],mx,col[N&lt;&lt;1];void dfs(int c,int p,int f)&#123; int i,q; for(i=head[p];i;i=e[i].near)&#123; q=e[i].end; if(q==f)continue; col[i&gt;&gt;1]=(++c)%mx; dfs(c,q,p); &#125;&#125;int main()&#123; int i,n,k,x,y; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;n;i++)scanf("%d%d",&amp;x,&amp;y),add(x,y),add(y,x),deg[x]++,deg[y]++; sort(deg+1,deg+n+1); printf("%d\n",mx=deg[n-k]); dfs(1,1,0); for(i=1;i&lt;n;i++)printf("%d ",col[i]+1); return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>Solutions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十三届北航程序设计竞赛预赛题解]]></title>
    <url>%2F2019%2F03%2F26%2F13thbcpc-pretest%2F</url>
    <content type="text"><![CDATA[大概咕掉了，以后看摸着再回来做吧。 Solved A B C D E F G H I J K L M 6/13 Ø Ø Ø Ø . . Ø Ø . . . . . O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述我们将五角星关于它的中心旋转$alpha$角度得到一个新五角星，再与原五角星重叠，得到一个新的平面图形，请问在新的平面图形中二维平面被分成了多少个区域？ 解题思路观察易得，情况就两种。 AC代码点击 12345678910 #include&lt;stdio.h&gt;int main()&#123; int n,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); printf("%d\n",n%72?32:7); &#125; return 0;&#125; B 题目描述给一个$01$串，求一个最短非空$01$串，使得其不是给定串的子串，求最短长度。 解题思路答案不超过$23$（$2^{23}&gt;4.5e6$），故从上界向下枚举即可。 AC代码点击 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N (1&lt;&lt;23)+10char a[N];int vis[N];int main()&#123; int i,j,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%s",a); int ans,l=strlen(a),k=0,now=0; while((1&lt;&lt;k)&lt;=l)k++; ans=k; for(i=0;i&lt;l;i++)&#123; if(i&lt;k)now=(now&lt;&lt;1)+a[i]-'0'; else now=((now&amp;((1&lt;&lt;k-1)-1))&lt;&lt;1)+a[i]-'0'; if(i&gt;=k-1)vis[now]=1; &#125; for(i=k-1;i;i--)&#123; int flag=0; for(j=0;j&lt;(1&lt;&lt;i);j++) if(vis[j&lt;&lt;1]||vis[j&lt;&lt;1|1]||vis[j+(1&lt;&lt;i)]||vis[j])vis[j]=1; else flag=1; if(flag)ans=i; else break; &#125; printf("%d\n",ans); memset(vis,0,sizeof(vis)); &#125; return 0;&#125; C 题目描述给定一个等腰梯形，每一行均匀分布一些点，问从这个等腰梯形中的点里面选三个构成正三角形的个数。 解题思路极其麻烦的一道题，做了整整三个小时。（还不是因为菜） 把三角形分为头朝上、头朝下两部分解决。假设头朝下的、底边在宽度为$i$的一层中的正三角形个数为$a_i$，头朝上的、顶点在宽度为$i$的一层中的正三角形个数为$b_i$，那么答案便是$\sum_{i=n}^{m}{a_i+b_i}$。 先求$a_i$。 底边在宽度为$i$的一层中的正三角形，其边长的取值范围为$l∈[1,i-n]$，记$h_i=i-n$，$H=m-n$，于是相当于考虑在$i+1$个点中选择距离$d\leq h_i$的种数，也就是$a_i=h_i(i+1)-\frac{h_i(h_i+1)}2$。 解释一下上面这个式子。在$i+1$个点中任选一个点$p$，在不考虑超出范围的情况下，距离$d\leq h_i$的点有$p+1,p+2,…,p+h_i$，共有$h_i$个。但显然这样多算了选了并不能选的点的情况。这种右端的点超出范围情况共有$(1+2+3+…+h_i)$种情况，即$\frac{h_i(h_i+1)}2$。 于是 $\sum_{i=n}^{m} a_i$ $=\sum_{i=n}^{m}{(i+1)h_i-\frac{h_i(h_i+1)}2}$ $=\sum_{i=0}^{H}{\frac{(i+2n+1)i}2}$ $=\sum_{i=0}^{H}{\frac{i^2}{2}+\frac{(2n+1)i}2}$ $=\frac{H(H+1)(2H+1)}{12}+\frac{(2n+1)(H+1)H}{4}$ $=\frac{n(H+1)H}2+\frac{H(H+1)(H+2)}6$ 再来计算$b_i$。 对于顶点在宽度为$i$的一层中的三角形，其边长为$l=min(i-n,\left\lfloor\frac i2\right\rfloor)$。枚举底边宽度$j$，则正三角形边长为$i-j$，个数为$2j-i+1$。 故$b_i=\sum_{j=n}^{i-1}2j-i+1,k\leq2n;\sum_{j=\left\lfloor\frac{k+1}2\right\rfloor}^{i-1}2j-i+1,k&gt;2n$。 分段求和，有 $1.m\leq2n$ $\sum_{i=n}^{m}b_i$ $=\sum_{i=n}^{m}\sum_{j=n}^{i-1}2j-i+1$ $=\sum_{i=n}^{m}(1-i)(i-1-n+1)+2\frac{(n+i-1)(i-n)}{2}$ $=\sum_{i=n}^{m}n(i-n)$ $=\frac{n(1+H)H}2$ $2.m&gt;2n$ $\sum_{i=n}^{m}b_i$ $=\sum_{i=n}^{2n}b_i+\sum_{i=2n+1}^{m}b_i$ $=\frac{n(1+2n-n)(2n-n)}2+\sum_{i=2n+1}^{m}b_i$ $=\frac{n^2(1+n)}2+\sum_{i=2n+1}^{m}\sum_{j=\left\lfloor\frac{k+1}2\right\rfloor}^{i-1}2j-i+1$ $=\frac{n^2(1+n)}2+\sum_{i=2n+1}^{m}(1-i)(i-\left\lfloor\frac{i+1}2\right\rfloor)+(\left\lfloor\frac{i+1}2\right\rfloor+i-1)(i-\left\lfloor\frac{i+1}2\right\rfloor)$ $=\frac{n^2(1+n)}2+\sum_{i=2n+1}^{m}\left\lfloor\frac{i+1}2\right\rfloor\left\lceil\frac{i+1}2\right\rceil$ $=\frac{n^2(1+n)}2+\sum_{i=2n+1}^{m}\frac{i^2}4-\frac14(当i为奇数)$ $=\frac{n^2(1+n)}2+\frac14(\frac{m(m+1)(2m+1)}6-\frac{2n(2n+1)(4n+1)}6)-\frac14(\left\lfloor\frac m2\right\rfloor-n)$ 然后加起来就行了。 AC代码点击 1234567891011121314151617#include&lt;stdio.h&gt;long long n,m,w=1e9+7;long long ans; int main()&#123; int t; scanf("%d",&amp;t); while(t--)&#123; ans=0; scanf("%lld%lld",&amp;m,&amp;n); long long H=m-n; ans=(n*H*(H+1)/2+(H+2)*(H+1)*H/6)%w; if(m&lt;=2*n)ans=(ans+(n*H*(H+1)/2)%w)%w; else ans=(ans+n*n*(n+1)/2+(((m*(m+1)*(2*m+1)-(2*n)*(2*n+1)*(4*n+1))/6+n-m/2)/4)%w)%w; printf("%lld\n",ans%w); &#125; return 0;&#125; D 题目描述从几堆牌中随机等概率取牌，一堆中取一张牌则所有的牌被取走。除了第一堆，每一堆牌的个数都是从一个闭区间中等概率选取的。当第一堆被取走时，游戏结束。问游戏结束时，取走的牌数期望值。 解题思路设$P(i,j)$表示第$i$堆牌有$j$个，这堆牌其中某一张牌在第一堆牌某一张牌之前被取走的概率。于是有$P(i,j)=\frac{j}{a_1+j}$。 $ans=\sum_{i=2}^{n}\frac1{up[i]-low[i]+1}\sum_{j=low[i]}^{up[i]}\frac{j^2}{a_1+j}$。 每组数据预处理出后一个求和号里的东西，逆元记忆化搜索即可。 AC代码点击 123456789101112131415161718192021222324252627282930313233 #include&lt;stdio.h&gt;#define N 100010typedef long long ll;int u[N],l[N],w=998244353;ll a[N*10];ll pw(ll a,ll p)&#123; ll x=1; for(;p;p&gt;&gt;=1,a=a*a%w)if(p&amp;1)x=x*a%w; return x;&#125;int inv[N*20];ll invf(int x)&#123; if(inv[x])return inv[x]; return inv[x]=pw(x,w-2);&#125;int main()&#123; int i,t,n,a1; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;a1); int max=0; ll ans=a1; for(i=1;i&lt;n;i++)&#123; scanf("%d%d",&amp;l[i],&amp;u[i]); if(u[i]&gt;max)max=u[i]; &#125; for(i=1;i&lt;=max;i++)a[i]=1LL*i*i%w*invf(a1+i)%w; for(i=1;i&lt;=max;i++)a[i]=(a[i]+a[i-1])%w; for(i=1;i&lt;n;i++)ans=(ans+(invf(u[i]-l[i]+1)*(a[u[i]]-a[l[i]-1]+w)%w)%w)%w; printf("%lld\n",(ans+w)%w); &#125; return 0;&#125; E 题目描述解题思路AC代码点击 1 F 题目描述解题思路AC代码点击 1 G 题目描述给定一个一元二次方程，如果有无限小数实数解则保留到$1e6$位，如果有有限小数实数解则保留所有小数，如果无解则输出无解。 按照以下规则输出：输出$0-9$在解中出现的频率百分比，保留到整数。 解题思路先判断有解无解、有无有理解，如果解无理，则全部输出$10$。 如果有有理解，再分为有限小数、无限小数讨论。如果无限小数且$1e6+1$位$\geq5$，则需要找到循环节中对应的位置进行进位、增加等处理；否则直接处理循环节输出。 我没有AC，但还是要发题解。 没有AC的代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#define M 1000000int num[11],cir[2010],cnt,infinite;//出现次数，余数是否出现，总数，不循环 int len,fir;//循环节长度及初始出现位置 int cy[2010];//循环节 int tail;//第1e6+1位在循环节中的位置 void init()&#123; memset(num,0,sizeof(num)); memset(cir,0,sizeof(cir)); memset(cy,0,sizeof(cy)); fir=tail=infinite=cnt=len=0;&#125;void solveinteger(int x)&#123; if(!x)num[0]++,cnt++; while(x)num[x%10]++,x/=10,cnt++;&#125;void find(int k,int d)&#123; int temp[11]=&#123;0&#125;,tot=0; int i,j,r=k; cir[r]=1; for(i=1;i&lt;=M;i++)&#123; if(!r)break; if(!infinite&amp;&amp;cir[r]&amp;&amp;i!=1)&#123; infinite=1; cy[++len]=r*10/d; for(j=r*10%d;j!=r;j=j*10%d)cy[++len]=j*10/d; fir=i-len; int number=(M-i)/len;//后面循环节个数 for(j=r*10%d;;j=j*10%d)&#123; temp[j*10/d]+=number; if(j==r)break; &#125; i+=number*len; tot+=number*len; tail=(M-i+2)%len;//M+1 &#125; temp[r*10/d]++; tot++; cir[r]=i; r=r*10%d; &#125; if(!infinite||cy[tail]&lt;5)&#123; for(i=0;i&lt;10;i++)num[i]+=temp[i]; cnt+=tot; &#125;else&#123; if(!tail)tail=len; int mx; for(i=1;i&lt;=len;i++)&#123; mx=(tail-1-i+len)%len+1; if(cy[mx]!=9)break; &#125; r=k; cir[r]=1; int tmp=i,flag=0; memset(cir,0,sizeof(cir)); for(i=1;i&lt;=M-tmp;i++)&#123; if(!r)break; if(!flag&amp;&amp;cir[r]&amp;&amp;i!=1)&#123; flag=1; int number=(M-i-tmp)/len;//后面循环节个数 for(j=r*10%d;;j=j*10%d)&#123; num[j*10/d]+=number; if(j==r)break; &#125; i+=number*len; &#125; num[r*10/d]++; cir[r]=i; r=r*10%d; &#125; num[(r*10/d+1)%10]++; for(i=M-tmp+2;i&lt;=M;i++)num[0]++; cnt+=M; &#125;&#125;void printresult()&#123; int i; for(i=0;i&lt;10;i++)&#123; double tp=num[i]*100.0/cnt; printf("%d ",tp-(int)tp&lt;0.5-1e-10?(int)tp:(int)tp+1); &#125; printf("\n");&#125;void print(int k,int d)&#123; if(k&lt;0)k=-k; if(d&lt;0)d=-d; init(); solveinteger(k/d); find(k%d,d); printresult();&#125; int main()&#123; int a,b,c,T; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); int delta=b*b-4*a*c; if(delta&lt;0)printf("NO JIE\n"); else if(round(sqrt(delta))*round(sqrt(delta))==delta)&#123; if(a&lt;0)print((-b+round(sqrt(delta))),2*a),print((-b-round(sqrt(delta))),2*a); else print((-b-round(sqrt(delta))),2*a),print((-b+round(sqrt(delta))),2*a); &#125;else printf("10 10 10 10 10 10 10 10 10 10\n10 10 10 10 10 10 10 10 10 10\n"); &#125; return 0;&#125; H 题目描述给定一个$300*300$以内的数字矩阵，其中$’x’$表示这个点不能被选择，再给出$\leq 1000$组询问，每组询问要求输出在包含给定$(x,y)$的基础上的、不选$’x’$点的元素之和最大的子矩阵中元素之和。 解题思路把子矩阵包含$(x,y)$这个条件转化成：在行数范围在$[up,down]$区间内、必选$k$这一列时，最大的子矩阵大小，并在$up\leq x\leq down$条件下取最大值。 $’x’$可设置成一个比较小的数，但不能太小，$-1e7$比较好，而$-1e8$就不太行了，否则可能会爆掉。 通过问题转化，可以$O(n^2m+q)$解决问题。 剧毒，卡常数（还不是因为我太菜了） TLE代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#define N 305int inf=-1e7;int read()&#123; char c=getchar();int f=1,num=0; while(c&gt;'9'||c&lt;'0')&#123; if(c=='-')f=-1; if(c=='x')return inf; c=getchar(); &#125; while(c&gt;='0'&amp;&amp;c&lt;='9')num=(num&lt;&lt;3)+(num&lt;&lt;1)+c-'0',c=getchar(); return num*f;&#125;#define max(a,b) (a&gt;b?(a):(b))int n,m,q,mt[N][N],sum[N][N];int pre[N],suc[N],s[N],mx[N][N][N];int p[N][N][N],f[N][N];void init()&#123; int i,j,k; for(i=1;i&lt;=n;i++)&#123; for(j=i;j&lt;=n;j++)&#123; pre[0]=suc[m+1]=0; for(k=1;k&lt;=m;k++)s[k]=sum[j][k]-sum[j][k-1]-(sum[i-1][k]-sum[i-1][k-1]); //预处理减小常数 for(k=1;k&lt;=m;k++)pre[k]=max(0,pre[k-1])+s[k]; for(k=m;k&gt;=0;k--)suc[k]=max(0,suc[k+1])+s[k]; for(k=1;k&lt;=m;k++)mx[i][j][k]=pre[k]+suc[k]-s[k]; //mx[i][j][k]:i为上界，j为下界，必须包含第k列在上下界范围内全部值的最大值 &#125; &#125; for(i=1;i&lt;=n;i++)&#123; for(k=1;k&lt;=m;k++)&#123; //p[i][j][k]:i为上界，j为下界的上界，必须包含第k列的最大值 //只是起到简化运算的作用 p[i][n+1][k]=inf; for(j=n;j&gt;=i;j--) p[i][j][k]=max(p[i][j+1][k],mx[i][j][k]); &#125; &#125; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=m;j++)&#123; //f[i][j]=min&#123;p[up][i][j]&#125;,up&lt;=i f[i][j]=p[1][i][j]; for(k=2;k&lt;=i;k++)f[i][j]=max(f[i][j],p[k][i][j]); &#125;&#125;int main()&#123; int i,j,t,x,y; t=read(); while(t--)&#123; n=read(),m=read(); for(i=1;i&lt;=n;i++)for(j=1;j&lt;=m;j++) mt[i][j]=read(),sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+mt[i][j]; init(); q=read(); while(q--)x=read(),y=read(),printf("%d\n",f[x][y]); &#125; return 0;&#125; AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#define max(a,b) (a&gt;b?(a):(b))#define N 304int inf=-1e7;int read()&#123; char c=getchar();int f=1,num=0; while(c&gt;'9'||c&lt;'0')&#123; if(c=='-')f=-1; if(c=='x')return inf; c=getchar(); &#125; while(c&gt;='0'&amp;&amp;c&lt;='9')num=(num&lt;&lt;3)+(num&lt;&lt;1)+c-'0',c=getchar(); return num*f;&#125;int n,m,q,mt[N][N],sum[N][N];int pre[N],suc[N],mx[N][N];int p[N][N][N],f[N][N],s[N];void init()&#123; int i,j,k; for(i=1;i&lt;=n;i++)&#123;//合并到用一个i for(j=i;j&lt;=n;j++)&#123; pre[0]=suc[m+1]=0; for(k=1;k&lt;=m;k++)s[k]=sum[j][k]-sum[j][k-1]-(sum[i-1][k]-sum[i-1][k-1]); for(k=1;k&lt;=m;k++)pre[k]=max(0,pre[k-1])+s[k]; for(k=m;k&gt;=0;k--)suc[k]=max(0,suc[k+1])+s[k]; for(k=1;k&lt;=m;k++)mx[j][k]=pre[k]+suc[k]-s[k]; //i为上界，j为下界，必须包含第k列的最大值 &#125; for(k=1;k&lt;=m;k++)p[i][n][k]=mx[n][k]; for(j=n-1;j&gt;=i;j--)for(k=1;k&lt;=m;k++)p[i][j][k]=max(p[i][j+1][k],mx[j][k]); for(j=1;j&lt;=m;j++)&#123; f[i][j]=p[1][i][j]; for(k=2;k&lt;=i;k++)f[i][j]=max(f[i][j],p[k][i][j]); &#125; &#125;&#125;int main()&#123; int i,j,t,x,y; t=read(); while(t--)&#123; n=read(),m=read(); for(i=1;i&lt;=n;i++)for(j=1;j&lt;=m;j++) mt[i][j]=read(),sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+mt[i][j]; init(); q=read(); while(q--)x=read(),y=read(),printf("%d\n",f[x][y]); &#125; return 0;&#125; I 题目描述解题思路AC代码点击 12 J 题目描述解题思路AC代码点击 12 K 题目描述解题思路AC代码点击 12 L 题目描述解题思路AC代码点击 12 M 题目描述解题思路AC代码点击 12]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>BCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四届北航程序设计竞赛预赛题解]]></title>
    <url>%2F2019%2F03%2F21%2F14thbcpc-pretest%2F</url>
    <content type="text"><![CDATA[整整花费了一个周的时间来做，不是依托自身实力而是依托大佬的帮助才完成了这次比赛。题目都很有意思，可惜能想出来的并不多。那集训队的事情就等明年了。 Solved A B C D E F G H I J K L 12/12 O O O O O O O O O O O O O for passing during the contest Ø for passing after the contest ! for attempted but failed · for having not attempted yet 比赛链接 A 题目描述给出一段序列，求最少去除几个数使得剩下的数能够组成总和相同的两堆。 $1≤T≤50$，$1≤n≤50$，$0≤a,b≤10^9$，$0≤b−a≤50$ 解题思路根据$a$的个数和$b-a$的总和进行$DP$，滚动数组优化。 AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;string.h&gt;int ans,x[55];int f[2][110][5015];int max(int p,int q)&#123;return p&gt;q?p:q;&#125;int main()&#123; int i,j,k,t,n,a,b; scanf("%d",&amp;t); while(t--)&#123; memset(f,0,sizeof(f)); f[0][50][2500]=1; int p=0; scanf("%d%d%d",&amp;n,&amp;a,&amp;b); for(i=1;i&lt;=n;i++)scanf("%d",&amp;x[i]),x[i]-=a; for(i=1;i&lt;=n;i++)&#123; p^=1; for(j=50-i;j&lt;=50+i;j++)&#123;//50+ a的个数 for(k=0;k&lt;=5000;k++)&#123;//2500+ b-a累加 f[p][j][k]=f[p^1][j][k]; if(k-x[i]&gt;=0&amp;&amp;j-1&gt;=0&amp;&amp;f[p^1][j-1][k-x[i]])f[p][j][k]=max(f[p][j][k],f[p^1][j-1][k-x[i]]+1); if(k+x[i]&lt;=5000&amp;&amp;j-1&gt;=0&amp;&amp;f[p^1][j+1][k+x[i]])f[p][j][k]=max(f[p][j][k],f[p^1][j+1][k+x[i]]+1); &#125; &#125; &#125; int ans=f[p][50][2500]; for(i=0;i&lt;=100;i++)&#123; if(a*(i-50)+2500&lt;0)continue; if(a*(i-50)+2500&gt;5000)break; ans=max(ans,f[p][i][-a*(i-50)+2500]); &#125; printf("%d\n",n-(ans-1)); &#125; return 0;&#125; B 题目描述升级有两种，吃糖直接升一级，或者攒经验。给定经验值，糖果数，各级升级经验数，问最多升到多少级。 解题思路排完序暴力枚举答案就行了。（虽然可以二分答案） AC代码点击 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct E&#123; int d,i; bool operator &lt;(const E&amp;a)const&#123;return d&gt;a.d&#125;;&#125;exp[110];int n,m,a,b,c,t,p[110];int jud(int x)&#123; int u[110]=&#123;0&#125;; int i,temp=n,mx=m; for(i=1;i&lt;=100;i++)&#123; if(temp&amp;&amp;exp[i].i&lt;=x)u[exp[i].x]=1,temp--; &#125; for(i=1;i&lt;=x;i++)&#123; if(!u[i])&#123; if(mx&gt;=p[i])mx-=p[i]; else return 0; &#125; &#125; return 1;&#125;int main()&#123; int i; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;a,&amp;b,&amp;c); for(i=1;i&lt;=100;i++)p[i]=exp[i].d=(i*a+b)%c,exp[i].i=i; sort(exp+1,exp+100); for(i=1;i&lt;=100;i++)if(!jud(i))break; printf("%d\n",i-1); &#125; return 0;&#125; C 题目描述给一棵树，求出所有节点间路径的权值和和异或和的乘积之和。 解题思路思路一：点分治，求出所有经过当前根的子树中的链，把所有链分别连起来，再减去在多算了的相同子树中链的加和。 思路二：树形DP。还暂时没有实现。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 100010#define w ((ll)(1e9+7))typedef long long ll;int max(int a,int b)&#123;return a&gt;b?a:b;&#125;struct Edge&#123; int end,near; ll len;&#125;e[N&lt;&lt;2];struct Chain&#123; ll sum,xos;&#125;sub[N&lt;&lt;4],all[N&lt;&lt;4];int head[N],cnt;void add(int a,int b,ll l)&#123; e[++cnt].end=b;e[cnt].len=l; e[cnt].near=head[a];head[a]=cnt;&#125;int n,rt,sum;int siz[N],mxt[N],vis[N];void getrt(int v,int fa)&#123; int i,p; siz[v]=1;mxt[v]=0; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(vis[p]||p==fa)continue; getrt(p,v); siz[v]+=siz[p]; mxt[v]=max(mxt[v],siz[p]); &#125; mxt[v]=max(mxt[v],sum-siz[v]); if(mxt[v]&lt;mxt[rt])rt=v;&#125;void getdis(int v,int fa,ll s,ll x)&#123; int i,p; sub[++sub[0].sum].sum=s; sub[sub[0].sum].xos=x; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(p==fa||vis[p])continue; getdis(p,v,(s+e[i].len)%w,x^e[i].len); &#125;&#125;ll allBin[N],subBin[N];ll calcsub()&#123; int i,j; ll ans=0; for(i=1;i&lt;=sub[0].sum;i++)&#123; ll r=0; for(j=0;j&lt;32;j++)&#123; if(sub[i].xos&amp;(1&lt;&lt;j))r+=(sub[0].sum-subBin[j])*(1&lt;&lt;j)%w; else r+=subBin[j]*(1&lt;&lt;j)%w; r%=w; &#125; ans+=r*sub[i].sum%w; ans%=w; &#125; return ans;&#125;ll calcall()&#123; int i,j; ll ans=0; for(i=1;i&lt;=all[0].sum;i++)&#123; ll r=0; for(j=0;j&lt;32;j++)&#123; if(all[i].xos&amp;(1&lt;&lt;j))r+=(all[0].sum-allBin[j])*(1&lt;&lt;j)%w; else r+=allBin[j]*(1&lt;&lt;j)%w; r%=w; &#125; ans+=r*all[i].sum%w; ans%=w; &#125; return ans;&#125;ll sol(int v)&#123; int i,p,j,k; vis[v]=1;all[0].sum=0; ll ans=0; for(i=0;i&lt;32;i++)allBin[i]=0; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(vis[p])continue; sub[0].sum=0; for(j=0;j&lt;32;j++)subBin[j]=0; getdis(p,v,e[i].len,e[i].len); for(j=1;j&lt;=sub[0].sum;j++) for(k=0;k&lt;32;k++) if(sub[j].xos&amp;(1&lt;&lt;k))subBin[k]++; ans-=calcsub();ans%=w; for(j=0;j&lt;32;j++)allBin[j]+=subBin[j]; for(j=1;j&lt;=sub[0].sum;j++)all[++all[0].sum]=sub[j]; &#125; ans+=calcall();ans%=w; for(i=1;i&lt;=all[0].sum;i++)&#123; ans+=all[i].sum*all[i].xos%w; ans%=w; &#125; for(i=head[v];i;i=e[i].near)&#123; p=e[i].end; if(!vis[p])&#123; sum=siz[p];mxt[0]=n;rt=0; getrt(p,v); ans+=sol(rt); ans%=w; &#125; &#125; return (ans+w)%w;&#125;int main()&#123; int i,a,b,t; ll c; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=1;i&lt;n;i++) scanf("%d%d%lld",&amp;a,&amp;b,&amp;c),add(a,b,c),add(b,a,c); rt=0;sum=mxt[0]=n;getrt(1,0); printf("%lld\n",sol(rt)); memset(vis,0,sizeof(int)*(n+1)); memset(head,0,sizeof(int)*(n+1)); cnt=0; &#125; return 0;&#125; D 题目描述一行点，往里头填数，每个点有最低限制，且要满足每个点相对左边的点的数满足给定条件，求最小总数。 解题思路暴力 AC代码点击 12345678910111213141516171819202122#include&lt;stdio.h&gt;int ans,now,a[110],b[110];int main()&#123; int i,t,n; scanf("%d",&amp;t); while(t--)&#123; scanf("%d",&amp;n); for(i=0;i&lt;n;i++)scanf("%d",&amp;a[i]); for(i=0;i&lt;n;i++)scanf("%d",&amp;b[i]); now=ans=a[0]; for(i=1;i&lt;n;i++)&#123; now+=b[i]; if(now&lt;a[i])&#123; ans+=i*(a[i]-now); now=a[i]; &#125; ans+=now; &#125; printf("%d\n",ans); &#125; return 0;&#125; E 题目描述给定$n$个点， 两点间道路长度为两点权值的$gcd$，求最大生成树。（$a_i\leq 1e5$） 解题思路根据$krustal$算法的原理，枚举边长上界，构造生成树。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int n,a[100010],f[100010],map[100010];int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;int main()&#123; int i,j,k,l,t,m; scanf("%d",&amp;t); while(t--)&#123; long long ans=0,max; int temp,p,q,u[2]=&#123;0&#125;,now=0,cnt=0; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]); sort(a+1,a+n+1); max=a[n]; for(i=1;i&lt;n;i++)if(a[i]==a[i+1])ans+=a[i],cnt++; for(i=1;i&lt;=n;i++)map[a[i]]=i; for(i=1;i&lt;=n;i++)f[i]=i; for(i=max;i;i--)&#123; now=u[0]=u[1]=0; for(j=1;j*i&lt;=max;j++)&#123; if(map[j*i])&#123; u[now]=map[j*i]; if(u[now^1])&#123; p=find(u[now]); q=find(u[now^1]); if(p!=q)&#123; ans+=i; f[p]=q; cnt++; &#125; &#125; now^=1; &#125; &#125; if(cnt==n-1)break; &#125; printf("%lld\n",ans); memset(map,0,sizeof(map)); &#125; return 0;&#125; F 题目描述求满足$(i+1)^i*i &equiv; 0(mod&ensp; m)$的$m$的个数的前缀和，$i\leq 1e7$。 解题思路先考虑枚举每个数的质因数个数，发现会$T$飞。 故反向从枚举质因数筛原数。 AC代码点击 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#define N 10000002int ans[N+4],w=998244353;int prime[N+4]=&#123;1,1&#125;,a[N/10],tot=1;int main()&#123; int i,j,t,n,cnt; scanf("%d",&amp;t); for(i=1;i&lt;N;i++)ans[i]=1; for(i=2;i&lt;N;i++)&#123; if(!prime[i])a[tot++]=i; for(j=1;j&lt;tot;j++)&#123; if(i*a[j]&gt;=N)break; prime[i*a[j]]=1; if(i%a[j]==0)break; &#125; &#125; for(i=1;i&lt;tot;i++)&#123; for(j=1;j*a[i]&lt;N;j++)&#123; cnt=0; int now=j*a[i],temp=now; while(now%a[i]==0)now/=a[i],cnt++; ans[temp-1]=ans[temp-1]*1LL*(cnt*1LL*(temp-1)+1)%w; ans[temp]=ans[temp]*1LL*(cnt+1)%w; &#125; &#125; for(i=2;i&lt;N;i++)ans[i]=(ans[i]+ans[i-1])%w; while(t--)&#123; scanf("%d",&amp;n); printf("%d\n",ans[n]); &#125; return 0;&#125; G 题目描述给定一个非常长的序列，求其中所有上升子序列的长度 $k$次方之和，答案对$1e9+7$取模，$k\leq 20$。 解题思路先考虑$k=1$的情况。可以想到，从前到后遍历数组，用一个树状数组维护当前所有以$x$为结尾的上升子序列长度的和前缀和，每次加入（$y+query(x-1)$）更新。 在考虑$k\geq 2$的情况。维护$k+1$个树状数组，第$i$个树状数组记录上升子序列长度$l^i$的和的前缀和，更新的时候用二项式定理扫一遍即可。 注意到数据较大，需要离散化。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define N 131073using namespace std;typedef long long ll;int n,k,x[N],y[N],seq[N*10],M;struct number&#123; int a,b,i; bool operator&lt;(const number&amp;p)const&#123;return a&lt;p.a;&#125;&#125;a[N];ll w=1e9+7,t[21][N],c[25][25];int l(int x)&#123;return x&amp;(-x);&#125;void add(int d,int x,ll p)&#123; while(x&lt;=M)&#123; t[d][x]+=p; t[d][x]%=w; x+=l(x); &#125;&#125;ll query(int d,int x)&#123; ll ans=0; while(x)&#123; ans+=t[d][x]; ans%=w; x-=l(x); &#125; return ans;&#125;int main()&#123; int i,j,m,T; ll now[25]; for(i=0;i&lt;=20;i++)c[i][0]=1; for(i=1;i&lt;=20;i++)for(j=1;j&lt;=20;j++)c[i][j]=c[i-1][j-1]+c[i-1][j]; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;k); for(i=1;i&lt;=n;i++)scanf("%d%d",&amp;x[i],&amp;y[i]),a[i].a=x[i],a[i].b=y[i],a[i].i=i; sort(a+1,a+n+1); for(i=1;i&lt;=n;i++)seq[a[i].a]=a[i].a==a[i-1].a?seq[a[i-1].a]:seq[a[i-1].a]+1; M=seq[a[n].a]+1; for(i=1;i&lt;=n;i++)&#123; int X=seq[x[i]]+1,Y=y[i]; for(j=0;j&lt;=k;j++)now[j]=query(j,X-1); for(j=0;j&lt;=k;j++)&#123; ll tot=0; for(m=0;m&lt;=j;m++)tot+=Y*c[j][m]%w*now[m]%w,tot%=w; add(j,X,(tot+Y)%w); &#125; &#125; printf("%lld\n",query(k,M)); for(i=0;i&lt;=k;i++)for(j=0;j&lt;=M;j++)t[i][j]=0; &#125; return 0;&#125; H 题目描述给定五张牌，问加入两张牌成为顺子有多少种情况。 解题思路巨麻烦的分类讨论？ 不，这题可以直接暴力。 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;char a[8];int x[150];int main()&#123; int t,i,j,k; x['A']=1;x['2']=2;x['3']=3;x['4']=4; x['5']=5;x['6']=6;x['7']=7;x['8']=8; x['9']=9;x['T']=10;x['J']=11;x['Q']=12; x['K']=13; scanf("%d",&amp;t); while(t--)&#123; int t[25]=&#123;0&#125;,ans=0; int used[60]=&#123;0&#125;,num[20]=&#123;0&#125;; scanf("%s",a); for(i=0;i&lt;5;i++)&#123; int s=x[a[i]]; t[s]++; used[s*4+num[s]++]++; if(a[i]=='A')t[14]++; &#125; for(i=4;i&lt;56;i++)&#123; if(used[i])continue; t[i/4]++; for(j=i+1;j&lt;56;j++)&#123; if(used[j])continue; t[j/4]++; int flag=0; for(k=1;k&lt;=13;k++)&#123; if(t[k]&amp;&amp;t[k+1]&amp;&amp;t[k+2]&amp;&amp;t[k+3]&amp;&amp;(t[k+4]||(k+4==14&amp;&amp;t[1])))&#123; flag=1; break; &#125; &#125; if(flag)ans++; t[j/4]--; &#125; t[i/4]--; &#125; printf("%d\n",ans); &#125; return 0;&#125; I 题目描述给定一个只含有$ATGC$的环，$ATGC$分别代表一种矩阵，定义一次操作为所有矩阵乘上下一个矩阵，问$k$次操作后（$k\leq 1e9$）的环。 解题思路列个表发现$ATGC$之间的乘积具有异或的性质。 然后利用$k$的可加性，找到规律，倍增解决。 AC代码点击 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;char a[4]=&#123;'A','T','G','C'&#125;,c[1000010];int res[4][4]=&#123;&#123;0,1,2,3&#125;,&#123;1,0,3,2&#125;,&#123;2,3,0,1&#125;,&#123;3,2,1,0&#125;&#125;;int now[2][1000010];int map[510];int main()&#123; int i,t,n,k,m; scanf("%d",&amp;t); map['A']=0;map['T']=1; map['G']=2;map['C']=3; while(t--)&#123; m=0; int p,cnt; scanf("%d%d%s",&amp;n,&amp;k,c); for(i=0;i&lt;n;i++)now[1][i]=map[c[i]]; while(k)&#123; p=1;cnt=0; while(k&gt;=(1&lt;&lt;cnt+1))cnt++; int d=(1&lt;&lt;cnt); k-=d; for(i=0;i&lt;n;i++)now[m][i]=res[now[m^1][i]][now[m^1][(i+d)%n]]; m^=1; &#125; for(i=0;i&lt;n;i++)printf("%c",a[now[m^1][i]]); printf("\n"); &#125; return 0;&#125; J 题目描述求满足方程组 $x_1+x_2+…+x_n=m$$0\leq x_i \leq a_i$ 的解的个数， 对一堆素数的乘积取模。 解题思路首先，求答案用插板法，写出组合数。然后，分别对每一个模数取模，得到相应答案。最后，把取模得到的数用中国剩余定理得到最终答案。 毒瘤爆$long long$，CRT需要龟速乘 AC代码点击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;using namespace std;typedef long long ll;int n,k;ll m,v[20],ans[20],p[20];ll jc[20][100010];ll mul(ll x,ll y,ll mod) &#123; ll res=0;x%=mod; for(;y;y&gt;&gt;=1,(x*=2)%=mod)if(y&amp;1)(res+=x)%=mod; return res;&#125;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y)&#123; if(!b)&#123;x=1,y=0;return;&#125; exgcd(b,a%b,y,x); y-=a/b*x;&#125;ll China(int n,ll *m,ll *a)&#123; int i; ll M=1,ans=0,y,x=0; for(i=0;i&lt;n;i++)M*=m[i]; for(i=0;i&lt;n;i++)&#123; ll w=M/m[i]; exgcd(m[i],w,x,y); ans=(ans+mul(mul(y,w,M),a[i],M))%M; &#125; return (ans%M+M)%M;&#125;ll pw(ll x,int y,int num)&#123; int i; ll ans=1;x%=p[num]; for(i=y;i;i&gt;&gt;=1,x=x*x%p[num])if(i&amp;1)ans=ans*x%p[num]; return ans;&#125;ll c(ll x,ll y,int num)&#123; if(x&lt;y)return 0; return mul(mul(jc[num][x],pw(jc[num][y],p[num]-2,num),p[num]),pw(jc[num][x-y],p[num]-2,num),p[num]);&#125;ll lucas(ll x,ll y,int num)&#123; if(!y)return 1; return mul(lucas(x/p[num],y/p[num],num),c(x%p[num],y%p[num],num),p[num]);&#125;int main()&#123; int i,s,cnt,t,j; ll temp; scanf("%d",&amp;t); while(t--)&#123; for(i=0;i&lt;20;i++)ans[i]=0; scanf("%d%lld%d",&amp;n,&amp;m,&amp;k); for(i=0;i&lt;n;i++)scanf("%lld",&amp;v[i]); for(i=0;i&lt;k;i++)scanf("%lld",&amp;p[i]); for(i=0;i&lt;k;i++)&#123; jc[i][0]=1; for(j=1;j&lt;=1e5;j++)jc[i][j]=jc[i][j-1]*j%p[i]; &#125; s=(1&lt;&lt;n); for(i=0;i&lt;s;i++)&#123; cnt=1; temp=0; for(j=0;j&lt;n;j++)&#123; if(i&amp;(1&lt;&lt;j))&#123; cnt*=-1; temp+=v[j]+1; &#125; &#125; if(temp&gt;m)continue; for(j=0;j&lt;k;j++) ans[j]=(ans[j]+mul(cnt&lt;0?p[j]-1:1,lucas(m-temp+n-1,n-1,j),p[j]))%p[j]; &#125; printf("%lld\n",China(k,p,ans)); &#125; return 0;&#125; K 题目描述多次操作区间对最小值（定义为非零的最小值）取模，求取模前后该区间数的总和。 解题思路线段树，区间和为$0$时特判剪枝。 AC代码点击 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;stdio.h&gt;#define N 200010typedef long long ll;struct SegmentTree&#123; int l,r; ll sum,min;&#125;t[N&lt;&lt;3];int n;ll a[N];ll minf(ll a,ll b)&#123; if(!a||!b)return b|a; return a&gt;b?b:a;&#125;void build(int p,int l,int r)&#123; if(l==r)&#123; t[p].l=t[p].r=l; t[p].min=t[p].sum=a[l]; return; &#125; t[p].l=l;t[p].r=r; build(p&lt;&lt;1,l,(l+r)&gt;&gt;1); build(p&lt;&lt;1|1,((l+r)&gt;&gt;1)+1,r); t[p].sum=t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].sum; t[p].min=minf(t[p&lt;&lt;1].min,t[p&lt;&lt;1|1].min);&#125;ll query(int p,int l,int r)&#123; int L=t[p].l,R=t[p].r; if(l&gt;R||r&lt;L)return 0; if(l&lt;=L&amp;&amp;r&gt;=R)return t[p].sum; return query(p&lt;&lt;1,l,r)+query(p&lt;&lt;1|1,l,r);&#125;ll minquery(int p,int l,int r)&#123; int L=t[p].l,R=t[p].r; if(l&gt;R||r&lt;L)return 0; if(l&lt;=L&amp;&amp;r&gt;=R)return t[p].min; return minf(minquery(p&lt;&lt;1,l,r),minquery(p&lt;&lt;1|1,l,r));&#125;ll modify(int p,int l,int r,ll k)&#123; int L=t[p].l,R=t[p].r; if(l&gt;R||r&lt;L||!t[p].sum)return 0; if(L==R)return t[p].min=t[p].sum%=k; modify(p&lt;&lt;1,l,r,k);modify(p&lt;&lt;1|1,l,r,k); t[p].min=minf(t[p&lt;&lt;1].min,t[p&lt;&lt;1|1].min); t[p].sum=t[p&lt;&lt;1].sum+t[p&lt;&lt;1|1].sum; return t[p].min;&#125;void print()&#123; int i; for(i=1;i&lt;=44;i++) if(t[i].l)printf("%d %d %lld %lld\n",t[i].l,t[i].r,t[i].sum,t[i].min); printf("\n");&#125;int main()&#123; int q,i,l,r,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d",&amp;n,&amp;q); for(i=1;i&lt;=n;i++)scanf("%lld",&amp;a[i]); build(1,1,n); for(i=0;i&lt;q;i++)&#123; scanf("%d%d",&amp;l,&amp;r); ll mn=minquery(1,l,r); if(!mn)printf("0 0\n"); else&#123; printf("%lld ",query(1,l,r)); modify(1,l,r,mn); printf("%lld\n",query(1,l,r)); &#125; //print(); &#125; &#125; return 0;&#125; L 题目描述告诉每回合出现哪些神龙，每回合怎么得钱，买一个神龙一块钱，问多少回合能集齐要求的神龙。 解题思路二分答案。注意$p$爆$long long$。 AC代码点击 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;string.h&gt;#define N 100010int n,m,p,k,l;int a[N],b[N],tmp[N];int f(int x,int y)&#123;return x*m+y;&#125;//1-&gt;2int g(int x)&#123;return x/m;&#125;//2-&gt;1int seq[N];int jud(int num)&#123; int i,mx=f(num,0)-1; memset(seq,0,sizeof(seq)); memset(tmp,0,sizeof(tmp)); for(i=0;i&lt;l;i++)tmp[b[i]]++; for(i=mx;i&gt;=0;i--)&#123; if(tmp[a[i]])&#123; seq[g(i)]++; tmp[a[i]]--; &#125; &#125; for(i=0;i&lt;l;i++)if(tmp[b[i]])return 0; long long now=p; for(i=0;i&lt;num;i++)&#123; now-=seq[i]; if(now&lt;0)return 0; if(now&lt;l)now+=now/k+p; &#125; return 1;&#125;int main()&#123; int i,j,q,t; scanf("%d",&amp;t); while(t--)&#123; scanf("%d%d%d%d%d",&amp;n,&amp;m,&amp;p,&amp;k,&amp;l); for(i=0;i&lt;n;i++)for(j=0;j&lt;m;j++)scanf("%d",&amp;a[f(i,j)]); for(i=0;i&lt;l;i++)scanf("%d",&amp;b[i]); int l=0,r=n; while(l&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(jud(mid))r=mid; else l=mid+1; &#125; if(!jud(l))l++; if(l&lt;=n)printf("%d\n",l); else printf("-1\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Solutions</category>
        <category>Contests</category>
      </categories>
      <tags>
        <tag>BCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My first blog]]></title>
    <url>%2F2019%2F03%2F09%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[啦啦啦，换到新的blog啦！ 原博客停用 标题一标题二标题三标题四标题五标题六 这是一段引用 123int mian()&#123;//这是一段代码 retrun 0;&#125; 这是一个链接 $\sum_{k|((1&lt;&lt;k)\&amp;S==0)}^{} {f[i-1][S-(1&lt;]}$ 嗯嗯 诶诶诶 黑体 斜体 a 道路千万条 你是第一条 第一条 -.- -。- 第二条~ 第三条 233 322 &lt;addr&gt; 233 $$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$ $$ \sideset{^1_2}{^3_4}\bigotimes $$ $$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$ $$\sqrt{2} \quad and \quad \sqrt[n]{3}$$ $$\vec{a} \cdot \vec{b}=0$$ $$\overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}$$ $$ \lim_{n \to +\infty} \frac{1}{n(n+1)}$$ $$\sum_{i=1}^n \frac{1}{i^2} \quad and \quad \prod_{i=1}^n \frac{1}{i^2} \quad and \quad \bigcup_{i=1}^{2} R$$ $\smash{\displaystyle\max_{0 \leq q \leq n-1}} f(q) \le n$ $f(x + \epsilon) \approx f(x) + f’(x) \epsilon + \mathcal{O}(\epsilon^2).$ $\text{d}x$ $\lim_{n \to +\infty}{1^n}=1$]]></content>
      <categories>
        <category>others</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
